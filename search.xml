<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Windows-API-程序设计（7,8）</title>
      <link href="/2023/06/03/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%887-8%EF%BC%89/"/>
      <url>/2023/06/03/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%887-8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="系统学习Windows-API-7"><a href="#系统学习Windows-API-7" class="headerlink" title="系统学习Windows API 7"></a>系统学习Windows API 7</h1><h2 id="文件操作的四种方法"><a href="#文件操作的四种方法" class="headerlink" title="文件操作的四种方法"></a>文件操作的四种方法</h2><p>​        我们学习到现在，实质上有四种方法进行文件操作。<code>C++, C, Windows API, Windows MFC</code></p><p>​        合适的选取方法是十分重要的。下面，为了能够更好的演示，我们选择在Windows MFC下演示之。</p><h2 id="创建MFC"><a href="#创建MFC" class="headerlink" title="创建MFC"></a>创建MFC</h2><p>​        如果先前并没有勾选过VS桌面开发者，可以前往安装之。这里就不再多述了，创建一个MFC的基于对话框的应用程序即可！</p><p>​        用MFC工具集，我搭建一个演示平台：</p><p><img src="image-20230603090808135.png" alt="image-20230603090808135"></p><p>​        其中，事先准备好一个文本（我这里是随意的一个1.txt）放到工程文件目录下面去了。</p><h2 id="clear按钮"><a href="#clear按钮" class="headerlink" title="clear按钮"></a>clear按钮</h2><p>​        介绍一下函数：<code>SetDlgItemText</code></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">SetDlgItemTextW</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> HWND    hDlg<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token keyword">int</span>     nIDDlgItem<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCWSTR lpString<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in] hDlg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型：<strong>HWND</strong></p><p>包含控件的对话框的句柄。</p><pre class="line-numbers language-none"><code class="language-none">[in] nIDDlgItem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>int</strong></p><p>具有要设置的标题或文本的控件。</p><pre class="line-numbers language-none"><code class="language-none">[in] lpString<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>LPCTSTR</strong></p><p>要复制到控件的文本。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>类型： <strong>BOOL</strong></p><p>如果该函数成功，则返回值为非零值。</p><p>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p><strong>SetDlgItemText</strong> 函数将<a href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a>消息发送到指定的控件。</p><p>​        而在MFC中，只需要给定指定的控件编号和文本即可：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton5()&#123;&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码SetDlgItemText(IDC_EDIT1, TEXT(&quot;&quot;));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-方式"><a href="#C-方式" class="headerlink" title="C  方式"></a>C  方式</h2><p>​        点击第一个按钮，书写响应函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton1()&#123;&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码CString s &#x3D; TEXT(&quot;************C*************\r\n&quot;); &#x2F;&#x2F;一个MFC类FILE* pF; &#x2F;&#x2F; 声明文件指针char line[256]; &#x2F;&#x2F;准备字符空间fopen_s(&amp;pF,&quot;1.txt&quot;, &quot;r&quot;); &#x2F;&#x2F; 阅读内容while (fgets(line, 256, pF) !&#x3D; NULL) &#123;s +&#x3D; line;&#x2F;&#x2F; 使用Cstring的函数s +&#x3D; TEXT(&quot;\r\n&quot;);&#125;fclose(pF);SetDlgItemText(IDC_EDIT1, s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-方式-1"><a href="#C-方式-1" class="headerlink" title="C++ 方式"></a>C++ 方式</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton2()&#123;&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码CString s &#x3D; TEXT(&quot;************C++*************\r\n&quot;);char line[256];std::ifstream ifs(&quot;1.txt&quot;);while (ifs.getline(line, 256)) &#123;s +&#x3D; line;s +&#x3D; TEXT(&quot;\r\n&quot;);&#125;ifs.close();SetDlgItemText(IDC_EDIT1, s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton3()&#123;&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码CString c &#x3D; TEXT(&quot;*****************API********************\r\n&quot;);CHAR lpFileDataBuffer[4096];ZeroMemory(lpFileDataBuffer, 4096);DWORD dwReadSize;HANDLE hfile;hfile &#x3D; CreateFile(TEXT(&quot;1.txt&quot;),GENERIC_READ, FILE_SHARE_READ,NULL, OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);ReadFile(hfile, lpFileDataBuffer, 4096, &amp;dwReadSize, NULL);CloseHandle(hfile);c +&#x3D; lpFileDataBuffer;SetDlgItemText(IDC_EDIT1,c);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Windows-MFC"><a href="#Windows-MFC" class="headerlink" title="Windows MFC"></a>Windows MFC</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton4()&#123;&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码CString s &#x3D; TEXT(&quot;******************MFC*******************\r\n&quot;);CString line;CStdioFile file(TEXT(&quot;1.txt&quot;),CFile::modeRead);while (file.ReadString(line))&#123;s +&#x3D; line;s +&#x3D; TEXT(&quot;\r\n&quot;);&#125;SetDlgItemText(IDC_EDIT1, s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="系统学习Windows-API-8"><a href="#系统学习Windows-API-8" class="headerlink" title="系统学习Windows API 8"></a>系统学习Windows API 8</h1><h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><p>​        首先，熟悉一下这个形式的main函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main(int argc, char* argv[])&#123;&#x2F;&#x2F;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​                在这里，<code>argc</code>指出了命令行有几个，<code>argv</code>给出了具体的参数是什么，来个demo:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;int main(int argc, char* argv[]) &#123;printf(&quot;个数：%d\n&quot;, argc);printf(&quot;第一个:%s\n&quot;, argv[0]);printf(&quot;第二个:%s\n&quot;, argv[1]);printf(&quot;第三个:%s\n&quot;, argv[2]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在只是<code>生成工程</code>！随后，使用<code>PowerShell</code>切换到工程的debug目录下面，找到这个自己的可执行文件。由于此时<code>int main(int argc, char* argv[])</code>带上了命令行参数，它可以接受命令！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./mu.exe <span class="token parameter variable">-d</span> a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230603094626567.png" alt="image-20230603094626567"></p><p><img src="image-20230603094646043.png" alt="image-20230603094646043"></p><p>​        这就是运行的结果。</p><h2 id="DeleteFile"><a href="#DeleteFile" class="headerlink" title="DeleteFile"></a>DeleteFile</h2><p>​        删除现有文件。</p><p>若要以事务处理操作的形式执行此操作，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-deletefiletransacteda">DeleteFileTransacted</a> 函数。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">DeleteFile</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpFileName<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in] lpFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        要删除的文件的名称。</p><p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\\？\”。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p><p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p><h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为零 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p><h2 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h2><p>​        如果应用程序尝试删除不存在的文件， <strong>DeleteFile</strong> 函数将失败并 <strong>ERROR_FILE_NOT_FOUND</strong>。 如果文件是只读文件，则函数将失败并 <strong>ERROR_ACCESS_DENIED</strong>。</p><p>​        以下列表标识了删除、删除或关闭文件的一些提示：</p><ul><li>若要删除只读文件，首先必须删除只读属性。</li><li>若要删除或重命名文件，必须对文件具有删除权限，或者具有父目录中的删除子权限。</li><li>若要以递归方式删除目录中的文件，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/shellapi/nf-shellapi-shfileoperationa">SHFileOperation</a> 函数。</li><li>若要删除空目录，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-removedirectorya">RemoveDirectory</a> 函数。</li><li>若要关闭打开的文件，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 函数。</li></ul><p>​        如果设置了除 delete 和 delete child 以外的所有访问权限的目录，并且访问控制列表 (ACL) 继承了新文件，则可以创建一个文件，但无法将其删除。 但是，你可以创建一个文件，然后获取在创建文件时返回给你的句柄上请求的所有访问权限。</p><p>​        如果在创建文件时请求删除权限，则可以使用该句柄删除或重命名文件，但不能使用任何其他句柄。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-security-and-access-rights">文件安全和访问权限</a>。</p><p>​        如果应用程序尝试删除具有打开正常 I/O 的其他句柄的文件或作为内存映射文件的文件 (<strong>FILE_SHARE_DELETE</strong>必须在打开其他句柄) 时指定，<strong>DeleteFile</strong> 函数将失败。</p><p>​        <strong>DeleteFile</strong> 函数在关闭时标记要删除的文件。 因此，在关闭文件的最后一个句柄之前，不会删除文件。 后续调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 以打开文件失败， <strong>并显示ERROR_ACCESS_DENIED</strong>。</p><p>​        符号链接行为 —</p><p>​        如果路径指向符号链接，则删除符号链接，而不是目标。 若要删除目标，必须调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 并指定 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong>。</p><h2 id="CopyFile"><a href="#CopyFile" class="headerlink" title="CopyFile"></a>CopyFile</h2><p>​        将现有文件复制到新文件。</p><p>​        <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-copyfileexa">CopyFileEx</a> 函数提供两个附加功能。 每次完成复制操作的一部分时，<strong>CopyFileEx</strong> 都可以调用指定的回调函数，并且可以在复制操作期间取消 <strong>CopyFileEx</strong>。</p><p>​        若要以事务处理操作的形式执行此操作，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-copyfiletransacteda">CopyFileTransacted</a> 函数。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">CopyFile</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpExistingFileName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpNewFileName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> BOOL    bFailIfExists<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-none"><code class="language-none">[in] lpExistingFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        现有文件的名称。</p><p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\？\”。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p><p> 提示</p><p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p><p>​        如果 <em>lpExistingFileName</em> 不存在， <strong>则 CopyFile</strong> 将失败， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 将返回 <strong>ERROR_FILE_NOT_FOUND</strong>。</p><pre class="line-numbers language-none"><code class="language-none">[in] lpNewFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        新文件的名称。</p><p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\？\”。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p><p> 提示</p><p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p><pre class="line-numbers language-none"><code class="language-none">[in] bFailIfExists<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果此参数为 <strong>TRUE</strong> 并且 <em>lpNewFileName</em> 指定的新文件已存在，则函数将失败。 如果此参数为 <strong>FALSE</strong> 且新文件已存在，则函数将覆盖现有文件并成功。</p><h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><h2 id="注解-2"><a href="#注解-2" class="headerlink" title="注解"></a>注解</h2><p>​        现有文件 (<strong>ATTRIBUTE_SECURITY_INFORMATION</strong>) 的安全资源属性将复制到新文件。</p><p>​        <strong>Windows 7、Windows Server 2008 R2、Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在Windows 8和Windows Server 2012之前，现有文件的安全资源属性不会复制到新文件。</p><p>​        现有文件的文件属性将复制到新文件。 例如，如果现有文件具有 <strong>FILE_ATTRIBUTE_READONLY</strong> 文件属性，则通过调用 <strong>CopyFile</strong> 创建的副本也将具有 <strong>FILE_ATTRIBUTE_READONLY</strong> 文件属性。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/retrieving-and-changing-file-attributes">检索和更改文件属性</a>。</p><p>​        如果目标文件已存在并且设置了<strong>FILE_ATTRIBUTE_HIDDEN或FILE_ATTRIBUTE_READONLY</strong>属性，则此函数将失败<strong>并ERROR_ACCESS_DENIED</strong>。</p><p>​        当 <strong>CopyFile</strong> 用于复制加密的文件时，它会尝试使用源文件加密中使用的密钥来加密目标文件。 如果无法执行此操作，此函数将尝试使用默认密钥加密目标文件。 如果这两种方法都无法完成， <strong>则 CopyFile</strong> 将失败并 <strong>显示ERROR_ENCRYPTION_FAILED</strong> 错误代码。</p><p>​        符号链接行为 - 如果源文件是符号链接，则复制的实际文件是符号链接的目标。</p><p>​        如果目标文件已存在并且是符号链接，则符号链接的目标将被源文件覆盖。</p><h2 id="MoveFile"><a href="#MoveFile" class="headerlink" title="MoveFile"></a>MoveFile</h2><p>​        移动现有文件或目录，包括其子级。</p><p>​        若要指定如何移动文件，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefileexa">MoveFileEx</a> 或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefilewithprogressa">MoveFileWithProgress</a> 函数。</p><p>​        若要以事务处理操作的形式执行此操作，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefiletransacteda">MoveFileTransacted</a> 函数。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">MoveFile</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpExistingFileName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpNewFileName<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-none"><code class="language-none">[in] lpExistingFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        本地计算机上文件或目录的当前名称。</p><p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\\？\”。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p><p> 提示</p><p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p><pre class="line-numbers language-none"><code class="language-none">[in] lpNewFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        文件或目录的新名称。 新名称不得已存在。 新文件可能位于不同的文件系统或驱动器上。 新目录必须位于同一驱动器上。</p><p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\\？\”。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p><p> 提示</p><p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p><h2 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><h2 id="注解-3"><a href="#注解-3" class="headerlink" title="注解"></a>注解</h2><p>​        <strong>MoveFile</strong> 函数将移动 (重命名) 文件或目录 (包括其子级) 在同一目录中或跨目录。 需要注意的是，当目标位于其他卷上时，移动目录时 <strong>，MoveFile</strong> 函数将失败。</p><p>​        如果文件跨卷移动， <strong>MoveFile</strong> 不会随文件一起移动安全描述符。 将为文件分配目标目录中的默认安全描述符。</p><p>​        <strong>MoveFile</strong> 函数将其操作与链接跟踪服务协调，因此可以在移动链接源时对其进行跟踪。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Windows 32API </tag>
            
            <tag> 摸鱼ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt &amp;&amp; Opencv Config</title>
      <link href="/2023/06/01/Qt-Opencv-Config/"/>
      <url>/2023/06/01/Qt-Opencv-Config/</url>
      
        <content type="html"><![CDATA[<h1 id="关于Qt-opencv各平台编译方法的水博客1（代价是搞了N久）"><a href="#关于Qt-opencv各平台编译方法的水博客1（代价是搞了N久）" class="headerlink" title="关于Qt + opencv各平台编译方法的水博客1（代价是搞了N久）"></a>关于Qt + opencv各平台编译方法的水博客1（代价是搞了N久）</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>​        正确选择模块的版本是必要的                                        ——爹的 instruction</p><p>​        首先，如果你是一个构件库者，哥们建议你仔细看看这帮写博客的人他们构建配置的版本是多少！防止坑上加坑，导致人寄上加寄！</p><p>​        下面，我将介绍一下简单的 Windows11/Linux-Ubuntu20.04 Qt5.12.8/Qt6.6.0 + Opencv 4.6.0/Opencv 4.5.3， 如果你是想在自己的电脑上搭建上述系统，烦请按照我下面给出的若干的reference version, 否则在编译，安装，运行，到最后的打包出了问题。。。很正常就会，以及，以及</p><p><strong>注意到本博客尚未解决：基于Windows11下如此操作方法qt6.6.0 + mingw_64bits打包程序的可移植性的问题，具体表现为于纯净Win10下爆出 RunTimeError - Unknown Terminate 以及Windows11下程序双击无反应的问题</strong></p><p>​        成功解决的是下面的，全流程简单的概括为👇</p><h2 id="Windows11-Qt-5-12-8-Opencv4-5-3"><a href="#Windows11-Qt-5-12-8-Opencv4-5-3" class="headerlink" title="Windows11 + Qt 5.12.8 + Opencv4.5.3"></a>Windows11 + Qt 5.12.8 + Opencv4.5.3</h2><p>​        首先，我们需要的是获取上面我提到的资源。</p><p>​        如果打算配置的是6.6.0，Cmake可以不用下，qt有自己自带的Cmake-gui，但是低版本的不自带Cmake-gui，需要自己来下载。</p><p>​        Qt 5.12.8可以通过点击这里获取：<a href="https://download.qt.io/new_archive/qt/5.12/5.12.8/qt-opensource-windows-x86-5.12.8.exe">qt-opensource-windows-x86-5.12.8.exe</a></p><p>​        或者，你想要浏览其他的版本，看这里：<a href="https://download.qt.io/new_archive/qt/">Index of /new_archive/qt</a></p><p>​        至于 opencv，这里给出传送门：</p><p>​        opencv:<a href="https://opencv.org/releases/">Releases - OpenCV</a>，对了，有人有疑问：我是该安装Source版本的还是Windows版本的呢？都一样，前者直接得到压缩包，后者是一个解压程序。基本一致的！结合自身的需求来！</p><p>​        opencv_contrib :  这个用户贡献的contribution的子模块，是需要到 github那里去下载的！注意到这里给出的是 opencv_contrib 4.x 的教程。读者可以自行尝试opencv_contrib 5.x的联合编译。<a href="https://github.com/opencv/opencv_contrib/tree/4.x（不过，不建议编译这个，我自己尝试过在后续的编译中这个会爆炸（爆一大堆错误））">https://github.com/opencv/opencv_contrib/tree/4.x（不过，不建议编译这个，我自己尝试过在后续的编译中这个会爆炸（爆一大堆错误））</a></p><p>​        我们下载好了之后。得到的是若干的压缩包和一个QT安装的SDK。</p><h3 id="安装QT"><a href="#安装QT" class="headerlink" title="安装QT"></a>安装QT</h3><p>​        原则上讲，这个版本的QT不使用线上安装，意味之我们不需要配置Qt tempory repository.注意到如果你先前有一个qt账号，登陆即可，反之，注册一个！直接选择对应的编译包和SDK包就可以了。为了联合演示 mingw_32, mingw_64, MSVC2017_32,MSVC_64编译器下的编译行为，这里我就都下载了，以及，在Tools选择上也都选择了MSVC编译器和mingw编译器（tnnd,13.8G）。Qt作为桌面开发的经典工具，安装也是press几个按钮的事情。这里就不细说说明了。</p><h3 id="安装opencv"><a href="#安装opencv" class="headerlink" title="安装opencv"></a>安装opencv</h3><p>​        解压就完事了！</p><h3 id="开始联合编译Qt-opencv"><a href="#开始联合编译Qt-opencv" class="headerlink" title="开始联合编译Qt + opencv"></a>开始联合编译Qt + opencv</h3><p>​        我们将opencv得到的资源，分别置于一个空间比较大的地方。比如说我的D盘（）。</p><p>​        专门建立一个文件夹，叫：</p><pre class="line-numbers language-none"><code class="language-none">Qt5_12_Opencv453Compile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在底下，再建立三个文件夹！</p><p><img src="image-20230602103923847.png" alt="image-20230602103923847"></p><p><img src="image-20230602103930586.png" alt="image-20230602103930586"></p><p>​        如上图所示。也就是：</p><pre class="line-numbers language-none"><code class="language-none">opencv_buildopencv_contribopencv_source<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        我想，你从名字就知道了——<code>opencv_source</code>装源码，把<code>Opencv4.5.3</code>的源码内容放到这里, <code>opencv_contrib</code> 装用户贡献模块，把contrib的所有内容放到这里，而<code>opencv_build</code>,任何一个熟知Cmake编译的人都知道装编译的结果的。</p><p>​        现在，打开你的Cmake-gui</p><p>​    <img src="image-20230602121940454.png" alt="image-20230602121940454"></p><p>​        你的<code>Where is the source code</code>和<code>where to build the binaries</code>，如果先前没有用过会是空的！source code自然在<code>opencv_source</code>下，build产生的文件放到<code>opencv_build</code>下，就像这样一样。</p><p>​        点击Advanced 和 Grouped,防止自己老花眼找半天的Cmake变量。点击Configure</p><p><img src="image-20230602122308408.png" alt="image-20230602122308408"></p><p>​        默认下，这里是没有编译器的，现在，选择Specify native Compliers（指定本地编译器），点击之</p><p><img src="image-20230602122412384.png" alt="image-20230602122412384"></p><p>​        下拉找到<code>Mingw Makefiles</code>，这就是我们想要的编译器了！</p><p>​        Config结束后，点击Next.</p><p>​        指定好自己C,C++语言的编译器位置，他们在自己QT安装的文件下的。</p><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\Tools\mingw730_64\bin\gcc.exe &#x2F;&#x2F; for C<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\Tools\mingw730_64\bin\g++.exe &#x2F;&#x2F; for C++<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230602122748504.png" alt="image-20230602122748504"></p><p>​        可以看到正在配置了。</p><p>​        同时，记得添加编译器到环境变量！</p><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\5.12.8\mingw73_64\bin;D:\QT\Qt5.12.12\Tools\mingw730_64;D:\QT\Qt5.12.8\Tools\mingw730_64\x86_64-w64-mingw32\bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        他们稍后是为了使系统可以找到Qt库来运行Qt的！</p><p>​        待到你添加完毕之后，现在，回到Cmake界面是满山红</p><p><img src="image-20230602123431972.png" alt="image-20230602123431972"></p><p>​        下面开始配置选项</p><p>​        1. 打开with_OpenGL 和 With_Qt,他们在WITH group下面</p><p>​        2. 配置好contrib模块，就是在Opencv Group下，找到这样的一个变量     OPENCV_EXTRA_MODOLES_PATH</p><p>​        给他写上：</p><pre class="line-numbers language-none"><code class="language-none">D:\QT5_12_Opencv453Compile\opencv_contrib\modules<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        呐！就是我们存放<code>contrib</code>模块下面的<code>modules</code>模块，注意。</p><p>​        再次重新配置：点击Configure</p><p>​        正常来讲，再次编译过后，是不会有红色出现的！但是我这里还是红色出现了！</p><p>​        是Qt5的库路径不知道。给我默认到自己的Anaconda的库里去了。自己手动修改一下，同时，留意一下正斜杠与反斜杠的区别（fuck Windows）</p><p><img src="image-20230602124437202.png" alt="image-20230602124437202"></p><p>​        _这里是为了测试mingw32编译才选择的32编译器_（WRANING!后续的编译中尝试过了！不建议选择这个，64位的系统就选择mingw64!）如果你不想打包库的话，可以选择64位编译器。</p><p>​        以及我看到有教程建议在Opencv的变量中只勾选opencv_world. 这是把若干的库编译成一个，显得笨重！这里就不这样做了！</p><p>​        点击Config</p><p><img src="image-20230602124653801.png" alt="image-20230602124653801"></p><p>​        (留心一下产生的清单里有没有都配置成为你想要的环境，确定了再点击！)</p><p>​        再点击Generate生成可以用的MakeFile.</p><h3 id="PowerShell启用mingw32编译源代码"><a href="#PowerShell启用mingw32编译源代码" class="headerlink" title="PowerShell启用mingw32编译源代码"></a>PowerShell启用mingw32编译源代码</h3><p><img src="image-20230602124918062.png" alt="image-20230602124918062"></p><pre class="line-numbers language-none"><code class="language-none">mingw32-make -j 8 &#x2F;&#x2F; 8 is then_recommend<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        后来还是调成8了，因为有一定概率产生多线程编译错误导致编译中止！</p><p>​        CD到自己的Build文件下，敲这个指令！（哈哈，其实是让他所有的CPU资源来调动编译之，可不想等1个小时）</p><p><img src="image-20230602125026896.png" alt="image-20230602125026896"></p><p>​        一敲击回车，程序开始快速的编译。泡杯咖啡休息一下把。</p><p>​        中间可能存在跑错！注意！明确选择的编译器是64位！同时，注意反复确认引入的Cmake选项指向的环境是你想要的那个（错一点都不行！）</p><p>​        _不！要！mingw编译器 停止编译了还要继续继续在原文件夹下再输mingw32-make_了，否则可能会跳过一些库的生成！导致后面程序应用后异常崩溃！</p><pre class="line-numbers language-none"><code class="language-none">mingw32-make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        下载好刚刚那些库！</p><p><img src="image-20230602135455371.png" alt="image-20230602135455371"></p><p>​        现在，我们下载好的库，就在</p><p><img src="image-20230602135533374.png" alt="image-20230602135533374"></p><p>以及opencv可用的文件在：</p><p><img src="image-20230602135559565.png" alt="image-20230602135559565"></p><p>​        打开QT，整一个MainWindow工程。</p><p>​        现在开始检验你配置的是否成功了！（大喜）</p><p>​        在PRO工程文件下，添加</p><pre class="line-numbers language-none"><code class="language-none">INCLUDEPATH +&#x3D; D:\QT5_12_Opencv453Compile\opencv_build\install\includeLIBS +&#x3D; D:\QT5_12_Opencv453Compile\opencv_build\install\x64\mingw\bin\libopencv_*.dll<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <strong>然！后！Ctrl+S重载一下工程，否则下面别让自己白忙活！</strong></p><p>​        尝试一下，在MainWindow.cpp下整点：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include&lt;opencv2&#x2F;opencv.hpp&gt; &#x2F;&#x2F; 关键时刻！#include&lt;QDebug&gt;using namespace cv;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    Mat img &#x3D; imread(&quot;D:\\QT projects\\5128opencv\\1.png&quot;);&#x2F;&#x2F;嘿！这个别照搬地址！哥们找自己的一张图片扔进来它的地址！    if(img.empty())&#123;       qDebug() &lt;&lt; &quot;Error in loading picture&quot;;    &#125;    namedWindow(&quot;Display window&quot;, WINDOW_AUTOSIZE );    imshow(&quot;Display window&quot;,img);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        好了，如果，我说如果，没有什么问题，那恭喜可以开摆了。。。</p><p>​        但是如果没有呢？</p><p>​        0. Can not find opencv2/opencv.hpp: 好好看看你有没有Ctrl + S你的工程</p><p>​        1.Unrecognize File Format</p><p>​        当你运行上面的代码在QConsole上扔出了这个错误的时候，注意选好你的编译器套餐！留意到你用了什么编译器编译的opencv+QT，就使用哪款编译器！</p><pre><code>    2. ​        程序异常结束</code></pre><p>​        哥们太倒霉了！程序不认识库！也就是说，他没办法按照你给的路径去寻找库，一个一点都不优雅的方法，就是把 自己编译产生的库，在install/x64/bin下的库，原封不动的扔到自己的debug或者是release文件夹下，让G++/GCC编译的时候直接在本地工作文件夹下找到库从而避免一场结束！（Windows的这个屏蔽了过多的细节，没办法）</p><p><img src="image-20230602141655611.png" alt="image-20230602141655611"></p><p>​        这是成功的界面！</p><h3 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a>程序打包</h3><p>​        成功了！后面经过调试，成功将这一个环境的qt+ opencv程序应用到了各台电脑上！（不用下载几百MB的库力，喜）</p><p>​        首先，转到自己同名目录下的：</p><pre><code>     很抽象的一个：》</code></pre><pre class="line-numbers language-none"><code class="language-none">D:\QT projects\build-5128opencv-Desktop_Qt_5_12_8_MinGW_64_bit-Release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        将这个目录下的可执行文件拿出来，和这下面的一大堆库一起</p><p><img src="image-20230602143253394.png" alt="image-20230602143253394"></p><p>​        和</p><p><img src="image-20230602143320878.png" alt="image-20230602143320878"></p><p>​        把他们拎出来：</p><p>​        扔到一个建议是<strong>全程不带一点中文名的路径（for example:你的D盘）</strong>，把我说的那一大坨东西，扔到一个新建的文件夹下。</p><p>​        现在，<strong>在应用搜索处，搜索你构建的编译器</strong>，比如说根据这个名字：</p><pre class="line-numbers language-none"><code class="language-none">build-5128opencv-Desktop_Qt_5_12_8_MinGW_64_bit-Release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我应当选择</p><pre class="line-numbers language-none"><code class="language-none">Qt5.12.8 Mingw64bits<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然后选择之运行：</p><p><img src="image-20230602144243995.png" alt="image-20230602144243995"></p><p>​        cd 到自己的构建文件夹下</p><pre class="line-numbers language-none"><code class="language-none">windeployqt yourFileName.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然后就会给你配置一些库了！</p><p><img src="image-20230602144734439.png" alt="image-20230602144734439"></p><p>​        点击一下</p><p>​        Error 1： 少库了！</p><p>​        总而言之就是少库了！别慌别慌，补一下就好啦！</p><pre class="line-numbers language-none"><code class="language-none">D:\QT\Qt5.12.8\5.12.8\mingw73_64\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        找到自己安装QT下的这种文件夹，找到缺什么库就直接Copy即可。</p><p>​        Error 2: Terminate by unknown Error</p><p>​        反正就是扔给你这个未知的错误，本质上来讲就是少库（对可执行文件而言），可能是没有在全英文路径下打包造成。</p><p>​        Error 3：EXE文件在装死</p><p>​        嘛，说白了还是少库，有人急了（是我/(ㄒoㄒ)/~~）咋还少库啊，事实上是：库签名对不上，使用的mingw编译器下的windeployqt没有给你正确的打包！可能还是：没有在全英文路径下打包造成。实在不行库全删了，缺啥补啥！</p><p>​        Anyway，忙活了两天的(大致回忆了一下是块30多个小时处理之)配置这里说完了，下一篇博客我介绍一下<code>Linux + qt5.12.8 + opencv 4.5.3</code>的配置。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ros小车简单操作（水！）</title>
      <link href="/2023/05/31/Ros%E5%B0%8F%E8%BD%A6%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%EF%BC%88%E6%B0%B4%EF%BC%81%EF%BC%89/"/>
      <url>/2023/05/31/Ros%E5%B0%8F%E8%BD%A6%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%EF%BC%88%E6%B0%B4%EF%BC%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS-小车文档"><a href="#ROS-小车文档" class="headerlink" title="ROS 小车文档"></a>ROS 小车文档</h1><h3 id="ROS小车的结构"><a href="#ROS小车的结构" class="headerlink" title="ROS小车的结构"></a>ROS小车的结构</h3><p><img src="image-20230531203328775.png" alt="image-20230531203328775"></p><p>​        小车主要由<strong>树莓派 4B、底盘控制器、激光雷达、深度相机、2 个配有编码器的电机以及底盘</strong>组成。<strong>竞赛版小车增加了麦克风阵列模块，能够实现声源识别和语义识别</strong></p><h2 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h2><p>​        它可以：</p><p><strong>1）无线手柄遥控小车运动</strong></p><p><strong>2）使用电脑端的图形界面遥控小车运动</strong></p><p><strong>3）使用激光雷达完成 SLAM 构建二维地图</strong></p><p><strong>4）在二维地图中完成任意终点的路径规划和动态壁障</strong></p><p><strong>5）使用激光雷达完成移动物体的实时跟踪</strong></p><p><strong>6）使用深度相机采集深度图像和 RGB 图像</strong></p><p><strong>7）使用深度相机结合激光雷达完成三维 SLAM 地图构建</strong></p><p><strong>8）在三维地图中完成任意终点的路径规划和动态壁障</strong></p><p><strong>9）使用 RGB 摄像头完成车道线和单线巡线</strong></p><p><strong>10）实现电量低自动回家功能</strong></p><p><strong>11）语音控制小车运动</strong></p><h2 id="为啥能做到：由ROS开发"><a href="#为啥能做到：由ROS开发" class="headerlink" title="为啥能做到：由ROS开发"></a>为啥能做到：由ROS开发</h2><p>​        ROS机器人操作系统<strong>（Robot Operating System）</strong>进行开发。该平台是用于编写机器人软件程序的一种具有高度灵活性的软件架构。它包含了大量工具软件、库代码和约定协议，旨在简化跨机器人平台创建复杂、鲁棒的机器人行为这一过程的难度与复杂度。</p><h2 id="能在啥场景下干活"><a href="#能在啥场景下干活" class="headerlink" title="能在啥场景下干活"></a>能在啥场景下干活</h2><ol><li><p>探测地图</p></li><li><p>在1 的基础之后自主导航</p></li><li><p>可以做家具机器人的基础，实现基于人语音指令下的定向空间运动</p></li><li><p>（我们自己的模块之一）：接入ChatGPT实现对话（but 还有音频接口问题尚待解决）</p><h2 id="使用方法（比较复杂）"><a href="#使用方法（比较复杂）" class="headerlink" title="使用方法（比较复杂）"></a>使用方法（比较复杂）</h2></li></ol><p>​        打开小车的开关（摁下按钮），其远程主机（也就是用户的电脑）连接小车的WIFI。</p><pre class="line-numbers language-none"><code class="language-none">WiFi 名称： NCUT-EPRobot密码： 12345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        打开Bitvise SSH Client，填上参数</p><p>​        点击Login_in就发现左侧这些栏目多了个New Terminal和可以打开GUI界面的文件系统按钮。在 New Terminal那个地方输入指令。</p><p>​        </p><h3 id="SubModule1-手柄控制"><a href="#SubModule1-手柄控制" class="headerlink" title="SubModule1:  手柄控制"></a>SubModule1:  手柄控制</h3><p>​            打开CMD窗口后输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roslaunch eprobot_start EPRobot_joy_start.launch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​            可以用手柄啦！    </p><h3 id="SubModule2-语言控制"><a href="#SubModule2-语言控制" class="headerlink" title="SubModule2:  语言控制"></a>SubModule2:  语言控制</h3><p>​        打开CMD窗口后输入</p><pre class="line-numbers language-none"><code class="language-none">roslaunch xf_mic_asr_offline voice_control.launch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        控制台上会输出大量的信息，随后站在车前说出关键词：<strong>梦工厂</strong>小车会摇动一下轮子表示接受到了，以表示被唤醒。</p><p>​        当唤醒小车后，便可按照<strong>启动时</strong>的终端<strong>提示</strong>进行语音控制。目前小车只能够响应小车前进”、“小车后退”、“小车停”、“小车左转”以及“小车右转”<strong>，更多的响应可自行编程实现。需要注意的是，该麦克风阵列的</strong>语义识别<strong>是按照</strong>关键词<strong>进行的，小车搭载的功能包中，将“小车”设定为</strong>主语关键词<strong>，“后退”、“前进”为</strong>动词关键词<strong>，只要一句话中包含</strong>这两组关键词，小车就可以响应，如“亲爱的小车请向后退”，小车便可后退一段距离。</p><p>​        <strong><em>Attention</em></strong>：注意，小车拥有降噪功能，实现的原理是检测声音位置并将离声源位置最近的麦克风设置成主麦克风，因此，背离主麦克风说话可能不会接收到（此次置信度过低而被小车判定为噪音过滤掉了）</p><p>​        其余的模块因为演示周期过长（而且复杂，强制要求使用Ubuntu16.04操作系统并且操作复杂，鉴于是科普性的讲座，还是思来想去略去了）</p><h3 id="About-比赛等"><a href="#About-比赛等" class="headerlink" title="About 比赛等"></a>About 比赛等</h3><p>​        因为是这个学期刚刚接手这个项目，因此只拿之参加了吉林省智能机器人大赛，还尚未到比赛结束日期，正在开发中。所以尚未有获奖记录。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT new 14</title>
      <link href="/2023/05/29/QT-new-14/"/>
      <url>/2023/05/29/QT-new-14/</url>
      
        <content type="html"><![CDATA[<h1 id="QT-new-14"><a href="#QT-new-14" class="headerlink" title="QT new 14"></a>QT new 14</h1><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>​        我们的定时器可以做到随着事件的事件流逝触发事件。</p><p>​        我们的办法是：添加窗口的代码，从而实现计时器。</p><p>​        在窗口中添加两个label:</p><p>​        随后改写事件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;QT_BEGIN_NAMESPACEnamespace Ui &#123; class Widget; &#125;QT_END_NAMESPACEclass Widget : public QWidget&#123;    Q_OBJECTpublic:    Widget(QWidget *parent &#x3D; nullptr);    ~Widget();    void timerEvent(QTimerEvent*);    int id1;    int id2;private:    Ui::Widget *ui;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F;启动定时器    id1  &#x3D; startTimer(1000);&#x2F;&#x2F;1,间隔, 单位是毫秒    id2 &#x3D; startTimer(2000);&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::timerEvent(QTimerEvent* ev)&#123;    if(ev-&gt;timerId() &#x3D;&#x3D; id1)&#123;        static int num &#x3D; 1;        ui-&gt;label_2-&gt;setText(QString::number(num++));    &#125;     if(ev-&gt;timerId() &#x3D;&#x3D; id2)    &#123;        static int num2 &#x3D; 1;        ui-&gt;label_3-&gt;setText(QString::number(num2++));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意到，对于多个计时器需要接受返回ID并加之以判断才好！</p><h2 id="类的形式"><a href="#类的形式" class="headerlink" title="类的形式"></a>类的形式</h2><p>​        这个形式简单的多!直接一个类解决所有的问题!</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include&lt;QTimer&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F;启动定时器    id1  &#x3D; startTimer(1000);&#x2F;&#x2F;1,间隔, 单位是毫秒    id2 &#x3D; startTimer(2000);    QTimer* timer &#x3D; new QTimer(this);    timer-&gt;start(500); &#x2F;&#x2F; 到0.5秒发出信号    connect(timer,&amp;QTimer::timeout,[&#x3D;]()&#123;        static int num &#x3D; 1;        ui-&gt;label_4-&gt;setText(QString::number(num++));    &#125;);    &#x2F;&#x2F;    connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[&#x3D;]()&#123;        timer-&gt;stop();    &#125;);&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::timerEvent(QTimerEvent* ev)&#123;    if(ev-&gt;timerId() &#x3D;&#x3D; id1)&#123;        static int num &#x3D; 1;        ui-&gt;label_2-&gt;setText(QString::number(num++));    &#125;     if(ev-&gt;timerId() &#x3D;&#x3D; id2)    &#123;        static int num2 &#x3D; 1;        ui-&gt;label_3-&gt;setText(QString::number(num2++));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Extensive-Reading"><a href="#Extensive-Reading" class="headerlink" title="Extensive Reading"></a>Extensive Reading</h2><p>​        传送门：<a href="https://blog.csdn.net/Mountain_tai_li/article/details/130529628">https://blog.csdn.net/Mountain_tai_li/article/details/130529628</a></p><p>​        QTimer 类提供重复和单次计时器。</p><p>​        QTimer 类为计时器提供了一个高级编程接口。要使用它，首先创建一个 QTimer实例，将其 timeout() 信号连接到相应的插槽，然后调用 start()。从那时起，它将以恒定的间隔发出 timeout() 信号。</p><p>​        一秒（1000毫秒）计时器的示例（来自模拟时钟示例）：</p><pre class="line-numbers language-none"><code class="language-none">QTimer *timer &#x3D; new QTimer(this);connect(timer, SIGNAL(timeout()), this, SLOT(update()));timer-&gt;start(1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        从那时起，每秒调用一次 update() 槽函数。</p><p>​        也可以通过调用 setSingleShot（true） 将计时器设置为仅超时一次。您还可以使用静态 QTimer::singleShot() 函数在指定的时间间隔后调用槽函数：</p><p>​        QTimer::singleShot(200, this, SLOT(updateCaption()));<br>​        在多线程应用程序中，可以在任何具有事件循环的线程中使用 QTimer。要从非 GUI 线程启动事件循环，使用 QThread::exec()。Qt使用计时器的线程亲和力来确定哪个线程将发出timeout()信号。因此，您必须在其线程中启动和停止计时器;无法从另一个线程启动计时器。作为特殊情况timeout 为 0 的 QTimer 将在窗口系统的事件队列中的所有事件都得到处理后立即timeout。这可用于完成繁重的工作，同时提供活泼的用户界面：</p><pre class="line-numbers language-none"><code class="language-none">QTimer *timer &#x3D; new QTimer(this);connect(timer, SIGNAL(timeout()), this, SLOT(processOneThing()));timer-&gt;start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        从那时起，processOneThing()槽函数将被重复调用。它应该以这样一种方式编写，即它总是快速返回（通常在处理一个数据项之后），以便Qt可以将事件传递到用户界面，并在完成所有工作后立即停止计时器。这是在GUI应用程序中实现繁重工作的传统方式，但随着多线程在越来越多的平台上变得可用，我们预计零毫秒QTimer对象将逐渐被QThreads取代。</p><p>​        定时器精度和分辨率<br>​        计时器的准确性取决于底层操作系统和硬件。大多数平台都支持 1 毫秒的分辨率，尽管在许多现实情况下，计时器的精度不会等于此分辨率。</p><p>​        精度还取决于计时器类型。对于Qt::PreciseTimer，QTimer将尝试将精度保持在1毫秒。精确的计时器也不会比预期早超时。对于 Qt::CoarseTimer 和 Qt::VeryCoarseTimer 类型，QTimer 可能会比预期更早timeout，在这些类型的范围内：Qt::CoarseTimer 的间隔为 5%，Qt::VeryCoarseTimer 的间隔为 500 毫秒。如果系统繁忙或无法提供请求的准确性，则所有计时器类型都可能晚于预期超时。在timeout 溢出的情况下，Qt只会发出一次active()，即使多个超时已经过期，然后恢复原始间隔。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows-API-程序设计（6）</title>
      <link href="/2023/05/29/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%886%EF%BC%89/"/>
      <url>/2023/05/29/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%886%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="系统学习Windows-API-6"><a href="#系统学习Windows-API-6" class="headerlink" title="系统学习Windows API 6"></a>系统学习Windows API 6</h1><h2 id="查看磁盘容量"><a href="#查看磁盘容量" class="headerlink" title="查看磁盘容量"></a>查看磁盘容量</h2><h3 id="GetDiskFreeSpace-amp-amp-GetDiskFreeSpaceEx"><a href="#GetDiskFreeSpace-amp-amp-GetDiskFreeSpaceEx" class="headerlink" title="GetDiskFreeSpace &amp;&amp; GetDiskFreeSpaceEx"></a>GetDiskFreeSpace &amp;&amp; GetDiskFreeSpaceEx</h3><p>​        我们使用这些函数来得到我们想要的信息：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;int main() &#123;BOOL isFine;&#x2F;&#x2F; 蔟DWORD dwTotlaClusters;DWORD dwFreeCluster;&#x2F;&#x2F; 扇区DWORD dwSectPerClust;&#x2F;&#x2F;字节DWORD dwBytesPerSect;isFine &#x3D; GetDiskFreeSpace(TEXT(&quot;C:&#x2F;&quot;),&amp;dwSectPerClust,&amp;dwBytesPerSect,&amp;dwFreeCluster,&amp;dwTotlaClusters);if (!isFine) &#123;printf(&quot;Error&quot;);return GetLastError();&#125;printf(&quot;\nGet:&gt;\n&quot;);printf(&quot;总蔟：%d\t每一蔟的扇区数:%d\t空闲的数量：%d\t每个扇区的字节数：%d\t&quot;, dwTotlaClusters, dwSectPerClust, dwFreeCluster, dwBytesPerSect);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <img src="image-20230529162144848.png" alt="image-20230529162144848"></p><p>​        OK的！</p><p>​        那这个Ex版本的是啥呢：精简的版本的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DWORD64 qwFreeBytes, qwFreeBytesToCaller, qwTotalBytes;isFine &#x3D; GetDiskFreeSpaceEx(TEXT(&quot;C:&quot;), (PULARGE_INTEGER)&amp; qwFreeBytesToCaller,(PULARGE_INTEGER)&amp;qwTotalBytes, (PULARGE_INTEGER)&amp;qwFreeBytes);if(!isFine) &#123;printf(&quot;Error&quot;);return GetLastError();&#125;printf(&quot;磁盘的总容量：%I64d\t磁盘的总空闲容量：%I64d\t&quot;, qwTotalBytes, qwFreeBytes);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230529163015847.png" alt="image-20230529163015847"></p><h3 id="getDiskFreeSpace-函数-fileapi-h"><a href="#getDiskFreeSpace-函数-fileapi-h" class="headerlink" title="getDiskFreeSpace 函数 (fileapi.h)"></a>getDiskFreeSpace 函数 (fileapi.h)</h3><p>​        本文内容<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#syntax">语法</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#parameters">参数</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#return-value">返回值</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#remarks">注解</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#requirements">要求</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#see-also">另请参阅</a></p><p>​        检索有关指定磁盘的信息，包括磁盘上的可用空间量。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetDiskFreeSpace</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  LPCSTR  lpRootPathName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpSectorsPerCluster<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpBytesPerSector<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpNumberOfFreeClusters<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpTotalNumberOfClusters<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        要为其返回信息的磁盘的根目录。 如果此参数为 <strong>NULL</strong>，则该函数使用当前磁盘的根目录。 如果此参数是 UNC 名称，则必须包含尾随反斜杠 (，例如“\\MyServer\MyShare\”) 。 此外，驱动器规范必须具有尾随反斜杠 (，例如“C：\”) 。 调用应用程序必须具有此目录 <strong>FILE_LIST_DIRECTORY</strong> 访问权限。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpSectorsPerCluster<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收每个群集扇区数的变量的指针。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpBytesPerSector<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收每个扇区字节数的变量的指针。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpNumberOfFreeClusters<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收磁盘上可用可用群集总数的变量的指针，该群集可供与调用线程关联的用户使用。</p><p>​        如果使用每用户磁盘配额，此值可能小于磁盘上的可用群集总数。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpTotalNumberOfClusters<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向一个变量的指针，该变量接收磁盘上可用于与调用线程关联的用户的群集总数。</p><p>​        如果使用每用户磁盘配额，此值可能小于磁盘上的群集总数。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespaceexa">        GetDiskFreeSpaceEx</a> 函数可避免 <strong>GetDiskFreeSpace</strong> 函数所需的一些算术。</p><p>​        符号链接行为 - 如果路径指向符号链接，则会对目标执行操作。</p><p> 备注</p><p>​        fileapi.h 标头将 GetDiskFreeSpace 定义为别名，该别名根据 UNICODE 预处理器常量的定义自动选择此函数的 ANSI 或 Unicode 版本。 将非中性编码别名与非非编码的代码混合使用可能会导致编译或运行时错误不匹配。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/intl/conventions-for-function-prototypes">函数原型的约定</a>。</p><h3 id="getDiskFreeSpaceEx函数-fileapi-h"><a href="#getDiskFreeSpaceEx函数-fileapi-h" class="headerlink" title="getDiskFreeSpaceEx函数 (fileapi.h)"></a>getDiskFreeSpaceEx函数 (fileapi.h)</h3><p>​        本文内容<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#syntax">语法</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#parameters">参数</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#return-value">返回值</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#remarks">注解</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#requirements">要求</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#see-also">另请参阅</a></p><p>​        检索有关磁盘卷上可用空间量的信息，即总空间量、可用空间总量以及与调用线程关联的用户可用的可用空间总量。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetDiskFreeSpaceEx</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  LPCSTR          lpDirectoryName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> PULARGE_INTEGER lpFreeBytesAvailableToCaller<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> PULARGE_INTEGER lpTotalNumberOfBytes<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> PULARGE_INTEGER lpTotalNumberOfFreeBytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpDirectoryName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        磁盘上的目录。</p><p>​        如果此参数为 <strong>NULL</strong>，则该函数使用当前磁盘的根目录。</p><p>​        如果此参数是 UNC 名称，则必须包含尾随反斜杠，例如“\\MyServer\MyShare\”。</p><p>​        此参数不必在磁盘上指定根目录。 该函数接受磁盘上的任何目录。</p><p>​        调用应用程序必须对此具有 <strong>FILE_LIST_DIRECTORY</strong> 访问权限<br>“sample”目录中。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFreeBytesAvailableToCaller<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向一个变量的指针，该变量接收磁盘上的可用字节总数，这些字节可供与调用线程关联的用户使用。</p><p>​        此参数可以为 NULL。</p><p>​        如果使用每用户配额，此值可能小于磁盘上的可用字节总数。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpTotalNumberOfBytes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向一个变量的指针，该变量接收磁盘上可用于与调用线程关联的用户的字节总数。</p><p>​        此参数可以为 NULL。</p><p>​        如果使用每用户配额，此值可能小于磁盘上的字节总数。</p><p>​        若要确定磁盘或卷上的字节总数，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpTotalNumberOfFreeBytes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收磁盘上可用字节总数的变量的指针。</p><p>​        此参数可以为 NULL。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为 0 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p><h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><p>​        此函数获取的值的类型 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">为ULARGE_INTEGER</a>。 不要将这些值截断为 32 位。</p><p>​        <strong>GetDiskFreeSpaceEx</strong> 函数返回 <em>lpTotalNumberOfFreeBytes</em> 和 <em>lpFreeBytesAvailable</em> 的所有 CD 请求的零 (0) ，除非磁盘是 CD-RW 驱动器中的未写入 CD。</p><p>​        符号链接行为 - 如果路径指向符号链接，则会对目标执行操作。</p><h3 id="ULARGE-INTEGER-union-winnt-h"><a href="#ULARGE-INTEGER-union-winnt-h" class="headerlink" title="ULARGE_INTEGER union (winnt.h)"></a>ULARGE_INTEGER union (winnt.h)</h3><p>​        本文内容<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#syntax">语法</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#members">成员</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#remarks">备注</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#requirements">要求</a><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#see-also">另请参阅</a></p><p>表示 64 位无符号整数值。</p><p><strong>注意</strong> C 编译器可能本机支持 64 位整数。 例如，Microsoft Visual C++支持<a href="https://learn.microsoft.com/zh-cn/windows/desktop/Midl/--int64">__int64</a>大小的整数类型。 有关详细信息，请参阅 C 编译器随附的文档。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">union</span> _ULARGE_INTEGER <span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    DWORD LowPart<span class="token punctuation">;</span>    DWORD HighPart<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> DUMMYSTRUCTNAME<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>    DWORD LowPart<span class="token punctuation">;</span>    DWORD HighPart<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> u<span class="token punctuation">;</span>  ULONGLONG QuadPart<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> ULARGE_INTEGER<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><pre class="line-numbers language-none"><code class="language-none">DUMMYSTRUCTNAMEDUMMYSTRUCTNAME.LowPartDUMMYSTRUCTNAME.HighPartuu.LowPartu.HighPartQuadPart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>64 位无符号整数。</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p><strong>ULARGE_INTEGER</strong>结构实际上是一个联合体。 如果编译器内置了对 64 位整数的支持，请使用 <strong>QuadPart</strong> 成员存储 64 位整数。 否则，请使用 <strong>LowPart</strong> 和 <strong>HighPart</strong> 成员存储 64 位整数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Windows 32API </tag>
            
            <tag> 摸鱼ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch学习5</title>
      <link href="/2023/05/28/pytorch%E5%AD%A6%E4%B9%A05/"/>
      <url>/2023/05/28/pytorch%E5%AD%A6%E4%B9%A05/</url>
      
        <content type="html"><![CDATA[<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>​        先扔一个<code>pytorch</code>的官网！<a href="https://pytorch.org/docs">https://pytorch.org/docs</a>        </p><p>​        继续：</p><p>​        这是参数：作为图像处理常用的是Conv2d</p><div class="table-container"><table><thead><tr><th><a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv1d.html#torch.nn.Conv1d"><code>nn.Conv1d</code></a></th><th>Applies a 1D convolution over an input signal composed of several input planes.</th></tr></thead><tbody><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d"><code>nn.Conv2d</code></a></td><td>Applies a 2D convolution over an input signal composed of several input planes.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv3d.html#torch.nn.Conv3d"><code>nn.Conv3d</code></a></td><td>Applies a 3D convolution over an input signal composed of several input planes.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose1d.html#torch.nn.ConvTranspose1d"><code>nn.ConvTranspose1d</code></a></td><td>Applies a 1D transposed convolution operator over an input image composed of several input planes.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose2d.html#torch.nn.ConvTranspose2d"><code>nn.ConvTranspose2d</code></a></td><td>Applies a 2D transposed convolution operator over an input image composed of several input planes.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose3d.html#torch.nn.ConvTranspose3d"><code>nn.ConvTranspose3d</code></a></td><td>Applies a 3D transposed convolution operator over an input image composed of several input planes.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConv1d.html#torch.nn.LazyConv1d"><code>nn.LazyConv1d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv1d.html#torch.nn.Conv1d"><code>torch.nn.Conv1d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>Conv1d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConv2d.html#torch.nn.LazyConv2d"><code>nn.LazyConv2d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html#torch.nn.Conv2d"><code>torch.nn.Conv2d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>Conv2d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConv3d.html#torch.nn.LazyConv3d"><code>nn.LazyConv3d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.Conv3d.html#torch.nn.Conv3d"><code>torch.nn.Conv3d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>Conv3d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConvTranspose1d.html#torch.nn.LazyConvTranspose1d"><code>nn.LazyConvTranspose1d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose1d.html#torch.nn.ConvTranspose1d"><code>torch.nn.ConvTranspose1d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>ConvTranspose1d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConvTranspose2d.html#torch.nn.LazyConvTranspose2d"><code>nn.LazyConvTranspose2d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose2d.html#torch.nn.ConvTranspose2d"><code>torch.nn.ConvTranspose2d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>ConvTranspose2d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.LazyConvTranspose3d.html#torch.nn.LazyConvTranspose3d"><code>nn.LazyConvTranspose3d</code></a></td><td>A <a href="https://pytorch.org/docs/stable/generated/torch.nn.ConvTranspose3d.html#torch.nn.ConvTranspose3d"><code>torch.nn.ConvTranspose3d</code></a> module with lazy initialization of the <code>in_channels</code> argument of the <code>ConvTranspose3d</code> that is inferred from the <code>input.size(1)</code>.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.Unfold.html#torch.nn.Unfold"><code>nn.Unfold</code></a></td><td>Extracts sliding local blocks from a batched input tensor.</td></tr><tr><td><a href="https://pytorch.org/docs/stable/generated/torch.nn.Fold.html#torch.nn.Fold"><code>nn.Fold</code></a></td><td>Combines an array of sliding local blocks into a large containing tensor.</td></tr></tbody></table></div><p>​        点进去看看：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">CLASS <span class="token class-name">torch</span><span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token punctuation">,</span> out_channels<span class="token punctuation">,</span> kernel_size<span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> dilation<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> groups<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> padding_mode<span class="token operator">=</span><span class="token string">'zeros'</span><span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        Applies a 2D convolution over an input signal composed of several input planes.</p><p>In the simplest case, the output value of the layer with input size </p><script type="math/tex; mode=display">(N,C_{in},H,W)</script><p>​        and output</p><script type="math/tex; mode=display">(N,C_{out},H_{out},W_{out})</script><p>​         can be precisely described as:</p><script type="math/tex; mode=display">out(N_i,C_{outj}) = bias(C_{outj})+\sum_{k=0}^{C_{in}-1}weight(C_{out},k)*input(N_i,k)</script><p>​        where ⋆ is the valid 2D <a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a> operator, <em>N</em> is a batch size, C<em> denotes a number of channels, </em>H<em> is a height of input planes in pixels, and </em>W* is width in pixels.</p><p>​        This module supports <a href="https://pytorch.org/docs/stable/notes/cuda.html#tf32-on-ampere">TensorFloat32</a>.</p><p>​        On certain ROCm devices, when using float16 inputs this module will use <a href="https://pytorch.org/docs/stable/notes/numerical_accuracy.html#fp16-on-mi200">different precision</a> for backward.</p><ul><li><p><code>stride</code> controls the stride for the cross-correlation, a single number or a tuple.</p></li><li><p><code>padding</code> controls the amount of padding applied to the input. It can be either a string {‘valid’, ‘same’} or an int / a tuple of ints giving the amount of implicit padding applied on both sides.</p></li><li><p><code>dilation</code> controls the spacing between the kernel points; also known as the à trous algorithm. It is harder to describe, but this <a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a> has a nice visualization of what <code>dilation</code> does.</p></li><li><p><code>groups</code> controls the connections between inputs and outputs. <code>in_channels</code> and <code>out_channels</code> must both be divisible by <code>groups</code>. For example,</p><blockquote><ul><li>At groups=1, all inputs are convolved to all outputs.</li><li>At groups=2, the operation becomes equivalent to having two conv layers side by side, each seeing half the input channels and producing half the output channels, and both subsequently concatenated.</li><li>At groups= <code>in_channels</code>, each input channel is convolved with its own set of filters (of size $\frac{in_channels}{out_channels}$)</li></ul></blockquote></li></ul><p>​        The parameters <code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> can either be:</p><blockquote><ul><li>a single <code>int</code> – in which case the same value is used for the height and width dimension</li><li>a <code>tuple</code> of two ints – in which case, the first int is used for the height dimension, and the second int for the width dimension</li></ul></blockquote><p>​        When groups == in_channels and out_channels == K * in_channels, where K is a positive integer, this operation is also known as a “depthwise convolution”.</p><p>​        In other words, for an input of size $(N,C_{in},L_{in})$, a depthwise convolution with a depthwise multiplier<em>K</em> can be performed with the arguments ($C_{in}=C_{in},C_{out}=C_{in}×K,…,groups=C_{in}$.)</p><p>​        In some circumstances when given tensors on a CUDA device and using CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting </p><pre class="line-numbers language-none"><code class="language-none">torch.backends.cudnn.deterministic &#x3D; True. <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        See <a href="https://pytorch.org/docs/stable/notes/randomness.html">Reproducibility</a> for more information.</p><p>​        <code>padding=&#39;valid&#39;</code> is the same as no padding. <code>padding=&#39;same&#39;</code> pads the input so the output has the shape as the input. However, this mode doesn’t support any stride values other than 1.</p><p>​        This module supports complex data types i.e. <code>complex32, complex64, complex128</code>.</p><p>Parameters:</p><ul><li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a>) – Number of channels in the input image</li><li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a>) – Number of channels produced by the convolution</li><li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a>) – Size of the convolving kernel</li><li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em> <em>optional</em>) – Stride of the convolution. Default: 1</li><li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#str"><em>str</em></a><em>,</em> <em>optional</em>) – Padding added to all four sides of the input. Default: 0</li><li><strong>padding_mode</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str"><em>str</em></a><em>,</em> <em>optional</em>) – <code>&#39;zeros&#39;</code>, <code>&#39;reflect&#39;</code>, <code>&#39;replicate&#39;</code> or <code>&#39;circular&#39;</code>. Default: <code>&#39;zeros&#39;</code></li><li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple"><em>tuple</em></a><em>,</em> <em>optional</em>) – Spacing between kernel elements. Default: 1</li><li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a><em>,</em> <em>optional</em>) – Number of blocked connections from input channels to output channels. Default: 1</li><li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool"><em>bool</em></a><em>,</em> <em>optional</em>) – If <code>True</code>, adds a learnable bias to the output. Default: <code>True</code></li></ul><h2 id="what-is-Convolution-arithmetic-from-read-ME"><a href="#what-is-Convolution-arithmetic-from-read-ME" class="headerlink" title="what is Convolution arithmetic(from read ME)"></a>what is Convolution arithmetic(from read ME)</h2><p>​        A technical report on convolution arithmetic in the context of deep learning.</p><p>​        The code and the images of this tutorial are free to use as regulated by the<br>licence and subject to proper attribution:</p><ul><li>[1] Vincent Dumoulin, Francesco Visin - <a href="https://arxiv.org/abs/1603.07285">A guide to convolution arithmetic<br>for deep learning</a><br>(<a href="https://gist.github.com/fvisin/165ca9935392fa9600a6c94664a01214">BibTeX</a>)</li></ul><h2 id="Convolution-animations"><a href="#Convolution-animations" class="headerlink" title="Convolution animations"></a>Convolution animations</h2><p>_N.B.: Blue maps are inputs, and cyan maps are outputs._</p><table style="width:100%; table-layout:fixed;">  <tr>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/no_padding_no_strides.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/arbitrary_padding_no_strides.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/same_padding_no_strides.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/full_padding_no_strides.gif"></td>  </tr>  <tr>    <td>No padding, no strides</td>    <td>Arbitrary padding, no strides</td>    <td>Half padding, no strides</td>    <td>Full padding, no strides</td>  </tr>  <tr>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/no_padding_strides.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/padding_strides.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/padding_strides_odd.gif"></td>    <td></td>  </tr>  <tr>    <td>No padding, strides</td>    <td>Padding, strides</td>    <td>Padding, strides (odd)</td>    <td></td>  </tr></table><h2 id="Transposed-convolution-animations"><a href="#Transposed-convolution-animations" class="headerlink" title="Transposed convolution animations"></a>Transposed convolution animations</h2><p>_N.B.: Blue maps are inputs, and cyan maps are outputs._</p><table style="width:100%; table-layout:fixed;">  <tr>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/no_padding_no_strides_transposed.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/arbitrary_padding_no_strides_transposed.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/same_padding_no_strides_transposed.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/full_padding_no_strides_transposed.gif"></td>  </tr>  <tr>    <td>No padding, no strides, transposed</td>    <td>Arbitrary padding, no strides, transposed</td>    <td>Half padding, no strides, transposed</td>    <td>Full padding, no strides, transposed</td>  </tr>  <tr>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/no_padding_strides_transposed.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/padding_strides_transposed.gif"></td>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/padding_strides_odd_transposed.gif"></td>    <td></td>  </tr>  <tr>    <td>No padding, strides, transposed</td>    <td>Padding, strides, transposed</td>    <td>Padding, strides, transposed (odd)</td>    <td></td>  </tr></table><h2 id="Dilated-convolution-animations"><a href="#Dilated-convolution-animations" class="headerlink" title="Dilated convolution animations"></a>Dilated convolution animations</h2><p>_N.B.: Blue maps are inputs, and cyan maps are outputs._</p><table style="width:25%"; table-layout:fixed;>  <tr>    <td><img width="150px" src="https://github.com/vdumoulin/conv_arithmetic/raw/master/gif/dilation.gif"></td>  </tr>  <tr>    <td>No padding, no stride, dilation</td>  </tr></table><h2 id="Generating-the-Makefile"><a href="#Generating-the-Makefile" class="headerlink" title="Generating the Makefile"></a>Generating the Makefile</h2><p>From the repository’s root directory:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./bin/generate_makefile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="Generating-the-animations"><a href="#Generating-the-animations" class="headerlink" title="Generating the animations"></a>Generating the animations</h2><p>From the repository’s root directory:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> all_animations<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>The animations will be output to the <code>gif</code> directory. Individual animation steps<br>will be output in PDF format to the <code>pdf</code> directory and in PNG format to the<br><code>png</code> directory.</p><h2 id="Compiling-the-document"><a href="#Compiling-the-document" class="headerlink" title="Compiling the document"></a>Compiling the document</h2><p>From the repository’s root directory:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230528203415187.png" alt="image-20230528203415187"></p><p>​        其实就是这样，我们3 x 3的扫过图像，并且对之求和输出到新单元，我们发现他会做九次。，故得到了一个 3 x 3的表。</p><p><img src="image-20230528203830290.png" alt="image-20230528203830290"></p><p>​        这样就可以升维了，从而提取信息特征。</p><p><img src="image-20230528213941244.png" alt="image-20230528213941244"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> Conv2d<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoaderdataset <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span><span class="token string">"../data"</span><span class="token punctuation">,</span>train <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">,</span>                                       transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                        download<span class="token operator">=</span><span class="token boolean">True</span>                                       <span class="token punctuation">)</span>dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span>batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">cc</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>cc<span class="token punctuation">,</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>out_channels<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> xc <span class="token operator">=</span> cc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token keyword">in</span> dataloader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span>data    output <span class="token operator">=</span> c<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>imgs<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们把它输出到tensorboard里去：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch <span class="token keyword">import</span> nn<span class="token keyword">from</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">import</span> Conv2d<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriterdataset <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span><span class="token string">"../data"</span><span class="token punctuation">,</span>train <span class="token operator">=</span> <span class="token boolean">False</span><span class="token punctuation">,</span>                                       transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                        download<span class="token operator">=</span><span class="token boolean">True</span>                                       <span class="token punctuation">)</span>dataloader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token punctuation">,</span>batch_size<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">cc</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>cc<span class="token punctuation">,</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>conv1 <span class="token operator">=</span> Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>out_channels<span class="token operator">=</span><span class="token number">6</span><span class="token punctuation">,</span>kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>conv1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> xc <span class="token operator">=</span> cc<span class="token punctuation">(</span><span class="token punctuation">)</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"../logs"</span><span class="token punctuation">)</span>step <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> data <span class="token keyword">in</span> dataloader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span> targets <span class="token operator">=</span>data    output <span class="token operator">=</span> c<span class="token punctuation">(</span>imgs<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>imgs<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    output <span class="token operator">=</span> torch<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>output<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_images<span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span>imgs<span class="token punctuation">,</span>step<span class="token punctuation">)</span>    writer<span class="token punctuation">.</span>add_images<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">,</span> output<span class="token punctuation">,</span> step<span class="token punctuation">)</span>    step <span class="token operator">=</span> step <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>yolofacev5<span class="token punctuation">)</span> pythonProject<span class="token operator"><span class="token file-descriptor important">1</span>></span> <span class="token builtin class-name">cd</span> <span class="token punctuation">..</span><span class="token punctuation">(</span>yolofacev5<span class="token punctuation">)</span> pythonProject<span class="token operator"><span class="token file-descriptor important">1</span>></span> tensorboard <span class="token parameter variable">--logdir</span><span class="token operator">=</span>logs      <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230528214836000.png" alt="image-20230528214836000"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pytorch </tag>
            
            <tag> python </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch学习4</title>
      <link href="/2023/05/28/pytorch%E5%AD%A6%E4%B9%A04/"/>
      <url>/2023/05/28/pytorch%E5%AD%A6%E4%B9%A04/</url>
      
        <content type="html"><![CDATA[<h1 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h1><p>​        dataLoader意如其名，就是（从dataset）加载数据集</p><p><img src="image-20230520131556354.png" alt="image-20230520131556354"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span class="token comment"># 测试集</span>test_data <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span>train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>test_loader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token operator">=</span>test_data<span class="token punctuation">,</span>batch_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>num_workers<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>drop_last<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># 第一张样本</span>img<span class="token punctuation">,</span>target <span class="token operator">=</span> test_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token comment"># 可以看看样本</span><span class="token keyword">for</span> data <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span>targets <span class="token operator">=</span>data    <span class="token keyword">print</span><span class="token punctuation">(</span>imgs<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>targets<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以使用SummaryWriter 来展示之：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> DataLoader<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriter<span class="token comment"># 测试集</span>test_data <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>CIFAR10<span class="token punctuation">(</span><span class="token string">"./dataset"</span><span class="token punctuation">,</span>train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>transform<span class="token operator">=</span>torchvision<span class="token punctuation">.</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>test_loader <span class="token operator">=</span> DataLoader<span class="token punctuation">(</span>dataset<span class="token operator">=</span>test_data<span class="token punctuation">,</span>batch_size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>num_workers<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>drop_last<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token comment"># 第一张样本</span>img<span class="token punctuation">,</span>target <span class="token operator">=</span> test_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>step <span class="token operator">=</span> <span class="token number">0</span>writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"dataLoader"</span><span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    imgs<span class="token punctuation">,</span>targets <span class="token operator">=</span>data    <span class="token comment"># print(imgs.shape)</span>    <span class="token comment"># print(targets)</span>    writer<span class="token punctuation">.</span>add_images<span class="token punctuation">(</span><span class="token string">"test_data"</span><span class="token punctuation">,</span>imgs<span class="token punctuation">,</span>step<span class="token punctuation">)</span>    step <span class="token operator">=</span> step <span class="token operator">+</span> <span class="token number">1</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tensorboard <span class="token assign-left variable">logdir</span><span class="token operator">=</span><span class="token string">"dataLoader"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230520132604606.png" alt="image-20230520132604606"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pytorch </tag>
            
            <tag> python </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch学习3</title>
      <link href="/2023/05/28/pytorch%E5%AD%A6%E4%B9%A03/"/>
      <url>/2023/05/28/pytorch%E5%AD%A6%E4%B9%A03/</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch学习3"><a href="#Pytorch学习3" class="headerlink" title="Pytorch学习3"></a>Pytorch学习3</h1><h2 id="torchvision-学习"><a href="#torchvision-学习" class="headerlink" title="torchvision 学习"></a>torchvision 学习</h2><p>​        pytorch的很多API可以去pytorch.org </p><p>​        下面来看一个加载：</p><p><img src="image-20230511224505274.png" alt="image-20230511224505274"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">import torchvisiontrain_set &#x3D; torchvision.datasets.CIFAR10(root&#x3D;&quot;.&#x2F;dataset&quot;,train&#x3D;True,download&#x3D;True)test_set &#x3D; torchvision.datasets.CIFAR10(root&#x3D;&quot;.&#x2F;dataset&quot;,train&#x3D;False,download&#x3D;True)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        稍等片刻，就会下载好数据！</p><p>​        来测试一下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>test_set<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230511224848459.png" alt="image-20230511224848459"></p><p>​        开debug发现还是很多属性的！</p><p>​        这里有相关的read_me:</p><p>The CIFAR-10 and CIFAR-100 are labeled subsets of the <a href="http://people.csail.mit.edu/torralba/tinyimages/">80 million tiny images</a> dataset. They were collected by Alex Krizhevsky, Vinod Nair, and Geoffrey Hinton.</p><h2 id="The-CIFAR-10-dataset"><a href="#The-CIFAR-10-dataset" class="headerlink" title="The CIFAR-10 dataset"></a>The CIFAR-10 dataset</h2><p>​        CIFAR-10数据集由10个类别的60000张32x32彩色图像组成，每个类别有6000张图像。有50000个训练图像和10000个测试图像。</p><p>​        数据集分为五个训练批次和一个测试批次，每个批次有10000张图像。测试批次包含从每个类别中随机选择的1000幅图像。训练批包含按随机顺序排列的剩余图像，但一些训练批可能包含来自一个类的图像多于来自另一类的图像。在它们之间，训练批次正好包含每个类的5000个图像。</p><p>​        以下是数据集中的类，以及每个类的10张随机图像：</p><div class="table-container"><table><thead><tr><th>airplane</th><th><img src="airplane1.png" alt="img"></th><th><img src="airplane2.png" alt="img"></th><th><img src="airplane3.png" alt="img"></th><th><img src="airplane4.png" alt="img"></th><th><img src="airplane5.png" alt="img"></th><th><img src="airplane6.png" alt="img"></th><th><img src="airplane7.png" alt="img"></th><th><img src="airplane8.png" alt="img"></th><th><img src="airplane9.png" alt="img"></th><th><img src="airplane10.png" alt="img"></th></tr></thead><tbody><tr><td>automobile</td><td><img src="automobile1.png" alt="img"></td><td><img src="automobile2.png" alt="img"></td><td><img src="automobile3.png" alt="img"></td><td><img src="automobile4.png" alt="img"></td><td><img src="automobile5.png" alt="img"></td><td><img src="automobile6.png" alt="img"></td><td><img src="automobile7.png" alt="img"></td><td><img src="automobile8.png" alt="img"></td><td><img src="automobile9.png" alt="img"></td><td><img src="automobile10.png" alt="img"></td></tr><tr><td>bird</td><td><img src="bird1.png" alt="img"></td><td><img src="bird2.png" alt="img"></td><td><img src="bird3.png" alt="img"></td><td><img src="bird4.png" alt="img"></td><td><img src="bird5.png" alt="img"></td><td><img src="bird6.png" alt="img"></td><td><img src="bird7.png" alt="img"></td><td><img src="bird8.png" alt="img"></td><td><img src="bird9.png" alt="img"></td><td><img src="bird10.png" alt="img"></td></tr><tr><td>cat</td><td><img src="cat1.png" alt="img"></td><td><img src="cat2.png" alt="img"></td><td><img src="cat3.png" alt="img"></td><td><img src="cat4.png" alt="img"></td><td><img src="cat5.png" alt="img"></td><td><img src="cat6.png" alt="img"></td><td><img src="cat7.png" alt="img"></td><td><img src="cat8.png" alt="img"></td><td><img src="cat9.png" alt="img"></td><td><img src="cat10.png" alt="img"></td></tr><tr><td>deer</td><td><img src="deer1.png" alt="img"></td><td><img src="deer2.png" alt="img"></td><td><img src="deer3.png" alt="img"></td><td><img src="deer4.png" alt="img"></td><td><img src="deer5.png" alt="img"></td><td><img src="deer6.png" alt="img"></td><td><img src="deer7.png" alt="img"></td><td><img src="deer8.png" alt="img"></td><td><img src="deer9.png" alt="img"></td><td><img src="deer10.png" alt="img"></td></tr><tr><td>dog</td><td><img src="dog1.png" alt="img"></td><td><img src="dog2.png" alt="img"></td><td><img src="dog3.png" alt="img"></td><td><img src="dog4.png" alt="img"></td><td><img src="dog5.png" alt="img"></td><td><img src="dog6.png" alt="img"></td><td><img src="dog7.png" alt="img"></td><td><img src="dog8.png" alt="img"></td><td><img src="dog9.png" alt="img"></td><td><img src="dog10.png" alt="img"></td></tr><tr><td>frog</td><td><img src="frog1.png" alt="img"></td><td><img src="frog2.png" alt="img"></td><td><img src="frog3.png" alt="img"></td><td><img src="frog4.png" alt="img"></td><td><img src="frog5.png" alt="img"></td><td><img src="frog6.png" alt="img"></td><td><img src="frog7.png" alt="img"></td><td><img src="frog8.png" alt="img"></td><td><img src="frog9.png" alt="img"></td><td><img src="frog10.png" alt="img"></td></tr><tr><td>horse</td><td><img src="horse1.png" alt="img"></td><td><img src="horse2.png" alt="img"></td><td><img src="horse3.png" alt="img"></td><td><img src="horse4.png" alt="img"></td><td><img src="horse5.png" alt="img"></td><td><img src="horse6.png" alt="img"></td><td><img src="horse7.png" alt="img"></td><td><img src="horse8.png" alt="img"></td><td><img src="horse9.png" alt="img"></td><td><img src="horse10.png" alt="img"></td></tr><tr><td>ship</td><td><img src="ship1.png" alt="img"></td><td><img src="ship2.png" alt="img"></td><td><img src="ship3.png" alt="img"></td><td><img src="ship4.png" alt="img"></td><td><img src="ship5.png" alt="img"></td><td><img src="ship6.png" alt="img"></td><td><img src="ship7.png" alt="img"></td><td><img src="ship8.png" alt="img"></td><td><img src="ship9.png" alt="img"></td><td><img src="ship10.png" alt="img"></td></tr><tr><td>truck</td><td><img src="truck1.png" alt="img"></td><td><img src="truck2.png" alt="img"></td><td><img src="truck3.png" alt="img"></td><td><img src="truck4.png" alt="img"></td><td><img src="truck5.png" alt="img"></td><td><img src="truck6.png" alt="img"></td><td><img src="truck7.png" alt="img"></td><td><img src="truck8.png" alt="img"></td><td><img src="truck9.png" alt="img"></td><td><img src="truck10.png" alt="img"></td></tr></tbody></table></div><p>​        这些类是完全互斥的。汽车和卡车之间没有重叠。“汽车”包括轿车、SUV之类的东西。“卡车”只包括大卡车。两者都不包括皮卡。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>如果您要使用此数据集，请引用本页底部的技术报告。</p><p>|版本|大小|md5sum|</p><p>| —————————————————————————————— | ——— | ———————————————— |</p><p>|[CIFAR-10 python版本](<a href="http://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz）|163">http://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz）|163</a> MB | c58f30108f718f92721af3b95e74349a|</p><p>|[CIFAR-10 Matlab版本](<a href="http://www.cs.toronto.edu/~kriz/cifar-10-matlab.tar.gz）|175">http://www.cs.toronto.edu/~kriz/cifar-10-matlab.tar.gz）|175</a> MB |70270af85842c9e89bb428ec9976c926|</p><p>|[CIFAR-10二进制版本（适用于C程序）](<a href="http://www.cs.toronto.edu/~kriz/cifar-10-binary.tar.gz）|162">http://www.cs.toronto.edu/~kriz/cifar-10-binary.tar.gz）|162</a> MB | c32a1d4ab5d03f1284b67883e8d87530|</p><h2 id="基线结果"><a href="#基线结果" class="headerlink" title="基线结果"></a>基线结果</h2><p>你可以在这个数据集上找到一些基线可复制的结果<a href="http://code.google.com/p/cuda-convnet/">在cuda convnet的项目页面上</a>. 这些结果是用卷积神经网络获得的。简单地说，在没有数据扩充的情况下，它们的测试误差为18%，在有数据扩充的条件下为11%。此外，<a href="http://www.cs.toronto.edu/~jasper/）有一篇[新论文](http://hips.seas.harvard.edu/content/practical-bayesian-optimization-machine-learning-algorithms">Jasper Snoek</a>其中，他使用贝叶斯超参数优化来找到权重衰减和其他超参数的良好设置，这使他能够使用获得18%的网络架构获得15%的测试错误率（没有数据扩充）。</p><h2 id="其他结果"><a href="#其他结果" class="headerlink" title="其他结果"></a>其他结果</h2><p>​        <a href="http://rodrigob.github.com/">罗德里戈·贝南森</a>好心地在他的网站上收集了CIFAR-10/100和其他数据集的结果；<a href="http://rodrigob.github.com/are_we_there_yet/build/classification_datasets_results.html">点击此处</a>查看。</p><p>​        数据集布局</p><p>​        Python/Matlab版本</p><p>​        我（这里指作者）将描述数据集的Python版本的布局。Matlab版本的布局是相同的。</p><p>​        档案包含文件data_batch_1，data_batch_2。。。，data_batch_5以及test_batch。这些文件中的每一个都是用[cPickle]生成的Python“pickle”对象(<a href="http://www.python.org/doc/2.5/lib/module-cPickle.html">http://www.python.org/doc/2.5/lib/module-cPickle.html</a>). 下面是一个python2例程，它将打开这样一个文件并返回一个字典：</p><pre class="line-numbers language-none"><code class="language-none">def unpickle（文件）：导入cPickle打开（文件，&#39;rb&#39;）为fo：dict&#x3D;cPickle.load（fo）返回dict<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一个蟒蛇3版本：</p><pre class="line-numbers language-none"><code class="language-none">def unpickle（文件）：进口泡菜打开（文件，&#39;rb&#39;）为fo：dict&#x3D;pickle.load（fo，编码&#x3D;“字节”）返回dict<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        以这种方式加载的每个批处理文件都包含一个字典，其中包含以下元素：</p><p>​        -<strong>数据</strong>—一个10000x3072<a href="http://numpy.scipy.org/">数字</a>uint8s的数组。阵列的每一行存储一个32x32颜色的图像。前1024个条目包含红色通道值，接下来的1024个条目为绿色，最后的1024个为蓝色。图像按行主顺序存储，因此阵列的前32个条目是图像第一行的红色通道值。</p><p>​        -<strong>标签</strong>—包含0-9范围内的10000个数字的列表。索引<em>i</em>处的数字表示数组<strong>数据</strong>中第<em>i</em>个图像的标签。</p><p>​        数据集包含另一个名为batches.meta的文件。它也包含一个Python字典对象。它包含以下条目：</p><p>​        -<strong>label_names</strong>——一个10元素列表，为上述<strong>标签</strong>数组中的数字标签提供有意义的名称。例如，label_names[0]=“飞机”、label_names[1]=“汽车”等。</p><h2 id="二进制版本"><a href="#二进制版本" class="headerlink" title="二进制版本"></a>二进制版本</h2><p>二进制版本包含文件data_batch_1.bin、data_batch_2.bin、…、data_back_5.bin以及test_batch.bin。这些文件的格式如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;1 x标签&gt;&lt;3072 x像素&gt;...&lt;1 x标签&gt;&lt;3072 x像素&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>换句话说，第一个字节是第一个图像的标签，它是0-9范围内的数字。接下来的3072个字节是图像的像素值。第一个1024字节是红色通道值，接下来的1024字节是绿色，最后的1024字节为蓝色。这些值按行主顺序存储，因此前32个字节是图像第一行的红色通道值。</p><p>每个文件包含10000个这样的3073字节的图像“行”，尽管没有<strong>任何行的分隔符</strong>。因此，每个文件的长度应该恰好为30730000字节。</p><p>还有另一个文件，名为batches.meta.txt。这是一个ASCII文件，它将0-9范围内的数字标签映射到有意义的类名。它只是10个类名的列表，每行一个。第<em>i</em>行的类名对应于数字标签<em>i</em>。</p><p>这个数据集和CIFAR-10一样，只是它有100个类，每个类包含600个图像。每节课有500个训练图像和100个测试图像。CIFAR-100中的100个类被分组为20个超类。每个图像都带有一个“精细”标签（它所属的类）和一个“粗略”标签（其所属的超类）。</p><p>以下是CIFAR-100中的类列表：</p><p>|超类|类|</p><p>| ——————————————— | ——————————————————————————- |</p><p>|水生哺乳动物|海狸、海豚、水獭、海豹、鲸鱼|</p><p>|鱼类|水族馆鱼类、比目鱼、鳐鱼、鲨鱼、鳟鱼|</p><p>|花|兰花、罂粟、玫瑰、向日葵、郁金香|</p><p>|食品容器|瓶子、碗、罐头、杯子、盘子|</p><p>|水果和蔬菜|苹果、蘑菇、橙子、梨、甜椒|</p><p>|家用电器|时钟、电脑键盘、灯、电话、电视|</p><p>|家用家具|床、椅子、沙发、桌子、衣柜|</p><p>|昆虫|蜜蜂、甲虫、蝴蝶、毛毛虫、蟑螂|</p><p>|大型食肉动物|熊、豹、狮子、老虎、狼|</p><p>|大型人造户外物品|桥梁、城堡、房屋、道路、摩天大楼|</p><p>|大型自然户外场景|云、森林、山脉、平原、海洋|</p><p>|大型杂食动物和草食动物|骆驼、牛、黑猩猩、大象、袋鼠|</p><p>|中型哺乳动物|狐狸、豪猪、负鼠、浣熊、臭鼬|</p><p>|非昆虫无脊椎动物|螃蟹、龙虾、蜗牛、蜘蛛、蠕虫|</p><p>|人|婴儿，男孩，女孩，男人，女人|</p><p>|爬行动物|鳄鱼、恐龙、蜥蜴、蛇、乌龟|</p><p>|小型哺乳动物|仓鼠、老鼠、兔子、鼩鼩、松鼠|</p><p>|树木|枫树、橡树、棕榈树、松树、柳树|</p><p>|车辆1|自行车、公共汽车、摩托车、皮卡、火车|</p><p>|车辆2|割草机、火箭、有轨电车、坦克、拖拉机|</p><p>是的，我知道蘑菇不是真正的水果或蔬菜，熊也不是真正的食肉动物。</p><h2 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h2><p>|版本|大小|md5sum|</p><p>| —————————————————————————————— | ——— | ———————————————— |</p><p>|[CIFAR-100 python版本](<a href="http://www.cs.toronto.edu/~kriz/cifar-100-python.tar.gz）|161">http://www.cs.toronto.edu/~kriz/cifar-100-python.tar.gz）|161</a> MB | eb9058c3a382ffc7106e4002c42a8d85|</p><p>|[CIFAR-100 Matlab版本](<a href="http://www.cs.toronto.edu/~kriz/cifar-100-matlab.tar.gz）|175">http://www.cs.toronto.edu/~kriz/cifar-100-matlab.tar.gz）|175</a> MB |6a4bfa1dcd5c9453dda6bb54194911f4|</p><p>|[CIFAR-100二进制版本（适用于C程序）](<a href="http://www.cs.toronto.edu/~kriz/cifar-100-二进制.tar.gz）|161">http://www.cs.toronto.edu/~kriz/cifar-100-二进制.tar.gz）|161</a> MB |03b5dce0913d631647c71ecec9e9cb8|</p><p>数据集布局</p><p>python/Matlab版本</p><p>python和Matlab版本在布局上与CIFAR-10相同，所以我不会在这里浪费空间来描述它们。</p><p>二进制版本</p><p>CIFAR-100的二进制版本与CIFAR-10的二进制版本一样，只是每个图像都有两个标签字节（粗略和精细）和3072个像素字节，所以二进制文件看起来是这样的：</p><pre class="line-numbers language-none"><code class="language-none">&lt;1 x粗略标签&gt;&lt;1 x精细标签&gt;&lt;3072 x像素&gt;...&lt;1 x粗略标签&gt;&lt;1 x精细标签&gt;&lt;3072 x像素&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        Sivan Sabato好心地提供了[这份文件](<a href="http://www.cs.toronto.edu/~kriz/cifar_indexes），它将cifar-100图像映射到8000万微小图像数据集中的图像。Sivan写道：">http://www.cs.toronto.edu/~kriz/cifar_indexes），它将cifar-100图像映射到8000万微小图像数据集中的图像。Sivan写道：</a></p><pre class="line-numbers language-none"><code class="language-none">该文件有60000行，每行都包含一个指向微小数据库的索引，其中微小数据库中的第一个图像被索引为“1”。“0”表示不是来自微小数据库的图像。前50000行对应于训练集，后10000行对应到测试集。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>​        本技术报告（第3章）更详细地描述了数据集以及收集数据时所遵循的方法。如果您打算使用此数据集，请引用它。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pytorch </tag>
            
            <tag> python </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch学习2</title>
      <link href="/2023/05/28/pytorch%E5%AD%A6%E4%B9%A02/"/>
      <url>/2023/05/28/pytorch%E5%AD%A6%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch学习2"><a href="#Pytorch学习2" class="headerlink" title="Pytorch学习2"></a>Pytorch学习2</h1><h2 id="常见的transformer"><a href="#常见的transformer" class="headerlink" title="常见的transformer"></a>常见的transformer</h2><p><img src="image-20230503184731008.png" alt="image-20230503184731008"></p><p>​        下面我们通过Run Demo的方式来实现记忆常见的transformer！</p><p>​        这是我们要处理的图片：</p><p><img src="image-20230503185022804.png" alt="image-20230503185022804"></p><h3 id="PIL-Image库读入图片"><a href="#PIL-Image库读入图片" class="headerlink" title="PIL-Image库读入图片"></a>PIL-Image库读入图片</h3><p>​        下面通过PIL的Image库来读取图片文件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">from PIL import Imageimg &#x3D; Image.open(&quot;1.png&quot;);print(img);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;PIL.PngImagePlugin.PngImageFile image mode&#x3D;RGBA size&#x3D;1717x1227 at 0x21AEC1CB880&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是我们得到的！导入成功！</p><h4 id="小插曲：-call-的用法"><a href="#小插曲：-call-的用法" class="headerlink" title="小插曲： __call__的用法"></a>小插曲： __call__的用法</h4><p>​        在Python类里存在内置函数__call__，我们这样的使用它：我们选择新建一个Python文件，</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"__call__ calls for:"</span><span class="token operator">+</span> <span class="token string">"hello"</span><span class="token operator">+</span><span class="token string">"name"</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">hello</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token operator">+</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person <span class="token operator">=</span> Person<span class="token punctuation">(</span><span class="token punctuation">)</span>person<span class="token punctuation">.</span>hello<span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">)</span>person<span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        书写上面的代码</p><p><img src="image-20230503190321481.png" alt="image-20230503190321481"></p><p>​        有点像C++的内置构建函数的感觉，只需要类对象（）后传对应参数就好了。</p><h4 id="继续："><a href="#继续：" class="headerlink" title="继续："></a>继续：</h4><p>​        看看这个Compose类：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Compose</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Composes several transforms together. This transform does not support torchscript.    Please, see the note below.    Args:        transforms (list of ``Transform`` objects): list of transforms to compose.    Example:        >>> transforms.Compose([        >>>     transforms.CenterCrop(10),        >>>     transforms.PILToTensor(),        >>>     transforms.ConvertImageDtype(torch.float),        >>> ])    .. note::        In order to script the transformations, please use ``torch.nn.Sequential`` as below.        >>> transforms = torch.nn.Sequential(        >>>     transforms.CenterCrop(10),        >>>     transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225)),        >>> )        >>> scripted_transforms = torch.jit.script(transforms)        Make sure to use only scriptable transformations, i.e. that work with ``torch.Tensor``, does not require        `lambda` functions or ``PIL.Image``.    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> transforms<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> torch<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>is_scripting<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token keyword">not</span> torch<span class="token punctuation">.</span>jit<span class="token punctuation">.</span>is_tracing<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            _log_api_usage_once<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>transforms <span class="token operator">=</span> transforms    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> t <span class="token keyword">in</span> self<span class="token punctuation">.</span>transforms<span class="token punctuation">:</span>            img <span class="token operator">=</span> t<span class="token punctuation">(</span>img<span class="token punctuation">)</span>        <span class="token keyword">return</span> img    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        format_string <span class="token operator">=</span> self<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__ <span class="token operator">+</span> <span class="token string">"("</span>        <span class="token keyword">for</span> t <span class="token keyword">in</span> self<span class="token punctuation">.</span>transforms<span class="token punctuation">:</span>            format_string <span class="token operator">+=</span> <span class="token string">"\n"</span>            format_string <span class="token operator">+=</span> <span class="token string-interpolation"><span class="token string">f"    </span><span class="token interpolation"><span class="token punctuation">&#123;</span>t<span class="token punctuation">&#125;</span></span><span class="token string">"</span></span>        format_string <span class="token operator">+=</span> <span class="token string">"\n)"</span>        <span class="token keyword">return</span> format_string<span class="token keyword">class</span> <span class="token class-name">ToTensor</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Convert a PIL Image or ndarray to tensor and scale the values accordingly.    This transform does not support torchscript.    Converts a PIL Image or numpy.ndarray (H x W x C) in the range    [0, 255] to a torch.FloatTensor of shape (C x H x W) in the range [0.0, 1.0]    if the PIL Image belongs to one of the modes (L, LA, P, I, F, RGB, YCbCr, RGBA, CMYK, 1)    or if the numpy.ndarray has dtype = np.uint8    In the other cases, tensors are returned without scaling.    .. note::        Because the input image is scaled to [0.0, 1.0], this transformation should not be used when        transforming target image masks. See the `references`_ for implementing the transforms for image masks.    .. _references: https://github.com/pytorch/vision/tree/main/references/segmentation    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        _log_api_usage_once<span class="token punctuation">(</span>self<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__call__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pic<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        Args:            pic (PIL Image or numpy.ndarray): Image to be converted to tensor.        Returns:            Tensor: Converted image.        """</span>        <span class="token keyword">return</span> F<span class="token punctuation">.</span>to_tensor<span class="token punctuation">(</span>pic<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">str</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string-interpolation"><span class="token string">f"</span><span class="token interpolation"><span class="token punctuation">&#123;</span>self<span class="token punctuation">.</span>__class__<span class="token punctuation">.</span>__name__<span class="token punctuation">&#125;</span></span><span class="token string">()"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            先看后面的ToTensor这个类，其负责把一些PIL Image数据转换为Tensor数据类型，举个例子，就处理我刚刚说的那张图片！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transforms<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriterwriter <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">)</span>img <span class="token operator">=</span> Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"1.png"</span><span class="token punctuation">)</span>trans <span class="token operator">=</span> transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span>img_tensor <span class="token operator">=</span> trans<span class="token punctuation">(</span>img<span class="token punctuation">)</span>writer<span class="token punctuation">.</span>add_image<span class="token punctuation">(</span><span class="token string">"ToTensor"</span><span class="token punctuation">,</span>img_tensor<span class="token punctuation">)</span>writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="To-PILImage"><a href="#To-PILImage" class="headerlink" title="To PILImage"></a>To PILImage</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class ToPILImage:    &quot;&quot;&quot;Convert a tensor or an ndarray to PIL Image - this does not scale values.    This transform does not support torchscript.    Converts a torch.*Tensor of shape C x H x W or a numpy ndarray of shape    H x W x C to a PIL Image while preserving the value range.    Args:        mode (&#96;PIL.Image mode&#96;_): color space and pixel depth of input data (optional).            If &#96;&#96;mode&#96;&#96; is &#96;&#96;None&#96;&#96; (default) there are some assumptions made about the input data:            - If the input has 4 channels, the &#96;&#96;mode&#96;&#96; is assumed to be &#96;&#96;RGBA&#96;&#96;.            - If the input has 3 channels, the &#96;&#96;mode&#96;&#96; is assumed to be &#96;&#96;RGB&#96;&#96;.            - If the input has 2 channels, the &#96;&#96;mode&#96;&#96; is assumed to be &#96;&#96;LA&#96;&#96;.            - If the input has 1 channel, the &#96;&#96;mode&#96;&#96; is determined by the data type (i.e &#96;&#96;int&#96;&#96;, &#96;&#96;float&#96;&#96;,            &#96;&#96;short&#96;&#96;).    .. _PIL.Image mode: https:&#x2F;&#x2F;pillow.readthedocs.io&#x2F;en&#x2F;latest&#x2F;handbook&#x2F;concepts.html#concept-modes    &quot;&quot;&quot;    def __init__(self, mode&#x3D;None):        _log_api_usage_once(self)        self.mode &#x3D; mode    def __call__(self, pic):        &quot;&quot;&quot;        Args:            pic (Tensor or numpy.ndarray): Image to be converted to PIL Image.        Returns:            PIL Image: Image converted to PIL Image.        &quot;&quot;&quot;        return F.to_pil_image(pic, self.mode)    def __repr__(self) -&gt; str:        format_string &#x3D; self.__class__.__name__ + &quot;(&quot;        if self.mode is not None:            format_string +&#x3D; f&quot;mode&#x3D;&#123;self.mode&#125;&quot;        format_string +&#x3D; &quot;)&quot;        return format_string<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        把其他数据转换成PIL数据类型，不多讲，当成接口就好！</p><h3 id="Normalize方法类"><a href="#Normalize方法类" class="headerlink" title="Normalize方法类"></a>Normalize方法类</h3><p>​        </p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">class Normalize(torch.nn.Module):    &quot;&quot;&quot;Normalize a tensor image with mean and standard deviation.    This transform does not support PIL Image.    Given mean: &#96;&#96;(mean[1],...,mean[n])&#96;&#96; and std: &#96;&#96;(std[1],..,std[n])&#96;&#96; for &#96;&#96;n&#96;&#96;    channels, this transform will normalize each channel of the input    &#96;&#96;torch.*Tensor&#96;&#96; i.e.,    &#96;&#96;output[channel] &#x3D; (input[channel] - mean[channel]) &#x2F; std[channel]&#96;&#96;    .. note::        This transform acts out of place, i.e., it does not mutate the input tensor.    Args:        mean (sequence): Sequence of means for each channel.        std (sequence): Sequence of standard deviations for each channel.        inplace(bool,optional): Bool to make this operation in-place.    &quot;&quot;&quot;    def __init__(self, mean, std, inplace&#x3D;False):        super().__init__()        _log_api_usage_once(self)        self.mean &#x3D; mean        self.std &#x3D; std        self.inplace &#x3D; inplace    def forward(self, tensor: Tensor) -&gt; Tensor:        &quot;&quot;&quot;        Args:            tensor (Tensor): Tensor image to be normalized.        Returns:            Tensor: Normalized Tensor image.        &quot;&quot;&quot;        return F.normalize(tensor, self.mean, self.std, self.inplace)    def __repr__(self) -&gt; str:        return f&quot;&#123;self.__class__.__name__&#125;(mean&#x3D;&#123;self.mean&#125;, std&#x3D;&#123;self.std&#125;)&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        说白了这个就是标准化过程！重要的是这个公式</p><pre class="line-numbers language-none"><code class="language-none">output[channel] &#x3D; (input[channel] - mean[channel]) &#x2F; std[channel]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Resize(torch.nn.Module):    &quot;&quot;&quot;Resize the input image to the given size.    If the image is torch Tensor, it is expected    to have [..., H, W] shape, where ... means an arbitrary number of leading dimensions    .. warning::        The output image might be different depending on its type: when downsampling, the interpolation of PIL images        and tensors is slightly different, because PIL applies antialiasing. This may lead to significant differences        in the performance of a network. Therefore, it is preferable to train and serve a model with the same input        types. See also below the &#96;&#96;antialias&#96;&#96; parameter, which can help making the output of PIL images and tensors        closer.    Args:        size (sequence or int): Desired output size. If size is a sequence like            (h, w), output size will be matched to this. If size is an int,            smaller edge of the image will be matched to this number.            i.e, if height &gt; width, then image will be rescaled to            (size * height &#x2F; width, size).            .. note::                In torchscript mode size as single int is not supported, use a sequence of length 1: &#96;&#96;[size, ]&#96;&#96;.        interpolation (InterpolationMode): Desired interpolation enum defined by            :class:&#96;torchvision.transforms.InterpolationMode&#96;. Default is &#96;&#96;InterpolationMode.BILINEAR&#96;&#96;.            If input is Tensor, only &#96;&#96;InterpolationMode.NEAREST&#96;&#96;, &#96;&#96;InterpolationMode.NEAREST_EXACT&#96;&#96;,            &#96;&#96;InterpolationMode.BILINEAR&#96;&#96; and &#96;&#96;InterpolationMode.BICUBIC&#96;&#96; are supported.            The corresponding Pillow integer constants, e.g. &#96;&#96;PIL.Image.BILINEAR&#96;&#96; are accepted as well.        max_size (int, optional): The maximum allowed for the longer edge of            the resized image: if the longer edge of the image is greater            than &#96;&#96;max_size&#96;&#96; after being resized according to &#96;&#96;size&#96;&#96;, then            the image is resized again so that the longer edge is equal to            &#96;&#96;max_size&#96;&#96;. As a result, &#96;&#96;size&#96;&#96; might be overruled, i.e. the            smaller edge may be shorter than &#96;&#96;size&#96;&#96;. This is only supported            if &#96;&#96;size&#96;&#96; is an int (or a sequence of length 1 in torchscript            mode).        antialias (bool, optional): Whether to apply antialiasing.            It only affects **tensors** with bilinear or bicubic modes and it is            ignored otherwise: on PIL images, antialiasing is always applied on            bilinear or bicubic modes; on other modes (for PIL images and            tensors), antialiasing makes no sense and this parameter is ignored.            Possible values are:            - &#96;&#96;True&#96;&#96;: will apply antialiasing for bilinear or bicubic modes.              Other mode aren&#39;t affected. This is probably what you want to use.            - &#96;&#96;False&#96;&#96;: will not apply antialiasing for tensors on any mode. PIL              images are still antialiased on bilinear or bicubic modes, because              PIL doesn&#39;t support no antialias.            - &#96;&#96;None&#96;&#96;: equivalent to &#96;&#96;False&#96;&#96; for tensors and &#96;&#96;True&#96;&#96; for              PIL images. This value exists for legacy reasons and you probably              don&#39;t want to use it unless you really know what you are doing.            The current default is &#96;&#96;None&#96;&#96; **but will change to** &#96;&#96;True&#96;&#96; **in            v0.17** for the PIL and Tensor backends to be consistent.    &quot;&quot;&quot;    def __init__(self, size, interpolation&#x3D;InterpolationMode.BILINEAR, max_size&#x3D;None, antialias&#x3D;&quot;warn&quot;):        super().__init__()        _log_api_usage_once(self)        if not isinstance(size, (int, Sequence)):            raise TypeError(f&quot;Size should be int or sequence. Got &#123;type(size)&#125;&quot;)        if isinstance(size, Sequence) and len(size) not in (1, 2):            raise ValueError(&quot;If size is a sequence, it should have 1 or 2 values&quot;)        self.size &#x3D; size        self.max_size &#x3D; max_size        if isinstance(interpolation, int):            interpolation &#x3D; _interpolation_modes_from_int(interpolation)        self.interpolation &#x3D; interpolation        self.antialias &#x3D; antialias    def forward(self, img):        &quot;&quot;&quot;        Args:            img (PIL Image or Tensor): Image to be scaled.        Returns:            PIL Image or Tensor: Rescaled image.        &quot;&quot;&quot;        return F.resize(img, self.size, self.interpolation, self.max_size, self.antialias)    def __repr__(self) -&gt; str:        detail &#x3D; f&quot;(size&#x3D;&#123;self.size&#125;, interpolation&#x3D;&#123;self.interpolation.value&#125;, max_size&#x3D;&#123;self.max_size&#125;, antialias&#x3D;&#123;self.antialias&#125;)&quot;        return f&quot;&#123;self.__class__.__name__&#125;&#123;detail&#125;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>img<span class="token punctuation">.</span>size<span class="token punctuation">)</span>trans_size <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">520</span><span class="token punctuation">,</span><span class="token number">520</span><span class="token punctuation">)</span><span class="token punctuation">)</span>imgResize <span class="token operator">=</span> trans_size<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>imgResize<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样就好了！</p><p><img src="image-20230503193919990.png" alt="image-20230503193919990"></p><h2 id="Compose-组合变换"><a href="#Compose-组合变换" class="headerlink" title="Compose 组合变换"></a>Compose 组合变换</h2><pre class="line-numbers language-none"><code class="language-none">trans_resize_2 &#x3D; transforms.Resize(512)trans_compose &#x3D; transforms.Compose([trans_resize_2, trans])img_resize_2 &#x3D; trans_compose(img)writer.add_image(&quot;Composer111&quot;, img_resize_2,2)writer.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们这样把若干变换组合在一起一并完成！</p>]]></content>
      
      
      
        <tags>
            
            <tag> pytorch </tag>
            
            <tag> python </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT NEW 12-13</title>
      <link href="/2023/05/28/QT-NEW-12-13/"/>
      <url>/2023/05/28/QT-NEW-12-13/</url>
      
        <content type="html"><![CDATA[<h1 id="QT-new-12"><a href="#QT-new-12" class="headerlink" title="QT new 12"></a>QT new 12</h1><h2 id="其他常见的控件一览"><a href="#其他常见的控件一览" class="headerlink" title="其他常见的控件一览"></a>其他常见的控件一览</h2><h3 id="滚动条控件"><a href="#滚动条控件" class="headerlink" title="滚动条控件"></a>滚动条控件</h3><p>​        我们可以在UI界面中找到滚动条控件——Scroll Widget，将大量的控件扔到里面之后，可以得到：</p><p><img src="image-20230527100557180.png" alt="image-20230527100557180"></p><p>​        可以上下拖拽的那种！</p><h3 id="ToolBox"><a href="#ToolBox" class="headerlink" title="ToolBox"></a>ToolBox</h3><p>​        回忆一下，我们的ToolBox，就跟QQ的好友栏一样的</p><p><img src="image-20230527100815303.png" alt="image-20230527100815303"></p><p>​        这里的Page1 和 Page2单击一下在属性栏的CurrrentPageName里更改就好了</p><h3 id="Tab-Widget"><a href="#Tab-Widget" class="headerlink" title="Tab Widget"></a>Tab Widget</h3><p>​        有点像网页那样的东西!</p><p><img src="image-20230527101102584.png" alt="image-20230527101102584"></p><p>​        当然,我们切换就带上按钮就好了!,使用信号与槽即可</p><p><img src="image-20230527101328100.png" alt="image-20230527101328100"></p><p>​        等等…</p><h3 id="利用QLable显示图片"><a href="#利用QLable显示图片" class="headerlink" title="利用QLable显示图片"></a>利用QLable显示图片</h3><p><img src="image-20230527101714658.png" alt="image-20230527101714658"></p><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><p>​                可以在工程中新建一个QT文件_自定义设计师类&gt;默认的Widget类中!设计好空间之后返回主窗口的UI, 随后点击提升为(本质是换成子对象),将之提升为设计好的Widget的名称后点击提升,运行就可看到效果</p><p>​        点击全局提升，下一次直接提升为.</p><h1 id="QT-new-13"><a href="#QT-new-13" class="headerlink" title="QT new 13"></a>QT new 13</h1><h2 id="QEvent"><a href="#QEvent" class="headerlink" title="QEvent"></a>QEvent</h2><p>​        下面我们自己写一个Lable，来学习自定义的事件这个模块。</p><p>​        首先，我们选择新建一个Widget：回忆下，就是在添加新文件下面——选择QWidget类型后include进来！</p><p>​        先不要着急include控件到UI界面下，我们修改几个地方：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef MYLABEL_H#define MYLABEL_H#include &lt;QLabel&gt;class MyLabel : public QLabel &#x2F;&#x2F; here&#123;    Q_OBJECTpublic:    explicit MyLabel(QWidget *parent &#x3D; nullptr);    void enterEvent(QEnterEvent*); &#x2F;&#x2F; add this    void leaveEvent(QEvent*); &#x2F;&#x2F;add thissignals:&#125;;#endif &#x2F;&#x2F; MYLABEL_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;#include&lt;QDebug&gt;MyLabel::MyLabel(QWidget *parent)    : QLabel&#123;parent&#125;&#123;&#125;void MyLabel::enterEvent(QEnterEvent* event)&#123;    qDebug()&lt;&lt;&quot;111&quot;;&#125;void MyLabel::leaveEvent(QEvent*)&#123;      qDebug()&lt;&lt;&quot;222&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         然后在UI界面中添加Label控件，提升为MyLabel。现在：</p><p><img src="image-20230528171240039.png" alt="image-20230528171240039"></p><p>​        现在，进入正题——鼠标事件的改写。</p><p>​        我们添加如下的事件函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef MYLABEL_H#define MYLABEL_H#include &lt;QLabel&gt;class MyLabel : public QLabel&#123;    Q_OBJECTpublic:    explicit MyLabel(QWidget *parent &#x3D; nullptr);    void enterEvent(QEnterEvent*);    void leaveEvent(QEvent*);    virtual void mousePressEvent(QMouseEvent* ev);    virtual void mouseReleaseEvent(QMouseEvent* ev);    virtual void mouseMoveEvent(QMouseEvent* ev);signals:&#125;;#endif &#x2F;&#x2F; MYLABEL_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;#include&lt;QDebug&gt;MyLabel::MyLabel(QWidget *parent)    : QLabel&#123;parent&#125;&#123;&#125;void MyLabel::enterEvent(QEnterEvent* event)&#123;    qDebug()&lt;&lt;&quot;111&quot;;&#125;void MyLabel::leaveEvent(QEvent*)&#123;      qDebug()&lt;&lt;&quot;222&quot;;&#125;void MyLabel::mousePressEvent(QMouseEvent* ev)&#123;      qDebug()&lt;&lt;&quot;You press your mouse&quot;;&#125;void MyLabel::mouseReleaseEvent(QMouseEvent* ev)&#123;      qDebug() &lt;&lt; &quot;yes, you depress the mouse&quot;;&#125;void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;      qDebug() &lt;&lt; &quot;yes, you move mouse&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230528171807801.png" alt="image-20230528171807801"></p><p>​        我们的ev实际上就返回了所有的信息：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;#include&lt;QDebug&gt;#include&lt;QMouseEvent&gt;MyLabel::MyLabel(QWidget *parent)    : QLabel&#123;parent&#125;&#123;&#125;void MyLabel::enterEvent(QEnterEvent* event)&#123;    qDebug()&lt;&lt;&quot;111&quot;;&#125;void MyLabel::leaveEvent(QEvent*)&#123;      qDebug()&lt;&lt;&quot;222&quot;;&#125;void MyLabel::mousePressEvent(QMouseEvent* ev)&#123;      qDebug()&lt;&lt;&quot;You press your mouse&quot;;&#125;void MyLabel::mouseReleaseEvent(QMouseEvent* ev)&#123;      qDebug() &lt;&lt; &quot;yes, you depress the mouse&quot;;&#125;void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;      QString str &#x3D; QString(&quot;yes, you move mouse x &#x3D; %1 y &#x3D; %2&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()); &#x2F;&#x2F; QString的格式化      qDebug() &lt;&lt;str;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230528172343019.png" alt="image-20230528172343019"></p><p>​        还有globle的，表明是相对于屏幕的为止！</p><p>​        如果是检测是不是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;    if(ev-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;        QString str &#x3D; QString(&quot;yes, you move mouse x &#x3D; %1 y &#x3D; %2&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()); &#x2F;&#x2F; QString的格式化      qDebug() &lt;&lt;str;       &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Qt-Event事件详解"><a href="#Qt-Event事件详解" class="headerlink" title="Qt Event事件详解"></a>Qt Event事件详解</h2><p>​        传送门：<a href="https://www.jianshu.com/p/48f007c2de09">https://www.jianshu.com/p/48f007c2de09</a></p><p>​        <strong>在与用户交互时发生</strong>。比如按下鼠标（mousePressEvent），敲击键盘（keyPressEvent）等。<br>​        <strong>系统自动发生</strong>，比如计时器事件（timerEvent）等。<br>在发生事件时（比如说上面说的按下鼠标），就会产生一个QEvent对象（这里是QMouseEvent，为QEvent的<a href="https://so.csdn.net/so/search?q=子类&amp;spm=1001.2101.3001.7020">子类</a>），这个QEvent对象会传给当前组件的event函数。如果当前组件没有安装事件过滤器（这个下文会提到），则会被event函数发放到相应的xxxEvent函数中（这里是mousePressEvent函数）。</p><p>​        Qt中所有的事件类都继承于QEvent类</p><p>​        这个QEvent对象会有各种各样的属性，这是由用户与界面交互时产生的。xxxEvent函数可以对其进行不同的处理（比如说是鼠标左键按下还是右键？）。查看帮助文档，可以看到QMouseEvent类有以下枚举。<br>在QtCreator中查看帮助文档<br>那么就可以在mousePressEvent中根据这个QEvent对象的这些枚举值来进行不同的处理，比如</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">myLabel</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QLabel</span></span><span class="token punctuation">&#123;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">mousePressEvent</span><span class="token punctuation">(</span>QMouseEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> myLabel<span class="token double-colon punctuation">::</span><span class="token function">mousePressEvent</span><span class="token punctuation">(</span>QMouseEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>event<span class="token operator">-></span>Buttons <span class="token operator">==</span> LeftButton<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//do sth</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>event<span class="token operator">-></span>Buttons <span class="token operator">==</span> RightButton<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//do sth</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到，我们首先需要先创建一个自己的QLabel类，并继承于Qt的QLabel类，然后并重写相应的xxxEvent函数（这些事件处理函数都是虚函数）。</p><p>​        Qt程序的main函数中需要创建一个QApplication对象，然后调用exec函数。这将令程序进入一个死循环，并不断监听应用程序的事件，发生事件时就生成一个QEvent对象。这又称为事件循环。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;QApplication></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mainwindow.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    QApplication <span class="token function">app</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>    MainWindow window<span class="token punctuation">;</span>    window<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> app<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、事件的分发：event函数"><a href="#二、事件的分发：event函数" class="headerlink" title="二、事件的分发：event函数"></a>二、事件的分发：event函数</h3><p>​        上面提到的xxxEvent函数，称为事件处理器（event handler）。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听某个按键的按下。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myWidget<span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>QEvent <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token comment">//将QEvent对象转换为真正的QKeyEvent对象</span>        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//按照原来的流程来进行事件的分发</span>    <span class="token keyword">return</span> <span class="token class-name">QWidget</span><span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在上面的程序中，myWidget是QWidget的子类。同样的，它的event函数是一个虚函数，带有一个QEvent类型的参数。当系统产生QEvent对象时，就会传入这个函数并调用。函数的返回值是bool类型，返回值不同有不同的意义。</p><p>​        如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODczOTU5OA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p>​        Qt系统在处理事件时，有一种机制叫事件传播机制。也就是说，在子组件（比如说一个QButton）中发生的事件，调用了子组件的event函数之后，还会调用父组件（比如说QWidget）的event函数。event函数的返回值就用于控制这样的一个过程。</p><p>​        需要注意的是，重写event函数之后最好返回父类的event函数来处理其他的事件分发，不然就只能处理自己定义的事件。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myTextEdit<span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>QEvent <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token comment">//将QEvent对象转换为真正的QKeyEvent对象</span>        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//直接返回false</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在这个例子中，因为没有调用父类QTextEdit的event函数，所以只能处理Tab的情况，你再按其他按键就啥反应都没有了。同样，事件也不能进行传播。</p><h3 id="三、事件过滤器（Even-Filter）"><a href="#三、事件过滤器（Even-Filter）" class="headerlink" title="三、事件过滤器（Even Filter）"></a>三、事件过滤器（Even Filter）</h3><p>​        某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器（evenFilter）。</p><p>​        QObject有一个虚函数，原型如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token class-name">QObject</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> watched<span class="token punctuation">,</span> QEvent <span class="token operator">*</span> event <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件（产生的QEvent对象）。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p><p>​        实际使用中，我们需要对QObject组件调用installEvenFilter函数，即为组件安装过滤器，才能使用事件过滤器这个机制。这样，该组件及其子组件的事件就会被监听。这个机制的好处在于不用像重写QEvent和xxxEvent函数一样需要继承Qt的内置类。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">QObject</span><span class="token double-colon punctuation">::</span><span class="token function">installEventFilter</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> filterObj <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        下面举一个例子。MainWindow中有一个QTextEdit控件，我们拦截它的键盘按下的事件。这样处理之后，会在输出窗口打印出按下的键位，但不会在控件上显示。这表明事件已被拦截，不会去调用even函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MainWindow</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QMainWindow</span></span><span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">MainWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>obj<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    QTextEdit <span class="token operator">*</span>textEdit<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token class-name">MainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">MainWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    textEdit <span class="token operator">=</span> <span class="token keyword">new</span> QTextEdit<span class="token punctuation">;</span>    <span class="token function">setCentralWidget</span><span class="token punctuation">(</span>textEdit<span class="token punctuation">)</span><span class="token punctuation">;</span>        textEdit<span class="token operator">-></span><span class="token function">installEventFilter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">bool</span> <span class="token class-name">MainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>obj<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> textEdit<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>            QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"you press"</span> <span class="token operator">&lt;&lt;</span> keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//事件不再进行传播，拦截</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//继续传播</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">else</span>     <span class="token punctuation">&#123;</span>        <span class="token comment">//当不确定是否继续传播时，按照父类的方法来处理</span>        <span class="token comment">//即调用父类的evenFilter函数</span>        <span class="token keyword">return</span> <span class="token class-name">QMainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同样的，even函数能干的事情，evenFilter也能干。比如说上面的处理键盘按下Tab键。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myObject<span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>object<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> target <span class="token operator">&amp;&amp;</span> event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span>         <span class="token punctuation">&#123;</span>            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>            <span class="token comment">//拦截</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token keyword">else</span>         <span class="token punctuation">&#123;</span>            <span class="token comment">//不进行拦截</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//不进行拦截</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们可以对QApplication或者QCoreApplication对象添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。这种行为会严重降低整个应用程序的事件分发效率，要看具体情况使用。</p><p>​        事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>Qt中使用事件机制，每一种事件对应一个事件处理器，比如：</p><ul><li>mouseEvent()</li><li>keyPressEvent()</li><li>etc…<br>发生事件时会生成一个QEvent对象，则需要even函数进行分发，来调用相应的事件处理器</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> QEvent<span class="token double-colon punctuation">::</span>MouseMove<span class="token operator">:</span>        <span class="token function">mouseMoveEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>QMouseEvent<span class="token operator">*</span><span class="token punctuation">)</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        事件过滤器（evenFilter）可以令事件进行拦截，阻止其传播，从而实现某些功能。</p><p>另外，有一种一般很少使用的方法，即去重写这么一个函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token class-name">QCoreApplication</span><span class="token double-colon punctuation">::</span><span class="token function">notify</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> receiver<span class="token punctuation">,</span> QEvent <span class="token operator">*</span> event <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数原实现相当于让组件调用even函数，即receiver-&gt;event(event)。这相当于全局的事件过滤器，且不会受到多线程的限制。</p><p>那么，在使用Qt的事件机制时，应该按照以下思路进行</p><ul><li>重写paintEvent、mousePressEvent等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</li><li>重写event函数。event函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</li><li>在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</li><li>在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，但会有多线程问题。</li><li>重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。</li></ul><h2 id="鼠标事件（QMouseEvent）"><a href="#鼠标事件（QMouseEvent）" class="headerlink" title="鼠标事件（QMouseEvent）"></a>鼠标事件（QMouseEvent）</h2><p>传送门：<a href="https://blog.csdn.net/qq_44386034/article/details/125637737">https://blog.csdn.net/qq_44386034/article/details/125637737</a></p><p>​        常用的鼠标事件：(本篇处理事件用的是方法一：重写鼠标事件)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void mousePressEvent(QMouseEvent *event);           &#x2F;&#x2F;单击void mouseReleaseEvent(QMouseEvent *event);       &#x2F;&#x2F;释放void mouseDoubleClickEvent(QMouseEvent *event); &#x2F;&#x2F;双击void mouseMoveEvent(QMouseEvent *event);           &#x2F;&#x2F;移动void wheelEvent(QWheelEvent *event);                      &#x2F;&#x2F;滑轮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        鼠标事件使用的时候，加头文件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QMouseEvent&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重写事件框架：</p><pre class="line-numbers language-none"><code class="language-none">鼠标按下事件void Widget::mousePressEvent(QMouseEvent *event)&#123;    &#x2F;&#x2F; 如果是鼠标左键按下       if(event-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;        ···    &#125;    &#x2F;&#x2F; 如果是鼠标右键按下    else if(event-&gt;button() &#x3D;&#x3D; Qt::RightButton)&#123;       ···    &#125;&#125;鼠标移动事件void Widget::mouseMoveEvent(QMouseEvent *event)&#123;    &#x2F;&#x2F; 这里必须使用buttons()    if(event-&gt;buttons() &amp; Qt::LeftButton)&#123;  &#x2F;&#x2F;进行的按位与       ···    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        默认情况下，触发事件需要点击一下，才能触发。可设置为自动触发:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">setMouseTracking(true); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">鼠标释放事件void Widget::mouseReleaseEvent(QMouseEvent *event)&#123;   ···&#125;鼠标双击事件void Widget::mouseDoubleClickEvent(QMouseEvent *event)&#123;    &#x2F;&#x2F; 如果是鼠标左键按下    if(event-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;              ···    &#125;&#125;滚轮事件void Widget::wheelEvent(QWheelEvent *event)&#123;    &#x2F;&#x2F; 当滚轮远离使用者时    if(event-&gt;delta() &gt; 0)&#123;        ···    &#125;else&#123;&#x2F;&#x2F;当滚轮向使用者方向旋转时        ···    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实例演示-在label控件中，移动鼠标获取实时位置，并显示在界面上"><a href="#实例演示-在label控件中，移动鼠标获取实时位置，并显示在界面上" class="headerlink" title="实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)"></a>实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)</h3><p>​        创建mylabel类，基类设置为QLabel <img src="b63f2e133baf5913fe5393dc477bfe20.png" alt="img"></p><pre><code>     这里用了类似自定义控件的方法，对Mylabel类进行封装。设置基类QLabel 是为了在ui界面中提升label控件(即将label控件和Mylabel关联，提升时候必须二者基类相同)</code></pre><p>​        在mylabel.h中声明鼠标事件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once#include &lt;qlabel.h&gt;class mylabel : public QLabel&#123;public:    mylabel(QWidget* parent &#x3D; 0);    ~mylabel();public:    &#x2F;&#x2F;鼠标移动事件    void mouseMoveEvent(QMouseEvent* event);    &#x2F;&#x2F;鼠标按下事件    void mousePressEvent(QMouseEvent* event);    &#x2F;&#x2F;鼠标释放事件    void mouseReleaseEvent(QMouseEvent* event);&#125;;在mylabel.cpp中重写事件#include &quot;mylabel.h&quot;#include&quot;QMouseEvent&quot;mylabel::mylabel(QWidget* parent) :QLabel(parent)&#123;    &#125;mylabel::~mylabel()&#123;&#125;&#x2F;&#x2F;鼠标移动显示坐标void mylabel::mouseMoveEvent(QMouseEvent* event)&#123;    if (event-&gt;buttons() &amp; Qt::LeftButton)  &#x2F;&#x2F;进行的按位与(只有左键点击移动才满足)    &#123;         QString str &#x3D; QString(&quot;Move:(X:%1,Y:%2)&quot;).arg(event-&gt;x()).arg(event-&gt;y());         this-&gt;setText(str);             &#125;&#125;&#x2F;&#x2F;鼠标按下显示“ok，mouse is press”void mylabel::mousePressEvent(QMouseEvent* event)&#123;    setText(&quot;Ok, mouse is press&quot;);&#125;&#x2F;&#x2F;鼠标释放清除显示void mylabel::mouseReleaseEvent(QMouseEvent* event)&#123;    setText(&quot; &quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在主函数(QTest.cpp)中声明mylabel的类对象(即声明一个mylabel类的label控件)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;qtest.h&quot;QTest::QTest(QWidget *parent)    : QWidget(parent)&#123;    ui.setupUi(this);    &#x2F;&#x2F;声明mylabel类的控件    mylabel* label1 &#x3D; new mylabel(this);    label1-&gt;setGeometry(QRect(130, 100, 271, 161));    &#x2F;&#x2F;设置边框    label1-&gt;setFrameShape(QFrame::Panel);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>     ![img](D:\My notebook project\Program language\C++\QT\QT new 13\2b78bd5ca82261a28798c809af0ef282.gif)</code></pre><p>​        另外，当调用setMouseTracking(true);时(即设置鼠标状态为自动触发)，需要将鼠标移动事件的if语句去掉(因为不需要点击触发了)</p><p>​        修改maylabel.cpp事件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;#include&quot;QMouseEvent&quot;mylabel::mylabel(QWidget* parent) :QLabel(parent)&#123;    &#x2F;&#x2F;设置鼠标状态(自动触发)    setMouseTracking(true);&#125;mylabel::~mylabel()&#123;&#125;&#x2F;&#x2F;鼠标移动显示坐标void mylabel::mouseMoveEvent(QMouseEvent* event)&#123;   QString str &#x3D; QString(&quot;Move:(X:%1,Y:%2)&quot;).arg(event-&gt;x()).arg(event-&gt;y());   this-&gt;setText(str);&#125;&#x2F;&#x2F;鼠标按下显示“ok，mouse is press”void mylabel::mousePressEvent(QMouseEvent* event)&#123;    setText(&quot;Ok, mouse is press&quot;);&#125;&#x2F;&#x2F;鼠标释放清除显示void mylabel::mouseReleaseEvent(QMouseEvent* event)&#123;    setText(&quot; &quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果展示：</p><p><img src="0c83943e6ee8c74e39d09db4a899b2c6.gif" alt="img"></p><p>​        这里用的是代码创建label控件，那么能不能用ui界面编辑然后在对label控件提升呢？</p><p>答案是可以的，但是需要注意的是：此处不能选择全局包含</p><p><img src="4cb8112d483f6e94c8fe196258871445.png" alt="img"></p><p> 否则会出现：</p><p><img src="e7df65e65f36ed436c5ec6ab7c41f417.png" alt="img"></p><p>​        我想其中的原因主要是因为：</p><p>​        本实例是新建了一个mylabel类，而不是像QT常用控件(三)——自定义控件封装 - 唯有自己强大 - 博客园 (cnblogs.com)这篇博文中直接新添加了一个设计师界面类(即包含ui .h .cpp)。当选择全局包含时，就包含了主类。</p><p>​        其实也有解决的办法：需要在提升界面的头文件处，将工程目录下自定义控件的地址放于此处(本篇地址：C:/Users/WFD/Desktop/QTest/QTest/mylabel.h)</p><p><img src="c3a41a90d53c14e6f9e28ea56aa4c497.png" alt="img"></p><p> 二，事件的分发：event函数<br>        上面提到的xxxEvent函数，称为事件处理器(event handler)。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听(阻塞)鼠标按下事件。</p><pre><code>     如果希望在事件分发之前做一些操作，就可以重写这个 event()函数了。比如我们希望阻塞鼠标按下事件，那么我们就在新建的Mylabel类中重写event()函数(该类的父类是QLabel)</code></pre><p>在Mylabel.h中声明event事件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;qlabel.h&quot;class Mylabel : public QLabel&#123;public:    explicit Mylabel(QWidget* parent &#x3D; 0);    &#x2F;&#x2F;鼠标按下事件    void mousePressEvent(QMouseEvent* event);     &#x2F;&#x2F;鼠标释放事件    void mouseReleaseEvent(QMouseEvent* event);    &#x2F;&#x2F;声明event事件    bool event(QEvent* e);&#125;;在Mylabel.cpp中重写event事件。#include &quot;Mylabel.h&quot;#include&quot;QMouseEvent&quot;Mylabel::Mylabel(QWidget* parent) :QLabel(parent)&#123;&#125;&#x2F;&#x2F;重写鼠标按下事件void Mylabel::mousePressEvent(QMouseEvent* event)&#123;    this-&gt;setText(QString(&quot;mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));&#125;&#x2F;&#x2F;重写鼠标释放事件void Mylabel::mouseReleaseEvent(QMouseEvent* event)&#123;    this-&gt;setText(&quot;mouse is release &quot;);&#125;&#x2F;&#x2F;重写event事件bool Mylabel::event(QEvent* e)&#123;    &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截    if (e-&gt;type()&#x3D;&#x3D;QEvent::MouseButtonPress)    &#123;        &#x2F;&#x2F;静态转换(将QEvent的对象转换为QMouseEvent对象)        QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);        this-&gt;setText(QString(&quot;event mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));        return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)    &#125;    return QLabel::event(e);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <img src="06ef2891b59dcc3d4f1953b7e3404c5e.png" alt="img"></p><p>​        点击鼠标可以看到，触发的是event的事件(即阻塞了mousePressEvent的事件)。特别需要注意的是：在将不需要阻塞分发的时候，需要分发给父类的event函数处理。即(return QLable::event(e)；)</p><p>​        由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个 event()函数，通过 QEvent::type()判断不同的事件。鉴于重写 event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器(当然，也必须记得是不是应该调用父类的同名处理器)。</p><h3 id="三，事件过滤器-Even-Filter"><a href="#三，事件过滤器-Even-Filter" class="headerlink" title="三，事件过滤器(Even Filter)"></a>三，事件过滤器(Even Filter)</h3><p>​         某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器，该过滤器在event分发之前进行拦截。</p><p>事件的过滤有两个步骤：</p><p>​        对QObject组件安装过滤器(调用installEvenFilter函数)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QObject::installEventFilter ( QObject * filterObj );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数filterobj 是指谁为组件安装过滤器(一般是父类)</p><p>​        这个函数接受一个 QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是 QObject 的一个成员函数，因此，任意 QObject 都可以作为事件过滤器(问题在于，如果你没有重写 eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤)。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。<br>我们可以向一个对象上面安装多个事件处理器 ，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。<br>​        事件过滤器的重写(evenFilter函数)</p><pre class="line-numbers language-none"><code class="language-none">virtual bool QObject::eventFilter ( QObject * watched, QEvent * event );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件(产生的QEvent对象)。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p><p>​        实例：通过事件过滤器阻塞上面代码中的鼠标按下事件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;qtest.h&quot;#include&quot;qmouseevent&quot;QTest::QTest(QWidget *parent)    : QWidget(parent)&#123;    ui.setupUi(this);    &#x2F;&#x2F;第一步：给label添加过滤器    ui.label-&gt;installEventFilter(this);&#125;&#x2F;&#x2F;第二步：重写过滤事件bool QTest::eventFilter(QObject* obj, QEvent* e)&#123;    if (obj &#x3D;&#x3D; ui.label)    &#123;        &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截        if (e-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress)        &#123;            QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);            ui.label-&gt;setText(QString(&quot;eventfilter mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));            return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)        &#125;    &#125;    return QWidget::eventFilter(obj, e);&#125;&#x2F;&#x2F;重写鼠标按下事件void QTest::mousePressEvent(QMouseEvent* event)&#123;    ui.label-&gt;setText(QString(&quot;mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));&#125;&#x2F;&#x2F;重写事件分发bool QTest::event(QEvent* e)&#123;    &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截    if (e-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress)    &#123;        QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);        ui.label-&gt;setText(QString(&quot;event mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));        return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)    &#125;    return QWidget::event(e);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：<img src="09dd8a5f89d61fa32b9e3800fe5fff9a.png" alt="img"></p><p>可以看到在过滤器事件中就监听了鼠标按压(即阻塞了后面的事件分发和鼠标按压)</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows-API-程序设计（5）</title>
      <link href="/2023/05/28/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%885%EF%BC%89/"/>
      <url>/2023/05/28/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%885%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="系统学习WindowsAPI-5函数"><a href="#系统学习WindowsAPI-5函数" class="headerlink" title="系统学习WindowsAPI 5函数"></a>系统学习WindowsAPI 5函数</h1><h2 id="遍历卷-GetLogicalDriveStrings"><a href="#遍历卷-GetLogicalDriveStrings" class="headerlink" title="遍历卷 GetLogicalDriveStrings"></a>遍历卷 GetLogicalDriveStrings</h2><p>​        一个卷也叫做逻辑驱动器，或者叫盘！这是一个基本的概念。</p><p>​        注意到它一次性返回的是若干的字字符串：</p><p><img src="image-20230528180359422.png" alt="image-20230528180359422"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define BFSIZE 1024int main()&#123;WCHAR szLogicalDriveString[BFSIZE];PWCHAR szDrive;ZeroMemory(szLogicalDriveString, BFSIZE);&#x2F;&#x2F;清空内存szDrive &#x3D; szLogicalDriveString;GetLogicalDriveStrings(BFSIZE - 1, szLogicalDriveString);do &#123;printf(&quot;%s\n&quot;, szDrive);szDrive +&#x3D; (lstrlen(szDrive)+1);&#125; while (*szDrive !&#x3D; &#39;\0&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查看第一个卷"><a href="#查看第一个卷" class="headerlink" title="查看第一个卷"></a>查看第一个卷</h2><p>​        我们可以使用<code>FindFirstVolume</code>这个函数的设备名称</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TCHAR buf[BFSIZE];HANDLE hVol;BOOL bFlag; &#x2F;&#x2F; as to see if the function work wellhVol &#x3D; FindFirstVolume(buf, BFSIZE);if (hVol &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;wprintf(TEXT(&quot;NO... Volumn has&#39;t been find!&quot;));return -1;&#125;printf(&quot;%ls\n&quot;, buf);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230528181002554.png" alt="image-20230528181002554"></p><p>​        这是驱动设备的真正名称，他是唯一的标识符。</p><p>​        使用<code>FindNextVolume</code>来找到下一个：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TCHAR buf[BFSIZE];HANDLE hVol;BOOL bFlag; &#x2F;&#x2F; as to see if the function work wellhVol &#x3D; FindFirstVolume(buf, BFSIZE);if (hVol &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;wprintf(TEXT(&quot;NO... Volumn has&#39;t been find!&quot;));return -1;&#125;printf(&quot;%ls\n&quot;, buf);while (FindNextVolume(hVol, buf, BFSIZE)) &#123;printf(&quot;%ls\n&quot;, buf);&#125;bFlag &#x3D; FindVolumeClose(hVol);return bFlag;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230528181246288.png" alt="image-20230528181246288"></p><h2 id="Extensive-Reading-for-Microsoft-API"><a href="#Extensive-Reading-for-Microsoft-API" class="headerlink" title="Extensive Reading for Microsoft API"></a>Extensive Reading for Microsoft API</h2><h3 id="ZeroMemory-宏-wdm-h"><a href="#ZeroMemory-宏-wdm-h" class="headerlink" title="ZeroMemory 宏 (wdm.h)"></a>ZeroMemory 宏 (wdm.h)</h3><p>​        <strong>ZeroMemory</strong> 例程使用零填充内存块，给定指向块的指针和要填充的长度（以字节为单位）。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">RtlZeroMemory</span><span class="token punctuation">(</span>   <span class="token keyword">void</span><span class="token operator">*</span>  Destination<span class="token punctuation">,</span>   size_t Length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] Destination<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向要用零填充的内存块的指针。</p><pre class="line-numbers language-none"><code class="language-none">[in] Length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要用零填充的字节数。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>无</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>​        若要将内存缓冲区归零以擦除安全敏感数据，请改用SecureZeroMemory</p><p>​        如果目标内存块位于非分页系统内存中， <strong>ZeroMemory</strong> 的调用方可以在任何 IRQL 上运行。 否则，调用方必须在 IRQL &lt;= APC_LEVEL 运行。</p><h4 id="本质上"><a href="#本质上" class="headerlink" title="本质上"></a>本质上</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">memset((Destination),0,(Length))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="getLogicalDriveStrings函数-fileapi-h"><a href="#getLogicalDriveStrings函数-fileapi-h" class="headerlink" title="getLogicalDriveStrings函数 (fileapi.h)"></a>getLogicalDriveStrings函数 (fileapi.h)</h3><p>​        用指定系统中有效驱动器的字符串填充缓冲区。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">DWORD <span class="token function">GetLogicalDriveStrings</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  DWORD  nBufferLength<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] nBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>TCHAR</strong> 中<em>由 lpBuffer</em> 指向的缓冲区的最大大小。 此大小不包括终止 null 字符。 如果此参数为零，则不使用 <em>lpBuffer</em> 。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向一个缓冲区的指针，该缓冲区接收一系列以 null 结尾的字符串，一个用于系统中每个有效驱动器，另外还有一个 null 字符。 每个字符串都是设备名称。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是复制到缓冲区的字符串的长度（以字符为单位），不包括终止 null 字符。 请注意，ANSI-ASCII null 字符使用一个字节，但 Unicode (UTF-16) null 字符使用两个字节。</p><p>​        如果缓冲区不够大，则返回值大于 <em>nBufferLength</em>。 它是保存驱动器字符串所需的缓冲区大小。</p><p>​        如果函数失败，则返回值为零。 若要获取扩展的错误信息，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>​        无论需要根目录（例如 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdrivetypea">GetDriveType</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> 函数），缓冲区中的每个字符串都可以使用。</p><p>​        此函数返回全局和本地 MS-DOS 设备命名空间中的驱动器串联。 如果这两个命名空间中都存在驱动器，此函数将返回本地 MS-DOS 设备命名空间中的条目。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/defining-an-ms-dos-device-name">定义 MS DOS 设备名称</a>。</p><p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">技术</th><th style="text-align:left">支持</th></tr></thead><tbody><tr><td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">群集共享卷文件系统 (CsvFS)</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">弹性文件系统 (ReFS)</td><td style="text-align:left">是</td></tr></tbody></table></div><p>​        SMB 不支持卷管理功能。</p><h3 id="FindFirstVolume-函数-fileapi-h"><a href="#FindFirstVolume-函数-fileapi-h" class="headerlink" title="FindFirstVolume 函数 (fileapi.h)"></a>FindFirstVolume 函数 (fileapi.h)</h3><p>​        检索计算机上的卷的名称。 <strong>FindFirstVolume</strong> 用于开始扫描计算机的卷。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">HANDLE <span class="token function">FindFirstVolume</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpszVolumeName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  DWORD  cchBufferLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] lpszVolumeName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收空终止字符串的缓冲区的指针，该字符串指定找到的第一个卷的卷 <strong>GUID</strong> 路径。</p><pre class="line-numbers language-none"><code class="language-none">[in] cchBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        要在 <strong>TCHAR</strong> 中接收卷 <strong>GUID</strong> 路径的缓冲区的长度。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是随后调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数时使用的搜索句柄。</p><p>​        如果函数找不到任何卷，则返回值为 <strong>INVALID_HANDLE_VALUE</strong> 错误代码。 要获得更多的错误信息，请调用 GetLastError。</p><h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><p>​        <strong>FindFirstVolume</strong> 函数打开卷搜索句柄，并返回有关计算机上找到的第一个卷的信息。 建立搜索句柄后，可以使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> 函数搜索其他卷。 不再需要搜索句柄时，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数将其关闭。</p><p>​        不应假定这些函数返回的卷的顺序与计算机上的卷顺序之间存在任何关联。 具体而言，如果) 或磁盘管理员，则不要假定由 BIOS (分配的卷顺序和驱动器号之间的任何关联。</p><p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">技术</th><th style="text-align:left">支持</th></tr></thead><tbody><tr><td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">群集共享卷文件系统 (CsvFS)</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">弹性文件系统 (ReFS)</td><td style="text-align:left">是</td></tr></tbody></table></div><p>​        SMB 不支持卷管理功能。</p><h3 id="FindNextVolume-函数-fileapi-h"><a href="#FindNextVolume-函数-fileapi-h" class="headerlink" title="FindNextVolume 函数 (fileapi.h)"></a>FindNextVolume 函数 (fileapi.h)</h3><p>继续通过调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 函数开始的卷搜索。 <strong>FindNextVolume</strong> 为每个调用查找一个卷。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">FindNextVolume</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  HANDLE hFindVolume<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpszVolumeName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  DWORD  cchBufferLength<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] hFindVolume<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        上一次调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 函数返回的卷搜索句柄。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpszVolumeName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收找到的卷 <strong>GUID</strong> 路径的字符串的指针。</p><pre class="line-numbers language-none"><code class="language-none">[in] cchBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        接收卷 <strong>GUID</strong> 路径的缓冲区的长度（以 <strong>TCHAR</strong> 为单位）。</p><h4 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。 如果未找到匹配的文件， <strong>GetLastError</strong> 函数将返回 <strong>ERROR_NO_MORE_FILES</strong> 错误代码。 在这种情况下，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数关闭搜索。</p><h4 id="注解-2"><a href="#注解-2" class="headerlink" title="注解"></a>注解</h4><p>​        通过调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 建立搜索句柄后，可以使用 <strong>FindNextVolume</strong> 函数搜索其他卷。</p><p>​        不应假定这些函数返回的卷的顺序与计算机上的卷顺序之间存在任何关联。 具体而言，如果存在任何) 或磁盘管理员，则不要假定 BIOS (分配的卷顺序和驱动器号之间的任何关联。</p><p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">技术</th><th style="text-align:left">支持</th></tr></thead><tbody><tr><td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">群集共享卷文件系统 (CsvFS)</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">弹性文件系统 (ReFS)</td><td style="text-align:left">是</td></tr></tbody></table></div><p>​        SMB 不支持卷管理功能。</p><h2 id="查看驱动器属性-GetDriverType-amp-amp-GetVolumeInformation"><a href="#查看驱动器属性-GetDriverType-amp-amp-GetVolumeInformation" class="headerlink" title="查看驱动器属性 GetDriverType &amp;&amp; GetVolumeInformation"></a>查看驱动器属性 GetDriverType &amp;&amp; GetVolumeInformation</h2><p>​        我们在盘上右键查看属性。</p><p><img src="image-20230528182104767.png" alt="image-20230528182104767"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;BOOL GetDriverInfo(LPSTR szDriver) &#123;UINT uDriverType &#x3D; GetDriveType(szDriver);printf(&quot;%u&quot;, uDriverType);return TRUE;&#125;int main()&#123;GetDriverInfo(TEXT(&quot;c:\\&quot;));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230528182835061.png" alt="image-20230528182835061"></p><p>​        有自己的特殊含义！在<code>WinBase.h</code>文件下</p><p><img src="image-20230528184406835.png" alt="image-20230528184406835"></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define DRIVE_UNKNOWN     0#define DRIVE_NO_ROOT_DIR 1#define DRIVE_REMOVABLE   2#define DRIVE_FIXED       3#define DRIVE_REMOTE      4#define DRIVE_CDROM       5#define DRIVE_RAMDISK     6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>     正是如此！</code></pre><p>​        下面是给出详细信息的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;BOOL GetDriverInfo(LPSTR szDriver) &#123;UINT uDriverType &#x3D; GetDriveType(szDriver);printf(&quot;%ls,the type is %u\n&quot;,szDriver, uDriverType);switch (uDriverType) &#123;case DRIVE_UNKNOWN: &#123;printf(&quot;can&#39;t get the driver type&quot;);break;&#125;case DRIVE_NO_ROOT_DIR: &#123;printf(&quot;the root path is invalid&quot;);break;&#125;case DRIVE_REMOVABLE:&#123;printf(&quot;the driver can be removed!&quot;);break;&#125;case DRIVE_FIXED :&#123;printf(&quot;this is a type that cannot move!&quot;);break;&#125;case DRIVE_REMOTE:&#123;printf(&quot;the driver is a remote drive!&quot;);break;&#125;case DRIVE_CDROM:&#123;printf(&quot;the driver is a CD-ROM!&quot;);break;&#125;case DRIVE_RAMDISK:&#123;printf(&quot;The driver is a RAM disk!&quot;);break;&#125;default:break;&#125;printf(&quot;\n&quot;);&#x2F;&#x2F; For more Information&#x2F;&#x2F; &#x2F;&#x2F; need to get Some valWCHAR szDriverName[MAX_PATH];DWORD dwVolumeSerialNumber;DWORD dwMaxComponentLength;DWORD dwFileSystemFlags;WCHAR szFileSystemNameBuffer[MAX_PATH];if (!GetVolumeInformation(szDriver,szDriverName,MAX_PATH,&amp;dwVolumeSerialNumber,&amp;dwMaxComponentLength,&amp;dwFileSystemFlags,szFileSystemNameBuffer,MAX_PATH)) &#123;return FALSE;&#125;if (lstrlen(szDriverName)) &#123;printf(&quot;\nDriverName is %ls\n&quot;, szDriverName);&#125;printf(&quot;Volumn Serial Number is %u\n&quot;, dwVolumeSerialNumber);printf(&quot;Maxinum Component Length is %u&quot;, dwMaxComponentLength);printf(&quot;Systems Type:%ls&quot;, szFileSystemNameBuffer);if (dwFileSystemFlags &amp; FILE_VOLUME_QUOTAS) &#123;&#x2F;&#x2F; 可以看到这是要求位判断printf(&quot;the file system does support the QUOTAS&quot;);&#125;&#x2F;&#x2F;...return TRUE;&#125;int main()&#123;GetDriverInfo(TEXT(&quot;c:\\&quot;));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Extensive-Reading-for-Microsoft-API-1"><a href="#Extensive-Reading-for-Microsoft-API-1" class="headerlink" title="Extensive Reading for Microsoft API"></a>Extensive Reading for Microsoft API</h2><h3 id="getDriveType-函数-fileapi-h"><a href="#getDriveType-函数-fileapi-h" class="headerlink" title="getDriveType 函数 (fileapi.h)"></a>getDriveType 函数 (fileapi.h)</h3><p>​        确定磁盘驱动器是可移动的、固定的、CD-ROM、RAM 磁盘还是网络驱动器。</p><p>​        若要确定驱动器是否为 USB 类型驱动器，请调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceregistrypropertya">SetupDiGetDeviceRegistryProperty</a> 并指定 <strong>SPDRP_REMOVAL_POLICY</strong> 属性。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">UINT <span class="token function">GetDriveTypeW</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPCWSTR lpRootPathName<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        驱动器的根目录。</p><p>​        需要尾随反斜杠。 如果此参数为 <strong>NULL</strong>，则该函数使用当前目录的根目录。</p><h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>​        返回值指定驱动器的类型，可以是下列值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">返回代码/值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>DRIVE_UNKNOWN</strong>0</td><td style="text-align:left">无法确定驱动器类型。</td></tr><tr><td style="text-align:left"><strong>DRIVE_NO_ROOT_DIR</strong>1</td><td style="text-align:left">根路径无效;例如，在指定路径上没有装载卷。</td></tr><tr><td style="text-align:left"><strong>DRIVE_REMOVABLE</strong>2</td><td style="text-align:left">驱动器具有可移动媒体;例如，软盘驱动器、拇指驱动器或闪存卡读取器。</td></tr><tr><td style="text-align:left"><strong>DRIVE_FIXED</strong>3</td><td style="text-align:left">驱动器具有固定媒体;例如，硬盘驱动器或闪存驱动器。</td></tr><tr><td style="text-align:left"><strong>DRIVE_REMOTE</strong>4</td><td style="text-align:left">驱动器是远程 (网络) 驱动器。</td></tr><tr><td style="text-align:left"><strong>DRIVE_CDROM</strong>5</td><td style="text-align:left">驱动器是 CD-ROM 驱动器。</td></tr><tr><td style="text-align:left"><strong>DRIVE_RAMDISK</strong>6</td><td style="text-align:left">驱动器是一个 RAM 磁盘。</td></tr></tbody></table></div><h3 id="getVolumeInformationW-函数-fileapi-h"><a href="#getVolumeInformationW-函数-fileapi-h" class="headerlink" title="getVolumeInformationW 函数 (fileapi.h)"></a>getVolumeInformationW 函数 (fileapi.h)</h3><p>​        检索与指定根目录关联的文件系统和卷的相关信息。</p><p>​        若要在检索此信息时指定句柄，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationbyhandlew">GetVolumeInformationByHandleW</a> 函数。</p><p>​        若要检索文件或目录的当前压缩状态，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>。</p><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetVolumeInformationW</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  LPCWSTR lpRootPathName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPWSTR  lpVolumeNameBuffer<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            DWORD   nVolumeNameSize<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPDWORD lpVolumeSerialNumber<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPDWORD lpMaximumComponentLength<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPDWORD lpFileSystemFlags<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPWSTR  lpFileSystemNameBuffer<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            DWORD   nFileSystemNameSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向包含要描述的卷的根目录的字符串的指针。</p><p>​        如果此参数为 <strong>NULL</strong>，则使用当前目录的根目录。 尾随反斜杠是必需的。 例如，将 \\MyServer\MyShare 指定为“\\MyServer\MyShare\”，或将 C 驱动器指定为“C：\”。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpVolumeNameBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收指定卷名称的缓冲区的指针。 缓冲区大小由 <em>nVolumeNameSize</em> 参数指定。</p><pre class="line-numbers language-none"><code class="language-none">[in] nVolumeNameSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        卷名称缓冲区的长度（以 <strong>TCHAR 为单位</strong>）。 最大缓冲区大小为 <strong>MAX_PATH</strong>+1。</p><p>​        如果未提供卷名缓冲区，则忽略此参数。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpVolumeSerialNumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收卷序列号的变量的指针。</p><p>​        如果不需要序列号，此参数可以为 <strong>NULL</strong> 。</p><p>​        此函数返回格式化硬盘时操作系统分配的卷序列号。 若要以编程方式获取制造商分配的硬盘序列号，请使用 Windows Management Instrumentation (WMI) <a href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a> 属性 <strong>SerialNumber</strong>。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpMaximumComponentLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向变量的指针，该变量接收指定文件系统支持的文件名组件的最大长度（以 <strong>TCHAR 为单位</strong>）。</p><p>​        文件名组件是文件名在反斜杠之间的部分。</p><p>​        存储在 <em>*lpMaximumComponentLength</em> 指向的变量中的值用于指示指定的文件系统支持长名称。 例如，对于支持长名称的 FAT 文件系统，函数存储值 255，而不是以前的 8.3 指示器。 使用 NTFS 文件系统的系统上也支持长名称。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFileSystemFlags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收与指定文件系统关联的标志的变量的指针。</p><p>​        此参数可以是以下一个或多个标志。 但是， <strong>FILE_FILE_COMPRESSION</strong> 和 <strong>FILE_VOL_IS_COMPRESSED</strong> 是相互排斥的。</p><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>FILE_CASE_SENSITIVE_SEARCH</strong> 0x00000001</td><td style="text-align:left">指定的卷支持区分大小写的文件名。</td></tr><tr><td style="text-align:left"><strong>FILE_CASE_PRESERVED_NAMES</strong> 0x00000002</td><td style="text-align:left">指定的卷支持在磁盘上放置名称时保留文件名大小写。</td></tr><tr><td style="text-align:left"><strong>FILE_UNICODE_ON_DISK</strong> 0x00000004</td><td style="text-align:left">指定的卷支持在磁盘上显示的文件名中的 Unicode。</td></tr><tr><td style="text-align:left"><strong>FILE_PERSISTENT_ACLS</strong> 0x00000008</td><td style="text-align:left">指定的卷保留并强制实施访问控制列表 (ACL) 。 例如，NTFS 文件系统保留并强制实施 ACL，而 FAT 文件系统则不这样做。</td></tr><tr><td style="text-align:left"><strong>FILE_FILE_COMPRESSION</strong> 0x00000010</td><td style="text-align:left">指定的卷支持基于文件的压缩。</td></tr><tr><td style="text-align:left"><strong>FILE_VOLUME_QUOTAS</strong> 0x00000020</td><td style="text-align:left">指定的卷支持磁盘配额。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_SPARSE_FILES</strong> 0x00000040</td><td style="text-align:left">指定的卷支持稀疏文件。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_REPARSE_POINTS</strong> 0x00000080</td><td style="text-align:left">指定的卷支持重新分析点。  <strong>裁判：</strong> ReFS 支持重新分析点，但不对其进行索引，因此 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> 将无法按预期工作。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_REMOTE_STORAGE</strong> 0x00000100</td><td style="text-align:left">文件系统支持远程存储。</td></tr><tr><td style="text-align:left"><strong>FILE_RETURNS_CLEANUP_RESULT_INFO</strong> 0x00000200</td><td style="text-align:left">成功执行清理操作后，文件系统将返回描述清理期间执行的其他操作的信息，例如删除文件。 文件系统筛选器可以在清理后回调中检查此信息。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_POSIX_UNLINK_RENAME</strong> 0x00000400</td><td style="text-align:left">文件系统支持 POSIX 样式的删除和重命名操作。</td></tr><tr><td style="text-align:left"><strong>FILE_VOLUME_IS_COMPRESSED</strong> 0x00008000</td><td style="text-align:left">指定的卷是压缩卷，例如 DoubleSpace 卷。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_OBJECT_IDS</strong> 0x00010000</td><td style="text-align:left">指定的卷支持对象标识符。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_ENCRYPTION</strong> 0x00020000</td><td style="text-align:left">指定的卷支持 EFS) 加密文件系统 (。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/FileIO/file-encryption">文件加密</a>。</td></tr><tr><td style="text-align:left"><strong>FILE_NAMED_STREAMS</strong> 0x00040000</td><td style="text-align:left">指定的卷支持命名流。</td></tr><tr><td style="text-align:left"><strong>FILE_READ_ONLY_VOLUME</strong> 0x00080000</td><td style="text-align:left">指定的卷是只读的。</td></tr><tr><td style="text-align:left"><strong>FILE_SEQUENTIAL_WRITE_ONCE</strong> 0x00100000</td><td style="text-align:left">指定的卷支持单个顺序写入。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_TRANSACTIONS</strong> 0x00200000</td><td style="text-align:left">指定的卷支持事务。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/Ktm/about-ktm">关于 KTM</a>。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_HARD_LINKS</strong> 0x00400000</td><td style="text-align:left">指定的卷支持硬链接。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/hard-links-and-junctions">硬链接和交接点</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前不支持此值。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</strong> 0x00800000</td><td style="text-align:left">指定的卷支持扩展属性。 扩展属性是应用程序特定的元数据片段，应用程序可与文件关联，并且不属于文件数据。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_OPEN_BY_FILE_ID</strong> 0x01000000</td><td style="text-align:left">文件系统支持通过 FileID 打开。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_USN_JOURNAL</strong> 0x02000000</td><td style="text-align:left">指定的卷支持更新序列号 (USN) 日志。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/FileIO/change-journal-records">更改日记记录</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_INTEGRITY_STREAMS</strong> 0x04000000</td><td style="text-align:left">文件系统支持 <a href="https://learn.microsoft.com/zh-cn/windows-server/storage/refs/integrity-streams">完整性流</a>。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_BLOCK_REFCOUNTING</strong> 0x08000000</td><td style="text-align:left">指定的卷支持在同一卷上的文件之间共享逻辑群集。 文件系统在写入共享群集时重新分配。 指示 <strong>FSCTL_DUPLICATE_EXTENTS_TO_FILE</strong> 是受支持的操作。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_SPARSE_VDL</strong> 0x10000000</td><td style="text-align:left">文件系统跟踪文件的每个群集是否包含来自显式文件写入或自动零的有效数据 () 或无效数据 (尚未写入或归零) 。 使用稀疏的有效数据长度 (VDL) 的文件系统不会存储有效的数据长度，也不需要有效数据在文件中连续。</td></tr><tr><td style="text-align:left"><strong>FILE_DAX_VOLUME</strong> 0x20000000</td><td style="text-align:left">指定的卷是 DAX) 卷 (直接访问。  <strong>注意：</strong>此标志是在 Windows 10 版本 1607 中引入的。</td></tr><tr><td style="text-align:left"><strong>FILE_SUPPORTS_GHOSTING</strong> 0x40000000</td><td style="text-align:left">文件系统支持重影。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFileSystemNameBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收文件系统名称的缓冲区的指针，例如 FAT 文件系统或 NTFS 文件系统。 缓冲区大小由 <em>nFileSystemNameSize</em> 参数指定。</p><pre class="line-numbers language-none"><code class="language-none">[in] nFileSystemNameSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        文件系统名称缓冲区的长度（以 <strong>TCHAR 为单位</strong>）。 最大缓冲区大小为 <strong>MAX_PATH</strong>+1。</p><p>​        如果未提供文件系统名称缓冲区，则忽略此参数。</p><h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果检索了所有请求的信息，则返回值为非零值。</p><p>​        如果未检索所有请求的信息，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><h4 id="注解-3"><a href="#注解-3" class="headerlink" title="注解"></a>注解</h4><p>​        当用户尝试获取有关没有软盘的软盘驱动器或没有光盘的 CD-ROM 驱动器的信息时，系统会显示一个消息框，供用户分别插入软盘或光盘。 若要防止系统显示此消息框，请使用 <strong>SEM_FAILCRITICALERRORS</strong>调用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> 函数。</p><p>​        <strong>FILE_VOL_IS_COMPRESSED</strong>标志是基于卷的压缩的唯一指示器。 文件系统名称不会更改以指示压缩，例如，此标志在 DoubleSpace 卷上返回设置。 如果压缩是基于卷的，则会压缩或未压缩整个卷。</p><p>​        <strong>FILE_FILE_COMPRESSION</strong>标志指示文件系统是否支持基于文件的压缩。 当压缩基于文件时，可以压缩或不压缩单个文件。</p><p>​        <strong>FILE_FILE_COMPRESSION</strong>和<strong>FILE_VOL_IS_COMPRESSED</strong>标志互斥。 不能设置这两个位。</p><p>​        <em>存储在 lpMaximumComponentLength</em> 中的最大组件长度值是唯一指示卷支持长于正常 FAT 文件系统 (或其他文件系统) 文件名。 不会更改文件系统名称以指示对长文件名的支持。</p><p>​        <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getcompressedfilesizea">GetCompressedFileSize</a> 函数获取文件的压缩大小。 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a> 函数可以确定是否压缩单个文件。</p><h4 id="符号链接行为"><a href="#符号链接行为" class="headerlink" title="符号链接行为"></a>符号链接行为</h4><p>​        如果路径指向符号链接，则 函数将返回目标的卷信息。</p><p>​        从Windows 8和Windows Server 2012开始，以下技术支持此函数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">技术</th><th style="text-align:left">支持</th></tr></thead><tbody><tr><td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">群集共享卷文件系统 (CsvFS)</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">弹性文件系统 (ReFS)</td><td style="text-align:left">是</td></tr></tbody></table></div><p>​        SMB 不支持卷管理功能。</p><h4 id="事务处理操作"><a href="#事务处理操作" class="headerlink" title="事务处理操作"></a>事务处理操作</h4><p>​        如果卷支持文件系统事务，则函数返回 <em>lpFileSystemFlags</em> 中的<strong>FILE_SUPPORTS_TRANSACTIONS</strong>。</p><h5 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h5><p>​        标头 <code>fileapi.h</code> 将 <strong>GetVolumeInformation</strong> 定义为别名，该别名根据 UNICODE 预处理器常量的定义自动选择此函数的 ANSI 或 Unicode 版本。 将非特定编码别名的使用与非非特定编码的代码混合使用可能会导致不匹配，从而导致编译或运行时错误。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/intl/conventions-for-function-prototypes">函数原型的约定</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Windows 32API </tag>
            
            <tag> 摸鱼ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>More effective C++ notes</title>
      <link href="/2023/05/27/More-effective-C-2/"/>
      <url>/2023/05/27/More-effective-C-2/</url>
      
        <content type="html"><![CDATA[<h1 id="More-effective-C-2"><a href="#More-effective-C-2" class="headerlink" title="More effective C++2"></a>More effective C++2</h1><h2 id="条款22-考虑以操作符复合形式（op-）来取代独身形式"><a href="#条款22-考虑以操作符复合形式（op-）来取代独身形式" class="headerlink" title="条款22 考虑以操作符复合形式（op=）来取代独身形式"></a>条款22 考虑以操作符复合形式（op=）来取代独身形式</h2><p>​        对于大部分的程序员，他们希望——</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; x + y;x &#x3D; x - y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        的同时</p><pre class="line-numbers language-none"><code class="language-none">x +&#x3D; y;x -&#x3D; y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        的形式也可以被接受。</p><p>​        为了让复合形式和独身形式都可以很好的运作——我们选则：让前者作为基础来实现</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Rational&#123;    public:    Rational&amp; operator+&#x3D;(const Rational&amp; rhs);    Rational&amp; operator-&#x3D;(const Rational&amp; rhs);&#125;const Rational operator+(const Rational&amp; lhs,const Rational&amp; rhs)&#123;    return Rational(lhs) +&#x3D; rhs;&#125;const Rational operator-(const Rational&amp; lhs,const Rational&amp; rhs)&#123;    return Rational(lhs) -&#x3D; rhs;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样的话，我们就只需要维护符合操作符就好了。</p><p>​        事实上，为了扩展性更强一些，我们一般的使用模板来完成通用化的工作：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;const T operator+(const T&amp; lhs,const T&amp; rhs)&#123;    return T(lhs) +&#x3D; rhs;&#125; template&lt;class T&gt;const T operator-(const T&amp; lhs,const T&amp; rhs)&#123;    return T(lhs) -&#x3D; rhs;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是现在为止我们都没有考虑效率的问题。</p><p>​        注意到复合操作类型不会花费时间构造一个巨大的对象返回。于是我们这样的设计可以让客户程序员选择效率与方便维护中二选一：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 易于维护的Rational a,b,c,d,result;result &#x3D; a + b + c + d;&#x2F;&#x2F; 追求效率的result &#x3D; a;result +&#x3D; b;result +&#x3D; c;result +&#x3D; d;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        程序的灵活性更好了！</p><h2 id="条款23：考虑使用其他库"><a href="#条款23：考虑使用其他库" class="headerlink" title="条款23：考虑使用其他库"></a>条款23：考虑使用其他库</h2><h2 id="条款24：了解virtual-functions-multiple-functions-virtual-base-classes-runtime-type-identification的成本"><a href="#条款24：了解virtual-functions-multiple-functions-virtual-base-classes-runtime-type-identification的成本" class="headerlink" title="条款24：了解virtual functions, multiple functions, virtual base classes runtime type identification的成本"></a>条款24：了解virtual functions, multiple functions, virtual base classes runtime type identification的成本</h2><p>​        当一个虚函数被调用，执行的代码必须对应于调用者的动态类型。我们的编译器可以做到虚函数的处理得益于 virtual table 或 virtual table pointers</p><p>​        我们的vtbl 通常是函数指针架构产生的数组。</p><p>比如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class C1&#123;    public:    C1();    virtual ~C1();    virtual void f1();    void f4() const;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230527133400105.png" alt="image-20230527133400105"></p><p>​        现在，一旦我们的子类继承了父类，并且自己重新实现了一些虚函数，那么——C2（假使它继承了C1）这张虚函数表的新改写函数就会换成子类自己的！</p><p>​        避免将虚函数声明为内联的inline,编译器也会自动忽视之。下面我会提到为什么</p><p>​        当然，只有虚函数表是不够的——我们的类中往往会增加一个函数数组指针，指向这个表！一旦发生继承，这个表就会被一大堆成员包围。</p><p>​        下面来看对于体系类的虚函数调用。还是回到C1，C2类的表</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void makeACall(C1* pC1)&#123;pC1()-&gt;f1();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        如果我们只看这点代码，完全不知道程序运行时会调用哪一段代码。编译器是这样处理的：</p><ol><li><p>根据对象的vptr 找到 vtbl</p></li><li><p>找到被调用的函数在vtbl的指针，然后调用之。</p><pre class="line-numbers language-none"><code class="language-none">(*pC1-&gt;vptr[i])(pC1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 你瞧！只有在运行的时候我们才会直到究竟是哪个！而inline跟virtual的设计理念完全冲突！这就是为什么不要给虚函数添加inline!</p></li></ol><p>​        下面考虑多重继承（相当恐怖的）</p><p>​        这是一个菱形继承：</p><p><img src="image-20230527134602652.png" alt="image-20230527134602652"></p><p>​        现在，我们视A作为最基本的类：</p><p><img src="image-20230527134822239.png" alt="image-20230527134822239"></p><p>​        当A内有任何一点虚函数</p><p><img src="image-20230527134941853.png" alt="image-20230527134941853"></p><p>​        我们看到了虚函数是如何使得对象变大的了</p><p>​        RTTI作为运行时获取对象类型，一个class只需要一个就可以了。我们在vtbl的开头加上一个 type_info对象就可以帮助识别。</p><div class="table-container"><table><thead><tr><th>性质</th><th>对象大小</th><th>Class数据量增加</th><th>内联几率降低</th></tr></thead><tbody><tr><td>虚函数</td><td>是</td><td>是</td><td>是</td></tr><tr><td>多重继承</td><td>是</td><td>是</td><td>否</td></tr><tr><td>虚拟基类</td><td>往往如此</td><td>有时候</td><td>否</td></tr><tr><td>RTTI</td><td>否</td><td>是</td><td>否</td></tr></tbody></table></div><h2 id="条款25：将构造函数和非成员函数虚化"><a href="#条款25：将构造函数和非成员函数虚化" class="headerlink" title="条款25：将构造函数和非成员函数虚化"></a>条款25：将构造函数和非成员函数虚化</h2><p>​        我们有必要将构造函数和非成员函数虚化——这是因为我们之间有关系的类可以做到一个构造函数完成更多的事情。而且更加的省精力。</p><p>​        构造函数的虚化有助于我们在实际调用的时候返回期望对象的构造函数！</p><h2 id="条款26-限制某个class所能产生的对象数量"><a href="#条款26-限制某个class所能产生的对象数量" class="headerlink" title="条款26 限制某个class所能产生的对象数量"></a>条款26 限制某个class所能产生的对象数量</h2><h3 id="允许0个或者1-个对象产出"><a href="#允许0个或者1-个对象产出" class="headerlink" title="允许0个或者1 个对象产出"></a>允许0个或者1 个对象产出</h3><p>​        阻止一个类的产生的最简单的方法就是把构造器放private里面。</p><p>​        那一个呢？配合static和接口函数！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class PrinterJob;class Printer&#123;    public:    void submitJob(const PrinterJob&amp; job);    void reset();    void performSelfTest();    friend Printer&amp; thePrinter();    private:    Printer();    Printer(const Printer&amp; rhs);    ...&#125;Printer&amp; thePrinter()&#123;    static Printer p;    return p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样一调用，我们就总是调用那个在静态区的变量。</p><p>​        我们也可以把这一大堆东西放到namespace里去，防止冲突！</p><p>​        有一个细节：我们为什么不把这个函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Printer&amp; thePrinter()&#123;    static Printer p;    return p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        设置成inline呢？答案是，防止被复制——因为我们把调用函数这个动作直接改成执行代码，这就意味着——这个对象可能会被复制！不要在带有locale static对象的函数中内联！</p><p>​        注意，<strong>一个构造函数是private 的类是不允许被继承的！</strong>（没办法显著的调用构造器）于是，<strong>避免一个具体类继承另一个具体类！</strong></p><h3 id="允许对象生生灭灭"><a href="#允许对象生生灭灭" class="headerlink" title="允许对象生生灭灭"></a>允许对象生生灭灭</h3><p>​        注意到：</p><pre class="line-numbers language-none"><code class="language-none">create Printer object p1;use p1;delete p1;create Printer object p2;use p2;delete p2;create Printer object p3;use p3;delete p3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样的事情不违反只允许一个对象！但是却不被允许，那么我们有必要整一个新办法</p><p>​        我们加上一个计数器就好了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Printer&#123;public:    class TooManyObj&#123;&#125;;    static Printer* makePrinter();    ~Printer();    void submitJob(const PrinterJob&amp; job);    void reset();    void performSelfTest();        private:    static size_t numObjects;    static size_t numObjects &#x3D; 10;    Printer();    Printer(const Printer&amp; rhs);&#125;size_t Printer::numObjects &#x3D; 0;Printer::Printer()&#123;        if(numObjects &gt;&#x3D; max_obj)&#123;            throw TooManyObj();        &#125;        ...        ++numObjects;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        也有程序员使用专门计数的类！但这里就不再展开了。</p><h3 id="判断对象在哪里（在不在heap-）"><a href="#判断对象在哪里（在不在heap-）" class="headerlink" title="判断对象在哪里（在不在heap?）"></a>判断对象在哪里（在不在heap?）</h3><p>​        不应当直接在class里声明一个bool变量，然后塞到operator new这个函数下，因为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">UPNumber* numArr &#x3D; new UPNumber[100];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这下坏了，编译器可能是：先调用operator new在调用构建器！（先开空间，在初始化，我们上面的办法就失效了！）</p><p>​        于是，不妨使用计组学的特性?</p><p><img src="image-20230527142543682.png" alt="image-20230527142543682"></p><p>​        可以给出这样的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool onHeap(const void* addr)&#123;char onStack;    return address &lt; &amp;onTheStack&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是别忘了，我们还有静态区！它无法区分和heap对象和static对象！</p><p>​        事实上，没有通用的办法！</p><h3 id="静止对象产生在heap上"><a href="#静止对象产生在heap上" class="headerlink" title="静止对象产生在heap上"></a>静止对象产生在heap上</h3><p>​        很简单了：直接把operator new 和operator delete直接扔到私有区！</p><h2 id="条款27：auto-ptr"><a href="#条款27：auto-ptr" class="headerlink" title="条款27：auto_ptr"></a>条款27：auto_ptr</h2><p>​        <strong>智能指针主要用于动态内存的管理,同时提供给用户与内置指针一样的使用方法,本条款主要涉及智能指针在构造与析构,复制和赋值,解引等方面的注意点,而非智能指针的实现细节.</strong></p><h3 id="智能指针的构造-赋值-析构"><a href="#智能指针的构造-赋值-析构" class="headerlink" title="智能指针的构造,赋值,析构"></a>智能指针的构造,赋值,析构</h3><pre><code>  智能指针的copy constructor,assignment operator,destructor对应于不同的观念而有不同的实现,主要有三种选择:  不允许对象的共享,在调用copy constructor和assignment时转移对象所有权,这样在调用destructor时就可以直接delete智能指针内含的内置指针,如标准库的auto_ptr,其实现可能像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;class auto_ptr &#123;public:    ...    auto_ptr(auto_ptr&lt;T&gt;&amp; rhs);     auto_ptr&lt;T&gt;&amp;  operator&#x3D;(auto_ptr&lt;T&gt;&amp; rhs);     ...&#125;;template&lt;class T&gt;auto_ptr&lt;T&gt;::auto_ptr(auto_ptr&lt;T&gt;&amp; rhs)&#123;    pointee &#x3D; rhs.pointee;     rhs.pointee &#x3D; 0; &#x2F;&#x2F; 转移对象所有权&#125; template&lt;class T&gt;auto_ptr&lt;T&gt;&amp; auto_ptr&lt;T&gt;::operator&#x3D;(auto_ptr&lt;T&gt;&amp; rhs)&#123;    if (this &#x3D;&#x3D; &amp;rhs) &#x2F;&#x2F; 自我赋值的情况        return *this;     delete pointee;     pointee &#x3D; rhs.pointee; &#x2F;&#x2F; 转移对象所有权    rhs.pointee &#x3D; 0;     return *this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      值得注意的是,由于auto_ptr的copy constructor被调用时,对象所有权便转移了,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void printTreeNode(ostream&amp; s, auto_ptr&lt;TreeNode&gt; p)&#123; s &lt;&lt; *p; &#125;int main()&#123;    auto_ptr&lt;TreeNode&gt; ptn(new TreeNode);    ...    printTreeNode(cout, ptn); &#x2F;&#x2F;通过传值方式传递auto_ptr    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      调用printTreeNode后,ptn所指向的内存便被释放,内含的内置指针也被置为0,但这并不符合用户的预期.这说明不能使用pass-by-value的方式传递auto_ptr给函数,只能使用pass-by-reference.      使用这种策略实现的智能指针的destructor可能像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;SmartPtr&lt;T&gt;::~SmartPtr()&#123;    if (*this owns *pointee) &#123;        delete pointee;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  2). 不允许对象的共享,调用copy constructor和assignment operator时进行深度拷贝——产生新对象.这种设计思想较简单,缺点也较明显:新对象的产生需要消耗资源.这里不再讨论  3). 允许对象的共享,使用引用计数,调用copy constructor和assignment operator增加引用计数的个数.当引用计数的个数为0时便析构对象并释放内存,如标准库的shared_ptr,关于引用计数的具体实现见[条款29](http://i.cnblogs.com/PostDone.aspx?postid=4857432&amp;actiontip=存为草稿成功).</code></pre><h3 id="实现Dereference-Operators-解引操作符"><a href="#实现Dereference-Operators-解引操作符" class="headerlink" title="实现Dereference Operators(解引操作符)"></a>实现Dereference Operators(解引操作符)</h3><pre><code>  主要讨论operator*和operator-&gt;的实现,前者放回所指对象的引用,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;T&amp; SmartPtr&lt;T&gt;::operator*() const&#123;    perform &quot;smart pointer&quot; processing;    return *pointee;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  如果程序采用了lazy fetching(见[条款17](http://www.cnblogs.com/reasno/p/4830677.html))策略,就有可能需要为pointers变换出一个新对象.需要注意的是,operator*返回的是引用,如果返回对象,可能会产生由于SmartPtr指向的是T的派生类对象而非T类对象而造成的切割问题.  operator-&gt;和operator*类似,operator-&gt;返回指针.  对于使用引用计数的shared_ptr,问题还未停止,它允许多个智能指针共享相同对象,但前提是这些指针所指向的对象相同.由于operator*和operator-&gt;返回所指对象的引用和指针,这可能导致其所指对象被更改,但原则上共享同一块内存的其他智能指针却要求所指对象保持不变.因此有必要在调用operator*和operator-&gt;的时候开辟一块新内存,使调用operator*和operator-&gt;的智能指针指向这块新内存以防止共享内存被篡改,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;T&amp; SmartPtr&lt;T&gt;::operator*() const&#123;    if(number of reference!&#x3D;1)&#123;        pointee&#x3D;new T(*pointee);        --reference number of the old object;        set the reference number of the new object to 1;     &#125;    return *pointee;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试Smart-Pointers是否为Null"><a href="#测试Smart-Pointers是否为Null" class="headerlink" title="测试Smart Pointers是否为Null"></a>测试Smart Pointers是否为Null</h3><pre><code>  直接的策略是定义隐式转换操作符operator void*,使得以下操作可以通过编译:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if (ptn &#x3D;&#x3D; 0) ... &#x2F;&#x2F; 正确if (ptn) ... &#x2F;&#x2F; 正确if (!ptn) ... &#x2F;&#x2F;正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>  但隐式转换操作符很容易被滥用,它使得不同类型的指针可以相比较,以下代码可以通过编译:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;Apple&gt; pa;SmartPtr&lt;Orange&gt; po;...if (pa &#x3D;&#x3D; po) ...&#x2F;&#x2F;可以通过编译<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  尽管pa和po是不同类型的智能指针,但由于没有定义Smart&lt;Apple&gt;和Smart&lt;Orange&gt;为参数的operator==,因此编译器默认调用operator void*,使得以上代码通过编译.  一种差强人意的方法是允许测试null,但使用!操作符,如果内置指针为null,便返回true,客户端要测试智能指针是否为null,就要像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;TreeNode&gt; ptn;...if (!ptn) &#123;     ...&#125;else &#123;    ... &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  但以下做法却被禁止:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if (ptn &#x3D;&#x3D; 0) ... if (ptn) ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>  `iostream`程序库不仅允许隐式类型转换`void*`,还提供`operator!` ,C++标准库中,&quot;隐式转换为void*&quot;已被&quot;隐式转换为bool&quot;取代,而operator bool总是返回operator!的反.</code></pre><h3 id="将Smart-Pointers转换为Dumb-Pointers"><a href="#将Smart-Pointers转换为Dumb-Pointers" class="headerlink" title="将Smart Pointers转换为Dumb Pointers"></a>将Smart Pointers转换为Dumb Pointers</h3><pre><code>  有时要兼容并未使用智能指针的程序库,就要允许智能指针到内置指针的转换,直接的思路还是隐式转换操作符:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;class DBPtr &#123;public:    ...    operator T*() &#123; return pointee; &#125;    ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  但是正如多次强调的,隐式转换操作符很容易被滥用,它使得客户可以轻易获得内置指针,从而绕过智能指针的控制,像这样:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Tuple&#123;...&#125;;void processTuple(DBPtr&lt;Tuple&gt;&amp; pt)&#123;    Tuple *rawTuplePtr &#x3D; pt; &#x2F;&#x2F; 得到内置指针    use rawTuplePtr to modify the tuple&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      像这样的操作也会被通过:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">DBPtr&lt;Tuple&gt; pt&#x3D;new Tuple;delete pt;&#x2F;&#x2F;通过,执行隐式类型转换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>      但这几乎肯定会造成错误,因为pt的析构函数执行时可能再次delete同一块内存.      此外,对于采用引用计数的实现版本来说,&quot;允许clinets直接使用dumb pointers&quot;往往会导致导致簿记方面的错误,造成严重后果,      即使实现了隐式转换操作符,但它还是不能做到提供和内置指针完全一样的行为,因为编译器禁止连续隐式调用自定义的隐式类型转换,像这样的使用会失败:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class TupleAccessors &#123;public:    TupleAccessors(const Tuple *pt); &#x2F;&#x2F; Tuple到TupleAccessor的转换    ... &#125;;TupleAccessors merge(const TupleAccessor&amp; ta1,const TupleAccessors&amp; ta2);DBPtr&lt;Tuple&gt; pt1, pt2;...merge(pt1,pt2);&#x2F;&#x2F;调用会出错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      尽管`DBPtr&lt;Tuple&gt;`到`Tuple*`再到`TupleAccessor`的转换就可以匹配merge的参数,但编译器禁止这么做.</code></pre><p>​          解决方法是使用普通成员函数进行显式转换以代替隐式转换操作符,像这样:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class DBPtr &#123;public:    ...    T* toPrimary() &#123; return pointee; &#125;    ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Smart-Pointers和”与继承有关的”类型转换"><a href="#Smart-Pointers和”与继承有关的”类型转换" class="headerlink" title="Smart Pointers和”与继承有关的”类型转换"></a>Smart Pointers和”与继承有关的”类型转换</h3><pre><code>      两个类之间有继承关系,但以这两个类为参数具现化的类模板却没有继承关系,由于智能指针是类模板,因此智能指针的包装会屏蔽内置指针的继承关系,例如对于以下继承层次:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class MusicProduct &#123;public:    MusicProduct(const string&amp; title);    virtual void play() const &#x3D; 0;    virtual void displayTitle() const &#x3D; 0;    ...&#125;;class Cassette: public MusicProduct &#123;public:    Cassette(const string&amp; title);    virtual void play() const;    virtual void displayTitle() const;    ...&#125;;class CD: public MusicProduct &#123;public:    CD(const string&amp; title);    virtual void play() const;    virtual void displayTitle() const;    ...&#125;void displayAndPlay(const MusicProduct* pmp, int numTimes)&#123;    for (int i &#x3D; 1; i &lt;&#x3D; numTimes; ++i) &#123;    pmp-&gt;displayTitle();    pmp-&gt;play();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  整个继承体系像这样:</code></pre><p><img src="699942-20151006212730503-151239962.png" alt="img"></p><pre><code>  由于各个类的继承关系,可以利用指针的多态实现面向对象编程,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Cassette *funMusic &#x3D; new Cassette(&quot;Alapalooza&quot;);CD *nightmareMusic &#x3D; new CD(&quot;Disco Hits of the 70s&quot;);displayAndPlay(funMusic, 10);displayAndPlay(nightmareMusic, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  但当指针经过封装成为智能指针之后,正如开始所说,以下代码将无法通过编译：</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void displayAndPlay(const SmartPtr&lt;MusicProduct&gt;&amp; pmp,int numTimes);SmartPtr&lt;Cassette&gt; funMusic(new Cassette(&quot;Alapalooza&quot;));SmartPtr&lt;CD&gt; nightmareMusic(new CD(&quot;Disco Hits of the 70s&quot;));displayAndPlay(funMusic, 10); &#x2F;&#x2F; 错误!displayAndPlay(nightmareMusic, 0); &#x2F;&#x2F; 错误!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是由于<code>MusicProduct,Cassette,CD</code>之间有继承关系,但智能指<code>SmartPtr&lt;MusicProduct&gt;,SmartPtr&lt;Cassette&gt;,SmartPtr&lt;CD&gt;</code>之间却没有内在的继承关系.</p><pre><code>      最直接的解决方法是为每一个智能指针类定义一个隐式类型转换操作符,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class SmartPtr&lt;Cassette&gt; &#123;public:    operator SmartPtr&lt;MusicProduct&gt;()    &#123; return SmartPtr&lt;MusicProduct&gt;(pointee); &#125;    ...private:    Cassette *pointee;&#125;;class SmartPtr&lt;CD&gt; &#123;public:    operator SmartPtr&lt;MusicProduct&gt;()    &#123; return SmartPtr&lt;MusicProduct&gt;(pointee); &#125;    ...private:    CD *pointee;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  这种方法可以解决类型转换的问题,但是却治标不治本:一方面,必须为每一个智能指针实例定义隐式类型转换操作符,这无疑与模板的初衷背道相驰;另一方面,类的继承层次可能很庞大,采用以上方式,继承层次的最底层类的负担将会非常大——必须为对象直接或间接继承的每一个基类提供隐式类型转换操作符.      &quot;将nonvirtual member function声明为templates&quot;是C++后来接入的一个性质,使用它可以从根本上解决饮食类型转换的问题,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt; class SmartPtr &#123; public:    SmartPtr(T* realPtr &#x3D; 0);    T* operator-&gt;() const;    T&amp; operator*() const;    template&lt;class newType&gt; &#x2F;&#x2F; 模板成员函数    operator SmartPtr&lt;newType&gt;()     &#123;        return SmartPtr&lt;newType&gt;(pointee);    &#125;    ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      这个成员函数模板将智能指针之间的隐式类型转换交由底层内置指针来完成,保证了指针转换的&quot;原生态&quot;:如果底层指针能够转换,那么包装后的智能指针也能够进行转换.唯一的缺点是它是通过指针之间的隐式类型转换来实现指针的多态,也就是说,它实际上并不能区分对象之间的继承层次,假如扩充MusicProduct的继承体系,加上一个新的CasSingle class,像这样:</code></pre><p><img src="699942-20151006213007737-1835434124.png" alt="img"> </p><p>  那么对于以下代码:</p><p><img src="ContractedBlock.gif" alt="img"> <img src="ExpandedBlockStart.gif" alt="img"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;class SmartPtr &#123; ... &#125;; void displayAndPlay(const SmartPtr&lt;MusicProduct&gt;&amp; pmp,int howMany);void displayAndPlay(const SmartPtr&lt;Cassette&gt;&amp; pc,int howMany);SmartPtr&lt;CasSingle&gt; dumbMusic(new CasSingle(&quot;Achy Breaky Heart&quot;));displayAndPlay(dumbMusic, 1);&#x2F;&#x2F;错误，隐式类型转换函数的调用具有二义性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>  正如之前所言,使用隐式类型转换操作符实现的指针多态并不能区分对象的继承层次,也就是说将SmartPtr&lt;CasSingle&gt;转为SmartPtr&lt;Cassette&gt;&amp;和转为SmartPtr&lt;MusicProduct&gt;&amp;具有同样的优先级,因此造成二义性.而内置指针却能做到这一点,它优先将CasSingle绑定到Cassette&amp;,因为CaSingle直接继承自Cassette.此外,以上策略还有移植性不高的缺点:有些编译器可能并不支持member templates.  对于内置指针,const修饰的含义因其位置而不同:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CD goodCD(&quot;Flood&quot;);const CD *p; &#x2F;&#x2F; p 是一个non-const 指针,指向 const CD 对象CD * const p &#x3D; &amp;goodCD; &#x2F;&#x2F; p 是一个const 指针,指向non-const CD 对象;因为 p 是const,它必须在定义时就被初始化const CD * const p &#x3D; &amp;goodCD; &#x2F;&#x2F; p 是一个const 指针,指向一个 const CD 对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      但对于智能指针,只有一个地方可以放置const,因此cosnt只能施行于指针之上,而不能施行于指针所指对象之上:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const SmartPtr&lt;CD&gt; p&#x3D;&amp;goodCD;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>      要是const修饰所值对象很简单,像这样:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;const CD&gt; p&#x3D;&amp;goodCD;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>      由此方法可以实现和内置指针相同的四种指针:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;CD&gt; p; &#x2F;&#x2F; non-const 对象, non-const 指针SmartPtr&lt;const CD&gt; p; &#x2F;&#x2F; const 对象,non-const 指针const SmartPtr&lt;CD&gt; p &#x3D; &amp;goodCD; &#x2F;&#x2F; non-const 对象,const 指针const SmartPtr&lt;const CD&gt; p &#x3D; &amp;goodCD; &#x2F;&#x2F; const 对象,const 指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre><code>      但这种方法仍有缺陷,正如经由模板包装之后,有继承关系的两个类完全没有关系一样,经由智能指针模板包装后的const和non-const对象完全不同,像这样看起来理所当然的代码通不过编译:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;CD&gt; pCD &#x3D; new CD(&quot;Famous Movie Themes&quot;);SmartPtr&lt;const CD&gt; pConstCD &#x3D; pCD;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>      使用之前的隐式类型转换技术可以顺带解决这个问题,但又有所区别:const与non-const的转换是单向的,即可以对const指针做的事也可以对non-const指针进行,但可以对non-const指针做的事未必可以对const指针进行.这与public继承类似,利用这种性质,令每一个smart pointer-to-T-class public继承一个对应的smart pointer-to-const-T class:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt; &#x2F;&#x2F; 指向const 对象的class SmartPtrToConst &#123;protected:    union &#123;        const T* constPointee; &#x2F;&#x2F; 提供给SmartPtrToConst 访问        T* pointee; &#x2F;&#x2F; 提供给SmartPtr 访问    &#125;;&#125;;template&lt;class T&gt; class SmartPtr: public SmartPtrToConst&lt;T&gt; &#123;public:    template&lt;class constType&gt;    operator SmartPtrToConst&lt;constType&gt;();    ... &#x2F;&#x2F;没有额外数据成员&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>       SmartPtrToConst使用了union,这样constPointee和pointee共享同一块内存SmartPtrToConst使用constPointee,SmartPtr使用pointee.        现在,使用SmartPtrToConst和SmartPtr分别代表指向const和non-const对象的智能指针,以下代码可以通过编译:</code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">SmartPtr&lt;CD&gt; pCD &#x3D; new CD(&quot;Famous Movie Themes&quot;);SmartPtrToConst&lt;CD&gt; pConstCD &#x3D; pCD;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>\8. 从2-7的讨论可以看出,智能指针功能强大,但索要付出的代价也很高,此外,智能指针无论如何也不能完全替代内置指针.当然,尽管内置指针在实现和维护方面需要大量技巧,但与其强大的功能相比在多数情况下还是值得的.</p><h2 id="条款28：引用计数"><a href="#条款28：引用计数" class="headerlink" title="条款28：引用计数"></a>条款28：引用计数</h2><p>​        引用计数是这样一个技巧，它允许多个有相同值的对象共享这个值的实现。这个技巧有两个常用动机。第一个是简化跟踪堆中的对象的过程。一旦一个对象通过调用new被分配出来，最要紧的就是记录谁拥有这个对象，因为其所有者－－并且只有其所有者－－负责对这个对象调用delete。但是，所有权可以被从一个对象传递到另外一个对象（例如通过传递指针型参数），所以跟踪一个对象的所有权是很困难的。象auto_ptr（见Item M9）这样的类可以帮助我们，但经验显示大部分程序还不能正确地得到这样的类。引用计数可以免除跟踪对象所有权的担子，因为当使用引用计数后，对象自己拥有自己。当没人再使用它时，它自己自动销毁自己。因此，引用计数是个简单的垃圾回收体系。</p><p>​        第二个动机是由于一个简单的常识。如果很多对象有相同的值，将这个值存储多次是很无聊的。更好的办法是让所有的对象共享这个值的实现。这么做不但节省内存，而且可以使得程序运行更快，因为不需要构造和析构这个值的拷贝。</p><p>​        和大部分看似简单的主意一样，这个动机也有一个曲折而有趣的细节。在其中必须有一个正确实现的引用计数体系。在开始钻研细节前，让我们掌握一些基础。一个好主意是先着眼于我们将可能如何遇到多个对象有相同的值。这儿有一个：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;                     &#x2F;&#x2F; the standard string type maypublic:                            &#x2F;&#x2F; employ the techniques in this Item, but that is not required  String(const char *value &#x3D; &quot;&quot;);  String&amp; operator&#x3D;(const String&amp; rhs);...private:  char *data;&#125;;String a, b, c, d, e;a &#x3D; b &#x3D; c &#x3D; d &#x3D; e &#x3D; &quot;Hello&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        看起来，对象a到e都有相同的值“Hello”。其值的形态取决于String类是怎么实现的，但通常的实现是每个string对象有一个这个值的拷贝。例如，String的赋值操作可能实现为这样：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String&amp; String::operator&#x3D;(const String&amp; rhs)&#123;  if (this &#x3D;&#x3D; &amp;rhs) return *this;         &#x2F;&#x2F; see Item E17  delete [] data;  data &#x3D;   new char[strlen(rhs.data) + 1];  strcpy(data, rhs.data);  return *this;                           &#x2F;&#x2F; see Item E15&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据这个实现，我们可以推测，这5个对象及其值如下：</p><p> <img src="20191114165634252.png" alt="img"></p><p>其冗余是显然的。在一个理想的世界中，我们希望将上图改为这样：</p><p> <img src="20191114165703168.png" alt="img"></p><p>​        这里，只存储了一个“Hello”的拷贝，所有具有此值的String对象共享其实现。</p><p>​        实际世界中，实现这个主意是不可能的，因为我们需要跟踪多少对象共享同一个值。如果上面的对象a被赋了“Hello”以外的另外一个值，我们不能摧毁值“Hello”，因为还有四个对象需要它。另一方面，如果只有一个对象有“Hello”这个值，当其超出生存空间时，没有对象具有这个值了，我们必须销毁这个值以避免资源泄漏。</p><p>​        保存当前共享/引用同一个值的对象数目的需求意味着我们的那张图必须增加一个计数值（引用计数）：</p><p> <img src="2019111416593759.png" alt="img"></p><p>​        （有些人将其叫作use count，但我不是其中之一。C++有很多它自己的特性，最后需要的一个是专业名词的派别之争。）</p><p>​        创建一个带引用计数的String类并不困难，但需要注意一些细节，所以我们将略述这样一个类的大部分常用成员函数的实现。然而，在开始之前，认识到“我们需要一个地方来存储这个计数值”是很重要的。这个地方不能在String对象内部，因为需要的是每个String值一个引用计数值，而不是每个String对象一个引用计数。这意味着String值和引用计数间是一一对应的关系，所以我们将创建一个类来保存引用计数及其跟踪的值。我们叫这个类StringValue，又因为它唯一的用处就是帮助我们实现String类，所以我们将它嵌套在String类的私有区内。另外，为了便于Sting的所有成员函数读取其数据区，我们将StringValue申明为struct。需要知道的是：将一个struct内嵌在类的私有区内，能便于这个类的所有成员访问这个结构，但阻止了其它任何人对它的访问（当然，除了友元）。</p><p>​        基本设计是这样的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;public:  ... &#x2F;&#x2F; the usual String member&#x2F;&#x2F; functions go hereprivate:  struct StringValue &#123; ... &#125;;        &#x2F;&#x2F; holds a reference count and a string value  StringValue *value;                &#x2F;&#x2F; value of this String&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们可以给这个类起个其它名字（如RCString）以强调它使用了引用计数，但类的实现不该是类的用户必须关心的东西，用户只关心类的公有接口。而我们带引用计数的String版本与不带引用计数的版本，其接口完全相同，所以为什么要用类的名字来把问题搅混呢？真的需要吗？所以我们没有这么做。</p><p>​        这是StringValue的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:struct StringValue &#123;  int refCount;  char *data;  StringValue(const char *initValue); ~StringValue();&#125;;...&#125;;String::StringValue::StringValue(const char *initValue): refCount(1)&#123;  data &#x3D; new char[strlen(initValue) + 1];  strcpy(data, initValue);&#125;String::StringValue::~StringValue()&#123;  delete [] data;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是其所有的一切，很清楚，这不足以实现带引用计数的String类。一则，没有拷贝构造函数和赋值运算；</p><p>​        二则，没有提供对refCount的操作。别担心，少掉的功能将由String类提供。StringValue的主要目的是提供一个空间将一个特别的值和共享此值的对象的数目联系起来。StringValue给了我们这个，这就足够了。</p><p>​        我们现在开始处理String的成员函数。首先是构造函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;public:  String(const char *initValue &#x3D; &quot;&quot;);  String(const String&amp; rhs);  ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        第一个构造函数被实现得尽可能简单。我们用传入的char *字符串创建了一个新的StringValue对象，并将我们正在构造的string对象指向这个新生成的StringValue：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String::String(const char *initValue): value(new StringValue(initValue))&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样的用户代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s(&quot;More Effective C++&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        生成的数据结构是这样的：</p><p> <img src="20191114170009545.png" alt="img"></p><p>​        String对象是独立构造的，有同样初始化值的对象并不共享数据，所以，这样的用户代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s1(&quot;More Effective C++&quot;);String s2(&quot;More Effective C++&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        产生这样的数据结构：</p><p> <img src="2019111417004483.png" alt="img"></p><p>​        消除这样的副本是可能的：通过让String（或StringValue）对象跟踪已存在的StringValue对象，并只在是不同串时才创建新的对象。但这样的改进有些偏离目标。于是，我将它作为习题留给读者。</p><p>​        String的拷贝构造函数很高效：新生成的String对象与被拷贝的对象共享相同的StringValue对象：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String::String(const String&amp; rhs): value(rhs.value)&#123;  ++value-&gt;refCount;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s1(&quot;More Effective C++&quot;);String s2 &#x3D; s1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>产生这样的数据结构：</p><p> <img src="2019111417004483-168517039708711.png" alt="img"></p><p>​        这肯定比通常的（不带引用计数的）string类高效，因为不需要为新生成的string值分配内存、释放内存以及将内容拷贝入这块内存。现在，我们只不过是拷贝了一个指针并增加了一次引用计数。</p><p>​        String类的析构函数同样容易实现，因为大部分情况下它不需要做任何事情。只要引用计数值不是0，也就是至少有一个String对象使用这个值，这个值就不可以被销毁。只有当唯一的使用者被析构了（也就是引用计数在进入函数前已经为1时），String的析构函数才摧毁StringValue对象：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;public:  ~String();  ...&#125;;String::~String()&#123;  if (--value-&gt;refCount &#x3D;&#x3D; 0) &#123;      delete value;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        和没有引用计数的版本比较一下效率。那样的函数总调用delete，当然会有一个相当程度的运行时间的代价。现在提供的String对象们实际上有时具有相同的值，上面的这个实现在此时只需要做一下减少引用计数并与0进行比较。</p><p>​        如果在这个问题上引用计数没有向外界表现出来，你就根本不需要花注意力。</p><p>​        这就是String的构造和析构，我们现在转到赋值操作：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;public:  String&amp; operator&#x3D;(const String&amp; rhs);  ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        当用户写下这样的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">s1 &#x3D; s2;                              &#x2F;&#x2F; s1 and s2 are both String objects<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        其结果应该是s1和s2指向相同的StringValue对象。对象的引用计数应该在赋值时被增加。并且，s1原来指向的StringValue对象的引用计数应该减少，因为s1不再具有这个值了。如果s1是拥有原来的值的唯一对象，这个值应该被销毁。在C++中，其实现看起来是这样的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String&amp; String::operator&#x3D;(const String&amp; rhs)&#123;  if (value &#x3D;&#x3D; rhs.value)     &#123;         &#x2F;&#x2F; do nothing if the values    return *this;                    &#x2F;&#x2F; are already the same; this&#125;                                     &#x2F;&#x2F; subsumes the usual test of&#x2F;&#x2F; this against &amp;rhs (see Item E17)  if (--value-&gt;refCount &#x3D;&#x3D; 0)     &#123;      &#x2F;&#x2F; destroy *this&#39;s value if    delete value;                    &#x2F;&#x2F; no one else is using it&#125;  value &#x3D; rhs.value;                 &#x2F;&#x2F; have *this share rhs&#39;s  ++value-&gt;refCount;                 &#x2F;&#x2F; value  return *this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        围绕我们的带引用计数的String类，考虑一下数组下标操作（[]），它允许字符串中的单个字符被读或写：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;public:  const char&amp;    operator[](int index) const;       &#x2F;&#x2F; for const Strings  char&amp; operator[](int index);           &#x2F;&#x2F; for non-const Strings...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个函数的const版本的实现很容易，因为它是一个只读操作，String对象的值不受影响：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const char&amp; String::operator[](int index) const&#123;  return value-&gt;data[index];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​    （这个函数实现了C++传统意义上的下标索引（根本不会说“不”）。如果你想加上参数检查，这是非常容易的。）</p><p>非const的operator[]版本就是一个完全不同的故事了。它可能是被调用了来读一个字符，也可能被调用了来写一个字符：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s;...cout &lt;&lt; s[3];                        &#x2F;&#x2F; this is a reads[5] &#x3D; &#39;x&#39;;                          &#x2F;&#x2F; this is a write<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们希望以不同的方式处理读和写。简单的读操作，可以用与const的operator[]类似的方式实现，而写操作必须用完全不同的方式来实现。</p><p>​        当我们修改一个String对象的值时，必须小心防止修改了与它共享相同StringValue对象的其它String对象的值。不幸的是，C++编译器没有办法告诉我们一个特定的operator[]是用作读的还是写的，所以我们必须保守地假设“所有”调用非const operator[]的行为都是为了写操作。（Proxy类可以帮助我们区分读还是写，见Item M30。）</p><p>​        为了安全地实现非const的operator[]，我们必须确保没有其它String对象在共享这个可能被修改的StringValue对象。简而言之，当我们返回StringValue对象中的一个字符的引用时，必须确保这个StringValue的引用计数是1。这儿是我们的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char&amp; String::operator[](int index)&#123;  &#x2F;&#x2F; if we&#39;re sharing a value with other String objects,  &#x2F;&#x2F; break off a separate copy of the value for ourselves  if (value-&gt;refCount &gt; 1) &#123;    --value-&gt;refCount;                    &#x2F;&#x2F; decrement current value&#39;srefCount, because we won&#39;t be using that value any more    value &#x3D;                               &#x2F;&#x2F; make a copy of the      new StringValue(value-&gt;data);       &#x2F;&#x2F; value for ourselves  &#125;  &#x2F;&#x2F; return a reference to a character inside our  &#x2F;&#x2F; unshared StringValue object  return value-&gt;data[index];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个“与其它对象共享一个值直到写操作时才拥有自己的拷贝”的想法在计算机科学中已经有了悠久而著名的历史了，尤其是在操作系统中：进程共享内存页直到它们想在自己的页拷贝中修改数据为止。这个技巧如此常用，以至于有一个名字：写时拷贝。它是提高效率的一个更通用方法－－缓式评估原则－－的特例。</p><p>​        大部分情况下，写时拷贝可以同时保证效率和正确性。只有一个挥之不去的问题。看一下这样的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s1 &#x3D; &quot;Hello&quot;;char *p &#x3D; &amp;s1[1];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数据结构是这样的：</p><p> <img src="20191114170147593.png" alt="img"></p><p>​        现在看增加一条语句：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String s2 &#x3D; s1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        String的拷贝构造函数使得s2共享s1的StringValue对象，所以数据结构将是：</p><p> <img src="20191114170246431.png" alt="img"></p><p>​        下面这样的语句将有不受欢迎的结果：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">*p &#x3D; &#39;x&#39;;                     &#x2F;&#x2F; modifies both s1 and s2!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        String的拷贝构造函数没有办法检测这样的问题，因为它不知道指向s1拥有的StringValue对象的指针的存在。并且，这个问题不局限于指针：它同样存在于有人保存了一个String的非const operator[]的返回值的引用的情况下。</p><p>​        至少有三种方法来应付这个问题。第一个是忽略它，假装它不存在。这是实现带引用计数的String类的类库中令人痛苦的常见问题。如果你有带引用计数的String类，试一下上面的例子，看你是否很痛苦。即使你不能确定你操作的是否是带引用计数的String类，也无论如何应该试一下这个例子。由于封装，你可能使用了一个这样的类型而不自知。</p><p>​        不是所以的实现都忽略这个问题。稍微好些的方法是明确说明它的存在。通常是将它写入文档，或多或少地说明“别这么做。如果你这么做了，结果为未定义。”无论你以哪种方式这么做了（有意地或无意地），并抱怨其结果时，他们辩解道：“好了，我们告诉过你别这么做的。”这样的实现通常很方便，但它们在可用性方面留下了太多的期望。</p><p>​        第三个方法是排除这个问题。它不难实现，但它将降低一个值共享于对象间的次数。它的本质是这样的：在每个StringValue对象中增加一个标志以指出它是否为可共享的。在最初（对象可共享时）将标志打开，在非const的operator[]被调用时将它关闭。一旦标志被设为false，它将永远保持在这个状态（注10）。</p><p>​        这是增加了共享标志的修改版本：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:  struct StringValue &#123;    int refCount;    bool shareable;                &#x2F;&#x2F; add this        char *data;        StringValue(const char *initValue);       ~StringValue();  &#125;;...&#125;;String::StringValue::StringValue(const char *initValue):refCount(1),shareable(true)                &#x2F;&#x2F; add this&#123;  data &#x3D; new char[strlen(initValue) + 1];  strcpy(data, initValue);&#125;String::StringValue::~StringValue()&#123;  delete [] data;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如你所见，并不需要太多的改变；需要修改的两行都有注释。当然，String的成员函数也必须被修改以处理这个共享标志。这里是拷贝构造函数的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String::String(const String&amp; rhs)&#123;  if (rhs.value-&gt;shareable) &#123;    value &#x3D; rhs.value;    ++value-&gt;refCount;  &#125;  else &#123;    value &#x3D; new StringValue(rhs.value-&gt;data);  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        所有其它的成员函数也都必须以类似的方法检查这个共享标志。非const的operator[]版本是唯一将共享标志设为false的地方：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char&amp; String::operator[](int index)&#123;  if (value-&gt;refCount &gt; 1) &#123;    --value-&gt;refCount;value &#x3D; new StringValue(value-&gt;data);  &#125;  value-&gt;shareable &#x3D; false;           &#x2F;&#x2F; add this  return value-&gt;data[index];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果使用Item M30中的proxy类的技巧以区分读写操作，你通常可以降低必须被设为不可共享的StringValue对象的数目。</p><p>​        引用计数不只用在字符串类上，只要是多个对象具有相同值的类都可以使用引用计数。改写一个类以获得引用计数需要大量的工作，而我们已经有太的工作需要做了。这样不好吗：如果我们将引用计数的代码写成与运行环境无关的，并能在需要时将它嫁接到其它类上？当然很好。很幸运，有一个方法可以实现它（至少完成了绝大部分必须的工作）。</p><p>​        第一步是构建一个基类RCObject，任何需要引用计数的类都必须从它继承。RCObject封装了引用计数功能，如增加和减少引用计数的函数。它还包含了当这个值不再被需要时摧毁值对象的代码（也就是引用计数为0时）。最后，它包含了一个字段以跟踪这个值对象是否可共享，并提供查询这个值和将它设为false的函数。不需将可共享标志设为true的函数，因为所有的值对象默认都是可共享的。如上面说过的，一旦一个对象变成了不可共享，将没有办法使它再次成为可共享。</p><p>​        RCObject的定义如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class RCObject &#123;public:  RCObject();  RCObject(const RCObject&amp; rhs);  RCObject&amp; operator&#x3D;(const RCObject&amp; rhs); virtual ~RCObject() &#x3D; 0;  void addReference();  void removeReference();void markUnshareable();bool isShareable() const;bool isShared() const;private:int refCount;bool shareable;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        RCObjcet可以被构造（作为派生类的基类部分）和析构；可以有新的引用加在上面以及移除当前引用；其可共享性可以被查询以及被禁止；它们可以报告当前是否被共享了。这就是它所提供的功能。对于想有引用计数的类，这确实就是我们所期望它们完成的东西。注意虚析构函数，它明确表明这个类是被设计了作基类使用的（见Item E14）。同时要注意这个析构函数是纯虚的，它明确表明这个类只能作基类使用。</p><p>​        RCOject的实现代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">RCObject::RCObject(): refCount(0), shareable(true) &#123;&#125;RCObject::RCObject(const RCObject&amp;): refCount(0), shareable(true) &#123;&#125;RCObject&amp; RCObject::operator&#x3D;(const RCObject&amp;)&#123;     return *this; &#125;RCObject::~RCObject() &#123;&#125;               &#x2F;&#x2F; virtual dtors must always                                       &#x2F;&#x2F; be implemented, even if                                           &#x2F;&#x2F; they are pure virtual                                           &#x2F;&#x2F; and do nothing (see also                                           &#x2F;&#x2F; Item M33 and Item E14)void RCObject::addReference() &#123;    ++refCount; &#125;void RCObject::removeReference()&#123;       if (--refCount &#x3D;&#x3D; 0)        delete this; &#125;void RCObject::markUnshareable()&#123;     shareable &#x3D; false; &#125;bool RCObject::isShareable() const&#123;     return shareable; &#125;bool RCObject::isShared() const&#123;     return refCount &gt; 1; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可能很奇怪，我们在所有的构造函数中都将refCount设为了0。这看起来违反直觉。确实，最少，构造这个RCObject对象的对象引用它！在它构造后，只需构造它的对象简单地将refCount设为1就可以了，所以我们没有将这个工作放入RCObject内部。这使得最终的代码看起来很简短。</p><p>​        另一个奇怪之处是拷贝构造函数也将refCount设为0，而不管被拷贝的RCObject对象的refCount的值。这是因为我们正在构造新的值对象，而这个新的值对象总是未被共享的，只被它的构造者引用。再一次，构造者负责将refCount设为正确的值。</p><p>​        RCObject的赋值运算看起来完全出乎意料：它没有做任何事情。这个函数不太可能被调用的。RCObject是基于引用计数来共享的值对象的基类，它不该被从一个赋给另外一个，而应该是拥有这个值的对象被从一个赋给另外一个。在我们这个设计里，我们不期望StringValue对象被从一个赋给另外一个，我们期望在赋值过程中只有String对象被涉及。在String参与的赋值语句中，StringValue的值没有发生变化，只是它的引用计数被修改了。</p><p>​        不过，可以想象，一些还没有写出来的类在将来某天可能从RCObject派生出来，并希望允许被引用计数的值被赋值（见Item M23和Item E16）。如果这样的话，RCObject的赋值操作应该做正确的事情，而这个正确的事情就是什么都不做。想清楚了吗？假设我们希望允许在StringValue对象间赋值。对于给定的StringValue对象sv1和sv2，在赋值过程中，它们的引用计数值上发生什么？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">sv1 &#x3D; sv2;                    &#x2F;&#x2F; how are sv1&#39;s and sv2&#39;s reference counts affected?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在赋值之前，已经有一定数目的String对象指向sv1。这个值在赋值过程中没有被改变，因为只是sv1的值被改变了。同样的，一定数目的String对象在赋值之前指向前v2，在赋值后，同样数目的对象指向sv2。sv2的引用计数同样没有改变。当RCObject在赋值过程中被涉及时，指向它的对象的数目没有受影响，因此RCObject::operator=不应该改变引用计数值。上面的实现是正确的。违反直觉？可能吧，但它是正确的。</p><p>​        RCObject::removeReference的代码不但负责减少对象的refCount值，还负责当refCount值降到0时析构对象。后者是通过delete this来实现的，如Item M27中解释的，这只当我们知道*this是一个堆对象时才安全。要让这个类正确，我们必须确保RCObject只能被构建在堆中。实现这一点的常用方法见Item M27，但我们这次采用一个特别的方法，这将在本条款最后讨论。</p><p>​        为了使用我们新写的引用计数基类，我们将StringValue修改为是从RCObject继承而得到引用计数功能的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:  struct StringValue: public RCObject &#123;    char *data;    StringValue(const char *initValue);        ~StringValue();&#125;;...&#125;;String::StringValue::StringValue(const char *initValue)&#123;  data &#x3D; new char[strlen(initValue) + 1]; strcpy(data, initValue);&#125;String::StringValue::~StringValue()&#123;  delete [] data;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个版本的StringValue和前面的几乎一样，唯一改变的就是StringValue的成员函数不再处理refCount字段。RCObject现在接管了这个工作。</p><p>​        不用感觉不舒服，如果你注意到嵌套类（StringValue）从一个与包容类（String）无关的类（RCObject）继承而来的话。它第一眼看上去是有些古怪，但完全合理。嵌套类和其它类是完全相同的，所以它有自由从它喜欢的任何其它类继承。以后，你不用第二次思考这种继承关系了。   </p><p>​        RCObject类给了我们一个存储引用计数的地方，并提供了成员函数供我们操作引用计数，但调用这些函数的动作还必须被手工加入其它类中。仍然需要在String的拷贝构造函数和赋值运算函数中调用StringValue的addReference和 removeReference函数。这很笨拙。我们想将这些调用也移入一个可重用的类中，以使得String这样的类的作者不用再担心引用计数的任何细节。能实现吗？C++支持这样的重用吗？</p><p>​        能。没有一个简单的方法将所有引用计数方面的工作从所有的类中移出来；但有一个方法可以从大部分类中将大部分工作移出来。（在一些类中，你可以消除所有引用计数方面的代码，但我们的String类不是其中之一。有一个成员函数搞坏了这件事，我希望你别吃惊，它是我们的老对头：非const版本的operator[]。别放心上，我们最终制服了这家伙。）</p><p>​        每个String对象包含一个指针指向StringValue对象：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:  struct StringValue: public RCObject &#123; ... &#125;;  StringValue *value;                &#x2F;&#x2F; value of this String  ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们必须操作StringValue对象的refCount字段，只要任何时候任一个指向它的指针身上发生了任何有趣的事件。“有趣的事件”包括拷贝指针、给指针赋值和销毁指针。如果我们能够让指针自己检测这些事件并自动地执行对refCount字段的必须操作，那么我们就自由了。不幸的是，指针功能很弱，对任何事情作检测并作出反应都是不可能的。还好，有一个办法来增强它们：用行为类似指针的对象替代它们，但那样要多做很多工作了。</p><p>​        这样的对象叫灵巧指针，你可以在Item M28这看到它的更多细节。就我们这儿的用途，只要知道这些就足够了：灵巧指针对象支持成员选择（-&gt;）和反引用（*）这两个操作符，就象真的指针一样，并和内建指针一样是强类型的：你不能将一个指向T的灵巧指针指向一个非T类型的对象。</p><p>​        这儿是供引用计数对象使用的灵巧指针模板：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; template class for smart pointers-to-T objects. T must&#x2F;&#x2F; support the RCObject interface, typically by inheriting&#x2F;&#x2F; from RCObjecttemplate&lt;class T&gt;class RCPtr &#123;public:  RCPtr(T* realPtr &#x3D; 0);  RCPtr(const RCPtr&amp; rhs);  ~RCPtr();  RCPtr&amp; operator&#x3D;(const RCPtr&amp; rhs);  T* operator-&gt;() const;            &#x2F;&#x2F; see Item 28  T&amp; operator*() const;             &#x2F;&#x2F; see Item 28private:  T *pointee;                       &#x2F;&#x2F; dumb pointer this                                    &#x2F;&#x2F; object is emulating  void init();                      &#x2F;&#x2F; common initialization&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个模板让灵巧指针对象控制在构造、赋值、析构时作什么操作。当这些事件发生时，这些对象可以自动地执行正确的操作来处理它们指向的对象的refCount字段。</p><p>​        例如，当一个RCPtr构建时，它指向的对象需要增加引用计数值。现在不需要程序员手工处理这些细节了，因为RCPtr的构造函数自己处理它。两个构造函数几乎相同，除了初始化列表上的不同，为了不写两遍，我们将它放入一个名为init的私有成员函数中供二者调用：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;RCPtr&lt;T&gt;::RCPtr(T* realPtr): pointee(realPtr)&#123;  init();&#125;template&lt;class T&gt;RCPtr&lt;T&gt;::RCPtr(const RCPtr&amp; rhs): pointee(rhs.pointee)&#123;  init();&#125;template&lt;class T&gt;void RCPtr&lt;T&gt;::init()&#123;  if (pointee &#x3D;&#x3D; 0) &#123;                &#x2F;&#x2F; if the dumb pointer is    return;                          &#x2F;&#x2F; null, so is the smart one  &#125;if (pointee-&gt;isShareable() &#x3D;&#x3D; false) &#123;           &#x2F;&#x2F; if the value    pointee &#x3D; new T(*pointee);                   &#x2F;&#x2F; isn&#39;t shareable,  &#125;                                              &#x2F;&#x2F; copy itpointee-&gt;addReference();             &#x2F;&#x2F; note that there is now a&#125;                                    &#x2F;&#x2F; new reference to the value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        将相同的代码移入诸如init这样的一个独立函数是很值得效仿的，但它现在暗淡无光，因为在此处，这个函数的行为不正确。</p><p>​        问题是这个：当init需要创建value的一个新拷贝时（因为已存在的拷贝处于不可共享状态），它执行下面的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">pointee &#x3D; new T(*pointee);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        pointee的类型是指向T的指针,所以这一语句构建了一个新的T对象，并用拷贝构造函数进行了初始化。由于RCPtr是在String类内部，T将是String::StringValue，所以上面的语句将调用String::StringValue的拷贝构造函数。我们没有为这个类申明拷贝构造函数，所以编译器将为我们生成一个。这个生成的拷贝构造函数遵守C++的自动生成拷贝构造函数的原则，只拷贝了StringValue的数据pointer，而没有拷贝所指向的char *字符串。这样的行为对几乎任何类（而不光是引用计数类）都是灾难，这就是为什么你应该养成为所有含有指针的类提供拷贝构造函数（和赋值运算）的习惯（见Item E11）。</p><p>​        RCPtr<T>模板的正确行为取决于T含有正确的值拷贝行为（如深拷贝）的拷贝构造函数。我们必须在StringValue中增加这样的一个构造函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:  struct StringValue: public RCObject &#123;    StringValue(const StringValue&amp; rhs);    ...  &#125;;  ...&#125;;String::StringValue::StringValue(const StringValue&amp; rhs)&#123;  data &#x3D; new char[strlen(rhs.data) + 1];  strcpy(data, rhs.data);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        深拷贝的构造函数的存在不是RCPtr<T>的唯一假设。它还要求T从RCObject继承，或至少提供了RCObject的所提供的函数。事实上由于RCPtr对象只是被设计了指向引用计数对象的，这个假设并不过分。不过，这个假设必须被明确写入文档。</p><p>​        RCPtr<T>的最后一个假设是它所指向的对象类型为T。这似乎是显然的。毕竟，pointee的类型被申明为T*。但pointee可能实际上指向T的一个派生类。例如，如果我们有一个类SpecialStringValue是从String::StringValue继承的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class String &#123;private:  struct StringValue: public RCObject &#123; ... &#125;;  struct SpecialStringValue: public StringValue &#123; ... &#125;;  ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以生成一个String，包容的RCPtr<StringValue>指向一个SpecialStringValue对象。这时，我们希望init的这句：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">pointee &#x3D; new T(*pointee);                &#x2F;&#x2F; T is StringValue, but pointee really points to a SpecialStringValue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        调用的是SpecialStringValue的拷贝构造函数，而不是StringValue的拷贝构造函数。我们可以提供使用虚拷贝构造函数（见Item M25）来实现这一点。对于我们的String类，我们不期望从StringValue派生子类，所以我们忽略这个问题。</p><p>​        用这种方式实现了RCPtr的构造函数后，类的其它函数实现得很轻快。赋值运算很简洁明了，虽然“需要测试源对象的可共享状态”将问题稍微复杂化了。幸好，同样的问题已经在我们为构造函数写的init函数中处理了。我们可以爽快地再度使用它：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::operator&#x3D;(const RCPtr&amp; rhs)&#123;  if (pointee !&#x3D; rhs.pointee)    &#123;              &#x2F;&#x2F; skip assignments， where the value doesn&#39;t changeif (pointee) &#123;  pointee-&gt;removeReference();        &#x2F;&#x2F; remove reference to&#125;                                    &#x2F;&#x2F; current valuepointee &#x3D; rhs.pointee;               &#x2F;&#x2F; point to new valueinit();                              &#x2F;&#x2F; if possible, share it  &#125;                                      &#x2F;&#x2F; else make own copy  return *this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>析构函数很容易。当一个RCPtr被析构时，它只是简单地将它对引用计数对象的引用移除：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;RCPtr&lt;T&gt;::~RCPtr()&#123;  if (pointee)pointee-&gt;removeReference();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果这个RCPtr是最后一个引用它的对象，这个对象将在RCObject的成员函数removeReference中被析构。因此，RCPtr对象无需关心销毁它们指向的值的问题。</p><p>​        最后，RCPtr的模拟指针的操作就是你在Item M28中看到的灵巧指针的部分：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;T* RCPtr&lt;T&gt;::operator-&gt;() const &#123; return pointee; &#125;template&lt;class T&gt;T&amp; RCPtr&lt;T&gt;::operator*() const &#123; return *pointee; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        够了！完结！最后，我们将各个部分放在一起，构造一个基于可重用的RCObject和RCPtr类的带引用计数的String类。或许，你还没有忘记这是我们的最初目标。</p><p>​        每个带引用计数的Sting对象被实现为这样的数据结构：</p><p>类的定义是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;                       &#x2F;&#x2F; template class for smartclass RCPtr &#123;                           &#x2F;&#x2F; pointers-to-T objects; Tpublic:                                 &#x2F;&#x2F; must inherit from RCObject  RCPtr(T* realPtr &#x3D; 0);  RCPtr(const RCPtr&amp; rhs);  ~RCPtr();  RCPtr&amp; operator&#x3D;(const RCPtr&amp; rhs);  T* operator-&gt;() const;  T&amp; operator*() const;private:  T *pointee;  void init();&#125;;class RCObject &#123;                       &#x2F;&#x2F; base class for reference-public:                                &#x2F;&#x2F; counted objects  void addReference();  void removeReference();  void markUnshareable();  bool isShareable() const;  bool isShared() const;protected:  RCObject();  RCObject(const RCObject&amp; rhs);  RCObject&amp; operator&#x3D;(const RCObject&amp; rhs);  virtual ~RCObject() &#x3D; 0;private:  int refCount;  bool shareable;&#125;;class String &#123;                           &#x2F;&#x2F; class to be used bypublic:                                  &#x2F;&#x2F; application developers  String(const char *value &#x3D; &quot;&quot;);  const char&amp; operator[](int index) const;  char&amp; operator[](int index);private:  &#x2F;&#x2F; class representing string values  struct StringValue: public RCObject &#123;    char *data;StringValue(const char *initValue);StringValue(const StringValue&amp; rhs);void init(const char *initValue);~StringValue();  &#125;;  RCPtr&lt;StringValue&gt; value;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        绝大部分都是我们前面写的代码的翻新，没什么奇特之处。仔细检查后发现，我们在String::StringValue中增加了一个init函数，但，如我们下面将看到的，它的目的和RCPtr中的相同：消除构造函数中的重复代码。</p><p>​        这里有一个重大的不同：这个String类的公有接口和本条款开始处我们使用的版本不同。拷贝构造函数在哪里？赋值运算在哪里？析构函数在哪里？这儿明显有问题。</p><p>​        实际上，没问题。它工作得很好。如果你没看出为什么，需要重学C++了（prepare yourself for a C++ epiphany）。</p><p>​        我们不再需要那些函数了！确实，String对象的拷贝仍然被支持，并且，这个拷贝将正确处理藏在后面的被引用计数的StringValue对象，但String类不需要写下哪怕一行代码来让它发生。因为编译器为String自动生成的拷贝构造函数将自动调用其RCPtr成员的拷贝构造函数，而这个拷贝构造函数完成所有必须的对StringValue对象的操作，包括它的引用计数。RCPtr是一个灵巧指针，所以这是它将完成的工作。它同样处理赋值和析构，所以String类同样不需要写出这些函数。我们的最初目的是将不可重用的引用计数代码从我们自己写的String类中移到一个与运行环境无关的类中以供任何其它类使用。现在，我们完成了这一点（用RCObject和RCPtr两个类），所以当它突然开始工作时别惊奇。它本来就应该能工作的。</p><p>​        将所以东西放在一起，这儿是RCObject的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">RCObject::RCObject(): refCount(0), shareable(true) &#123;    &#125;RCObject::RCObject(const RCObject&amp;): refCount(0), shareable(true) &#123;    &#125;RCObject&amp; RCObject::operator&#x3D;(const RCObject&amp;)&#123;     return *this; &#125;RCObject::~RCObject() &#123;&#125;void RCObject::addReference() &#123;     ++refCount; &#125;void RCObject::removeReference()&#123;     if (--refCount &#x3D;&#x3D; 0) delete this; &#125;void RCObject::markUnshareable()&#123;     shareable &#x3D; false;&#125;bool RCObject::isShareable() const&#123;     return shareable; &#125;bool RCObject::isShared() const&#123;    return refCount &gt; 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是RCPtr的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;void RCPtr&lt;T&gt;::init()&#123;  if (pointee &#x3D;&#x3D; 0)       return;  if (pointee-&gt;isShareable() &#x3D;&#x3D; false)   &#123;    pointee &#x3D; new T(*pointee);  &#125;  pointee-&gt;addReference();&#125;template&lt;class T&gt;RCPtr&lt;T&gt;::RCPtr(T* realPtr): pointee(realPtr)&#123; init(); &#125;template&lt;class T&gt;RCPtr&lt;T&gt;::RCPtr(const RCPtr&amp; rhs): pointee(rhs.pointee)&#123; init(); &#125;template&lt;class T&gt;RCPtr&lt;T&gt;::~RCPtr()&#123; if (pointee)pointee-&gt;removeReference(); &#125;template&lt;class T&gt;RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::operator&#x3D;(const RCPtr&amp; rhs)&#123;  if (pointee !&#x3D; rhs.pointee)     &#123;    if (pointee)         &#123;            pointee-&gt;removeReference();        &#125;pointee &#x3D; rhs.pointee;init();  &#125;return *this;&#125;template&lt;class T&gt;T* RCPtr&lt;T&gt;::operator-&gt;() const &#123; return pointee; &#125;template&lt;class T&gt;T&amp; RCPtr&lt;T&gt;::operator*() const &#123; return *pointee; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是String::StringValue的实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void String::StringValue::init(const char *initValue)&#123;  data &#x3D; new char[strlen(initValue) + 1];  strcpy(data, initValue);&#125;String::StringValue::StringValue(const char *initValue)&#123;     init(initValue); &#125;String::StringValue::StringValue(const StringValue&amp; rhs)&#123;     init(rhs.data); &#125;String::StringValue::~StringValue()&#123;     delete [] data; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，归结到String，它的实现是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">String::String(const char *initValue): value(new StringValue(initValue)) &#123;&#125;const char&amp; String::operator[](int index) const&#123;     return value-&gt;data[index]; &#125;char&amp; String::operator[](int index)&#123;  if (value-&gt;isShared()) &#123;    value &#x3D; new StringValue(value-&gt;data);  &#125; value-&gt;markUnshareable();  return value-&gt;data[index];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果你将它和我们用内建指针实现的版本相比较，你会受到两件事的打击。第一，代码有很多的减少。因为RCPtr完成了大量以前在String内部完成的处理引用计数的担子。第二，剩下的代码几乎没有变化：灵巧指针无缝替换了内建指针。实际上，唯一的变化是在operator[]里，我们用调用isShared函数代替了直接检查refCount的值，并用灵巧指针RCPtr对象消除了写时拷贝时手工维护引用计数值的工作。</p><p>​        这当然全都很漂亮。谁能反对减少代码？谁能反对成功的封装？然而，这个全新的String类本身对用户的冲击远胜过它的实现细节，这才是真正的闪光点。如果没有什么消息是好消息的话，这本身就是最好的消息。String的接口没有改变！我们增加了引用计数，我们增加了标记某个String的值为不可共享的能力，我们将引用计数功能移入一个新类，我们增加了灵巧指针来自动处理引用计数，但用户的一行代码都不需要修改。当然，我们改变了String类的定义，所以用户需要重新编译和链接，但他们在自己代码上的投资受到了完全的保护。你看到了吗？封装确实是个很好的东西。</p><p>​        到现在为止，我们所讨论的都假设我们能够访问有关类的源码。但如果我们想让一个位于支撑库中而无法修改的类获得引用计数的好处呢？不可能让它们从RCObject继承的，所以也不能对它们使用灵巧指针RCPtr。我们运气不好吗？</p><p>​        不是的。只要对我们的设计作小小的修改，我们就可以将引用计数加到任意类型上。</p><p>​        首先考虑如果从RCObject继承的话，我们的设计看起来将是什么样子。在这种情况下，我们需要增加一个类RCWidget以供用户使用，而所有的事情都和String/StringValue的例子一样，RCWidget和String相同，Widget和StringValue相同。设计看起来是这样的：</p><p>​        <strong>我们现在可以应用这句格言：计算机科学中的绝大部分问题都可以通过增加一个中间层次来解决。</strong>我们增加一个新类CountHolder以处理引用计数，它从RCObject继承。我们让CountHolder包含一个指针指向Widget。然后用等价的灵巧指针RCIPter模板替代RCPtr模板，它知道CountHolder类的存在。（名字中的“i”表示间接“indirect”。）修改后的设计为：</p><p>​        如同StringValue一样，CountHolder对用户而言，是RCWidget的实现细节。实际上，它是RCIPtr的实现细节，所以它嵌套在这个类中。RCIPtr的实现如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;class RCIPtr &#123;public:  RCIPtr(T* realPtr &#x3D; 0);  RCIPtr(const RCIPtr&amp; rhs);  ~RCIPtr();  RCIPtr&amp; operator&#x3D;(const RCIPtr&amp; rhs);  const T* operator-&gt;() const;               &#x2F;&#x2F; see below for an  T* operator-&gt;();                           &#x2F;&#x2F; explanation of why  const T&amp; operator*() const;                &#x2F;&#x2F; these functions are  T&amp; operator*();                            &#x2F;&#x2F; declared this wayprivate:  struct CountHolder: public RCObject   &#123;    ~CountHolder() &#123;        delete pointee;     &#125;    T *pointee;  &#125;;  CountHolder *counter;  void init();  void makeCopy();                                &#x2F;&#x2F; see below&#125;;template&lt;class T&gt;void RCIPtr&lt;T&gt;::init()&#123;  if (counter-&gt;isShareable() &#x3D;&#x3D; false)  &#123;    T *oldValue &#x3D; counter-&gt;pointee;counter &#x3D; new CountHolder;counter-&gt;pointee &#x3D; new T(*oldValue); &#125;  counter-&gt;addReference();&#125;template&lt;class T&gt;RCIPtr&lt;T&gt;::RCIPtr(T* realPtr): counter(new CountHolder)&#123;  counter-&gt;pointee &#x3D; realPtr;  init();&#125;template&lt;class T&gt;RCIPtr&lt;T&gt;::RCIPtr(const RCIPtr&amp; rhs): counter(rhs.counter)&#123;     init();&#125;template&lt;class T&gt;RCIPtr&lt;T&gt;::~RCIPtr()&#123;     counter-&gt;removeReference(); &#125;template&lt;class T&gt;RCIPtr&lt;T&gt;&amp; RCIPtr&lt;T&gt;::operator&#x3D;(const RCIPtr&amp; rhs)&#123;  if (counter !&#x3D; rhs.counter)     &#123;    counter-&gt;removeReference();     counter &#x3D; rhs.counter; init();  &#125;  return *this;&#125;template&lt;class T&gt;                          &#x2F;&#x2F; implement the copyvoid RCIPtr&lt;T&gt;::makeCopy()                 &#x2F;&#x2F; part of copy-on-&#123;                                          &#x2F;&#x2F; write (COW)  if (counter-&gt;isShared())   &#123;    T *oldValue &#x3D; counter-&gt;pointee;counter-&gt;removeReference();counter &#x3D; new CountHolder;counter-&gt;pointee &#x3D; new T(*oldValue);counter-&gt;addReference();    &#125;    &#125;template&lt;class T&gt;                           &#x2F;&#x2F; const access;const T* RCIPtr&lt;T&gt;::operator-&gt;() const      &#x2F;&#x2F; no COW needed&#123;    return counter-&gt;pointee; &#125;template&lt;class T&gt;                           &#x2F;&#x2F; non-constT* RCIPtr&lt;T&gt;::operator-&gt;()                  &#x2F;&#x2F; access; COW&#123;     makeCopy();     return counter-&gt;pointee; &#125;    &#x2F;&#x2F; neededtemplate&lt;class T&gt;                           &#x2F;&#x2F; const access;const T&amp; RCIPtr&lt;T&gt;::operator*() const       &#x2F;&#x2F; no COW needed&#123;     return *(counter-&gt;pointee);&#125;template&lt;class T&gt;                           &#x2F;&#x2F; non-constT&amp; RCIPtr&lt;T&gt;::operator*()                   &#x2F;&#x2F; access; do the&#123;    makeCopy();     return *(counter-&gt;pointee); &#125; &#x2F;&#x2F; COW thing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        RCIPtr与RCPtr只两处不同。第一，RCPtr对象直接指向值对象，而RCIptr对象通过中间层的CountHolder对象指向值对象。第二，RCIPtr重载了operator-&gt;和operator*，当有对被指向的对象的非const的操作时，写时拷贝自动被执行。</p><p>​        有了RCIPtr，很容易实现RCWidget，因为RCWidget的每个函数都是将调用传递给RCIPtr以操作Widget对象。举个例子，如果Widget是这样的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Widget &#123;public:  Widget(int size);  Widget(const Widget&amp; rhs);  ~Widget();  Widget&amp; operator&#x3D;(const Widget&amp; rhs);  void doThis();  int showThat() const;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        那么RCWidget将被定义为这样：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class RCWidget &#123;public:  RCWidget(int size): value(new Widget(size)) &#123;&#125;  void doThis() &#123; value-&gt;doThis(); &#125;  int showThat() const &#123; return value-&gt;showThat(); &#125;private:  RCIPtr&lt;Widget&gt; value;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意RCWidget的构造函数是怎么用它被传入的参数调用Widget的构造函数的（通过new操作符，见Item M8）；RCWidget的doThis怎么调用Widget的doThis函数的；以及RCWidget的showThat怎么返回Widget的showThat的返回值的。同样要注意RCWidget没有申明拷贝构造函数和赋值操作函数，也没有析构函数。如同String类一样，它不需要这些函数。感谢于RCIPtr的行为，RCWidget的默认版本将完成正确的事情。</p><p>​        如果认为生成RCWidget的行为很机械，它应该自动进行，那么你是对的。不难写个小程序接受如Widget这样的类而输出RCWidget这样的类。如果你写了一个这样的程序，请让我知道。</p><p>​        让我们从Widget、String、值、灵巧指针和引用计数基类中摆脱一下。给个机会回顾一下，在更广阔的环境下看一下引用计数。在更大的环境下，我们必须处理一个更高层次的问题，也就是什么时候使用引用计数？</p><p>​        实现引用计数不是没有代价的。每个被引用的值带一个引用计数，其大部分操作都需要以某种形式检查或操作引用计数。对象的值需要更多的内存，而我们在处理它们时需要执行更多的代码。此外，就内部的源代码而言，带引用计数的类的复杂度比不带的版本高。没有引用计数的String类只依赖于自己，而我们最终的String类如果没有三个辅助类（StringValue、RCObject和RCPtr）就无法使用。确实，我们这个更复杂的设计确保在值可共享时的更高的效率；免除了跟踪对象所有权的需要，提高了引用计数的想法和实现的可重用性。但，这四个类必须写出来、被测试、文档化、和被维护，比单个类要多做更多的工作。即使是管理人员也能看出这点。</p><p>​        引用计数是基于对象通常共享相同的值的假设的优化技巧（参见Item M18）。如果假设不成立的话，引用计数将比通常的方法使用更多的内存和执行更多的代码。另一方面，如果你的对象确实有具体相同值的趋势，那么引用计数将同时节省时间和空间。共享的值所占内存越大，同时共享的对象数目越多，节省的内存也就越大。创建和销毁这个值的代价越大，你节省的时间也越多。总之，引用计数在下列情况下对提高效率很有用：</p><p>​        少量的值被大量的对象共享。这样的共享通常通过调用赋值操作和拷贝构造而发生。对象/值的比例越高，越是适宜使用引用计数。</p><p>​        对象的值的创建和销毁代价很高昂，或它们占用大量的内存。即使这样，如果不是多个对象共享相同的值，引用计数仍然帮不了你任何东西。</p><p>​        只有一个方法来确认这些条件是否满足，而这个方法不是猜测或依赖直觉（见Item M16）。这个方法是使用profiler或其它工具来分析。使用这种方法，你可以发现是否创建和销毁值的行为是性能瓶颈，并能得出对象/值的比例。只有当你手里有了这些数据，你才能得出是否从引用计数上得到的好处超过其缺点。</p><p>​        即使上面的条件满足了，使用引用计数仍然可能是不合适的。有些数据结构（如有向图）将导致自我引用或环状结构。这样的数据结构可能导致孤立的自引用对象，它没有被别人使用，而其引用计数又绝不会降到零。因为这个无用的结构中的每个对象被同结构中的至少一个对象所引用。商用化的垃圾收集体系使用特别的技术来查找这样的结构并消除它们，但我们现在使用的这个简单的引用计数技术不是那么容易扩充出这个功能的。</p><p>​        即使效率不是主要问题，引用计数仍然很吸引人。如果你不放心谁应该去执行删除动作，那么引用计数正是这种让你放下担子的技巧。很多程序员只因为这个原因就使用引用计数。</p><p>​        让我们用最后一个问题结束讨论。当RCObject::removeReference减少对象的引用计数时，它检查新值是否为0。如果是，removeReference通过调用delete this销毁对象。这个操作只在对象是通过调用new生成时才安全，所以我们需要一些方法以确保RCObject只能用这种方法产生。</p><p>​        此处，我们用习惯方法来解决。RCObject被设计为只作被引用计数的值对象的基类使用，而这些值对象应该只通过灵巧指针RCPtr引用。此外，值对象应该只能由值会共享的对象来实例化；它们不能被按通常的方法使用。在我们的例子中，值对象的类是StringValue，我们通过将它申明为String的私有而限制其使用。只有String可以创建StringValue对象，所以String类的作者应该确保这些值对象都是通过new操作产成的。</p><p>​        于是，我们限制RCObject只能在堆上创建的方法就是指定一组满足这个要求的类，并确保只有这些类能创建RCObject对象。用户不可能无意地（或有意地）用一种不恰当的方法创建RCObject对象。我们限制了创建被引用计数对象的权力，当我们交出这个权力时，必须明确其附带条件是满足创建对象的限制条件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows-API-程序设计(4)</title>
      <link href="/2023/05/27/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4/"/>
      <url>/2023/05/27/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4/</url>
      
        <content type="html"><![CDATA[<h1 id="系统学习Windows-API-4"><a href="#系统学习Windows-API-4" class="headerlink" title="系统学习Windows API 4"></a>系统学习Windows API 4</h1><p>​        下面专门讲授<code>wchar_t</code>，他是宽字符的意思。</p><p>​        因为我们需要大量的输出中文，为了适配，我们常常使用<code>wchar_t</code></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;int main() &#123;char c &#x3D; &#39;A&#39;; &#x2F;&#x2F; 此类型在默认下只可以保存一个字节wchar_t c2 &#x3D; L&#39;牛&#39;; &#x2F;&#x2F; 现在就可以存下了。&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是这样还是会不认识，原因在于。。。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;locale.h&gt;int main() &#123;setlocale(LC_ALL, &quot;&quot;); &#x2F;&#x2F; 设置windows本地的编码char c &#x3D; &#39;A&#39;; &#x2F;&#x2F; 此类型在默认下只可以保存一个字节wchar_t c2 &#x3D; L&#39;牛&#39;; &#x2F;&#x2F; 现在就可以存下了。wprintf(L&quot;%c&quot;, c2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230526205326835.png" alt="image-20230526205326835"></p><p>​        那如何查看当前的地域呢？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%s\n&quot;, setlocale(LC_ALL, NULL));setlocale(LC_ALL, &quot;&quot;);printf(&quot;%s\n&quot;, setlocale(LC_ALL, NULL));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230526205514732.png" alt="image-20230526205514732"></p><p>​        对于宽字符，我们有跟char一样配饰的各式各样的函数。这里不再做什么介绍了！</p><h2 id="三大版本的char类型"><a href="#三大版本的char类型" class="headerlink" title="三大版本的char类型"></a>三大版本的char类型</h2><p>​        在微软中，有三大类型——CHAR , WCHAR, TCHAR（ASCII，Unicode和通用版本）</p><p>​        随后还有字符串版本的PSTR PWSTR, PTSTR, PC(onst)STR PCWSTR, PCTSTR…</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;int WINAPI WinMain(    _In_ HINSTANCE hInstance,    _In_opt_ HINSTANCE hPrevInstance,    _In_ LPSTR lpCmdLine,    _In_ int nShowCmd) &#123;    CHAR a &#x3D; &#39;a&#39;;    WCHAR b &#x3D; &#39;b&#39;;    TCHAR c &#x3D; &#39;c&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        看到TCHAR是根据平台的字符集选择而发生变动！建议我们的编程使用Unicode字符集。</p><h2 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h2><p>​        下面来看字符转换——将多字节字符和宽字符。为了使得转换方便，我们需要使用：</p><h3 id="MultiByteToWideChar"><a href="#MultiByteToWideChar" class="headerlink" title="MultiByteToWideChar();"></a>MultiByteToWideChar();</h3><p>​        这个函数将字符串映射到 UTF-16 (宽字符) 字符串。 字符串不一定来自多字节字符集。</p><p>​        注意！错误地使用 <strong>MultiByteToWideChar</strong> 函数可能会损害应用程序的安全性。 调用此函数很容易导致缓冲区溢出，因为 <em>lpMultiByteStr</em> 指示的输入缓冲区的大小等于字符串中的字节数，而 <em>lpWideCharStr</em> 指示的输出缓冲区的大小等于字符数。 为了避免缓冲区溢出，应用程序必须指定适合缓冲区接收的数据类型的缓冲区大小。</p><p>​        ANSI 代码页在不同计算机上可能不同，也可以更改单个计算机，从而导致数据损坏。 为了获得最一致的结果，应用程序应使用 Unicode（如 UTF-8 或 UTF-16），而不是特定代码页，除非旧标准或数据格式阻止使用 Unicode。 如果无法使用 Unicode，应用程序应在协议允许时使用适当的编码名称标记数据流。 HTML 和 XML 文件允许标记，但文本文件不会。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            UINT                              CodePage<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            DWORD                             dwFlags<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            <span class="token function">_In_NLS_string_</span><span class="token punctuation">(</span>cbMultiByte<span class="token punctuation">)</span>LPCCH lpMultiByteStr<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            <span class="token keyword">int</span>                               cbMultiByte<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPWSTR                            lpWideCharStr<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            <span class="token keyword">int</span>                               cchWideChar<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] CodePage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        用于执行转换的代码页。 此参数可以设置为在操作系统中安装或可用的任何代码页的值。 有关代码页的列表，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/Intl/code-page-identifiers">代码页标识符</a>。 应用程序还可以指定下表中显示的值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>CP_ACP</strong></td><td style="text-align:left">系统默认的 Windows ANSI 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td></tr><tr><td style="text-align:left"><strong>CP_MACCP</strong></td><td style="text-align:left">当前系统 Macintosh 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。 <strong>注意</strong> 此值主要用于旧代码，通常不需要，因为新式 Macintosh 计算机使用 Unicode 进行编码。</td></tr><tr><td style="text-align:left"><strong>CP_OEMCP</strong></td><td style="text-align:left">当前系统 OEM 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td></tr><tr><td style="text-align:left"><strong>CP_SYMBOL</strong></td><td style="text-align:left">符号代码页 (42) 。</td></tr><tr><td style="text-align:left"><strong>CP_THREAD_ACP</strong></td><td style="text-align:left">当前线程的 Windows ANSI 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td></tr><tr><td style="text-align:left"><strong>CP_UTF7</strong></td><td style="text-align:left">UTF-7。 仅当 7 位传输机制强制使用此值。 首选使用 UTF-8。</td></tr><tr><td style="text-align:left"><strong>CP_UTF8</strong></td><td style="text-align:left">UTF-8。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[in] dwFlags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指示转换类型的标志。 应用程序可以指定以下值的组合，MB_PRECOMPOSED为默认值。 MB_PRECOMPOSED和MB_COMPOSITE互斥。 无论其他标志的状态如何，都可以设置MB_USEGLYPHCHARS和MB_ERR_INVALID_CHARS。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_COMPOSITE</strong></td><td style="text-align:left">始终使用分解字符，即基字符和一个或多个非分步字符各具有不同的代码点值。 例如，Ä 由 A + ー 表示：拉丁文大写字母 A (U+0041) + 组合 DIAERESIS (U+0308) 。 请注意，此标志不能与MB_PRECOMPOSED一起使用。</td></tr><tr><td style="text-align:left"><strong>MB_ERR_INVALID_CHARS</strong></td><td style="text-align:left">如果遇到无效的输入字符，则失败。从 Windows Vista 开始，如果应用程序未设置此标志，函数不会删除非法代码点，而是将非法序列替换为根据指定的代码页) 编码的 U+FFFD (。<strong>Windows 2000 SP4 及更高版本，Windows XP：</strong> 如果未设置此标志，函数将无提示删除非法代码点。 对 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 的调用返回ERROR_NO_UNICODE_TRANSLATION。</td></tr><tr><td style="text-align:left"><strong>MB_PRECOMPOSED</strong></td><td style="text-align:left">默认;请勿与MB_COMPOSITE一起使用。 始终使用预编译字符，即具有基字符或非加速度字符组合的单个字符值。 例如，在字符 è 中，e 是基字符，重音符严重标记是非节奏字符。 如果为字符定义了单个 Unicode 码位，则应用程序应使用它而不是单独的基字符和非节奏字符。 例如，Ä 由单一 Unicode 码位 LATIN 大写字母 A WITH DIAERESIS (U+00C4) 表示。</td></tr><tr><td style="text-align:left"><strong>MB_USEGLYPHCHARS</strong></td><td style="text-align:left">使用字形字符而不是控制字符。</td></tr></tbody></table></div><p>​        对于下面列出的代码页， <em>dwFlags</em> 必须设置为 0。 否则，函数将失败并ERROR_INVALID_FLAGS。50220，50221，50222，50225，50227，，50229，57002 到 57011，65000 (UTF-7)，42 (符号)</p><p>​        对于 UTF-8 或代码页 54936 (GB18030，从 Windows Vista) 开始， <em>dwFlags</em> 必须设置为 0 或MB_ERR_INVALID_CHARS。 否则，函数将失败并ERROR_INVALID_FLAGS。</p><pre class="line-numbers language-none"><code class="language-none">[in] lpMultiByteStr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向要转换的字符串的指针。</p><pre class="line-numbers language-none"><code class="language-none">[in] cbMultiByte<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <em>lpMultiByteStr</em> 参数指示的字符串的大小（以字节为单位）。 或者，如果字符串以 null 结尾，则可以将此参数设置为 -1。 请注意，如果 <em>cbMultiByte</em> 为 0，函数将失败。</p><p>​        如果此参数为 -1，则该函数将处理整个输入字符串，包括终止 null 字符。 因此，生成的 Unicode 字符串具有终止 null 字符，函数返回的长度包括此字符。</p><p>​        如果此参数设置为正整数，则函数将完全处理指定的字节数。 如果提供的大小不包括终止 null 字符，则生成的 Unicode 字符串不会以 null 结尾，并且返回的长度不包括此字符。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpWideCharStr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收转换后的字符串的缓冲区的指针。</p><pre class="line-numbers language-none"><code class="language-none">[in] cchWideChar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <em>lpWideCharStr</em> 指示的缓冲区的大小（以字符为单位）。 如果此值为 0，则该函数将返回所需的缓冲区大小（以字符为单位，包括任何终止 null 字符）并且不使用 <em>lpWideCharStr</em> 缓冲区。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>​        返回写入缓冲区的字符数，如果成功，则返回 <em>由 lpWideCharStr</em> 指示的字符数。 如果函数成功且 <em>cchWideChar</em> 为 0，则返回值是 <em>lpWideCharStr</em> 指示的缓冲区所需的大小（以字符为单位）。 另请参阅 <em>dwFlags</em> ，了解输入无效序列时MB_ERR_INVALID_CHARS标志如何影响返回值的信息。</p><p>​        如果函数不成功，则返回 0。 若要获取扩展的错误信息，应用程序可以调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>，后者可以返回以下错误代码之一：</p><ul><li>ERROR_INSUFFICIENT_BUFFER。 提供的缓冲区大小不够大，或者错误地设置为 <strong>NULL</strong>。</li><li>ERROR_INVALID_FLAGS。 为标志提供的值无效。</li><li>ERROR_INVALID_PARAMETER。 任何参数值都无效。</li><li>ERROR_NO_UNICODE_TRANSLATION。 在字符串中找到无效的 Unicode。</li></ul><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>​        此函数的默认行为是转换为输入字符串的预编译形式。 如果预编译的窗体不存在，该函数将尝试转换为复合窗体。</p><p>​        使用MB_PRECOMPOSED标志对大多数代码页的影响很小，因为大多数输入数据已经组成。 考虑使用 <strong>MultiByteToWideChar</strong> 进行转换后调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnls/nf-winnls-normalizestring">NormalizeString</a>。 <strong>NormalizeString</strong> 提供更准确、标准和一致的数据，还可以更快。 请注意，对于传递给 <strong>NormalizeString</strong><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnls/ne-winnls-norm_form">的NORM_FORM</a>枚举，NormalizationC 对应于MB_PRECOMPOSED，NormalizationD 对应于MB_COMPOSITE。</p><p>​        如上述警告中所述，如果未首先使用 <em>cchWideChar</em> 设置为 0 调用此函数，则输出缓冲区很容易溢出，以获取所需的大小。 如果使用MB_COMPOSITE标志，则每个输入字符的输出长度可以为三个或多个字符。</p><p>​        <em>lpMultiByteStr</em> 和 <em>lpWideCharStr</em> 指针不能相同。 如果它们相同，函数将失败， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回值ERROR_INVALID_PARAMETER。</p><p>​        如果显式指定输入字符串长度而不终止 null 字符，<strong>则 MultiByteToWideChar</strong> 不会终止输出字符串。 若要为此函数终止输出字符串，应用程序应传入 -1 或显式计算输入字符串的终止 null 字符。</p><p>​        如果设置了MB_ERR_INVALID_CHARS并且源字符串中遇到无效字符，则函数将失败。 无效字符为下列字符之一：</p><ul><li>不是源字符串中默认字符的字符，但在未设置MB_ERR_INVALID_CHARS时转换为默认字符</li><li>对于 DBCS 字符串，具有前导字节但没有有效尾随字节的字符</li></ul><p>​        从 Windows Vista 开始，此函数完全符合 UTF-8 和 UTF-16 的 Unicode 4.1 规范。 在早期操作系统上使用的函数编码或解码孤独 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/Intl/surrogates-and-supplementary-characters">代理项半</a> 部分或不匹配的代理项对。 在早期版本的 Windows 中编写的代码，这些代码依赖于此行为对随机非文本二进制数据进行编码可能会遇到问题。 但是，在有效的 UTF-8 字符串上使用此函数的代码的行为方式与早期 Windows 操作系统相同。</p><p>​        <strong>Windowsxp：</strong> 为了防止 UTF-8 字符的非最短格式版本的安全问题， <strong>MultiByteToWideChar</strong> 会删除这些字符。</p><p>​        <strong>从 Windows 8 开始：</strong>MultiByteToWideChar 在 Stringapiset.h 中声明。 在Windows 8之前，它在 Winnls.h 中声明。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// Save in-memory logging buffer to a log file on error.</span>    <span class="token double-colon punctuation">::</span>std<span class="token double-colon punctuation">::</span>wstring wideWhat<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> convertResult <span class="token operator">=</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>convertResult <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            wideWhat <span class="token operator">=</span> L<span class="token string">"Exception occurred: Failure to convert its message text using MultiByteToWideChar: convertResult="</span><span class="token punctuation">;</span>            wideWhat <span class="token operator">+=</span> convertResult<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            wideWhat <span class="token operator">+=</span> L<span class="token string">"  GetLastError()="</span><span class="token punctuation">;</span>            wideWhat <span class="token operator">+=</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span>        <span class="token punctuation">&#123;</span>            wideWhat<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>convertResult <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            convertResult <span class="token operator">=</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wideWhat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>wideWhat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>convertResult <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                wideWhat <span class="token operator">=</span> L<span class="token string">"Exception occurred: Failure to convert its message text using MultiByteToWideChar: convertResult="</span><span class="token punctuation">;</span>                wideWhat <span class="token operator">+=</span> convertResult<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                wideWhat <span class="token operator">+=</span> L<span class="token string">"  GetLastError()="</span><span class="token punctuation">;</span>                wideWhat <span class="token operator">+=</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span>            <span class="token punctuation">&#123;</span>                wideWhat<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> L<span class="token string">"Exception occurred: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span>    <span class="token punctuation">&#123;</span>        wideWhat <span class="token operator">=</span> L<span class="token string">"Exception occurred: Unknown."</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    Platform<span class="token double-colon punctuation">::</span>String<span class="token operator">^</span> errorMessage <span class="token operator">=</span> ref <span class="token keyword">new</span> <span class="token class-name">Platform</span><span class="token double-colon punctuation">::</span><span class="token function">String</span><span class="token punctuation">(</span>wideWhat<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// The session added the channel at level Warning. Log the message at</span>    <span class="token comment">// level Error which is above (more critical than) Warning, which</span>    <span class="token comment">// means it will actually get logged.</span>    _channel<span class="token operator">-></span><span class="token function">LogMessage</span><span class="token punctuation">(</span>errorMessage<span class="token punctuation">,</span> LoggingLevel<span class="token double-colon punctuation">::</span>Error<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">SaveLogInMemoryToFileAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span>StorageFile<span class="token operator">^</span> logFile<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        _logFileGeneratedCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">StatusChanged</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> ref <span class="token keyword">new</span> <span class="token function">LoggingScenarioEventArgs</span><span class="token punctuation">(</span>LoggingScenarioEventType<span class="token double-colon punctuation">::</span>LogFileGenerated<span class="token punctuation">,</span> logFile<span class="token operator">-></span>Path<span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="WideCharToMultiByte"><a href="#WideCharToMultiByte" class="headerlink" title="WideCharToMultiByte"></a>WideCharToMultiByte</h3><p>传送门：<a href="https://www.cnblogs.com/vranger/p/3793123.html">函数WideCharToMultiByte（） 详解 - vranger - 博客园 (cnblogs.com)</a></p><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><pre class="line-numbers language-none"><code class="language-none">int WideCharToMultiByte( UINT CodePage,  DWORD dwFlags,  LPWSTR lpWideCharStr,  int cchWideChar,  LPCSTR lpMultiByteStr,  int cchMultiByte,  LPCSTR lpDefaultChar,  PBOOL pfUsedDefaultChar );  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数功能：</strong></p><p>此函数把宽字符串转换成指定的新的字符串，如ANSI，UTF8等，新字符串不必是多字节字符集。 </p><p>(—-Unicode 转 ANSI(GB2312)，UTF8) </p><p><strong>参数：</strong></p><ul><li>CodePage：指定执行转换的代码页，这个参数可以为系统已安装或有效的任何代码页所给定的值。</li></ul><p>你也可以指定其为下面的任意一值：</p><p> (我想最常用的应该是CP_ACP和CP_UTF8了，前者将宽字符转 换为ANSI，后者转换为UTF8。 ) </p><div class="table-container"><table><thead><tr><th>CP_ACP</th><th>当前系统ANSI代码页</th></tr></thead><tbody><tr><td>CP_MACCP</td><td>当前系统Macintosh代码页</td></tr><tr><td>CP_OEMCP</td><td>当前系统OEM代码页，一种原始设备制造商硬件扫描码</td></tr><tr><td>CP_SYMBOL</td><td>符号代码页（42）</td></tr><tr><td>CP_THREAD_ACP</td><td>当前线程ANSI代码页</td></tr></tbody></table></div><ul><li>dwFlags：指定如何处理没有转换的字符，但不设此参数函数会运行的更快一些，我都是把它设为0。</li></ul><p>可设的值如下表所示：</p><pre class="line-numbers language-none"><code class="language-none">WC_NO_BEST_FIT_CHARS 把不能直接转换成相应多字节字符的Unicode字符转换成lpDefaultChar指定的默认字符。也就是说，如果把Unicode转换成多字节字符，然后再转换回来，你并不一定得到相同的Unicode字符，因为这期间可能使用了默认字符。此选项可以单独使用，也可以和其他选项一起使用。WC_COMPOSITECHECK 把合成字符转换成预制的字符。它可以与后三个选项中的任何一个组合使用，如果没有与他们中的任何一个组合，则与选项WC_SEPCHARS相同。WC_ERR_INVALID_CHARS 此选项会致使函数遇到无效字符时失败返回，并且GetLastError会返回错误码ERROR_NO_UNICODE_TRANSLATION。否则函数会自动丢弃非法字符。此选项只能用于UTF8。WC_DISCARDNS      转换时丢弃不占空间的字符，与WC_COMPOSITECHECK 一起使用WC_SEPCHARS 转换时产生单独的字符，此是默认转换选项，WC_COMPOSITECHECK一起使用WC_DEFAULTCHAR 转换时使用默认字符代替例外的字符，(最常见的如’?’)，与WC_COMPOSITECHECK一起使用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <em>注意：当指定WC_COMPOSITECHECK时，函数会将合成字符转换成预制字符。合成字符由一个基字符和一个不占空间的字符(如欧洲国家及汉语拼音的音标)组成，</em></p><p><em>每一个都有不同的字符值。预制字符有一个用于表示基字符和不占空间字符的合成体的单一的字符值。</em></p><p><em>当指定WC_COMPOSITECHECK选项时，也可以使用上表列出的最后3个选项来定制预制字符的转换规则。这些选项决定了函数在遇到宽字符串的合成字符没有对</em></p><p><em>应的预制字符时的行为，他们与WC_COMPOSITECHECK一起使用，如果都没有指定，函数默认WC_SEPCHARS。</em><br><em>对于下列代码页，dwFlags必须为0，否则函数返回错误码ERROR_INVALID_FLAGS。</em><br><em>50220 50221 50222 50225 50227 50229 52936 54936 57002到57011 65000(UTF7) 42(Symbol)</em><br><em>对于UTF8，dwFlags必须为0或WC_ERR_INVALID_CHARS，否则函数都将失败返回并设置错误码ERROR_INVALID_FLAGS，你可以调用GetLastError获得。</em></p><ul><li>lpWideCharStr： 待转换的宽字符串。</li></ul><ul><li>cchWideChar： 待转换宽字符串的长度，-1表示转换到字符串结尾。</li></ul><ul><li>lpMultiByteStr： 接收转换后输出新串的缓冲区。</li></ul><ul><li>cbMultiByte：输出缓冲区大小，如果为0，lpMultiByteStr将被忽略，函数将返回所需缓冲区大小而不使用lpMultiByteStr。</li></ul><ul><li>lpDefaultChar： 指向字符的指针， 在指定编码里找不到相应字符时使用此字符作为默认字符代替。如果为NULL则使用系统默认字符。对于要求此参数为NULL的dwFlags而使用此参数，函数将失败返回并设置错误码ERROR_INVALID_PARAMETER。</li></ul><ul><li>lpUsedDefaultChar：开关变量的指针，用以表明是否使用过默认字符。对于要求此参数为NULL的dwFlags而使用此参数，函数将失败返回并设置错误码ERROR_INVALID_PARAMETER。lpDefaultChar和lpUsedDefaultChar都设为NULL，函数会更快一些。</li></ul><ul><li>返回值：如果函数成功，且cbMultiByte非0，返回写入lpMultiByteStr的字节数(包括字符串结尾的null)；cbMultiByte为0，则返回转换所需字节数。函数失败，返回0。</li></ul><p>​        注意：函数WideCharToMultiByte使用不当，会给影响程序的安全。调用此函数会很容易导致内存泄漏，因为lpWideCharStr指向的输入缓冲区大小是宽字符数，而lpMultiByteStr指向的输出缓冲区大小是字节数。为了避免内存泄漏，应确保为输出缓冲区指定合适的大小。我的方法是先使cbMultiByte为0调用WideCharToMultiByte一次以获得所需缓冲区大小，为缓冲区分配空间，然后再次调用WideCharToMultiByte填充缓冲区，详见下面的代码。另外，从Unicode UTF16向非Unicode字符集转换可能会导致数据丢失，因为该字符集可能无法找到表示特定Unicode数据的字符。</p><h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><pre class="line-numbers language-none"><code class="language-none">wchar_t* pwszUnicode &#x3D; L&quot;Holle, word! 你好，中国！ &quot;;int iSize;char* pszMultiByte;iSize &#x3D; WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, NULL, 0, NULL, NULL);pszMultiByte &#x3D; (char*)malloc(iSize*sizeof(char));WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, pszMultiByte, iSize, NULL, NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;#include&lt;locale.h&gt;int main() &#123;DWORD dwNum &#x3D; 0;setlocale(LC_ALL, &quot;&quot;);char sText[] &#x3D; &quot;多字节转换为宽字符&quot;;&#x2F;&#x2F; 问题来了，我们给多少空间呢？&#x2F;*1. from ASCII 2. a control flag, we usually have no need of that3.what str 4. transform ALL 5.to where(here we don&#39;t want to get result), final: tha space that contain*&#x2F;dwNum &#x3D; MultiByteToWideChar(CP_ACP, 0, sText, -1, NULL, 0);WCHAR* pwText &#x3D; (WCHAR)malloc(sizeof(WCHAR) * dwNum*2);if (pwText &#x3D;&#x3D; NULL) &#123;free(pwText);return 1;&#125;MultiByteToWideChar(CP_ACP, 0, sText, -1, pwText, dwNum);wprintf(L&quot;M-&gt;W:%s&quot;, pwText);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Windows 32API </tag>
            
            <tag> 摸鱼ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows-API-程序设计(3)</title>
      <link href="/2023/05/27/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3/"/>
      <url>/2023/05/27/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3/</url>
      
        <content type="html"><![CDATA[<h1 id="系统学习Windows-API-3"><a href="#系统学习Windows-API-3" class="headerlink" title="系统学习Windows API 3"></a>系统学习Windows API 3</h1><p>​        在QT中，我们已经看到了生成一个对话框是容易的——但是现在，让我们把目光聚焦在基于Windows API的MFC下如何召唤一个对话框。</p><p>​        跟QT类似的——我们找到资源文件 》添加新建项 》 对话框，添加即可。</p><p>​        我们随后设计也界面 </p><p><img src="image-20230523195326640.png" alt="image-20230523195326640"></p><p>​        随便整点。</p><p>​        现在看看你的resource.h，多了四个宏：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;&#123;&#123;NO_DEPENDENCIES&#125;&#125;&#x2F;&#x2F; Microsoft Visual C++ 生成的包含文件。&#x2F;&#x2F; 供 Project2.rc 使用&#x2F;&#x2F;#define IDD_DIALOG1                     101#define IDC_BUTTON1                     1001#define IDC_BUTTON2                     1002#define IDC_BUTTON3                     1003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        他们是我们操作之的接口。</p><p>​        下面开始写主函数的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int APIENTRY WinMain(_In_ HINSTANCE hInstance,    _In_opt_ HINSTANCE hPrevInstance,    _In_ LPSTR lpCmdLine,    _In_ int nShowCmd) &#123;    DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, MainDlgProc);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="APIEntry"><a href="#APIEntry" class="headerlink" title="APIEntry:"></a>APIEntry:</h2><pre class="line-numbers language-none"><code class="language-none">APIENTRY系统函数的调用约定。此类型在 WinDef.h 中声明，如下所示：#define APIENTRY WINAPI<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        也就是说，它本质上时WINAPI的重定义与重命名。</p><h2 id="DialogBox"><a href="#DialogBox" class="headerlink" title="DialogBox"></a>DialogBox</h2><p>​        从对话框模板资源创建模式对话框。 在指定的回调函数通过调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> 函数终止模式对话框之前，<strong>DialogBox</strong> 不会返回控件。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">DialogBoxA</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  hInstance<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            lpTemplate<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  hWndParent<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  lpDialogFunc<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in, optional] hInstance<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>HINSTANCE</strong></p><p>包含对话框模板的模块的句柄。 如果此参数为 NULL，则使用当前可执行文件。</p><pre class="line-numbers language-none"><code class="language-none">[in] lpTemplate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>LPCTSTR</strong></p><p>对话框模板。 此参数是指向指定对话框模板名称的以空字符结尾的字符串的指针，或者是指定对话框模板的资源标识符的整数值。 如果参数指定了资源标识符，则其高位字必须为零，其低位字必须包含该标识符。 你可以使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> 宏来创建此值。</p><pre class="line-numbers language-none"><code class="language-none">[in, optional] hWndParent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型：<strong>HWND</strong></p><p>拥有对话框的窗口的句柄。</p><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpDialogFunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>DLGPROC</strong></p><p>指向对话框过程的指针。 有关对话框过程的详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>。</p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p><strong>DialogBox</strong> 宏使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> 函数创建对话框。 然后，如果模板指定对话框过程DS_SETFONT<a href="https://learn.microsoft.com/zh-cn/windows/desktop/dlgbox/about-dialog-boxes">或DS_SHELLFONT</a>样式) ，<strong>则 DialogBox</strong> 会发送<a href="https://learn.microsoft.com/zh-cn/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a><a href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/wm-setfont">消息 (</a>和WM_SETFONT消息。 该函数显示对话框 (，无论模板是否指定 <strong>WS_VISIBLE</strong> 样式) ，禁用所有者窗口，并启动其自己的消息循环来检索和调度对话框的消息。</p><p>当对话框过程调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> 函数时，<strong>DialogBox</strong> 将销毁对话框，结束消息循环，如果以前启用) ，则启用所有者窗口 (，并在调用 <strong>EndDialog</strong> 时返回对话框过程指定的 <em>nResult</em> 参数。</p><h2 id="MAKEINTERSOURCE"><a href="#MAKEINTERSOURCE" class="headerlink" title="MAKEINTERSOURCE"></a>MAKEINTERSOURCE</h2><p>VC的定义是(winuser.h):</p><pre class="line-numbers language-none"><code class="language-none">#define MAKEINTRESOURCEA(i) ([LPSTR](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;LPSTR&#x2F;9782867?fromModule&#x3D;lemma_inlink))((ULONG_PTR)((WORD)(i)))#define MAKEINTRESOURCEW(i) (LPWSTR)((ULONG_PTR)((WORD)(i)))#define MAKEINTRESOURCE MAKEINTRESOURCEW#else#define MAKEINTRESOURCE MAKEINTRESOURCEA[#endif](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;%23endif&#x2F;2834688?fromModule&#x3D;lemma_inlink) &#x2F;&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用这个宏的主要原因是有的资源是用序号定义的,而不是字符串.所以要把数字转换成字符串<a href="https://baike.baidu.com/item/指针?fromModule=lemma_inlink">指针</a>,然后再传递给<a href="https://baike.baidu.com/item/LoadResource/530202?fromModule=lemma_inlink">LoadResource</a>之类的函数,这样才加载了资源.</p><p>要释放资源(用LoadResource加载的)可以调用FreeResource函数把LoadResource返回的指针传递给FreeResource.</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>​        是把一个”数字形ID”,转化为”字符串”.但是执行前后,输入的数据的内容和长度是不变的!它只不过就是C语言里面”<a href="https://baike.baidu.com/item/强制类型转换/1580197?fromModule=lemma_inlink">强制类型转换</a>“而已.</p><p>​        请看 Winuser.h 代码:</p><pre class="line-numbers language-none"><code class="language-none">#define MAKEINTRESOURCEA(i) ([LPSTR](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;LPSTR&#x2F;9782867?fromModule&#x3D;lemma_inlink))(([DWORD](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;DWORD&#x2F;5043783?fromModule&#x3D;lemma_inlink))((WORD)(i)))#define MAKEINTRESOURCEW(i) (LPWSTR)((DWORD)((WORD)(i)))#define MAKEINTRESOURCE MAKEINTRESOURCEW#else#define MAKEINTRESOURCE MAKEINTRESOURCEA[#endif](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;%23endif&#x2F;2834688?fromModule&#x3D;lemma_inlink) &#x2F;&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        的用法.就用<a href="https://baike.baidu.com/item/FindResource/6375062?fromModule=lemma_inlink">FindResource</a>来说明.</p><pre class="line-numbers language-none"><code class="language-none">HRSRC FindResource(HMODULE hModule, &#x2F;&#x2F; module handleLPCTSTR lpName, &#x2F;&#x2F; resource nameLPCTSTR lpType &#x2F;&#x2F; resource type);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        就是lpName参数需要使用MAKEINTRESOURCE ,因为它需要<a href="https://baike.baidu.com/item/LPCTSTR/6495202?fromModule=lemma_inlink">LPCTSTR</a>类型的参数输入.那么,情况就很清楚了.凡涉及”资源”的API或者MFC类,在参数类型为LPCTSTR时,就应该使用 MAKEINTRESOURCE.这是针对”资源名字”为”数字类型”时的情况.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;Windows.h&gt;#include&quot;resource.h&quot;INT_PTR CALLBACK MainDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) &#123;    BOOL bRet &#x3D; TRUE;    int usrChoice;    switch (uMsg)    &#123;    case WM_LBUTTONDOWN:        MessageBox(hDlg, L&quot;Hello!&quot;, L&quot;A Greeting&quot;, MB_OK);    case WM_COMMAND:        switch (LOWORD(wParam)) &#123;        case IDC_BUTTON1:            usrChoice &#x3D; MessageBox(hDlg, L&quot;I convinced that you push the button1&quot;, L&quot;A greeting&quot;, MB_OK);            if (usrChoice &#x3D;&#x3D; MB_OK) &#123;                bRet &#x3D; FALSE;                break;            &#125;            break;        case IDC_BUTTON2:            usrChoice &#x3D; MessageBox(hDlg, L&quot;I convinced that you push the button2&quot;, L&quot;A greeting&quot;, MB_OK);            if (usrChoice &#x3D;&#x3D; MB_OK) &#123;                bRet &#x3D; FALSE;                break;            &#125;            break;        case IDC_BUTTON3:            EndDialog(hDlg, 0);            bRet &#x3D; FALSE;            break;        default:            bRet &#x3D; FALSE;            break;        &#125;        break;    default:        bRet &#x3D; FALSE;        break;    &#125;    return bRet;&#125;int APIENTRY WinMain(_In_ HINSTANCE hInstance,    _In_opt_ HINSTANCE hPrevInstance,    _In_ LPSTR lpCmdLine,    _In_ int nShowCmd) &#123;    DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, MainDlgProc);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个demo生成一个有趣的对话框，可以试试看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Windows 32API </tag>
            
            <tag> 摸鱼ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT new 9-10-11</title>
      <link href="/2023/05/26/QT-new-9-10-11/"/>
      <url>/2023/05/26/QT-new-9-10-11/</url>
      
        <content type="html"><![CDATA[<h1 id="QT-new-9"><a href="#QT-new-9" class="headerlink" title="QT new 9"></a>QT new 9</h1><h2 id="一些经典容器的若干操作"><a href="#一些经典容器的若干操作" class="headerlink" title="一些经典容器的若干操作"></a>一些经典容器的若干操作</h2><h3 id="QListWidget"><a href="#QListWidget" class="headerlink" title="QListWidget"></a>QListWidget</h3><p>​        下面的文段来自QT帮助助手！</p><pre><code>Detailed Description</code></pre><p><img src="image-20230526191818350.png" alt="image-20230526191818350"></p><p>​        QListWidget is a convenience class that provides a list view similar to the one supplied by QListView, but with a classic item-based interface for adding and removing items. QListWidget uses an internal model to manage each QListWidgetItem in the list.<br>For a more flexible list view widget, use the QListView class with a standard model.<br>List widgets are constructed in the same way as other widgets:</p><pre class="line-numbers language-none"><code class="language-none">QListWidget *listWidget &#x3D; new QListWidget(this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        The selectionMode() of a list widget determines how many of the items in the list can be selected at the same time, and whether complex selections of items can be created. This can be set with the setSelectionMode() function.<br>There are two ways to add items to the list: they can be constructed with the list widget as their parent widget, or they can be constructed with no parent widget and added to the list later. If a list widget already exists when the items are constructed, the first method is easier to use:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">new QListWidgetItem(tr(&quot;Oak&quot;), listWidget);new QListWidgetItem(tr(&quot;Fir&quot;), listWidget);new QListWidgetItem(tr(&quot;Pine&quot;), listWidget);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        If you need to insert a new item into the list at a particular position, then it should be constructed without a parent widget. The insertItem() function should then be used to place it within the list. The list widget will take ownership of the item.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem *newItem &#x3D; new QListWidgetItem;newItem-&gt;setText(itemText);listWidget-&gt;insertItem(row, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        For multiple items, insertItems() can be used instead. The number of items in the list is found with the count() function. To remove items from the list, use takeItem().<br>​        The current item in the list can be found with currentItem(), and changed with setCurrentItem(). The user can also change the current item by navigating with the keyboard or clicking on a different item. When the current item changes, the currentItemChanged() signal is emitted with the new current item and the item that was previously current.</p><p>​        大致就是创建一个长得像那样链表似的一个控件！</p><p><img src="image-20230526192003545.png" alt="image-20230526192003545">        在QT 的 UI设计下，常常见这个控件于： List Widget下面。</p><p>​        我们这里不对对象名称做什么修改了！默认的情况下——</p><pre class="line-numbers language-none"><code class="language-none">ui -&gt; listWidget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        找到它来！</p><p>​        为了添加控件，我们有两种方式来进行：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 方式1QListWidgetItem* item &#x3D; new QListWidgetItem(&quot;卢本伟牛逼&quot;);ui-&gt;listWidget-&gt;addItem(item);item-&gt;setTextAlignment(Qt::AlignHCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这就是一种方式——通过包装成 Item 送到Widget里去。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 方式2QStringList list;list &lt;&lt; &quot;卢&quot;&lt;&lt;&quot;本&quot;&lt;&lt;&quot;伪&quot;&lt;&lt;&quot;牛&quot;&lt;&lt;&quot;逼&quot;;ui-&gt;listWidget-&gt;addItems(list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是通过传入String List 链表的方式送数据。</p><h3 id="1）添加条目的函数"><a href="#1）添加条目的函数" class="headerlink" title="1）添加条目的函数"></a>1）<strong>添加条目的函数</strong></h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">void</span> <span class="token class-name static-context">QListWidget</span><span class="token operator">::</span><span class="token function">addItem</span><span class="token punctuation">(</span>QListWidgetItem <span class="token operator">*</span> item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个添加函数需要实现 new 一个 <a href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 条目对象，然后添加到列表控件末尾，下面小节会专门讲 QListWidgetItem 类。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::addItem(const QString &amp; label)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这第二个添加函数其实更常用，因为更简便，功能是将字符串 label 添加到列表控件末尾显示，其实该函数内部会自动根据字符串 new 一个条目对象添加到列表控件。<br>如果有设置好的字符串列表，那么可以通过如下函数把多个字符串全部添加到列表控件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::addItems(const QStringList &amp; labels)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>add<em> 函数是将条目添加到末尾，如果要将条目插入到指定行 row 位置，则使用 insert</em> 函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::insertItem(int row, QListWidgetItem * item) &#x2F;&#x2F;插入条目到第 row 行void QListWidget::insertItem(int row, const QString &amp; label) &#x2F;&#x2F;插入字符串到第 row 行void QListWidget::insertItems(int row, const QStringList &amp; labels) &#x2F;&#x2F;插入多个字符串到从 row 行开始的多个行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>获取列表控件里面的条目计数使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QListWidget::count() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="（2）删除函数"><a href="#（2）删除函数" class="headerlink" title="（2）删除函数"></a>（2）<strong>删除函数</strong></h2><p>​        因为是基于条目的控件，所以列表控件的删除单个条目函数名字是 <strong>takeItem()</strong>：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::takeItem(int row)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        takeItem() 根据行号从列表控件移除一个条目，并返回该条目指针，如果行号不合法，返回 NULL 指针。<br>​        如果返回的是实际存在的条目，那么需要注意，返回的条目指针需要手动 delete 掉，因为列表控件不再拥有该条目，该条目<strong>不会由列表控件析构时自动删除。</strong><br>​        <strong>takeItem() 函数还有第二个用途，因为列表控件没有直接的调整条目前后顺序的函数，可以先将要调整顺序的条目移出来takeItem()，然后再调用 insertItem() 把这个条目插入到新的位置。</strong>（重点关注之）</p><p>​        如果要清空整个列表控件，删除之前添加的所有条目，可以调用槽函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="（3）条目访问函数"><a href="#（3）条目访问函数" class="headerlink" title="（3）条目访问函数"></a>（3）<strong>条目访问函数</strong></h2><p>​        根据行号获取条目对象的指针，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::item(int row) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果已知列表控件含有的条目对象指针，反查当前行号，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QListWidget::row(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>在图形界面，如果希望根据列表控件在屏幕显示的相对坐标位置（以列表控件内部左上角为原点）来获取条目，使用如下函数：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::itemAt(const QPoint &amp; p) constQListWidgetItem * QListWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>反过来，如果根据已知条目，获取这个条目占据的矩形区域，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QRect QListWidget::visualItemRect(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="（4）当前选中条目的操作"><a href="#（4）当前选中条目的操作" class="headerlink" title="（4）当前选中条目的操作"></a>（4）<strong>当前选中条目的操作</strong></h2><p>获取列表控件当前选中条目的函数如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::currentItem() const &#x2F;&#x2F;当前选中 条目int QListWidget::currentRow() const  &#x2F;&#x2F;当前选中的行号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果当前没有选中的条目，那么返回的指针为 NULL，返回的序号为 -1 ，代码里要注意判断返回值。</p><p>设置已存在的某个条目为选中状态，使用函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::setCurrentItem(QListWidgetItem * item)    &#x2F;&#x2F;设置当前选中条目为 itemvoid QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)void QListWidget::setCurrentRow(int row, QItemSelectionModel::SelectionFlags command)&#x2F;&#x2F;设置当前选中行为 rowvoid QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        第二个和第四个设置函数有个 SelectionFlags 类型的参数 command，这个参数决定选中的方式，是要选中QItemSelectionModel::Select ，还是取消选中 QItemSelectionModel::Deselect，还有其他选中方式，等到表格控件一节再详细列出来。<br>如果当前选中的条目发生变化，会触发如下三个信号，可以根据实际用途选择合适的信号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::currentItemChanged(QListWidgetItem * current, QListWidgetItem * previous)void QListWidget::currentRowChanged(int currentRow)void QListWidget::currentTextChanged(const QString &amp; currentText)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意参数里的指针有可能为空值，序号可能为 -1，字符串也可能是空串，一定要注意判断非法的参数值。</p><p>​        本章的三个控件都可以设置选中模式，比如单选模式，一次只能选中一个条目，多选模式，一次可以选中多个条目等等，详细的选中模式在放到表格控件一节讲解，因为表格 中涉及的选中模式较多，一块讲解。本节的列表控件默认情况下，选中模式为单选 。QAbstractItemView::SingleSelection，以上的 <em>current</em> 等函数都是基于默认的单选模式的。</p><p>​        如果需要用到多选模式，可以设置 selectionMode 属性为 QAbstractItemView::ExtendedSelection，这种扩展选中模式类似常见的文件资源管理器的选中模式，可以使用 Ctrl 或 Shift 加鼠标点击实现多选：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setSelectionMode(QAbstractItemView::SelectionMode mode)  &#x2F;&#x2F;设置选中模式QAbstractItemView::SelectionMode    selectionMode() const     &#x2F;&#x2F;获取选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        QAbstractItemView 是本章所有控件的抽象基类，本章后面控件也有类似的选中模式设置，如果把列表控件设置成多选模式，那么可以用如下函数获取同 时选中的多个条目：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QListWidgetItem *&gt; QListWidget::selectedItems() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        不论单选还是多选模式，条目选中情况有任何变化时，会触发如下信号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemSelectionChanged()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="（5）条目查找和排序"><a href="#（5）条目查找和排序" class="headerlink" title="（5）条目查找和排序"></a>（5）<strong>条目查找和排序</strong></h2><p>​        如果需要根据文本查找匹配的条目，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QListWidgetItem *&gt; QListWidget::findItems(const QString &amp; text, Qt::MatchFlags flags) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        该函数第一个参数 text 是要查找的模板子串，第二个参数是匹配标志，Qt::MatchFlags 是非常通用的枚举类型，不仅可用于字符串匹配，还能用于其他类型变量的匹配，Qt::MatchFlags 包含关于查找匹配的多种方式的枚举值：</p><div class="table-container"><table><thead><tr><th><strong>Qt::MatchFlags 枚举常量</strong></th><th><strong>数值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>Qt::MatchExactly</td><td>0</td><td>精确匹配，执行基于 QVariant 的匹配。</td></tr><tr><td>Qt::MatchFixedString</td><td>8</td><td>执行基于字符串的匹配，如果不指定 MatchCaseSensitive，默认是大小写不敏感。</td></tr><tr><td>Qt::MatchContains</td><td>1</td><td>条目包含要查找的模板子串。</td></tr><tr><td>Qt::MatchStartsWith</td><td>2</td><td>条目以要查找的模板子串打头。</td></tr><tr><td>Qt::MatchEndsWith</td><td>3</td><td>条目以要查找的模板子串结尾。</td></tr><tr><td>Qt::MatchCaseSensitive</td><td>16</td><td>查找时大小写敏感。</td></tr><tr><td>Qt::MatchRegExp</td><td>4</td><td>根据正则表达式模板子串匹配字符串。</td></tr><tr><td>Qt::MatchWildcard</td><td>5</td><td>根据通配符模板子串（如 *.txt）匹配字符串。</td></tr><tr><td>Qt::MatchWrap</td><td>32</td><td>执行回绕查找，当查找到最后一个条目时返回到第一个的条目继续查找，直到所有的条目都检查一遍。</td></tr><tr><td>Qt::MatchRecursive</td><td>64</td><td>递归查找，遍历所有子条目。</td></tr></tbody></table></div><p>​        后面两节的表格控件和树形控件也有类似的查找函数 findItems() ，第二个匹配标志参数也是一样的类型。</p><p>​        列表控件的自动排序是通过 sortingEnabled 属性来控制，获取和设置函数如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool isSortingEnabled() constvoid setSortingEnabled(bool enable)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        列表控件条目默认是不排序的，如果希望自动按照字典序排序，调用 setSortingEnabled(true) 即可。另外还可以手动对列表控件现有条目排序：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::sortItems(Qt::SortOrder order &#x3D; Qt::AscendingOrder)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Qt::AscendingOrder 是按升序排列，Qt::DescendingOrder 是按降序排列。</p><h2 id="（6）条目显示和运行时条目编辑"><a href="#（6）条目显示和运行时条目编辑" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）<strong>条目显示和运行时条目编辑</strong></h2><p>​        关于列表控件 QListWidget 和里面的条目 QListWidgetItem，需要注意条目 QListWidgetItem 仅仅是数据，不是控件或子控件，列表控件根据多个 QListWidgetItem 对象，来呈现条目里的数据，<strong>只有列表控件自己是控件实体。</strong><br>列表控件默认以自己的方式呈现条目数据，比如白底黑字的普通条目显示，如果要按照特殊的子控件来显示字符串，比如用 QLabel 对象显示条目数据，可以用如下函 数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::setItemWidget(QListWidgetItem * item, QWidget * widget)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        列表控件会同时拥有 item 数据条目和用于显示 item 的子控件 widget。注意这里的子控件 widget 只有静态显示功能，如果用按钮作为显示子控件，那么按钮是不可点击的。如果希望自己定制一个能交互操作的子条目显示控件，需要使用 QListView 并子类化 QItemDelegate 类，这些复杂的等到模型视图章节再讲。</p><p>​        对于本节列表控件，如果要获取 setItemWidget() 函数指定某个条目的显示子控件，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QWidget * QListWidget::itemWidget(QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果要删除上面 setItemWidget() 指定的特殊显示控件，使用函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::removeItemWidget(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        特殊的显示子控件移除后，该条目就还按照列表控件原来的普通条目显示。</p><p>​        <strong>如果希望在程序运行时编辑列表控件的条目，有两种方式，本小节先讲第一种（第二种是设置条目自身的特性标志），手动打开条目的文本编辑器（这个编辑器是列表控件自 带功能，与 setItemWidget 设置的显示子控件没关系）：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::openPersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>这个函数名是打开条目的持续编辑器，持续的意思是如果不调用关闭函数，该条目的编辑器会一直开启，关闭这个持续编辑器使用如下函数：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::closePersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>一般可以在检测到条目激活信号（itemActivated）时调用打开函数 openPersistentEditor() ，在当前条目变化（ currentItemChanged）时调用关闭函数 closePersistentEditor() 。</strong> 使用这一对开关持续编辑器函数涉及到编写多个信号的槽函数，使用比较麻烦，建议用后面第二小节介绍的条目标 志位和 QListWidget::editItem(QListWidgetItem * item) 实现条目的可编辑功能。</p><h2 id="（7）其他信号和槽函数"><a href="#（7）其他信号和槽函数" class="headerlink" title="（7）其他信号和槽函数"></a>（7）<strong>其他信号和槽函数</strong></h2><p>除了上面关于当前条目变化和选中条目变化的信号，条目还有激活、单击、双击等信号，罗列如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemActivated(QListWidgetItem * item)  &#x2F;&#x2F;激活信号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当用户点击或双击条目时，条目会被激活，具体哪些操作会激活条目，要根据操作系统设置来定，比如 Windows 一般是双击打开激活，KDE 桌面通常是单击打开激活。另外，系统的快捷键也可以激活条目，如 Windows 和 Linux X11 桌面是回车键激活，Mac OS X 是 Ctrl+0 ，一般激活信号用于开启编辑等操作。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemChanged(QListWidgetItem * item)   &#x2F;&#x2F;条目内容发生变化<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意这是条目内容变化的信号，不是选中状态变化，程序如果在运行时改变了条目文本内容，比如持续编辑器修改了文本，会触发这个信号。<br>剩下几个单击、双击、进入、按压等信号意义比较直白，不详细解释了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemClicked(QListWidgetItem * item)   &#x2F;&#x2F;条目单击信号void QListWidget::itemDoubleClicked(QListWidgetItem * item)  &#x2F;&#x2F;条目双击信号void QListWidget::itemEntered(QListWidgetItem * item)  &#x2F;&#x2F;鼠标追踪时进入条目的信号，一般用不着void QListWidget::itemPressed(QListWidgetItem * item)  &#x2F;&#x2F;鼠标按键在条目上处于按下状态时发的信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>列表控件的槽函数除了前面讲过的 clear() 槽函数用于清空所有条目，还有个比较实用的条目滚动函数，列表控件自带滚动条，当条目总数超出控件矩形能呈现的数目时，滚动条自动出现，通过滚动条支持更多的条目显示。使 用如下槽函数可 以让列表控件滚动到想显示的某个条目位置：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::scrollToItem(const QListWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个参数 item 就是想显示出来的条目，第二个参数是滚动显示方式，默认是 QAbstractItemView::EnsureVisible，即保证指定条目显示出来，还有其他的滚动显示方式：</p><div class="table-container"><table><thead><tr><th><strong>QAbstractItemView::ScrollHint 枚举常量</strong></th><th><strong>数值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>QAbstractItemView::EnsureVisible</td><td>0</td><td>滚动到指定条目能显示出来即可。</td></tr><tr><td>QAbstractItemView::PositionAtTop</td><td>1</td><td>滚动直到将指定条目显示到可视区域的顶部。</td></tr><tr><td>QAbstractItemView::PositionAtBottom</td><td>2</td><td>滚动直到将指定条目显示到可视区域的底部。</td></tr><tr><td>QAbstractItemView::PositionAtCenter</td><td>3</td><td>滚动直到将指定条目显示到可视区域的中间。</td></tr></tbody></table></div><p>原博客：<a href="https://blog.csdn.net/kongcheng253/article/details/128615688">[QT_007]Qt学习之QListWidget控件详解_天空之城8020的博客-CSDN博客</a></p><h1 id="QT-NEW-10"><a href="#QT-NEW-10" class="headerlink" title="QT NEW 10"></a>QT NEW 10</h1><h2 id="主要控件"><a href="#主要控件" class="headerlink" title="主要控件"></a>主要控件</h2><h3 id="QTreeWidget"><a href="#QTreeWidget" class="headerlink" title="QTreeWidget"></a>QTreeWidget</h3><pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        The QTreeWidget class is a convenience class that provides a standard tree widget with a classic item-based interface similar to that used by the QListView class in Qt 3. This class is based on Qt’s Model/View architecture and uses a default model to hold items, each of which is a QTreeWidgetItem.<br>​        Developers who do not need the flexibility of the Model/View framework can use this class to create simple hierarchical lists very easily. A more flexible approach involves combining a QTreeView with a standard item model. This allows the storage of data to be separated from its representation.<br>​        In its simplest form, a tree widget can be constructed in the following way:</p><pre class="line-numbers language-none"><code class="language-none">QTreeWidget *treeWidget &#x3D; new QTreeWidget();treeWidget-&gt;setColumnCount(1);QList&lt;QTreeWidgetItem *&gt; items;for (int i &#x3D; 0; i &lt; 10; ++i)&#123; items.append(new QTreeWidgetItem(static_cast&lt;QTreeWidget *&gt;\(nullptr), QStringList(QString(&quot;item: %1&quot;).arg(i))));&#125; treeWidget-&gt;insertTopLevelItems(0, items);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        Before items can be added to the tree widget, the number of columns must be set with setColumnCount(). This allows each item to have one or more labels or other decorations. The number of columns in use can be found with the columnCount() function.<br>The tree can have a header that contains a section for each column in the widget. It is easiest to set up the labels for each section by supplying a list of strings with setHeaderLabels(), but a custom header can be constructed with a QTreeWidgetItem and inserted into the tree with the setHeaderItem() function.<br>​        The items in the tree can be sorted by column according to a predefined sort order. If sorting is enabled, the user can sort the items by clicking on a column header. Sorting can be enabled or disabled by calling setSortingEnabled(). The isSortingEnabled() function indicates whether sorting is enabled.</p><h2 id="一些详解："><a href="#一些详解：" class="headerlink" title="一些详解："></a>一些详解：</h2><p>原博客：</p><p>​        <a href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p><p>​        树形控件的节点可以有多层、多个子节点， 如果将子节点全部展开，那么每一行都是一个数据条目。<a href="https://so.csdn.net/so/search?q=QTreeWidgetItem&amp;spm=1001.2101.3001.7020">QTreeWidgetItem</a> 比较特殊，一个条目内部可以有多列数据信息，相当于表格控件一整行的表格单元集成为一个条目，所以树形条目要比前面两节的列表条目和表格条目都复杂。树形控件每行的条目之间可以是兄弟关系或父子关系，含有子节点的条目可以折叠也可以展开，进行遍历时有专门的迭代器 QTreeWidgetItemIterator 实现，也可以自行编写<a href="https://so.csdn.net/so/search?q=递归算法&amp;spm=1001.2101.3001.7020">递归算法</a>遍历所有条目。</p><h3 id="8-3-1-QTreeWidget"><a href="#8-3-1-QTreeWidget" class="headerlink" title="8.3.1 QTreeWidget"></a>8.3.1 QTreeWidget</h3><p>在 Qt 设计师界面可以直接拖动树形控件到窗口里，下图展示树形控件的外观和构成：</p><p><img src="1.png" alt="f1ce3ab52d8fb8ed2698fa14a9ddb2b0.png"></p><p> 默认情况下，树形控件<strong>最上面是一个树头条目</strong>，<strong><em>\</em>树头条目也是 QTreeWidgetItem 对象**</strong>，可以有<strong>多列内容</strong>。<br>树头下面是真正的树形控件所有条目，在折叠的情况下，如上图所示，每行一个顶级条目，顶级条目也是 QTreeWidgetItem 对象，<strong>顶级条目的父节点指针 QTreeWidgetItem::parent() 为 NULL</strong>。<br>将所有节点展开之后，可以看到每个节点可以有多个子节点：</p><p><img src="2d11f9ba73fbaed337db73e2e141f4e7.png" alt="2d11f9ba73fbaed337db73e2e141f4e7.png"></p><p>对于包含子节点的父节点，左边会有小的三角形指示器，用于控制折叠或展开父节点。子节点也可以拥有更低级别的子节点（孙节点），以此类推，树形控件没 有限定子节点 的层数。顶级节点和其子孙节点的数据结构一样，都可以有多列数据，只是添加的函数、父节点指针不一样。下面介绍树形控件的函数和功能。</p><h3 id="（0）树形控件的构造函数很简单："><a href="#（0）树形控件的构造函数很简单：" class="headerlink" title="（0）树形控件的构造函数很简单："></a>（0）树形控件的构造函数很简单：</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidget(QWidget * parent &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数里只有指定父窗口或父控件的指针 parent 。树形控件在添加条目之前，必须要先设置列数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setColumnCount(int columns) &#x2F;&#x2F;设置列数int columnCount() const &#x2F;&#x2F;获取列数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <strong>默认的列数是 1 列</strong>，如果涉及到多列数据，比如文件浏览树，有文件名、文件类型、大小、修改时间等等，就需要设置为多列数据的树。<br>树形控件设置好列数就可以添加相应的顶级条目，添加顶级条目是由树形控件自身的函数实现，而子条目则由 QTreeWidgetItem 的函数实现。本小节主要围绕树形控件和其基类的函数来讲，<strong>树形控件也可以设置和表格控件类似的表头，这里称为树头条目</strong>。</p><h3 id="（1）添加和访问顶级条目"><a href="#（1）添加和访问顶级条目" class="headerlink" title="（1）添加和访问顶级条目"></a>（1）添加和访问顶级条目</h3><p>树形控件顶级条目的操作比较类似 <a href="https://so.csdn.net/so/search?q=QListWidget&amp;spm=1001.2101.3001.7020">QListWidget</a> 的列表条目操作函数。新建条目之后，可以用如下函数把条目添加到树形控件的顶级条目<strong>列表末尾</strong>：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::addTopLevelItem(QTreeWidgetItem * item) &#x2F;&#x2F;添加一个顶级条目到末尾void QTreeWidget::addTopLevelItems(const QList&lt;QTreeWidgetItem *&gt; &amp; items) &#x2F;&#x2F;添加多个顶级条目到末尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        如果希望将条目插入到指定顶级条目列表的 index 序号位置，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::insertTopLevelItem(int index, QTreeWidgetItem * item)void QTreeWidget::insertTopLevelItems(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; items)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <strong>树形控件所有的顶级条目父节点指针都为 NULL</strong> （父节点是指树形层次中的节点关系，<strong>而条目的父控件依然是树形控件本身</strong>）。<br>​        添加了顶级条目之后，可以对顶级条目进行计数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::topLevelItemCount() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（2）移除顶级条目"><a href="#（2）移除顶级条目" class="headerlink" title="（2）移除顶级条目"></a>（2）移除顶级条目</h3><p>​        移除顶级条目的函数也是take*打头：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::takeTopLevelItem(int index)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        index是顶级条目的序号，<strong>该函数只是从树形控件卸下顶级条目，但不会删除条目的内存空间，如果希望彻底删除，那么手动 delete 该函数返回的条目。</strong><br>如果要清空所有的顶级条目和子条目，使用槽函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（3）条目访问函数-1"><a href="#（3）条目访问函数-1" class="headerlink" title="（3）条目访问函数"></a>（3）条目访问函数</h3><p>​        对于顶级条目，如果知道顶级条目的序号获取对应的条目：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::topLevelItem(int index) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        反过来，对于已知顶级条目对象，查看其顶级序号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::indexOfTopLevelItem(QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果条目不是顶级条目或者条目不属于该控件，那么会返回 -1。<br>​        树形控件实际运行时，可能既有顶级条目，也有展开后的子孙条目同时显示，<strong>所以某个条目上面或下面的相邻条目不一定是同级别的兄弟条目，有可能是叔辈祖 辈的条目，也 可能是子辈孙辈条目。</strong>获取某个条目的相邻条目函数为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::itemAbove(const QTreeWidgetItem * item) const &#x2F;&#x2F;上面相邻条目QTreeWidgetItem * QTreeWidget::itemBelow(const QTreeWidgetItem * item) const &#x2F;&#x2F;下面相邻条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        从屏幕控件显示角度，如果根据树形控件<strong>内部相对坐标</strong>获取条目（树形控件显示区域的左上角为原点），使用下面函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::itemAt(const QPoint &amp; p) constQTreeWidgetItem * QTreeWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这两个函数是一个意思，一<strong>个用 QPoint 对象表示相对坐标，另一个直接用 x 和 y 数值表示坐标，如果对应坐标没有条目，会返回</strong> <strong>NULL</strong>，注意判断 返回值。<br>​        树形控件也是自带滚动条的，如果条目特别多，自动显示滚动条，对于树形控件在屏幕可见的条目，可以根据条目对象获取它的<strong>可视矩形</strong>（树形控件显示区域的 左上角为原 点）：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QRect QTreeWidget::visualItemRect(const QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="（4）当前条目的操作"><a href="#（4）当前条目的操作" class="headerlink" title="（4）当前条目的操作"></a>（4）当前条目的操作</h3><p>​        树形控件的选中操作默认比较像 QListWidget，如果不手动设置，<strong>只能选中一个高亮条目</strong>。<br>获取当前高亮选中条目的函数为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::currentItem() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        树形控件可以有多列，当前条目被点击选中的列号为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::currentColumn() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        树形控件内的条目一般都没有固定行号，<strong>因为条目可以展开也可以折叠，行号是变化的，所以没有基于行号的操作函数。</strong></p><p>​        如果要设置某个条目为当前选中的状态：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setCurrentItem(QTreeWidgetItem * item)void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column)void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        第一个 setCurrentItem() 函数相当<strong>于设置该条目整行高亮选中</strong>，第二个是设置该条目行的 column <strong>列高亮选中</strong>，第三个函数是<strong>单次选中命令</strong>，参考“8.2.4 选中区域和选中行为”的单次选中命令内容，<strong>只是树形控件是一整行为一个条目，定位到条目的某列数据，就 类似指定表格控件的单元格。</strong><br>如果当前高亮选中的状态发生变化，会触发如下信号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::currentItemChanged(QTreeWidgetItem * current, QTreeWidgetItem * previous)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数里分别是当前高亮选中的条目，和之前高亮选中的条目，注意指针可能是 NULL，使用指针前一定要判断指针非空</p><h3 id="（5）条目查找和排序-1"><a href="#（5）条目查找和排序-1" class="headerlink" title="（5）条目查找和排序"></a>（5）条目查找和排序</h3><p>​        如果要根据模板子串查找某列文本匹配的条目，使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QTreeWidgetItem *&gt; QTreeWidget::findItems(const QString &amp; text, Qt::MatchFlags flags, int column &#x3D; 0) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数里text是模板子串，flags是匹配标志（参看“8.1.1 QListWidget”中的字符串匹配标志表格），第三个参数是指定查找的列。<strong>该函数只查找一列的文本，其他列的文本是不查找的</strong>。如果需要查找所有列数据，那么要根据不同列号逐列查询。</p><p>​        类似表格控件，树形控件也可以按照列的文本进行自动排序，自动排序的设置函数为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool    isSortingEnabled() const          &#x2F;&#x2F;设置是否自动排序void    setSortingEnabled(bool enable)   &#x2F;&#x2F;查看是否开启自动排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        指定排序的列号和升序降序，使用从基类继承的函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeView::sortByColumn(int column, Qt::SortOrder order)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>在没有开启自动排序的情况下，也可以调用该函数进行一次性的条目排序。</strong></p><h3 id="（6）条目显示和运行时条目编辑-1"><a href="#（6）条目显示和运行时条目编辑-1" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）条目显示和运行时条目编辑</h3><p>​        可以为条目的某列“单元格”设置单独的控件来静态显示（控件不具有编辑功能）：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setItemWidget(QTreeWidgetItem * item, int column, QWidget * widget) &#x2F;&#x2F;设置条目列控件QWidget * QTreeWidget::itemWidget(QTreeWidgetItem * item, int column) const &#x2F;&#x2F;获取条目列控件，不设置就是NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        注意该函数只能在条目添加到树形控件之后*<em>才能调用，否则无效，\并且条目列控件只能用于显示，无法编辑，如果要定制可编辑的“单元格”控件，必须用基类 QTreeView 并继承 QItemDelegate 做代理，这些内容到后面模型视图章节讲解<br>​        再次强调：itemWidget 条目控件，在默认情况下是与条目本身数据完全无关的，是条目数据的替换品，而不是协作模式。<strong>只有手动设置信号与槽，它们才可能关联上。</strong><br>QListWidget 和 QTreeWidget 的条目控件<strong>都是静态显示，不能编辑。</strong><br>​        QTreeWidget 控件的条目列控件 widget 还必须把默认是透明背景<em>*，</em></em>这样控件的内容和内部模型数据（就是条目的列数据）同时显示，文本会重影，效果就糟糕了。<br>删除条目的列控件使用如下函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::removeItemWidget(QTreeWidgetItem * item, int column)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>这个函数没有返回值，会自动地彻底删除条目列控件。</strong></p><p>​        在大多数情况下都用不到 itemWidget ，因为能够为条目设置可编辑标志位，然后调用如下函数开启树形控件自带的文本编辑器：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::editItem(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数 item 是指定的条目，column 是条目的列（类似“单元格”）。在没有为条目设置可编辑标志位的情况下，可以调用下面一对函数进行持续编辑器的开启和关闭：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::openPersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)void QTreeWidget::closePersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <strong>注意这对函数一开一关，要成对调用，否则编辑完了不会自动关闭持续编辑器。</strong></p><h3 id="（7）信号"><a href="#（7）信号" class="headerlink" title="（7）信号"></a>（7）信号</h3><p>​        关于当前高亮选中变化的信号 currentItemChanged() 前面讲过了，这里先列几个常规的信号，然后再将树形控件独有的信号。常规信号就是下面这 几个：（条目列就类似表格控件的单元格）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void itemActivated(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被激活void itemChanged(QTreeWidgetItem * item, int column)   &#x2F;&#x2F;条目列的数据发生变化，比如文本或图标修改了void itemClicked(QTreeWidgetItem * item, int column)  &#x2F;&#x2F;条目列被单击void itemDoubleClicked(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被双击void itemEntered(QTreeWidgetItem * item, int column) &#x2F;&#x2F;进入条目列void itemPressed(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被点 击按下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>树形控件最独特的就是展开和折叠信号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::itemExpanded(QTreeWidgetItem * item)  &#x2F;&#x2F;条目展开时发送信号void QTreeWidget::itemCollapsed(QTreeWidgetItem * item) &#x2F;&#x2F;条目折叠时发送信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        如果调用槽函数 expandAll() 展开所有子孙条目，那么不会触发 itemExpanded() 信号，因为触发太多会非常影响性能。<br>​        类似地，如果用槽函数 collapseAll() 折叠所有子孙条目，也不会触发 itemCollapsed() 信号，以免影响性能。<br>举例来说，在文件夹浏览的时候，因为操作系统里的文件太多，没法一次性构建完整的文件树，那么就可以用展开和折叠信号实时枚举某一层次文件夹的内容， 而不是一次性 枚举文件系统所有文件，因为一次性枚举所有文件的性能太糟糕。<br>树形控件还有一个 <strong>itemSelectionChanged</strong>() 信号，一般在多选模式才会用到，稍后讲解。</p><h3 id="（8）槽函数"><a href="#（8）槽函数" class="headerlink" title="（8）槽函数"></a>（8）槽函数</h3><p>​        树形控件的槽函数包括四个（基类的另算）：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void clear() &#x2F;&#x2F;清空整个树形控件void collapseItem(const QTreeWidgetItem * item) &#x2F;&#x2F;折叠指定的条目void expandItem(const QTreeWidgetItem * item)  &#x2F;&#x2F;展开指定 条目void scrollToItem(const QTreeWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible) &#x2F;&#x2F;滚动到指定条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        滚动函数 scrollToItem() 第二个参数是<strong><em>\</em>滚到到该条目的显示方式**</strong>，参考“8.1.1 QListWidget”QAbstractItemView::  ScrollHint 枚举常量的表格。</p><h3 id="（9）基类-QTreeView-的函数"><a href="#（9）基类-QTreeView-的函数" class="headerlink" title="（9）基类 QTreeView 的函数"></a>（9）基类 QTreeView 的函数</h3><p>QTreeView 的功能函数也很多，这里列举几个可能常用的，详细的内容等到模型视图章节讲解。关于列隐藏或显示、设置列宽的函数如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeView::setColumnHidden(int column, bool hide) &#x2F;&#x2F;设置列隐藏或显示bool QTreeView::isColumnHidden(int column) const &#x2F;&#x2F;判断列是否隐藏void QTreeView::hideColumn(int column) &#x2F;&#x2F;槽函数，隐藏指定列void QTreeView::showColumn(int column) &#x2F;&#x2F;槽函数，显示指定列void QTreeView::setColumnWidth(int column, int width) &#x2F;&#x2F;设置列宽int QTreeView::columnWidth(int column) const &#x2F;&#x2F;获取指定列的宽度void QTreeView::resizeColumnToContents(int column) &#x2F;&#x2F;槽函数，自动调整 指定列的宽度属性  &#x2F;&#x2F;indentation 控制显示父子节点的缩进宽度：int indentation() const    &#x2F;&#x2F;获取父子节点的缩进宽度void setIndentation(int i) &#x2F;&#x2F;设置缩进宽度void resetIndentation()    &#x2F;&#x2F;重置缩进宽度为默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基类还有几个常用的折叠和展开槽函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void collapseAll() &#x2F;&#x2F;折叠所有子孙节点，这样只能看到顶级节点void expandAll() &#x2F;&#x2F;展开所有子孙节点，完全展开的树void expandToDepth(int depth) &#x2F;&#x2F;展开 depth 层级的子节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        expandToDepth() 函数是指一直展开，直到将第 depth 层级的子节点都展开为止。以顶级条目为第 0 层级，顶级条目的直接子节点为第 1 层级，孙子节点为第 2 层级，依次类推。<br>​        例如 expandToDepth(0) 的效果如下：</p><p><img src="c1f8eac3f9ec327ea98347e5abab1354.png" alt="c1f8eac3f9ec327ea98347e5abab1354.png"></p><p>​        如果调用 expandToDepth(1) 展开第1级的节点：</p><p><img src="590d3ad8a2fcae012d2240bdbe9a012c.png" alt="590d3ad8a2fcae012d2240bdbe9a012c.png"></p><p>​        如果把 expandToDepth() <strong>参数设置成负数，那么相当于展开无穷大级别，就是展开所有的子孙节点。</strong></p><h3 id="（10）树头条目"><a href="#（10）树头条目" class="headerlink" title="（10）树头条目"></a>（10）树头条目</h3><p>​        树形控件只有一个表头，就是<strong>显示在上面的水平表头，本节也叫树头条目</strong>。设置树头条目的函数为：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setHeaderItem(QTreeWidgetItem * item) &#x2F;&#x2F;设置树头条目，树头条目可以有多列数据，相当于多列的表头一次性设置了。void QTreeWidget::setHeaderLabel(const QString &amp; label) &#x2F;&#x2F;只设置第 0 列的表头void QTreeWidget::setHeaderLabels(const QStringList &amp; labels) &#x2F;&#x2F;设置多列的表头QTreeWidgetItem * QTreeWidget::headerItem() const &#x2F;&#x2F;获取树头条目树头条目本质其实也是由 QHeaderView 子控件来显示的，可以在基类找到相关函数：QHeaderView * QTreeView::header() const &#x2F;&#x2F;获取表头视图控件void QTreeView::setHeader(QHeaderView * header) &#x2F;&#x2F;设置表头视图， 一般树形控件不需要用这个函数void QTreeView::setHeaderHidden(bool hide) &#x2F;&#x2F;设置表头是否隐藏bool QTreeView::isHeaderHidden() const &#x2F;&#x2F;判断是否隐藏了表头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        无论是 QTableWidget 还是 QTreeWidget 的表头，都是 QHeaderView 子控件显示，QHeaderView 参考“8.2.3 表头设置”的内容。</p><h3 id="（11）选中行为和选中模式"><a href="#（11）选中行为和选中模式" class="headerlink" title="（11）选中行为和选中模式"></a>（11）选中行为和选中模式</h3><p>​        与 QTableWidget 类似，QTreeWidget也从祖类 QAbstractItemView 继承了选中行为和选中模式的属性：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QAbstractItemView::SelectionBehavior  selectionBehavior() const &#x2F;&#x2F;获取选中行为，按条目选中、整行或整列选中void setSelectionBehavior(QAbstractItemView::SelectionBehavior behavior) &#x2F;&#x2F;设置选中行为QAbstractItemView::SelectionMode  selectionMode() const &#x2F;&#x2F;获取选中模式，比如单选、多选、扩展选择void setSelectionMode(QAbstractItemView::SelectionMode mode) &#x2F;&#x2F;设置选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        关于选中模式和选中行为的枚举常量参看“8.2.4 选中区域和选中行为”小节中的枚举常量表格，单次选中命令的函数和枚举常量也参考该小节。</p><p>​        默认情况下，树形控件是按照整行选中，并且是单选模式，如果把选中模式改成多选的 QAbstractItemView::ExtendedSelection，那么树形控件也可以使多选的，这时候信号 itemSelectionChanged() 就能派上用场：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">void</span> <span class="token class-name static-context">QTreeWidget</span><span class="token operator">::</span><span class="token function">itemSelectionChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        多选状态变化时会触发该信号（单选模式也触发，只是不需要用这个信号），可以关联该信号，监视当前所有选中的条目：</p><pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">QList<span class="token operator">&lt;</span>QTreeWidgetItem <span class="token comment">*> QTreeWidget::selectedItems() const</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        注意，<strong>这里的选中条目仅仅是指实际显示的直接选中的条目，不包括折叠隐藏的子孙条目计数</strong>，因为选中父节点与选中其子孙节点没关系，不会递归选中所有子 孙：</p><p><img src="c216490e8c65baf4903b5093b2deddcc.png" alt="c216490e8c65baf4903b5093b2deddcc.png"></p><p>​        树形控件及其基类没有递归选中子条目的属性或函数，<strong>如果希望递归选中某个节点的所有子孙节点，那么需要自行编写递归函数。</strong>关于树形控件类本身的内容介 绍到这，因为 涉及到父子节点隶属关系、节点展开和折叠，树形控件还有很大一部分功能都是由其条目类 QTreeWidgetItem 的函数实现的.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include&lt;QListWidgetItem&gt;#include&lt;QStringList&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;       ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt;&quot;卢本伟&quot;&lt;&lt;&quot;牛逼&quot;);QTreeWidgetItem* item &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐&quot;);    QTreeWidgetItem* item2 &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐2&quot;);    ui-&gt;treeWidget-&gt;addTopLevelItem(item);    ui-&gt;treeWidget-&gt;addTopLevelItem(item2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230526200623971.png" alt="image-20230526200623971"></p><h1 id="QT-NEW-11"><a href="#QT-NEW-11" class="headerlink" title="QT NEW 11"></a>QT NEW 11</h1><h2 id="主要控件-1"><a href="#主要控件-1" class="headerlink" title="主要控件"></a>主要控件</h2><h3 id="QTableWidget"><a href="#QTableWidget" class="headerlink" title="QTableWidget"></a>QTableWidget</h3><p><img src="image-20230526200740443.png" alt="image-20230526200740443"></p><pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Table widgets provide standard table display facilities for applications. The items in a QTableWidget are provided by QTableWidgetItem.<br>​        If you want a table that uses your own data model you should use QTableView rather than this class.<br>​        Table widgets can be constructed with the required numbers of rows and columns:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">tableWidget &#x3D; new QTableWidget(12, 3, this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Alternatively, tables can be constructed without a given size and resized later:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">tableWidget &#x3D; new QTableWidget(this);tableWidget-&gt;setRowCount(10);tableWidget-&gt;setColumnCount(5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        Items are created outside the table (with no parent widget) and inserted into the table with setItem():</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem *newItem &#x3D; new QTableWidgetItem(tr(&quot;%1&quot;).arg(\         (row+1)*(column+1)));tableWidget-&gt;setItem(row, column, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        If you want to enable sorting in your table widget, do so after you have populated it with items, otherwise sorting may interfere with the insertion order (see setItem() for details).<br>Tables can be given both horizontal and vertical headers. The simplest way to create the headers is to supply a list of strings to the setHorizontalHeaderLabels() and setVerticalHeaderLabels() functions. These will provide simple textual headers for the table’s columns and rows. More sophisticated headers can be created from existing table items that are usually constructed outside the table. For example, we can construct a table item with an icon and aligned text, and use it as the header for a particular column:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem *cubesHeaderItem &#x3D; new QTableWidgetItem(tr(&quot;Cubes&quot;));cubesHeaderItem-&gt;setIcon(QIcon(QPixmap(&quot;:&#x2F;Images&#x2F;cubed.png&quot;)));cubesHeaderItem-&gt;setTextAlignment(Qt::AlignVCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        The number of rows in the table can be found with rowCount(), and the number of columns with columnCount(). The table can be cleared with the clear() function.</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>​        原博客：</p><p>​        <a href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p><h2 id="QTableWidgetItem"><a href="#QTableWidgetItem" class="headerlink" title="QTableWidgetItem"></a>QTableWidgetItem</h2><p>​        表格控件条目 QTableWidgetItem 与 8.1.2 节 <a href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 有很多相似的地方，<br>QTableWidgetItem 也是一个纯数据类，不是控件，没有基类，也就没有信号和槽函数。QTableWidgetItem 可以直接用数据流 <a href="https://so.csdn.net/so/search?q=QDataStream&amp;spm=1001.2101.3001.7020">QDataStream</a> 读写，表格条目不单单有文本，还可以有自己的图标、复选框等特性，表格控件会根据条目对象的丰富特性来呈现数据并进行交互操作。</p><h3 id="（1）首先来看看条目的构造函数："><a href="#（1）首先来看看条目的构造函数：" class="headerlink" title="（1）首先来看看条目的构造函数："></a>（1）<strong>首先来看看条目的构造函数：</strong></h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem(int type &#x3D; Type)QTableWidgetItem(const QString &amp; text, int type &#x3D; Type)QTableWidgetItem(const QIcon &amp; icon, const QString &amp; text, int type &#x3D; Type)QTableWidgetItem(const QTableWidgetItem &amp; other) &#x2F;&#x2F;复制构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        参数里的 type 一般用于派生类，指定条目独特的分类，对于普通的表格控件条目，通常用默认的数值即可。第二个构造函数是指定了条目的文本，第三个构造函数同 时指定了条目图标和文本。<br>​        在构造函数里不能直接指定所属的表格控件，因为表格控件有行号、列号所以不能简单追加到表格里，而只能用表格控件的 QTableWidget::setItem() 函数把条目设置到指定单元格里。注意一个条目只能设置给表格控件唯一的一个单元格，不能把一个条目设置给多个单元格。如果希望为多个单元格设置相似的条目数据内容，那么可 以用后面介绍的 clone() 函数制造大量新的复制体条目。<br>​        复制构造函数不会复制旧条目的 type() 类型值和tableWidget() 所属表格控件指针，条目其他的内部数据和条目标志都会复制。</p><h3 id="（2）复制函数和运算符函数"><a href="#（2）复制函数和运算符函数" class="headerlink" title="（2）复制函数和运算符函数"></a>（2）<strong>复制函数和运算符函数</strong></h3><p>​        除了复制构造函数，还有专门的克隆函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem * QTableWidgetItem::clone() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        克隆函数会新建一个当前条目的复制体，然后返回新复制体条目的指针，如果要构造并添加大量重复内容的条目，这个函数就比较实用。clone() 函数内部会调用复制构造函数创建新条目并返回。<br>​        条目复制还可以用等于号函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        等于号函数复制的内容与复制构造函数差不多，type() 类型值和 tableWidget() 所属表格控件指针也不复制。<br>​        还有个小于号函数，可以比较条目文本的字典序：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果希望使用更多的比较函数，可以直接用 QString 的比较函数。</p><h3 id="（3）QTableWidgetItem-的功能函数与内部数据"><a href="#（3）QTableWidgetItem-的功能函数与内部数据" class="headerlink" title="（3）QTableWidgetItem 的功能函数与内部数据"></a>（3）<strong>QTableWidgetItem 的功能函数与内部数据</strong></h3><p>​        QTableWidgetItem 内部的数据也大致分为两类：第一类是以数据角色形式管理的通用数据，这些数据自动参与 QDataStream 数据流的读写；第二类是非通用数据，不参与数据流读写，与 QListWidgetItem 和 QListWidget 自身特性有关。QTableWidgetItem 主要的功能函数也是围绕这两类内部数据展开的。</p><p>​        ● <strong>第一类：通用数据及其处理函数</strong><br>​        通用数据是以数据角色与数据变量一一对应的形式存储管理，比如设置文本 setText()、设置图标 setIcon() 等函数，其本质都是根据各自的角色调用通用设置数据的函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">virtual void setData(int role, const QVariant &amp; value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也可以根据角色来获取各个数据变量：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">virtual QVariant data(int role) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        查看表格控件的源代码文件可以看到关于图标操作函数的源码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> QIcon <span class="token function">icon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>     <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">qvariant_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QIcon<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DecorationRole<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">QTableWidgetItem</span><span class="token double-colon punctuation">::</span><span class="token function">setIcon</span><span class="token punctuation">(</span><span class="token keyword">const</span> QIcon <span class="token operator">&amp;</span>aicon<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">setData</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DecorationRole<span class="token punctuation">,</span> aicon<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        QTableWidgetItem 的通用数据与 QListWidgetItem 的通用数据一模一样，函数名也一样，列表如下：</p><div class="table-container"><table><thead><tr><th><strong>获取函数</strong></th><th><strong>设置函数</strong></th><th><strong>数据角色</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>text()</td><td>setText(const QString &amp;text)</td><td>Qt::DisplayRole</td><td>条目显示的文本。</td></tr><tr><td>icon()</td><td>setIcon(const QIcon &amp;icon)</td><td>Qt::DecorationRole</td><td>条目显示的图标。</td></tr><tr><td>statusTip()</td><td>setStatusTip(const QString &amp;statusTip)</td><td>Qt::StatusTipRole</td><td>如果主界面有状态栏，鼠标悬停在该条目上时显示该状态信息到状态栏。</td></tr><tr><td>toolTip()</td><td>setToolTip(const QString &amp;toolTip)</td><td>Qt::ToolTipRole</td><td>鼠标悬停在该条目上时显示的工具提示信息。</td></tr><tr><td>whatsThis()</td><td>setWhatsThis(const QString &amp;whatsThis)</td><td>Qt::WhatsThisRole</td><td>如果主界面窗口标题栏有？帮助按钮，点击帮助按钮再点击该条目会显示该帮助信息。</td></tr><tr><td>font()</td><td>setFont(const QFont &amp;font)</td><td>Qt::FontRole</td><td>显示条目文本用的字体。</td></tr><tr><td>textAlignment()</td><td>setTextAlignment(int alignment)</td><td>Qt::TextAlignmentRole</td><td>文本的对齐方式。</td></tr><tr><td>backgroundColor()</td><td>setBackgroundColor(const QColor &amp;color)</td><td>Qt::BackgroundColorRole</td><td>文本背景色。</td></tr><tr><td>textColor()</td><td>setTextColor(const QColor &amp;color)</td><td>Qt::TextColorRole</td><td>文字颜色。</td></tr><tr><td>background()</td><td>setBackground(const QBrush &amp;brush)</td><td>Qt::BackgroundRole</td><td>条目的背景画刷。</td></tr><tr><td>foreground()</td><td>setForeground(const QBrush &amp;brush)</td><td>Qt::ForegroundRole</td><td>条目的前景画刷。</td></tr><tr><td>checkState()</td><td>setCheckState(Qt::CheckState state)</td><td>Qt::CheckStateRole</td><td>条目自带的复选框选中状态，可以是三态复选框。</td></tr><tr><td>sizeHint()</td><td>setSizeHint(const QSize &amp;size)</td><td>Qt::SizeHintRole</td><td>条目显示的建议尺寸。</td></tr></tbody></table></div><p>​        表格条目 QTableWidgetItem 可以直接用数据流 QDataStream 读写，是通过下面运算符重载函数实现的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QDataStream &amp;    operator&lt;&lt;(QDataStream &amp; out, const QTableWidgetItem &amp; item)QDataStream &amp;    operator&gt;&gt;(QDataStream &amp; in, QTableWidgetItem &amp; item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        使用 &gt;&gt; 和 &lt;&lt; 运算符进行流输入输出比较常见，当然也可以用 QTableWidgetItem 类内部的读写函数进行输入输出：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTableWidgetItem::read(QDataStream &amp; in)void QTableWidgetItem::write(QDataStream &amp; out) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​         <strong>第二类：非通用数据及其操作函数</strong><br>表格控件的条目也是在构造函数一次性指定条目类型，然后这个类型是只读的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTableWidgetItem::type() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        类型值一般用于派生类区分不同的条目类型，自定义的条目类型值需要大于等于 QTableWidgetItem::UserType 。<br>​        新条目通过表格控件 QTableWidget::setItem() 函数设置给表格控件之后，条<strong>目会自动保存所属的表格控件指针，</strong>可以用如下函数获取：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidget * QTableWidgetItem::tableWidget() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        程序运行时，除了可以通过表格控件的 QTableWidget::selectedItems() 获取用户选中的条目列表，每个单元格条目自身也会记录是否 被用户选中，并且能设置自身是否被选中：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool QTableWidgetItem::isSelected() const &#x2F;&#x2F;判断条目自身是否高亮选中void QTableWidgetItem::setSelected(bool select) &#x2F;&#x2F;设置条目自身是 否被选中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        <strong>表格控件条目初始化时也有默认的标志位，并且运行时可以修改条目的特性标志：</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Qt::ItemFlags QTableWidgetItem::flags() const &#x2F;&#x2F;获取特性标志位void QTableWidgetItem::setFlags(Qt::ItemFlags flags) &#x2F;&#x2F;设置特性标志位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        QTableWidgetItem 构造<strong>时默认的标志位为</strong>：</p><div class="table-container"><table><thead><tr><th>QT宏</th></tr></thead><tbody><tr><td>Qt::ItemIsSelectable</td></tr><tr><td>Qt::ItemIsUserCheckable</td></tr><tr><td>Qt::ItemIsEnabled</td></tr><tr><td>Qt::ItemIsDragEnabled</td></tr><tr><td>Qt::ItemIsDropEnabled</td></tr><tr><td>Qt::ItemIsEditable</td></tr></tbody></table></div><p>​        因此程序代码生成的所有表格条目默认都是可编辑的，程序运行时用户双击空的单元格时，表格控件会自动创建新条目保存用户编辑内容，这些自动创建的条目也都是可编辑的。如果希望条目是只读的，那么把标志位设置不带Qt::ItemIsEditable 的新标志位即可。</p><p>​        Qt::ItemFlags 所有的枚举常量在 8.1.2 节末尾有详细的表格描述，这里不重复贴了。表格条目默认就是支持复选状态的，只是默认没有显示出来，要让表格控件显示条目对应的复选框，可以用下面一句代码实现：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">item-&gt;setCheckState( Qt::Unchecked );  &#x2F;&#x2F;显示复选框<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        对于表格控件和表格条目，自带单行编辑器和复选框功能，因此不需要为单元格添加自定义的单行编辑器或复选框，如果要用到其他更多的输入控件，那才需要定制单元格。<br>​        表格控件条目与 QListWidgetItem 最大的一个区别就是表格条目既有行号，也有列号：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTableWidgetItem::row() const &#x2F;&#x2F;获取行号int QTableWidgetItem::column() const &#x2F;&#x2F;获取列号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        行号和列号也是在 QTableWidget::setItem() 函数里指定的，条目自身并不能修改行号或列号。表格控件条目与 QListWidgetItem 另一个区别是，<strong>表格控件条目没有隐藏函数，所有表格条目都是显示的（只要不被单元格控件QTableWidget::cellWidget() 遮挡）。</strong></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent)    : QWidget(parent)    , ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F;设函数列数    ui-&gt;tableWidget-&gt;setColumnCount(3);    &#x2F;&#x2F;设置表头    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;&quot;姓名&quot;&lt;&lt;&quot;性别&quot;&lt;&lt;&quot;年龄&quot;);    ui-&gt;tableWidget-&gt;setRowCount(10);    ui-&gt;tableWidget-&gt;setItem(0,0,new QTableWidgetItem(&quot;泰勒&quot;));&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230526202457563.png" alt="image-20230526202457563"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT new 7-8</title>
      <link href="/2023/05/26/QT-new-7-8/"/>
      <url>/2023/05/26/QT-new-7-8/</url>
      
        <content type="html"><![CDATA[<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p>​            可是我们的点击事件还是没有任何反应。下面使用信号与槽让他动起来</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include&lt;QDialog&gt;#include&lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F; 点击新建按钮来弹出对话框    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;        &#x2F;&#x2F; 对话框 分类        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）        QDialog dlg(this);  &#x2F;&#x2F;创建一个        dlg.exec();        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;    &#125;);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230516215248714.png" alt="image-20230516215248714"></p><p>​        出现这样的警告，说明是对话框太小了，需要调整</p><p><img src="image-20230516215825806.png" alt="image-20230516215825806"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include&lt;QDialog&gt;#include&lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F; 点击新建按钮来弹出对话框    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;        &#x2F;&#x2F; 对话框 分类        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）        QDialog dlg(this);        dlg.resize(100,200);        dlg.exec();        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;    &#125;);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        那我们现在来看一个非模糊的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include&lt;QDialog&gt;#include&lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F; 点击新建按钮来弹出对话框    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;        &#x2F;&#x2F; 对话框 分类        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）&#x2F;&#x2F;        QDialog dlg(this);&#x2F;&#x2F;        dlg.resize(100,200);&#x2F;&#x2F;        dlg.exec();        QDialog* dig &#x3D; new QDialog(this); &#x2F;&#x2F; 不可以开栈上，对象一show完就没了！        dig-&gt;resize(100,200);        dig-&gt;show();        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;    &#125;);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        为了防止用户一直点，一直创建对话框，我们可以设置关闭就删掉的属性</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">dig-&gt;setAttribute(Qt::WA_DeleteOnClose);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="QT-NEW8"><a href="#QT-NEW8" class="headerlink" title="QT NEW8"></a>QT NEW8</h1><h2 id="消息对话框"><a href="#消息对话框" class="headerlink" title="消息对话框"></a>消息对话框</h2><p>​        系统自己提供了大量的对话框，如：</p><p>​        QColorDialog                选择颜色</p><p>​        QFileDialog                    选择文件或者目录</p><p>​        QFontDialog                    选择字体</p><p>​        QInputDialog                允许用户输入一个值</p><p>​        QMessageDialog            模态对话框</p><p>​        QPageSetUpDialog        为打印机提供相关选项</p><p>​        QPrintDialog                    打印机配置</p><p>​        QPrintPreviewDialog        打印预览</p><p>​        QProcessDialog                显示操作过程</p><p>​        我们现在着重看看消息框是啥情况！在帮助文档下搜索QMessageBox</p><p><img src="image-20230519123236586.png" alt="image-20230519123236586"></p><p>​        下面显示之。</p><pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    ui.setupUi(this);    QMessageBox::critical(this, &quot;critical&quot;, &quot;666&quot;);&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230519123918761.png" alt="image-20230519123918761"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    ui.setupUi(this);    QMessageBox::information(this, &quot;information&quot;, &quot;666&quot;);&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++</p><p><img src="image-20230519124310043.png" alt="image-20230519124310043"></p><pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    ui.setupUi(this);    QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;);&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230519124401064.png" alt="image-20230519124401064"></p><p><img src="image-20230519124448267.png" alt="image-20230519124448267"></p><p>​        于是可以更改参数就好了。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;,QMessageBox::Save|QMessageBox::Cancel);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230519124653246.png" alt="image-20230519124653246"></p><p>​        这个函数参数是这样的：</p><p>​        参数1：父类</p><p>​        参数2：标题</p><p>​        参数3：提示内容</p><p>​        参数4：按键类型</p><p>​        参数5：默认回车关联的按键</p><p>​        返回参数：用户选择</p><p>如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;#include&lt;tchar.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    setLocale(QLocale::AnyLanguage);    ui.setupUi(this);    if (QMessageBox::Save &#x3D;&#x3D; QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;, QMessageBox::Save | QMessageBox::Cancel)) &#123;        qDebug() &lt;&lt; &quot;you clicked the save&quot;;    &#125;&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        想看Debug信息去项目属性那里更改一下输出为控制台即可！</p><p><img src="image-20230519125534877.png" alt="image-20230519125534877"></p><p>​        来看看其他demo:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;#include&lt;qcolordialog.h&gt;#include&lt;qcolor.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    setLocale(QLocale::AnyLanguage);    ui.setupUi(this);    QColor color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));    qDebug() &lt;&lt; &quot;r &#x3D; &quot; &lt;&lt; color.red() &lt;&lt; &quot;g &#x3D; &quot; &lt;&lt; color.green() &lt;&lt; &quot;h &#x3D; &quot; &lt;&lt; color.blue() ;&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230519125944025.png" alt="image-20230519125944025"></p><p><img src="image-20230519125950425.png" alt="image-20230519125950425"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;#include&lt;qmessagebox.h&gt;#include&lt;qcolordialog.h&gt;#include&lt;qcolor.h&gt;#include&lt;qfile.h&gt;#include&lt;qfiledialog.h&gt;QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)    : QMainWindow(parent)&#123;    setLocale(QLocale::AnyLanguage);    ui.setupUi(this);    &#x2F;*QColor color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));    qDebug() &lt;&lt; &quot;r &#x3D; &quot; &lt;&lt; color.red() &lt;&lt; &quot;g &#x3D; &quot; &lt;&lt; color.green() &lt;&lt; &quot;h &#x3D; &quot; &lt;&lt; color.blue() ;*&#x2F;&#125;QtWidgetsApplication1::~QtWidgetsApplication1()&#123;    QFileDialog::getOpenFileName(        this,&#x2F;&#x2F; 设置父亲        &quot;open the file&quot;, &#x2F;&#x2F; caption        &#x2F;&#x2F;目录        &quot;D:\\&quot;&#x2F;&#x2F;文件夹        &quot;(*.txt)&quot;&#x2F;&#x2F;过滤器，回忆Linux通配符就好了！    );&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230519130333549.png" alt="image-20230519130333549"></p><p>​        返回的是文件的路径！这个可以注意一下！</p><h2 id="登录窗口界面布局介绍"><a href="#登录窗口界面布局介绍" class="headerlink" title="登录窗口界面布局介绍"></a>登录窗口界面布局介绍</h2><p>​        现在使用Widget控件把一些模块分类装之，随后垂直布局，就是这样</p><p><img src="image-20230519131530620.png" alt="image-20230519131530620"></p><h2 id="QListWidget空间"><a href="#QListWidget空间" class="headerlink" title="QListWidget空间"></a>QListWidget空间</h2><p><img src="image-20230523200845020.png" alt="image-20230523200845020"></p><p>​        是的！从这里拖一个QListWidget控件出来！</p><p><img src="image-20230523201158972.png" alt="image-20230523201158972"></p><p>​        代码里如上图所示，运行：</p><p><img src="image-20230523201220072.png" alt="image-20230523201220072"></p><p>​        也可以使用类似于list的容器放置一大堆内容：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QListWidgetItem&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)    , ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    QListWidgetItem* item &#x3D; new QListWidgetItem(&quot;锄禾日当午&quot;);    ui-&gt;listWidget-&gt;addItem(item);    item-&gt;setTextAlignment(Qt::AlignHCenter);    &#x2F;&#x2F; QStringList      List&lt;String&gt;    QStringList list;    list &lt;&lt; &quot;锄禾日当午&quot;&lt;&lt;&quot;汗&quot;;    ui-&gt;listWidget-&gt;addItems(list);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230523201833675.png" alt="image-20230523201833675"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows-API-程序设计（2）</title>
      <link href="/2023/05/19/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89/"/>
      <url>/2023/05/19/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="系统学习Windows-API-2"><a href="#系统学习Windows-API-2" class="headerlink" title="系统学习Windows API 2"></a>系统学习Windows API 2</h1><h2 id="Windows数据结构"><a href="#Windows数据结构" class="headerlink" title="Windows数据结构"></a>Windows数据结构</h2><p>​        这里的数据结构指的是Windows文件体系的结构。</p><p>​        这里的结构是用老式的C定义与实现的，为了与之对应，我们采取打开一个文件的属性查看作为可视化的理解。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef struct _WIN32_FILE_ATTRIBUTE_DATA &#123;    DWORD dwFileAttributes;&#x2F;&#x2F; 文件属性    FILETIME ftCreationTime;&#x2F;&#x2F; 创建时间    FILETIME ftLastAccessTime;&#x2F;&#x2F; 最后访问时间    FILETIME ftLastWriteTime;&#x2F;&#x2F; 最后修改    DWORD nFileSizeHigh;&#x2F;&#x2F; 文件长度    DWORD nFileSizeLow; &#x2F;&#x2F; 文件长度&#125; WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230516204344506.png" alt="image-20230516204344506"></p><p>​        下面我们来看怎样使用这样的结构. </p><h2 id="一些函数的讲解"><a href="#一些函数的讲解" class="headerlink" title="一些函数的讲解"></a>一些函数的讲解</h2><p>​        我们获取文件属性使用Windows的<code>GetFileAttributesEx</code>函数宏,他需要参数文件地址,获取方式和<code>WIN32_FILE_ATTRIBUTE_DATA</code>结构体.这个函数跟我们熟悉的C变成一样,以参数的参数进入返回初始化后的参数.</p><h3 id="GetFileAttributesEx"><a href="#GetFileAttributesEx" class="headerlink" title="GetFileAttributesEx()"></a>GetFileAttributesEx()</h3><h4 id="GetFileAttributesExW-函数-fileapi-h"><a href="#GetFileAttributesExW-函数-fileapi-h" class="headerlink" title="GetFileAttributesExW 函数 (fileapi.h)"></a>GetFileAttributesExW 函数 (fileapi.h)</h4><p>反馈</p><p>检索指定文件或目录的属性。</p><p>若要将此操作作为事务处理操作执行，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-getfileattributestransacteda">GetFileAttributesTransacted</a> 函数。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetFileAttributesExW</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  LPCWSTR                lpFileName<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  GET_FILEEX_INFO_LEVELS fInfoLevelId<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPVOID                 lpFileInformation<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><pre class="line-numbers language-none"><code class="language-none">[in] lpFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        文件或目录的名称。</p><p>​        在此函数的 ANSI 版本中，名称限制为 <strong>MAX_PATH</strong> 个字符。 若要将此限制扩展到 32，767 宽字符，请调用函数的 Unicode 版本 (<strong>GetFileAttributesExW</strong>) ，并将“\\？\”追加到路径。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-file">命名文件</a>。</p><p><strong>提示</strong></p><p>从 Windows 10 版本 1607 开始，对于此函数的 unicode 版本， (<strong>GetFileAttributesExW</strong>) ，可以选择加入以删除<strong>MAX_PATH</strong>字符限制，而无需追加“\\？\”。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径限制”部分。</p><pre class="line-numbers language-none"><code class="language-none">[in] fInfoLevelId<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        要检索的属性信息的类。</p><p>​        此参数可以是 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> 枚举中的以下值。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>GetFileExInfoStandard</strong></td><td style="text-align:left"><em>lpFileInformation</em> 参数是<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">一个WIN32_FILE_ATTRIBUTE_DATA</a>结构。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[out] lpFileInformation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向接收属性信息的缓冲区的指针。</p><p>​        存储在此缓冲区中的属性信息类型由 fInfoLevelId 的值决定。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果函数成功，则返回值为非零值。</p><p>​        如果函数失败，则返回值为 0 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p><h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><p>​        现在我们拿到了初始化结束的结构体,我们想看看时间.要知道,显示时间是可以多样化的,意味着微软希望我们自己书写函数来展示之.</p><p>​        为了提高效率,时间被压缩在几个字节,需要我们自己来转化.这个也是一个结构体<code>FileTime</code>.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void showFileTime(PFILETIME aTime)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;iostream&gt;using namespace std;void showFileTime(PFILETIME aTime)&#123;FILETIME filetimeLocal;SYSTEMTIME sysFileTime;FileTimeToLocalFileTime(aTime, &amp;filetimeLocal);&#x2F;&#x2F; 转换成系统时区时间FileTimeToSystemTime(&amp;filetimeLocal, &amp;sysFileTime);cout &lt;&lt; sysFileTime.wYear &lt;&lt; &quot; 年 &quot; &lt;&lt; sysFileTime.wMonth &lt;&lt; &quot; 月 &quot; &lt;&lt; \sysFileTime.wDay &lt;&lt; &quot; 日 &quot; &lt;&lt; sysFileTime.wHour&lt;&lt;&quot;时&quot; &lt;&lt; sysFileTime.wMinute &lt;&lt; &quot; 分 &quot; &lt;&lt; sysFileTime.wSecond &lt;&lt; &quot; 秒&quot; &lt;&lt; endl;return;&#125;void showInfo(LPWIN32_FILE_ATTRIBUTE_DATA pWfad)&#123;if (pWfad &#x3D;&#x3D; NULL) &#123;cout &lt;&lt; &quot;Failed to get the file&quot;;return;&#125;showFileTime(&amp;pWfad-&gt;ftCreationTime);showFileTime(&amp;pWfad-&gt;ftLastAccessTime);&#125;int main()&#123;WIN32_FILE_ATTRIBUTE_DATA wfad;if (!GetFileAttributesEx(L&quot;1.cpp&quot;, GetFileExInfoStandard, &amp;wfad))&#123;cout &lt;&lt; &quot;Failed to get the file&quot;;return 1;&#125;showInfo(&amp;wfad);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230516211817965.png" alt="image-20230516211817965"></p><h2 id="获取系统目录"><a href="#获取系统目录" class="headerlink" title="获取系统目录"></a>获取系统目录</h2><p>​        为了获取系统目录信息，需要使用函数来完成这项工作！这个函数是<code>GetSystemDirectory()</code></p><p>​        使用它很简单：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;locale.h&gt;int main() &#123;setlocale(LC_ALL,&quot;&quot;);TCHAR szSystemDir[MAX_PATH];GetSystemDirectory(szSystemDir, MAX_PATH);printf(&quot;%ls&quot;, szSystemDir);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="GetSystemDirectoryW-函数-sysinfoapi-h"><a href="#GetSystemDirectoryW-函数-sysinfoapi-h" class="headerlink" title="GetSystemDirectoryW 函数 (sysinfoapi.h)"></a>GetSystemDirectoryW 函数 (sysinfoapi.h)</h3><p>​        检索系统目录的路径。 系统目录包含系统文件，如动态链接库和驱动程序。</p><p>​        此函数主要用于兼容性。 应用程序应将代码存储在 Program Files 文件夹中，并将持久数据存储在用户配置文件的 Application Data 文件夹中。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">ShGetFolderPath</a>。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">UINT <span class="token function">GetSystemDirectoryW</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpBuffer<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  UINT   uSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向要接收路径的缓冲区的指针。 除非系统目录是根目录，否则此路径不会以反斜杠结尾。 例如，如果系统目录在驱动器 C 上命名为 Windows\System32，则此函数检索的系统目录的路径为 C：\Windows\System32。</p><pre class="line-numbers language-none"><code class="language-none">[in] uSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        缓冲区的最大大小（以 <strong>TCHAR</strong> 为单位）。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值为复制到缓冲区的字符串的长度（以 <strong>TCHAR</strong> 为单位），不包括终止 null 字符。 如果长度大于缓冲区的大小，则返回值是保存路径所需的缓冲区大小，包括终止 null 字符。</p><p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><p>​        </p><p><img src="image-20230518231050866.png" alt="image-20230518231050866"></p><p>​        下面写之进入一个文件！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;locale.h&gt;int main() &#123;setlocale(LC_ALL,&quot;&quot;);TCHAR szSystemDir[MAX_PATH];GetSystemDirectory(szSystemDir, MAX_PATH);printf(&quot;%ls&quot;, szSystemDir);DWORD dwWritten;HANDLE hFile;hFile &#x3D; CreateFile(L&quot;SystemRoot.txt&quot;, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);if (hFile !&#x3D; INVALID_HANDLE_VALUE) &#123;if (!WriteFile(hFile, szSystemDir, 2*lstrlen(szSystemDir), &amp;dwWritten, NULL)) &#123;return GetLastError();&#125;&#125;CloseHandle(hFile);printf(&quot;OK&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建窗口和消息处理"><a href="#创建窗口和消息处理" class="headerlink" title="创建窗口和消息处理"></a>创建窗口和消息处理</h2><p>​        两大方法：使用向导来创建窗口，或者是手写代码自己来写</p><p>​        我们来创建一个Windows应用程序。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; WindowsProject1.cpp : 定义应用程序的入口点。&#x2F;&#x2F;#include &quot;framework.h&quot;#include &quot;WindowsProject1.h&quot;#define MAX_LOADSTRING 100&#x2F;&#x2F; 全局变量:HINSTANCE hInst;                                &#x2F;&#x2F; 当前实例WCHAR szTitle[MAX_LOADSTRING];                  &#x2F;&#x2F; 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING];            &#x2F;&#x2F; 主窗口类名&#x2F;&#x2F; 此代码模块中包含的函数的前向声明:ATOM                MyRegisterClass(HINSTANCE hInstance);BOOL                InitInstance(HINSTANCE, int);LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance,                     _In_opt_ HINSTANCE hPrevInstance,                     _In_ LPWSTR    lpCmdLine,                     _In_ int       nCmdShow)&#123;    UNREFERENCED_PARAMETER(hPrevInstance);    UNREFERENCED_PARAMETER(lpCmdLine);    &#x2F;&#x2F; TODO: 在此处放置代码。    &#x2F;&#x2F; 初始化全局字符串    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);    LoadStringW(hInstance, IDC_WINDOWSPROJECT1, szWindowClass, MAX_LOADSTRING);    MyRegisterClass(hInstance);    &#x2F;&#x2F; 执行应用程序初始化:    if (!InitInstance (hInstance, nCmdShow))    &#123;        return FALSE;    &#125;    HACCEL hAccelTable &#x3D; LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSPROJECT1));    MSG msg;    &#x2F;&#x2F; 主消息循环:    while (GetMessage(&amp;msg, nullptr, 0, 0))    &#123;        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))        &#123;            TranslateMessage(&amp;msg);            DispatchMessage(&amp;msg);        &#125;    &#125;    return (int) msg.wParam;&#125;&#x2F;&#x2F;&#x2F;&#x2F;  函数: MyRegisterClass()&#x2F;&#x2F;&#x2F;&#x2F;  目标: 注册窗口类。&#x2F;&#x2F;ATOM MyRegisterClass(HINSTANCE hInstance)&#123;    WNDCLASSEXW wcex;    wcex.cbSize &#x3D; sizeof(WNDCLASSEX);    wcex.style          &#x3D; CS_HREDRAW | CS_VREDRAW;    wcex.lpfnWndProc    &#x3D; WndProc;    wcex.cbClsExtra     &#x3D; 0;    wcex.cbWndExtra     &#x3D; 0;    wcex.hInstance      &#x3D; hInstance;    wcex.hIcon          &#x3D; LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));    wcex.hCursor        &#x3D; LoadCursor(nullptr, IDC_ARROW);    wcex.hbrBackground  &#x3D; (HBRUSH)(COLOR_WINDOW+1);    wcex.lpszMenuName   &#x3D; MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1);    wcex.lpszClassName  &#x3D; szWindowClass;    wcex.hIconSm        &#x3D; LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));    return RegisterClassExW(&amp;wcex);&#125;&#x2F;&#x2F;&#x2F;&#x2F;   函数: InitInstance(HINSTANCE, int)&#x2F;&#x2F;&#x2F;&#x2F;   目标: 保存实例句柄并创建主窗口&#x2F;&#x2F;&#x2F;&#x2F;   注释:&#x2F;&#x2F;&#x2F;&#x2F;        在此函数中，我们在全局变量中保存实例句柄并&#x2F;&#x2F;        创建和显示主程序窗口。&#x2F;&#x2F;BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123;   hInst &#x3D; hInstance; &#x2F;&#x2F; 将实例句柄存储在全局变量中   HWND hWnd &#x3D; CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);   if (!hWnd)   &#123;      return FALSE;   &#125;   ShowWindow(hWnd, nCmdShow);   UpdateWindow(hWnd);   return TRUE;&#125;&#x2F;&#x2F;&#x2F;&#x2F;  函数: WndProc(HWND, UINT, WPARAM, LPARAM)&#x2F;&#x2F;&#x2F;&#x2F;  目标: 处理主窗口的消息。&#x2F;&#x2F;&#x2F;&#x2F;  WM_COMMAND  - 处理应用程序菜单&#x2F;&#x2F;  WM_PAINT    - 绘制主窗口&#x2F;&#x2F;  WM_DESTROY  - 发送退出消息并返回&#x2F;&#x2F;&#x2F;&#x2F;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123;    switch (message)    &#123;    case WM_COMMAND:        &#123;            int wmId &#x3D; LOWORD(wParam);            &#x2F;&#x2F; 分析菜单选择:            switch (wmId)            &#123;            case IDM_ABOUT:                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);                break;            case IDM_EXIT:                DestroyWindow(hWnd);                break;            default:                return DefWindowProc(hWnd, message, wParam, lParam);            &#125;        &#125;        break;    case WM_PAINT:        &#123;            PAINTSTRUCT ps;            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...            EndPaint(hWnd, &amp;ps);        &#125;        break;    case WM_DESTROY:        PostQuitMessage(0);        break;    default:        return DefWindowProc(hWnd, message, wParam, lParam);    &#125;    return 0;&#125;&#x2F;&#x2F; “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123;    UNREFERENCED_PARAMETER(lParam);    switch (message)    &#123;    case WM_INITDIALOG:        return (INT_PTR)TRUE;    case WM_COMMAND:        if (LOWORD(wParam) &#x3D;&#x3D; IDOK || LOWORD(wParam) &#x3D;&#x3D; IDCANCEL)        &#123;            EndDialog(hDlg, LOWORD(wParam));            return (INT_PTR)TRUE;        &#125;        break;    &#125;    return (INT_PTR)FALSE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这就是一个demo,下面我们使用手写的办法来写一个超级简化版本</p><p><img src="image-20230519142819377.png" alt="image-20230519142819377"></p><p>​        基本原理</p><p>​        先看窗口：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef struct tagWNDCLASSEXW &#123;    UINT        cbSize;    &#x2F;* Win 3.x *&#x2F;    UINT        style;    WNDPROC     lpfnWndProc;    int         cbClsExtra;    int         cbWndExtra;    HINSTANCE   hInstance;    HICON       hIcon;    HCURSOR     hCursor;    HBRUSH      hbrBackground;    LPCWSTR     lpszMenuName;    LPCWSTR     lpszClassName;    &#x2F;* Win 4.0 *&#x2F;    HICON       hIconSm;&#125; WNDCLASSEXW, *PWNDCLASSEXW, NEAR *NPWNDCLASSEXW, FAR *LPWNDCLASSEXW;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;#include&lt;tchar.h&gt;HWND hwnd;HINSTANCE hInst;LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) &#123;&#x2F;&#x2F;窗口WNDCLASSEX wcx;&#x2F;&#x2F;消息MSG msg;BOOL fGotMsg;wcx.cbSize &#x3D; sizeof(wcx);wcx.style &#x3D; CS_HREDRAW | CS_VREDRAW; &#x2F;&#x2F; 发生大小改变时再次绘制窗口wcx.lpszClassName &#x3D; L&quot;MainWndProc&quot;;wcx.lpfnWndProc &#x3D; MainWndProc;wcx.cbClsExtra &#x3D; 0;&#x2F;&#x2F; 不使用额外内存wcx.cbWndExtra &#x3D; 0;wcx.hInstance &#x3D; hInstance;wcx.hIcon &#x3D; LoadIcon(NULL,IDI_APPLICATION);wcx.hCursor &#x3D; LoadCursor(NULL, IDC_ARROW);wcx.hbrBackground &#x3D; (HBRUSH)GetStockObject(WHITE_BRUSH);wcx.lpszMenuName &#x3D; NULL;wcx.hIconSm &#x3D; (HICON)LoadImage(hInstance, MAKEINTRESOURCE(5),IMAGE_ICON, GetSystemMetrics(SM_CXSMICON),GetSystemMetrics(SM_CXSMICON),LR_DEFAULTCOLOR);&#x2F;&#x2F; 注册！在创建if (!RegisterClassEx(&amp;wcx)) &#123;return -1;&#125;TCHAR h1[] &#x3D; L&quot;hello&quot;;TCHAR h2[] &#x3D; L&quot;hello&quot;;hwnd &#x3D; CreateWindowEx(0, h1, h2, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, \CW_USEDEFAULT, 300, 180, NULL, NULL, hInstance, NULL);if (!hwnd) &#123;return GetLastError();&#125;ShowWindow(hwnd, nCmdShow);UpdateWindow(hwnd);&#x2F;&#x2F;提升优先级到最先&#x2F;&#x2F; 消息队列取消息while ((fGotMsg &#x3D; GetMessage(&amp;msg, (HWND)NULL, 0, 0))!&#x3D;0) &#123;TranslateMessage(&amp;msg); &#x2F;&#x2F; 一些消息需要翻译DispatchMessage(&amp;msg); &#x2F;&#x2F;转发消息给窗口过程&#125;return msg.wParam;&#125;&#x2F;&#x2F;LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) &#123;switch (uMsg) &#123;case WM_DESTROY:PostQuitMessage(0); &#x2F;&#x2F; 退出线程return 0;case WM_LBUTTONDOWN:MessageBox(hwnd, L&quot;hello&quot;, L&quot;hello&quot;, MB_OK);return 0;default:return DefWindowProc(hwnd, uMsg, wParam, lParam);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Windows 32API </tag>
            
            <tag> 摸鱼ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>More Effective C++(1)</title>
      <link href="/2023/05/19/More-Effective-C-1/"/>
      <url>/2023/05/19/More-Effective-C-1/</url>
      
        <content type="html"><![CDATA[<h1 id="More-Effective-C-1"><a href="#More-Effective-C-1" class="headerlink" title="More Effective C++ 1"></a>More Effective C++ 1</h1><h2 id="Basic-Issues"><a href="#Basic-Issues" class="headerlink" title="Basic Issues"></a>Basic Issues</h2><p>我们现在开始C++的一大名著阅读.在这个sections，更多关注的是基础的C++议题。</p><h3 id="条款1-区分pointers-和-reference"><a href="#条款1-区分pointers-和-reference" class="headerlink" title="条款1 区分pointers 和 reference"></a>条款1 区分pointers 和 reference</h3><p>​        Pointers和reference确实不一样。在使用方式上，我们对Pointers是*（解引用）和<code>-&gt;</code>的方式来访问Reference确跟对象本身一样，访问成员使用 . </p><p>​        作为Reference，不存在空引用！也就是说，不存在一个引用不指向任何对象。这点上，真是跟指针不大一样！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char* pc &#x3D; 0;char* pc1 &#x3D; &amp;aCh; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        当然，那这样如何呢？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char *pc &#x3D; 0;char&amp; rc &#x3D; *pc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        答案是未定义行为！千万别显示的，或者是隐式的做这样的事情！</p><p>​        其二，基于上面的阐述，被引用的对象——必须——在引用之前就被初始化！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string&amp; rs; &#x2F;&#x2F; 不存在这样的代码！这是非法的string s(&quot;xxyyzz&quot;);string&amp; rs &#x3D; s;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        相对应的——</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string* ps;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        通过编译！但是，比如说我的编译器会警告你没有初始化。于是，有必要对指针的合法性进行判断，而引用从来没有必要关注这件事情。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;void checkPointersValid(double* pt) &#123;if (pt &#x3D;&#x3D; nullptr) &#123;throw &quot;trying to use empty double pointer! that&#39;s really bad :(&quot;;return;&#125;std::cout &lt;&lt; &quot;Got value:&gt; &quot; &lt;&lt; *pt &lt;&lt; std::endl;return;&#125;void Processing(double* pt) &#123;try &#123;checkPointersValid(pt);&#125;catch (const char* errorStr) &#123;std::cout &lt;&lt; errorStr &lt;&lt; std::endl;exit(-1);&#125;return;&#125;int main() &#123;double val &#x3D; 10;double* p1 &#x3D; &amp;val;double* null &#x3D; nullptr;Processing(p1);Processing(null);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        很是复杂。。。</p><p>​        另一个重要的区别在于：pointers是可变的，它可以从指向一个内存，原生的话，不加以说明的——指向另一块内存，而不会告诉你这件事情——这是很危险的（对于指向堆内存的话，容易造成泄漏）。但是reference就相当于常指针，总是指向那个对象不会改变。</p><p>​        总结来看：当你——需要考虑到“不指向任何对象”的可能性时，或者考虑：在不同时间需要指向不同对象的可能性时，有必要使用指针来完成你的工作，其余的情况下可以使用reference。</p><h3 id="条款2：最好使用C-转型操作符"><a href="#条款2：最好使用C-转型操作符" class="headerlink" title="条款2：最好使用C++转型操作符"></a>条款2：最好使用C++转型操作符</h3><p>​        在旧时的C语言，我们如下转换类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">(target_type)expression<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然而，这样的作法没有经过检查且辨识度太低了：为了解决这个问题，C++引入了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">static_cast&lt;target_type&gt;(expression)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        来个例子：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int res1 &#x3D; 10, res2 &#x3D; 20;double do_res &#x3D; static_cast&lt;double&gt;(res1)&#x2F;res2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        static_cast跟旧时的C一样有威力，也拥有一样的限制。甚至不可以移除const修饰符，于是const_cast来干这个事情了。</p><p>​        const_cast只可以改变变量的常量性和变易性。其余的都改变不了！</p><p><img src="D:\Hexo-Blog\source\_posts\More-Effective-C-1\image-20230514123125051-16844694129151.png" alt="image-20230514123125051"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class widget &#123;public:int a;&#125;;class specialWidget :public widget &#123;public:int b;&#125;;void update(specialWidget* psw) &#123;&#125;int main() &#123;specialWidget sw;const specialWidget&amp; csw &#x3D; sw;update(&amp;csw); &#x2F;&#x2F; invalidupdate(const_cast&lt;specialWidget*&gt;(&amp;csw)); &#x2F;&#x2F; finish work properly!update((specialWidget*)&amp;csw);widget* pw &#x3D; new specialWidget;update(pw);&#x2F;&#x2F;error ： 类型错误，不可以需要孩子传父亲！update(const_cast&lt;specialWidget*&gt;(pw)); &#x2F;&#x2F; error&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还有个dynamic_cast，特别用在了安全的向下转性或者跨系转型的动作。也就是说，可以将指向基类的指针或引用转向指向派生或者是兄弟类的类的指针或者是引用。他没有办法用在缺乏虚函数的类型，也不可改变常量性！</p><h3 id="条款3：不要以多态的方式处理数组"><a href="#条款3：不要以多态的方式处理数组" class="headerlink" title="条款3：不要以多态的方式处理数组"></a>条款3：不要以多态的方式处理数组</h3><p>​        继承的最重要的性质之一就是可以通过指向基类的指针或者是引用来操纵派生类。比如说</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class BST&#123;...&#125;class BalancedBST: public BST&#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        打印这些东西，我们涉及到：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void PrintBSTArray(ostream&amp; os,const BSTarray[],int numElems)&#123;    &#x2F;&#x2F; omit some basic check    for(int i &#x3D; 0; i &lt; int numElems; i++)&#123;        os&lt;&lt;array[i]; &#x2F;&#x2F; pretended that it has already been designed for using &lt;&lt;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是下一次传入：BalancedBST的时候，我们却依然实际上生成的是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">os &lt;&lt; array + sizeof(BST)*i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        而不是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">os &lt;&lt; array + sizeof(BalancedBST)*i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这很麻烦了！倘若这个函数是删除元素的话，就意味着删除是不完全的！因为基类总是不会比派生类小的！而且行为未定义！极易造成程序的崩溃！所以不要一多态的方式来处理数组，是啥就是啥的处理！</p><h3 id="条款四：非必要不提供默认构造函数"><a href="#条款四：非必要不提供默认构造函数" class="headerlink" title="条款四：非必要不提供默认构造函数"></a>条款四：非必要不提供默认构造函数</h3><p>​        Default constructors是C++从无到有的生成一个对象的办法。这个东西你不指定初始化方法，其成员也会拥有一些值——对于数值者是０或者是其他些什么无意义的随机值，对于指针者是nullptr。一些内置的数据结构被初始化作空容器。</p><p>​        但是有一些类，倘若我们不提供任何其他信息，是不应该存在的！也就是说：一些可以从无到有的类才适合default constructor.反之不需要。比如说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class EquipmentPieces&#123;      public:    EquipmentPieces(int ID);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是不难意料到：这样的初始化不可能合法：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">EquipmentPieces EqVec[10];&#x2F;&#x2F; no Default constructors<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        哪有该怎么办嘞，要不我们：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int IDArray[]&#x3D;&#123;1,2,3,...&#125;;&#x2F;&#x2F; make the Id valid previouslyEquipmentPiece eqVec[10] &#x3D; &#123;        EquipmentPiece(IDArray[0]),    EquipmentPiece(IDArray[1]),    ...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是这没办法解决我们在堆上完成类似的行为。于是，我们不妨先声明指针数组</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef EquipmentPieces* PEP;PEP aPointerArray[10];&#x2F;&#x2F; in stackPEP aPointerArrayInHeap[10] &#x3D; new PEP[10];for(int i &#x3D; 0; i &lt; 10; i++)&#123;        aPointerArrayInHeap[i] &#x3D; new EquipmentPieces(ID[i]);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        麻烦在于，我们必须记住我们在这里开辟了内存，是需要我们手动释放的。其次，可能指针本身还要占据内存，这是不好的。</p><p>​        于是还有第三种方法，那就是类似于C式的——先分配空数据，让数组指针指向之！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* rawMem &#x3D; operator new[](10*sizeof(EquipmentPiece));EquipmentPiece* EPArray &#x3D; static_cast&lt;EquipmentPiece*&gt; (rawMem);for(int i &#x3D; 0; i &lt; 10; i++)&#123;    new(&amp;bestPieces[i]) EquipmentPieces(ID[i]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        就算如此，你会发现还得是要手动初始化！况且，释放掉他需要很麻烦的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for(int i &#x3D; 0 i &gt;&#x3D; 0; i--)&#123;epVec[i].~EquipmentPieces();&#125;operator delete[](rawMem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        一个没有默认构造器的类很快还会有第二个麻烦，那就是没办法直接调用大部分的模板！你当然可以谨慎的设计之来回避这个问题。但是大部分人只有会在出现问题的时候想起来这回事情。</p><p>​        所以要不要它呢？注意到如果一切类都给了默认构造器，我们就必须手动的检查它，否则会产生大量的问题！</p><p>​        于是，还是回到这里：倘若我们不提供任何其他信息，是不应该存在的！也就是说：一些可以从无到有的类才适合default constructor.反之不需要！</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="条款5：对定制的类型转换符保持警觉"><a href="#条款5：对定制的类型转换符保持警觉" class="headerlink" title="条款5：对定制的类型转换符保持警觉"></a>条款5：对定制的类型转换符保持警觉</h3><p>​        C++自然允许不同类型之间的隐式转换，我是说，比如说</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">short a &#x3D; 10;double b &#x3D; a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        居然是可行的！这还好，C++甚至可以：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">double b &#x3D; 10.00；char a &#x3D; b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这样会造成信息丢失的转换都是可以正常运行的！ 这是因为C++编译器会想尽办法的找到</p><p>​        于是，在C++的类设计上，有必要专门提供一个转换函数来促使之客户程序员调用，</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Rational&#123;public:    Rational(double a, double b); &#x2F;&#x2F; make a&#x2F;b &#125;;Rational r(1,2);cout &lt;&lt; r;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这居然是可以输出的：0.5！</p><p>​        这是因为C++编译器会想尽办法的找到转化方式。这就很容易造成自己不期望你被调用的函数被调用了！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Rational&#123;public:    Rational(double a, double b); &#x2F;&#x2F; make a&#x2F;b 、    double asDouble() const;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，显示的调用即可：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cout &lt;&lt; r.asDouble()&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        或者，采用关键字explict来防止隐式转换！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;class T&gt;class Array&#123;    public:    ...        explicit Array(int num);    ...&#125;;Array&lt;int&gt; a(10);Array&lt;int&gt; b(10);if(a &#x3D;&#x3D; b[i])&#x2F;&#x2F; invalid!!! as it is expicited, you can not transform it underconciously!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条款6区分前置操作符和后置操作符"><a href="#条款6区分前置操作符和后置操作符" class="headerlink" title="条款6区分前置操作符和后置操作符"></a>条款6区分前置操作符和后置操作符</h3><p>​        在很久以前的C++，没办法区分前置＋＋和后置＋＋（或者－－）。于是，我们这样设计类来防止语法混淆：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;class UpInt &#123;public:UpInt(int i) :_val(i) &#123;&#125;;UpInt&amp; operator++() &#123; this-&gt;_val++; return *this; &#125;;const UpInt operator++(int) &#123; UpInt old &#x3D; *this; ++(*this); return old; &#125;;UpInt&amp; operator--()&#123; this-&gt;_val--; return *this; &#125;const UpInt operator--(int) &#123; UpInt old &#x3D; *this; --(*this); return old; &#125;;int getVal()const &#123; return _val; &#125;private:int _val;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; os, const UpInt&amp; my_data) &#123; os &lt;&lt; my_data.getVal() &lt;&lt; endl; return os; &#125;;int main() &#123;UpInt val(10);++val;cout &lt;&lt; val;--val;cout &lt;&lt; val;val++;cout &lt;&lt; val;val--;cout &lt;&lt; val;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        为什么:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const UpInt operator++(int) &#123; UpInt old &#x3D; *this; ++(*this); return old; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为我们是为了防止:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int i &#x3D; 0;i++++; &#x2F;&#x2F; invalid! C++ abandon this behaviors<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        所以就是直接禁止!只需要加个const将返回的对象常量化!就好了</p><h3 id="条款7：千万不要重载-amp-amp-和-操作符"><a href="#条款7：千万不要重载-amp-amp-和-操作符" class="headerlink" title="条款7：千万不要重载&amp;&amp;,|| 和 , 操作符"></a>条款7：千万不要重载&amp;&amp;,|| 和 , 操作符</h3><p>​        继承于C的，C++对真假值的逻辑表达式也是采用“骤死式”的判别表达式。也就是说，针对这样的表达式：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">char* p;...&#x2F;&#x2F; probably init the string or notif((p !&#x3D; NULL) &amp;&amp; (strlen(p) &gt; 10))&#123;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不需要担心strlen(p)会使用空指针，事实上，一旦判定 p == NULL，那就意味着这个表达式一定为假，就不需要我们去计算第二个式子。于是第二条甚至不会执行。</p><p>​        但是，一旦我们重载了，就无法预期编译器的行为。</p><p>​        于是在C++中，一些运算符是不可以重载的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">..*::?: new  deletesizeoftypeidstatic_castdynamic_castconst_castreinterpret_cast<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="条款8：了解不同含义的new和delete"><a href="#条款8：了解不同含义的new和delete" class="headerlink" title="条款8：了解不同含义的new和delete"></a>条款8：了解不同含义的new和delete</h3><p>​        我们必须指出，C++的语言有时候确实令人感到难绷，比如说我们会说new operator和operator new 不是一件事情！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string* phs &#x3D; new string(&quot;Memory Managements&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        首先，这个new式语言内建的，就是说：首先他分配足够多的内存，放置一个东西。然后调用编译器找到的最合适的初始constructor来完成初始化工作！这样的行为不可以我们改变。</p><p>​        我们可以改变什么啥呢？改变operator new。什么意思？我们发现，new在一些适合调用一个函数执行必要的内存分配空间。这个函数我们可以重写！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* operator new(size_t size);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也就是说，这是一个操作符函数，该函数返回一个空的内存！嘿，就像malloc函数一样！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* rawMem &#x3D; operator new(sizeof(string));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        于是，new operator实际上就是operator new + 内存初始化了</p><pre class="line-numbers language-none"><code class="language-none">string* phs &#x3D; new string(&quot;Memory Managements&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        等价于</p><pre class="line-numbers language-none"><code class="language-none">void* tempName &#x3D; operator new(sizeof(string));call the func &gt;&gt; string::string(&quot;Memory Managements&quot;); on tempmemorystring* ps &#x3D; static_cast&lt;string*&gt;(memory);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        还有一种有趣的new ，叫placement new. 啥意思？就是我们已经知道了指定了一个地方就要放摸一个类的对象，那就可以用之</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Widget&#123;    public:    Widget(size_t size);    ...&#125;;Widget* constructWidgetInBuffer(void* buffer,size_t size)&#123; return new(buffer) Widget(size);   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        欸我的嘛，抽象！其实这是在隐式的调用operator new</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* operator new(size_t size,void* locations)&#123;        return locations;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Deletion-amp-amp-Deallocation"><a href="#Deletion-amp-amp-Deallocation" class="headerlink" title="Deletion &amp;&amp; Deallocation"></a>Deletion &amp;&amp; Deallocation</h4><p>​        为了避免 resource leak （资源泄露），每一个动态分配行为都必须分配一个。函数operator delete 对于内建的delete operator 对于内建的 delete operator ，好像operator new 对于 new operator 一样。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string* ps;&#x2F;&#x2F;...delete ps;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>     你的编译器必须产生怎样的代码？它必须可以析构ps所指对象。又可以释放该对象占用的内存。</code></pre><p>​        内存释放动作由于函数operator delete 执行。通常声明如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void operator delete(void* memoryToBeDeallocated);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        由此delete ps;</p><p>​        造成编译器产生这样的代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ps-&gt;~string();operator delete(ps);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这里呈现的一个暗示就是，如果你只打算处理原始的，未设置初值的内存，应该完全回避new operator 和 delete operators。改用operator new取得内存并以 operator delete 归还给系统。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* buffer &#x3D; operator new(50*sizeof(char));&#x2F;&#x2F;...operator delete(buffer);    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>     这组行为在C++相当于malloc和free.</code></pre><p>​        如果你使用placement new, 在某内存块中产生的对象，你应该避免对那块内存使用 delete operator. 因为delete operator调用operator delete释放内存，但是该内存含有的对象最初并非是由operator new 分配得来的。毕竟placement new只是返回它所接受的指针而已，谁知道那个指针从哪里来呢？所以为了抵消该对象的构建器的影响，我们选择直接调用对象的destructor。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void* mallocShared(size_t size);void freeShared(void *memory);void *sharedMemory &#x3D; mallocShared(sizeof(Widget));Widget* pW &#x3D; constructWidgetInBuffer(sharedMemory,10);...&#x2F;&#x2F; delete pW; 不要这样做！没有意义，因为sharedMemory来自mallocShared函数而不是new 出来的！pW-&gt;~Widget();&#x2F;&#x2F;可以的！手动调用析构器是允许的freeShared(pW);&#x2F;&#x2F; 可以的！释放pW所指向的内存，不调用任何destructor!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Arrays数组"><a href="#Arrays数组" class="headerlink" title="Arrays数组"></a>Arrays数组</h4><p>​        下面，我们考虑一些更远的事情，我是说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string* ps &#x3D; new string[10];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        用的还是new operator，但是这次是数组！于是，我们实际上调用的是它的兄弟oprator new[ ]!当然这也就意味着我们可以重写之，但是往往重写全局的new函数是不明智的，因为其他的new operator也会发生行为的改变而使得程序发生剧烈的变化！</p><p>​        类似的，删除使用了new operator</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>​        C++增加了Exceptions 之后，改变了太多的事情。比如说原始指针的使用成为了一个高风险事件，资源泄露的风险也是大增。</p><p>​        但是为了使程序可以在触发异常后安全的退出程序，就必须使用它来处理推出前的工作！</p><h3 id="条款9：使用destructor来防止内存泄漏"><a href="#条款9：使用destructor来防止内存泄漏" class="headerlink" title="条款9：使用destructor来防止内存泄漏"></a>条款9：使用destructor来防止内存泄漏</h3><p>​        假设我们现在正在书写一个类（Adorable Little Animal）ALA，我们在之后派生出来了小猫和小狗两个类</p><p><img src="D:\Hexo-Blog\source\_posts\More-Effective-C-1\image-20230519100041781-16844694129162.png" alt="image-20230519100041781"></p><p>​        为了实现领养工作，我们在抽象类下书写虚函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class ALA &#123;public:virtual void processAdoption() &#x3D; 0;&#x2F;&#x2F; 强迫重写protected:string name;&#125;;class Puppy : public ALA&#123;public:virtual void processAdoption();&#125;;class Kitten :public ALA &#123;public:virtual void processAdoption();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        大致如此</p><p>​        现在我们需要读取星系返回一个ALA指针</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ALA* readALA(istream&amp; s);&#x2F;&#x2F; 不在谈论怎么实现<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        于是，我们的收养问题实际上可以这样书写：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 框架void processAdoption(istream&amp; dataSource)&#123;while(dataSource)&#123;        ALA *pa &#x3D; readALA(dataSource);        pa-&gt;processAdoption();        delete pa;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这要求我们函数走遍dataSource，处理所有的信息，显然的——我们调用一次，就必须释放一次！</p><p>​        现在出现问题了：假如说我们的 <code>pa-&gt;processAdoption()</code>抛出了一个异常！麻烦大了，这个异常会追溯到调用端，导致<code>delete pa;</code>被跳过了，也就是说，只要触发一次异常，资源泄露一次！</p><p>​        这个时候，C++的Exception就可以出马了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void processAdoption(istream&amp; dataSource)&#123;while(dataSource)&#123;        ALA *pa &#x3D; readALA(dataSource);       try&#123;           pa-&gt;processAdoption();       &#125;        catch(...)&#123;            delete pa;            throw;&#x2F;&#x2F;再把异常传递出去        &#125;        delete pa;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        嘿！实在是太麻烦了！为什么不让delete代码剧中于一处呢？这就是智能指针的来源！我们只需要使用智能指针指向之，当发现需要被析构的时候就直接析构就好了。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void processAdoption(istream&amp; dataSource)&#123;    while(dataSource)&#123;        unique_ptr&lt;ALA&gt; pa(readALA(dataSource));        pa-&gt;processAdoption();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        隐藏在智能指针背后的理念是——以一个对象存放“必须自动释放的资源”，并且是依赖他自己的destructor来干这样的事情。</p><p>​        下面来看窗口设计，比如说我们来看使用窗口显示信息</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void displayInfo(const Information&amp; info)&#123;    WINDOW_HANDLE w(createWindow());        &#x2F;&#x2F;displayInfo here        destroyWindow(w);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还是先前的问题，如果允许时发生了exception，我们怎么办？</p><p>​        我们设计一个class：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class WindowHandle&#123;    public:    WindowHnadle(WINDOW_HANDLE handle):w(handle)&#123;&#125;;    ~WindowHandle()&#123;destroyWindow(w)&#125;;    operator WINDOW_HANDLE()&#123;return w;&#125;;        private:    WINDOW_HANDLE w;    WindowHandle(const WindowHandle&amp;);    WindowHandle&amp; operator&#x3D;(const WindowHandle);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们把复制和赋值行为给静止了，同时还给予了一个隐式操作符！，于是，这个函数的设计变得十分的简单：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void displayInfo(const Information&amp; info)&#123;   WindowHandle w(createWindow());    &#x2F;&#x2F;displayInfo here&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在我们把它作为临时对象可以销毁了！</p><h3 id="条款10：在constructor内部阻止内存泄漏"><a href="#条款10：在constructor内部阻止内存泄漏" class="headerlink" title="条款10：在constructor内部阻止内存泄漏"></a>条款10：在constructor内部阻止内存泄漏</h3><p>​        我们再说一遍，Exception的出现不太好，比如说我们正在写通讯录：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;list&gt;using namespace std;class Image &#123;public:Image(const string&amp; imageDataFileName);&#125;;class AudioClip &#123;public:AudioClip(const string&amp; audioDataFileName);&#125;;class PhoneNumber &#123;&#125;;class BookEntry &#123;public:BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;);~BookEntry();void addPhoneNumber(const PhoneNumber&amp; phoneNumber);private:string theName;string theAddr;list&lt;PhoneNumber&gt; thePhone;Image* theImage;AudioClip* theAudioClip;&#125;;BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(0), theAudioClip(0) &#123;if (imageFile !&#x3D; &quot;&quot;) &#123;theImage &#x3D; new Image(imageFile);&#125;if (audioClipFile !&#x3D; &quot;&quot;) &#123;theAudioClip &#x3D; new AudioClip(audioClipFile);&#125;&#125;BookEntry::~BookEntry() &#123;delete theImage;delete theAudioClip;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是当现在有了异常之后，假使我们正在初始化的对象抛出异常，就还会发生资源泄漏，即使使用智能指针也不行，因为其调用的destructor要求对象必须已经构建完整！</p><p>​        解决的办法是，在constructor内部就完成异常处理！</p><p>​        </p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(0), theAudioClip(0) &#123;try&#123;if (imageFile !&#x3D; &quot;&quot;) &#123;theImage &#x3D; new Image(imageFile);&#125;if (audioClipFile !&#x3D; &quot;&quot;) &#123;theAudioClip &#x3D; new AudioClip(audioClipFile);&#125;&#125;catch (...) &#123;delete theImage;delete theAudioClip;throw;&#x2F;&#x2F; &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        清除这个过程还是可以抽象成一个私有函数！把他放到类里去：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;list&gt;using namespace std;class Image &#123;public:Image(const string&amp; imageDataFileName);&#125;;class AudioClip &#123;public:AudioClip(const string&amp; audioDataFileName);&#125;;class PhoneNumber &#123;&#125;;class BookEntry &#123;public:BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;);~BookEntry();void addPhoneNumber(const PhoneNumber&amp; phoneNumber);private:string theName;string theAddr;list&lt;PhoneNumber&gt; thePhone;Image* theImage;AudioClip* theAudioClip;void cleanUp();&#125;;void BookEntry::cleanUp() &#123;delete theImage;delete theAudioClip;&#125;BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(0), theAudioClip(0) &#123;try&#123;if (imageFile !&#x3D; &quot;&quot;) &#123;theImage &#x3D; new Image(imageFile);&#125;if (audioClipFile !&#x3D; &quot;&quot;) &#123;theAudioClip &#x3D; new AudioClip(audioClipFile);&#125;&#125;catch (...) &#123;cleanUp();throw;&#x2F;&#x2F; &#125;&#125;BookEntry::~BookEntry() &#123;cleanUp();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们再次改进：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class BookEntry &#123;public:BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;);~BookEntry();void addPhoneNumber(const PhoneNumber&amp; phoneNumber);private:string theName;string theAddr;list&lt;PhoneNumber&gt; thePhone;Image* const theImage;AudioClip* const theAudioClip;void cleanUp();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在外面就必须通过初值链表的方式才会给予之赋值。这样就可以这样给予一个安全的初始化方式</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(imageFile !&#x3D; &quot;&quot;?new Image(ImageFile):0), theAudioClip(audioClipFile !&#x3D; &quot;&quot;? new AudioClip(audioClipFile):0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是这又把问题绕回去了！</p><p>​        于是，为了使异常不流到外面，外面直接使用组合的方式完成任务：其构造函数放到类私有的地方：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class BookEntry&#123;    public:BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;);~BookEntry();void addPhoneNumber(const PhoneNumber&amp; phoneNumber);private:string theName;string theAddr;list&lt;PhoneNumber&gt; thePhone;Image* const theImage;AudioClip* const theAudioClip;void cleanUp();    Image* initImage(const string&amp; imageFile);    AudioClip* initAudioClipFile(const string&amp; audioClipFile);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是可以改写了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(initImage(imageFile)), theAudioClip(initAudioClipFile(audioClipFile))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        把异常处理转换到函数的内部：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Image* BookEntry::initImage(const string&amp; imageFile)&#123;    if(imageFile !&#x3D; &quot;&quot;)        return new ImageFile(imageFile);    else return 0;&#125;&#x2F;&#x2F;这里不用，因为他是第一个被初始化，出现了其他问题会直接被释放<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">AudioClip* BookEntry::initAudioClipFile(const string&amp; audioClipFile)&#123;try&#123;        if(audioClipFile !&#x3D; &quot;&quot;)&#123;            return new AudioClip(audioClipFile);        &#125;       else return 0;    &#125;    catch(...)&#123;        delete theImage;        throw;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        好吧，维护有些困难！那就是用<code>unique_ptr</code>!</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class BookEntry&#123;    public:BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;);~BookEntry();void addPhoneNumber(const PhoneNumber&amp; phoneNumber);private:string theName;string theAddr;list&lt;PhoneNumber&gt; thePhone;const unique_ptr&lt;Image&gt; theImage;const unique_ptr&lt;AudioClip&gt; theAudioClip;void cleanUp();    Image* initImage(const string&amp; imageFile);    AudioClip* initAudioClipFile(const string&amp; audioClipFile);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，就可以回到上一个设计了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BookEntry::BookEntry(const string&amp; name,const string&amp; addr &#x3D; &quot;&quot;,const string&amp; imageFile &#x3D; &quot;&quot;,const string&amp; audioClipFile &#x3D; &quot;&quot;) :theName(name), theAddr(addr), theImage(imageFile !&#x3D; &quot;&quot;?new Image(ImageFile):0), theAudioClip(audioClipFile !&#x3D; &quot;&quot;? new AudioClip(audioClipFile):0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        同时，不在需要构建手写destructor了，直接放：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">BookEntry::~BookEntry()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="条款11-禁止异常流出destructor"><a href="#条款11-禁止异常流出destructor" class="headerlink" title="条款11 禁止异常流出destructor"></a>条款11 禁止异常流出destructor</h3><p>​        假设现在外面的析构爆发问题了，我们的办法是：在里头使用try_catch语句接受处理之，甚至是这样：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Session::~Session()&#123;    try&#123;        logDestruction(this);    &#125;    catch(...)&#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这使得异常直接被吸收，防止程序调用std::abort()造成释放不完全！</p><h3 id="条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”"><a href="#条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”" class="headerlink" title="条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”"></a>条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”</h3><p>​        首先声明：我们调用函数返回到的是函数的调用端（除非失败了），而异常抛出一定不会回到抛出端！</p><p>​        如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">istream operator&lt;&lt;(istream&amp; s,Widget&amp; w);void passAndThrowWidget()&#123;    Widget localWidget;    cin &gt;&gt; localWidget;    throw localWidget;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们把localWidget交到operator&gt;&gt;手里的时候，没有发生复制行为，而是绑定到reference上操作！（passByReference）,但是Exception不一样！无论是值传递还是引用传递，他都会发生复制行为！这是容易理解的：我们一旦调用了<code>throw localWidget</code>，程序离开函数，造成了<code>localWidget</code>析构，我们的catch如果是reference传递，那传的是一具尸体！好吧，我们就不得不复制了！这造成了throw是很慢的（特别是对象很大的时候）</p><p>​        现在事情复杂起来了！假使我们：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Widget&#123;&#125;;class SpecialWidget:public Widget&#123;&#125;;void passAndThrowWidget()&#123;    SpecialWidget localSpecialWidget;    ...    Widget&amp; rw &#x3D; localSpecialWidget;    throw rw;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不是SpeicalWidget类型！因为这里抛出的是静态类型！复制的永远会是对象的静态类型！这是我们需要注意的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">catch(Widget&amp; w)&#123;    ...    throw;&#125;&#x2F;&#x2F; andcatch(Widget&amp; w)&#123;    ...    throw w;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不是一回事情，前者传入的啥抛出的就是啥！不会发生复制行为。但是第二种就会！于是，有必要对那些就是想要处理的一场样本的对象直接使用</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">throw;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        即可！</p><p>​        对于继承体制的异常处理：必须指出：一个接受基类的catch会接受基类和其派生类！而接受派生类的catch只管派生类：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">try&#123;    ...&#125;catch(base_error)&#123;&#125;catch(derived_error)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的这个设计不合适！因为derived_error catch不到任何异常！这跟虚函数：”最吻合调用机制“不同，catch是最先吻合的调用机制。</p><p>​        总结一下我们的长篇大论：</p><p>​        首先：exception object总是会被复制，使用pass by val会被复制两次！而传递函数的参数则不会</p><p>​        其次：跑出去成为exception的对象允许类转换的动作，比被传递到函数去的对象少。</p><p>​        最后，catch字句是源码顺序调用优先而不是吻合度调用优先！</p><h3 id="条款13-以引用传递捕捉异常"><a href="#条款13-以引用传递捕捉异常" class="headerlink" title="条款13 以引用传递捕捉异常"></a>条款13 以引用传递捕捉异常</h3><p>​        我们有三种方式传递异常：值传递，引用传递，指针传递。</p><p>​        先考虑指针传递：不得不说因为不复制对象而显得十分搞笑，但是不大好，程序员们往往会忘记：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void someFunc&#123;    exception ex;        &#x2F;&#x2F;...        throw &amp;ex;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对象早就被析构了！传递了一个非法指针！</p><p>​        好吧，开堆上：</p><pre class="line-numbers language-none"><code class="language-none">void someFunc&#123;    exception ex;        &#x2F;&#x2F;...        throw new ex;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        那问题更大了，用户程序员没有办法知道：他们什么时候需要释放，什么时候不需要释放！这下麻烦了！还是不要用之为妙。</p><p>​        值传递呢？除了低效以外，如果我们传递了派生类指针，那意味着后续的处理下，对象都是基类，调用的虚函数是基类虚函数！程序爆炸了！</p><p>​        于是还是引用传递好！避免了上述的问题！</p><h3 id="条款14：明智使用exception-specification"><a href="#条款14：明智使用exception-specification" class="headerlink" title="条款14：明智使用exception specification"></a>条款14：明智使用exception specification</h3><p>​        谨慎使用他！</p><p>​        如：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void f1();&#x2F;&#x2F; throw anythingvoid f2()throw(int)&#123;    ...    f1();    ...&#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这下麻烦了，我们承诺了f2只会抛出int的意外，但是是事实f1会抛出一堆其他的意外！编译器不会帮助你检查这个事情，他默许了这样非法的行为。</p><p>​        同时，不要将template和 特殊异常一起使用！因为我们无法知道template会抛出什么异常，导致未定义行为的发生！</p><p>​        其二，如果A函数调用了B函数，若B没有特殊异常，A也不要有！但是很容易出错的：就是回调函数的问题：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef void(*CallBackPtr)(int X,int Y,void* dataToPassBack);class CallBack&#123;    public:    CallBack(CallBackPtr fPtr,void* dataToPassBack):    func(fPtr),data(dataToPassBack);    void makeCallBack(int X,int Y)const throw();    private:    CallBackPtr func;    void* data;&#125;;void CallBack::makeCallBack(int X,int Y)const throw()&#123;    func(X,Y,data);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <code>makeCallBack</code>函数内部就违反了特殊异常，谁知道func里面抛出了什么异常呢？但是这就可以：</p><pre class="line-numbers language-none"><code class="language-none">typedef void(*CallBackPtr)(int X,int Y,void* dataToPassBack) throw();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这样就强迫函数必须书写<code>throw()</code>后缀保证函数不会跑出任何异常！</p><p>​        还有其三：可以使用转化异常的方式防止出事情：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class UnexpectedExeception&#123;&#125;;void convertException()&#123;    throw UnexpectedExeception();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样就好了！</p><h2 id="条款15：了解异常处理的代价"><a href="#条款15：了解异常处理的代价" class="headerlink" title="条款15：了解异常处理的代价"></a>条款15：了解异常处理的代价</h2><p>​        我的评价是简单的：一坨大便，下一个（）</p><p>​        好吧，异常处理是能少用就少用的：首先是程序开销巨大，其次：跳转使得程序逻辑结构不再清晰。完事！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows-API-程序设计（1）</title>
      <link href="/2023/05/16/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89/"/>
      <url>/2023/05/16/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="系统学习Windows-API"><a href="#系统学习Windows-API" class="headerlink" title="系统学习Windows API"></a>系统学习Windows API</h1><h2 id="数据类型一看"><a href="#数据类型一看" class="headerlink" title="数据类型一看"></a>数据类型一看</h2><p>​        原生C数据类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int float double ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Windows自己的：</p><pre class="line-numbers language-none"><code class="language-none">BOOL BYTE CHAR CONST DWORD DOWRD32 DWORD64 FLOAT HANDLE HICON HINSTANCEHKEY HMODULE HWND INT INT_PTR INT32 INT64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        看看这个：</p><pre class="line-numbers language-none"><code class="language-none">LPSTR szString &#x3D; L&quot;this is a long pointer to string.&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        跳转得到：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;&#x2F;&#x2F; ANSI (Multi-byte Character) types&#x2F;&#x2F;typedef CHAR *PCHAR, *LPCH, *PCH;typedef CONST CHAR *LPCCH, *PCCH;typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        进一步针对CHAR类型跳转</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef char CHAR;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        微软搞那么多宏，一方面是历史遗留，另一方面是方便他们的工程师更容易区分</p><p>​        Dword是这个东西：一个四个字节的数据类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DWORD dwMax &#x3D; 0xFFFFFFFF<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef unsigned long       DWORD;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        于是INT就是有符号的，DWORD是无符号的。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;int main()&#123;LPSTR szString &#x3D; L&quot;this is a long pointer to string.&quot;;INT a &#x3D; 10;DWORD dwMax &#x3D; 0xFFFFFFFF;MessageBox(NULL, szString, TEXT(&quot;LPSTR&quot;), MB_OK);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在C中我们有：memcpy</p><p>​        在Windows下，有一个函数叫CopyMemory()</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">CopyMemory(IpStr, szString, lstrlen(szString) + 1); &#x2F;&#x2F; add one to include the \0.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define CopyMemory RtlCopyMemory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Handle,也就是句柄，是这样被定义的：</p><p>​        他有如下的句柄：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void *HANDLE;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        HICON图标</p><pre class="line-numbers language-X" data-language="X"><code class="language-X">DECLARE_HANDLE(HICON);#define DECLARE_HANDLE(name) struct name##__&#123;int unused;&#125;; typedef struct name##__ *name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        HInstance实例句柄</p><pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE(HINSTANCE);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        HKey注册表的句柄</p><pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE(HKEY);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        Hmodule模块句柄</p><pre class="line-numbers language-none"><code class="language-none">typedef HINSTANCE HMODULE;      &#x2F;* HMODULEs can be used in place of HINSTANCEs *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        HWND窗口句柄</p><pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE            (HWND);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="API基础函数"><a href="#API基础函数" class="headerlink" title="API基础函数"></a>API基础函数</h2><p>​        WindowAPI大量的使用了Windows的数据类型！所有的API都有W版和A版，分别表示的是支持Unicode字符集和ASCII多字节字符集。下面我们来看一个Windows自己创建的demo，选择Win32项目创建。看到主文件下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; WindowsProject1.cpp : 定义应用程序的入口点。&#x2F;&#x2F;#include &quot;framework.h&quot;#include &quot;WindowsProject1.h&quot;#define MAX_LOADSTRING 100&#x2F;&#x2F; 全局变量:HINSTANCE hInst;                                &#x2F;&#x2F; 当前实例WCHAR szTitle[MAX_LOADSTRING];                  &#x2F;&#x2F; 标题栏文本WCHAR szWindowClass[MAX_LOADSTRING];            &#x2F;&#x2F; 主窗口类名&#x2F;&#x2F; 此代码模块中包含的函数的前向声明:ATOM                MyRegisterClass(HINSTANCE hInstance);BOOL                InitInstance(HINSTANCE, int);LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);int APIENTRY wWinMain(_In_ HINSTANCE hInstance,                     _In_opt_ HINSTANCE hPrevInstance,                     _In_ LPWSTR    lpCmdLine,                     _In_ int       nCmdShow)&#123;    UNREFERENCED_PARAMETER(hPrevInstance);    UNREFERENCED_PARAMETER(lpCmdLine);    &#x2F;&#x2F; TODO: 在此处放置代码。    &#x2F;&#x2F; 初始化全局字符串    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);    LoadStringW(hInstance, IDC_WINDOWSPROJECT1, szWindowClass, MAX_LOADSTRING);    MyRegisterClass(hInstance);    &#x2F;&#x2F; 执行应用程序初始化:    if (!InitInstance (hInstance, nCmdShow))    &#123;        return FALSE;    &#125;    HACCEL hAccelTable &#x3D; LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSPROJECT1));    MSG msg;    &#x2F;&#x2F; 主消息循环:    while (GetMessage(&amp;msg, nullptr, 0, 0))    &#123;        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))        &#123;            TranslateMessage(&amp;msg);            DispatchMessage(&amp;msg);        &#125;    &#125;    return (int) msg.wParam;&#125;&#x2F;&#x2F;&#x2F;&#x2F;  函数: MyRegisterClass()&#x2F;&#x2F;&#x2F;&#x2F;  目标: 注册窗口类。&#x2F;&#x2F;ATOM MyRegisterClass(HINSTANCE hInstance)&#123;    WNDCLASSEXW wcex;    wcex.cbSize &#x3D; sizeof(WNDCLASSEX);    wcex.style          &#x3D; CS_HREDRAW | CS_VREDRAW;    wcex.lpfnWndProc    &#x3D; WndProc;    wcex.cbClsExtra     &#x3D; 0;    wcex.cbWndExtra     &#x3D; 0;    wcex.hInstance      &#x3D; hInstance;    wcex.hIcon          &#x3D; LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));    wcex.hCursor        &#x3D; LoadCursor(nullptr, IDC_ARROW);    wcex.hbrBackground  &#x3D; (HBRUSH)(COLOR_WINDOW+1);    wcex.lpszMenuName   &#x3D; MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1);    wcex.lpszClassName  &#x3D; szWindowClass;    wcex.hIconSm        &#x3D; LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));    return RegisterClassExW(&amp;wcex);&#125;&#x2F;&#x2F;&#x2F;&#x2F;   函数: InitInstance(HINSTANCE, int)&#x2F;&#x2F;&#x2F;&#x2F;   目标: 保存实例句柄并创建主窗口&#x2F;&#x2F;&#x2F;&#x2F;   注释:&#x2F;&#x2F;&#x2F;&#x2F;        在此函数中，我们在全局变量中保存实例句柄并&#x2F;&#x2F;        创建和显示主程序窗口。&#x2F;&#x2F;BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)&#123;   hInst &#x3D; hInstance; &#x2F;&#x2F; 将实例句柄存储在全局变量中   HWND hWnd &#x3D; CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);   if (!hWnd)   &#123;      return FALSE;   &#125;   ShowWindow(hWnd, nCmdShow);   UpdateWindow(hWnd);   return TRUE;&#125;&#x2F;&#x2F;&#x2F;&#x2F;  函数: WndProc(HWND, UINT, WPARAM, LPARAM)&#x2F;&#x2F;&#x2F;&#x2F;  目标: 处理主窗口的消息。&#x2F;&#x2F;&#x2F;&#x2F;  WM_COMMAND  - 处理应用程序菜单&#x2F;&#x2F;  WM_PAINT    - 绘制主窗口&#x2F;&#x2F;  WM_DESTROY  - 发送退出消息并返回&#x2F;&#x2F;&#x2F;&#x2F;LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123;    switch (message)    &#123;    case WM_COMMAND:        &#123;            int wmId &#x3D; LOWORD(wParam);            &#x2F;&#x2F; 分析菜单选择:            switch (wmId)            &#123;            case IDM_ABOUT:                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);                break;            case IDM_EXIT:                DestroyWindow(hWnd);                break;            default:                return DefWindowProc(hWnd, message, wParam, lParam);            &#125;        &#125;        break;    case WM_PAINT:        &#123;            PAINTSTRUCT ps;            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...            EndPaint(hWnd, &amp;ps);        &#125;        break;    case WM_DESTROY:        PostQuitMessage(0);        break;        default:        return DefWindowProc(hWnd, message, wParam, lParam);    &#125;    return 0;&#125;&#x2F;&#x2F; “关于”框的消息处理程序。INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)&#123;    UNREFERENCED_PARAMETER(lParam);    switch (message)    &#123;    case WM_INITDIALOG:        return (INT_PTR)TRUE;    case WM_COMMAND:        if (LOWORD(wParam) &#x3D;&#x3D; IDOK || LOWORD(wParam) &#x3D;&#x3D; IDCANCEL)        &#123;            EndDialog(hDlg, LOWORD(wParam));            return (INT_PTR)TRUE;        &#125;        break;    &#125;    return (INT_PTR)FALSE;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们尝试加点东西，留心到</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在switch语句下面添加点东西（有注释//）:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)&#123;    LPCWSTR msg_str1 &#x3D; L&quot;你单击了左键（乐）&quot;;&#x2F;&#x2F;    LPCWSTR msg_str2 &#x3D; L&quot;你单击了右键（乐）&quot;;&#x2F;&#x2F;    LPCWSTR title_str &#x3D; L&quot;这是一个标题&quot;;&#x2F;&#x2F;    switch (message)    &#123;    case WM_COMMAND:        &#123;            int wmId &#x3D; LOWORD(wParam);            &#x2F;&#x2F; 分析菜单选择:            switch (wmId)            &#123;            case IDM_ABOUT:                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);                break;            case IDM_EXIT:                DestroyWindow(hWnd);                break;            default:                return DefWindowProc(hWnd, message, wParam, lParam);            &#125;        &#125;        break;    case WM_PAINT:        &#123;            PAINTSTRUCT ps;            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...            EndPaint(hWnd, &amp;ps);        &#125;        break;    case WM_DESTROY:        PostQuitMessage(0);        break;    case WM_LBUTTONDOWN:&#x2F;&#x2F;        MessageBoxW(NULL,msg_str1,title_str, MB_OKCANCEL);&#x2F;&#x2F;        break;&#x2F;&#x2F;    case WM_RBUTTONDOWN:&#x2F;&#x2F;        MessageBoxW(NULL, msg_str2, title_str, MB_OKCANCEL);&#x2F;&#x2F;        break;&#x2F;&#x2F;    default:        return DefWindowProc(hWnd, message, wParam, lParam);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是我们频繁点击会产生大量的窗口！那就更改父窗口就好了，传入一个句柄！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">case WM_LBUTTONDOWN:    MessageBoxW(hWnd,msg_str1,title_str, MB_OKCANCEL);    break;case WM_RBUTTONDOWN:    MessageBoxW(hWnd, msg_str2, title_str, MB_OKCANCEL);    break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在就好了！</p><p><img src="image-20230514113233694.png" alt="image-20230514113233694"></p><p><img src="image-20230514113445737.png" alt="image-20230514113445737"></p><p><img src="image-20230514113504873.png" alt="image-20230514113504873"></p><h2 id="读取文件demo"><a href="#读取文件demo" class="headerlink" title="读取文件demo"></a>读取文件demo</h2><p>​        在Windows下，使用</p><pre class="line-numbers language-none"><code class="language-none">CreateFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        宏来打开并创建一个文件句柄！</p><blockquote><p>from Microsoft API</p></blockquote><h2 id="read-file"><a href="#read-file" class="headerlink" title="read file"></a>read file</h2><p>​        我们使用readFile来读取文件：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;iostream&gt;#define BUFSIZE 256#include&lt;tchar.h&gt;11int main()&#123;setlocale(LC_ALL, &quot;zh_CN.UTF-8&quot;); &#x2F;&#x2F; 设置正确的编码环境，防止读取乱码！HANDLE hFileRead;&#x2F;&#x2F; 创建文件句柄hFileRead &#x3D; CreateFile(L&quot;1.txt&quot;, GENERIC_READ, FILE_SHARE_READ, \NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);if (hFileRead &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;printf(&quot;Error in open the file:%x&quot;,GetLastError());&#125;DWORD nIn &#x3D; 0;CHAR buffer[BUFSIZE];while (ReadFile(hFileRead, buffer, BUFSIZE, &amp;nIn, NULL) &amp;&amp; nIn &gt; 0) &#123;printf(&quot;%s\n&quot;, buffer);&#125;CloseHandle(hFileRead);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230514113206643.png" alt="image-20230514113206643"></p><h3 id="createFileW-函数-fileapi-h"><a href="#createFileW-函数-fileapi-h" class="headerlink" title="createFileW 函数 (fileapi.h)"></a>createFileW 函数 (fileapi.h)</h3><p>​        创建或打开文件或 I/O 设备。 最常用的 I/O 设备如下所示：文件、文件流、目录、物理磁盘、卷、控制台缓冲区、磁带驱动器、通信资源、mailslot 和管道。 该函数返回一个句柄，该句柄可用于访问不同类型的 I/O 的文件或设备，具体取决于文件或设备以及指定的标志和属性。</p><p>若要将此操作作为事务处理操作执行，这会导致可用于事务处理 I/O 的句柄，请使用 CreateFileTransacted 函数。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">HANDLE CreateFileW(  [in]           LPCWSTR               lpFileName,  [in]           DWORD                 dwDesiredAccess,  [in]           DWORD                 dwShareMode,  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,  [in]           DWORD                 dwCreationDisposition,  [in]           DWORD                 dwFlagsAndAttributes,  [in, optional] HANDLE                hTemplateFile);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数<br>        [in] lpFileName</p><p>​        要创建或打开的文件或设备的名称。 可以在此名称中使用正斜杠 (/) 或反斜杠 () 。</p><p>​        在此函数的 ANSI 版本中，名称限制为 MAX_PATH 个字符。 若要将此限制扩展到 32，767 宽字符，请使用此 Unicode 版本的函数，并将“\\？\”前面附加到路径。 有关详细信息，请参阅命名文件、路径和命名空间。</p><p>​        有关特殊设备名称的信息，请参阅 定义 MS-DOS 设备名称。</p><p>​        若要创建文件流，请指定文件的名称、冒号，然后指定流的名称。 有关详细信息，请参阅 文件流。</p><p>​        提示从Windows 10版本 1607 开始，对于此函数的 unicode 版本 (CreateFileW) ，你可以选择加入以删除MAX_PATH限制，而无需附加“\\？\”。 有关详细信息，请参阅 命名文件、路径和命名空间 的“最大路径长度限制”部分。<br>[in] dwDesiredAccess</p><p>​        请求对文件或设备的访问权限，可汇总为读取、写入或两者均不) 。</p><p>​        最常用的值是 GENERIC_READ、 GENERIC_WRITE或两者 () GENERIC_READ | GENERIC_WRITE 。 有关详细信息，请参阅 通用访问权限、 文件安全性和访问权限、 文件访问权限常量和 ACCESS_MASK。</p><p>​        如果此参数为零，则应用程序可以在不访问该文件或设备的情况下查询某些元数据，例如文件、目录或设备属性，即使 拒绝了GENERIC_READ 访问。</p><p>​        不能请求与已打开句柄的打开请求中 dwShareMode 参数指定的共享模式冲突的访问模式。</p><p>​        有关详细信息，请参阅本主题的“备注”部分和 “创建和打开文件”。</p><p>​        [in] dwShareMode</p><p>​        文件或设备请求的共享模式，可以读取、写入、删除、所有这些或无 (引用下表) 。 对属性或扩展属性的访问请求不受此标志的影响。</p><p>​        如果此参数为零且 CreateFile 成功，则文件或设备无法共享，并且无法在文件或设备的句柄关闭之前再次打开。 有关详细信息，请参见“备注”部分。</p><p>​        无法请求与具有打开句柄的现有请求中指定的访问模式冲突的共享模式。 CreateFile 将失败， GetLastError 函数将返回 ERROR_SHARING_VIOLATION。</p><p>​        若要启用进程在打开文件或设备时共享文件或设备，请使用以下一个或多个值的兼容组合。 有关此参数与 dwDesiredAccess 参数的有效组合的详细信息，请参阅 创建和打开文件。</p><p>​        <strong>注意</strong> 无论进程上下文如何，每个打开句柄的共享选项都将有效，直到该句柄关闭。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>0</strong>0x00000000</td><td style="text-align:left">如果文件或设备请求删除、读取或写入访问权限，则阻止对文件或设备上的后续打开操作。</td></tr><tr><td style="text-align:left"><strong>FILE_SHARE_DELETE</strong>0x00000004</td><td style="text-align:left">在文件或设备上启用后续打开操作以请求删除访问权限。否则，如果文件或设备请求删除访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开以删除访问权限，则函数将失败。<strong>注意</strong> 删除访问权限允许删除和重命名操作。</td></tr><tr><td style="text-align:left"><strong>FILE_SHARE_READ</strong>0x00000001</td><td style="text-align:left">在文件或设备上启用后续打开操作以请求读取访问权限。否则，如果文件或设备请求读取访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开以供读取访问，则函数将失败。</td></tr><tr><td style="text-align:left"><strong>FILE_SHARE_WRITE</strong>0x00000002</td><td style="text-align:left">在文件或设备上启用后续打开操作以请求写入访问权限。否则，如果文件或设备请求写入访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开进行写入访问或具有写入访问权限的文件映射，则函数将失败。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpSecurityAttributes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        指向包含两个独立但相关数据成员的 <a href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85">SECURITY_ATTRIBUTES</a>) 结构的指针：可选的安全描述符，以及一个布尔值，该值确定返回的句柄是否可以由子进程继承。</p><p>​        此参数可以为 NULL。</p><p>​        如果此参数为 <strong>NULL</strong>，则 <strong>由 CreateFile</strong> 返回的句柄不能由应用程序可能创建的任何子进程继承，并且与返回的句柄关联的文件或设备获取默认的安全描述符。</p><p>​        结构的 <strong>lpSecurityDescriptor</strong> 成员指定文件或设备的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> 。 如果此成员为 <strong>NULL</strong>，则会为与返回的句柄关联的文件或设备分配一个默认的安全描述符。</p><p>​        <strong>CreateFile</strong> 在打开现有文件或设备时忽略 <strong>lpSecurityDescriptor</strong> 成员，但继续使用 <strong>bInheritHandle</strong> 成员。</p><p>​        结构的 <strong>bInheritHandle</strong> 成员指定是否可以继承返回的句柄。</p><p>​        有关详细信息，请参见“备注”部分。</p><pre class="line-numbers language-none"><code class="language-none">[in] dwCreationDisposition<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        对存在或不存在的文件或设备执行的操作。</p><p>​        对于文件以外的设备，此参数通常设置为 <strong>OPEN_EXISTING</strong>。</p><p>​        有关详细信息，请参见“备注”部分。</p><p>​        此参数必须是以下值之一，不能合并：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>CREATE_ALWAYS</strong>2</td><td style="text-align:left">始终创建新文件。如果指定的文件存在且可写，则函数将覆盖文件、函数成功，最后错误代码设置为 <strong>ERROR_ALREADY_EXISTS</strong> (183) 。如果指定的文件不存在且路径有效，则会创建一个新文件，该函数成功，最后一个错误代码设置为零。有关详细信息，请参阅本主题的“备注”部分。</td></tr><tr><td style="text-align:left"><strong>CREATE_NEW</strong>1</td><td style="text-align:left">仅当该文件尚不存在时才创建一个新文件。如果指定的文件存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_EXISTS (</strong> 80) 。如果指定的文件不存在并且是可写位置的有效路径，则会创建新文件。</td></tr><tr><td style="text-align:left"><strong>OPEN_ALWAYS</strong>4</td><td style="text-align:left">始终打开文件。如果指定文件存在，则函数成功，最后一个错误代码设置为 <strong>ERROR_ALREADY_EXISTS (</strong> 183) 。如果指定的文件不存在并且是可写位置的有效路径，则函数将创建一个文件，最后一个错误代码设置为零。</td></tr><tr><td style="text-align:left"><strong>OPEN_EXISTING</strong>3</td><td style="text-align:left">仅当文件或设备存在时，才打开该文件或设备。如果指定的文件或设备不存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_NOT_FOUND (</strong> 2) 。有关设备的详细信息，请参阅“备注”部分。</td></tr><tr><td style="text-align:left"><strong>TRUNCATE_EXISTING</strong>5</td><td style="text-align:left">打开文件并截断该文件，使其大小为零字节，仅当它存在时。如果指定的文件不存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_NOT_FOUND</strong> (2) 。调用过程必须打开文件，并将 <strong>GENERIC_WRITE</strong> 位设置为 <em>dwDesiredAccess</em> 参数的一部分。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[in] dwFlagsAndAttributes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        文件或设备属性和标志， <strong>FILE_ATTRIBUTE_NORMAL</strong> 是文件最常见的默认值。</p><p>​        此参数可以包含可用文件属性的任意组合， <strong>(FILE_ATTRIBUTE_*</strong>) 。 所有其他文件属性都替代 <strong>FILE_ATTRIBUTE_NORMAL</strong>。</p><p>​        此参数还可以包含标志组合 <strong>， (FILE_FLAG_)</strong> <em>来控制文件或设备缓存行为、访问模式和其他特殊用途标志。 这些值与任何 <strong>FILE_ATTRIBUTE_</strong></em> 值结合使用。</p><p>​        此参数还可以通过指定 <strong>SECURITY_SQOS_PRESENT</strong> 标志来包含安全服务质量 (SQOS) 信息。 下表显示了其他与 SQOS 相关的标志信息，这些属性和标志表如下。</p><p>​        <strong>注意当CreateFile</strong> 打开现有文件时，它通常将文件标志与现有文件的文件属性组合在一起，并忽略作为 <em>dwFlagsAndAttributes</em> 的一部分提供的任何文件属性。 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”中详细介绍了特殊情况。</p><p>​        以下某些文件属性和标志只能应用于文件，不一定是 <strong>CreateFile</strong> 可以打开的所有其他类型的设备。 有关详细信息，请参阅本主题的“备注”部分和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”。    </p><p>​        有关对文件属性的更高级访问，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>。 有关所有文件属性及其值和说明的完整列表，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-attribute-constants">文件属性常量</a>。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Attribute</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_ARCHIVE</strong>32 (0x20)</td><td style="text-align:left">该文件应存档。 应用程序使用此属性来标记要备份或删除的文件。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_ENCRYPTED</strong>16384 (0x4000)</td><td style="text-align:left">此文件或目录已加密。 对于文件来说，表示文件中的所有数据都是加密的。 对于目录，这意味着加密是新创建的文件和子目录的默认值。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。如果还指定 <strong>了FILE_ATTRIBUTE_SYSTEM</strong> ，则此标志无效。家庭版、家庭高级版、初学者版或 ARM 版 Windows 不支持此标志。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_HIDDEN</strong>2 (0x2)</td><td style="text-align:left">文件被隐藏。 不要将其包含在普通目录列表中。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_NORMAL</strong>128 (0x80)</td><td style="text-align:left">该文件没有设置其他属性。 此属性仅在单独使用时有效。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_OFFLINE</strong>4096 (0x1000)</td><td style="text-align:left">文件的数据不能立即可用。 此属性指示文件数据以物理方式移动到脱机存储。 此属性由远程存储（分层存储管理软件）使用。 应用程序不应随意更改此属性。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_READONLY</strong>1 (0x1)</td><td style="text-align:left">文件为只读文件。 应用程序可以读取文件，但无法写入或删除该文件。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_SYSTEM</strong>4 (0x4)</td><td style="text-align:left">该文件是操作系统的一部分或完全使用的文件。</td></tr><tr><td style="text-align:left"><strong>FILE_ATTRIBUTE_TEMPORARY</strong>256 (0x100)</td><td style="text-align:left">该文件用于临时存储。有关详细信息，请参阅本主题的 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">标志</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>FILE_FLAG_BACKUP_SEMANTICS</strong>0x02000000</td><td style="text-align:left">正在为备份或还原操作打开或创建该文件。 系统确保调用进程在进程具有 <strong>SE_BACKUP_NAME</strong> 和 <strong>SE_RESTORE_NAME</strong> 特权时替代文件安全检查。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecBP/changing-privileges-in-a-token">更改令牌中的特权</a>。必须设置此标志才能获取目录的句柄。 目录句柄可以传递给某些函数，而不是文件句柄。 有关详细信息，请参见“备注”部分。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_DELETE_ON_CLOSE</strong>0x04000000</td><td style="text-align:left">文件在其所有句柄都关闭后立即被删除，其中包括指定的句柄和任何其他打开或重复的句柄。如果文件存在现有的打开句柄，则调用会失败，除非这些句柄都使用 <strong>FILE_SHARE_DELETE</strong> 共享模式打开。针对文件的后续打开请求将失败，除非指定 FILE_SHARE_DELETE 共享模式。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_NO_BUFFERING</strong>0x20000000</td><td style="text-align:left">文件或设备正在打开，没有系统缓存来读取和写入数据。 此标志不会影响硬盘缓存或内存映射文件。使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志成功使用 <strong>CreateFile</strong> 打开的文件有严格的要求，有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_OPEN_NO_RECALL</strong>0x00100000</td><td style="text-align:left">请求文件数据，但它应继续位于远程存储中。 不应将其传输回本地存储。 此标志供远程存储系统使用。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>0x00200000</td><td style="text-align:left">不会进行正常的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/reparse-points">重新分析点</a> 处理; <strong>CreateFile</strong> 将尝试打开重新分析点。 打开文件时，将返回文件句柄，无论控制重新分析点的筛选器是否正常运行。此标志不能与 <strong>CREATE_ALWAYS</strong> 标志一起使用。如果文件不是重新分析点，则忽略此标志。有关详细信息，请参见“备注”部分。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_OVERLAPPED</strong>0x40000000</td><td style="text-align:left">文件或设备正在为异步 I/O 打开或创建。在此句柄上完成后续 I/O 操作时， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件将设置为信号状态。如果指定了此标志，则该文件可用于同时读取和写入操作。如果未指定此标志，则即使对读取和写入函数的调用指定 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">了 OVERLAPPED</a> 结构，I/O 操作也会序列化。有关使用此标志创建的文件句柄时的注意事项，请参阅本主题的 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#synchronous_and_asynchronous_i_o_handles">同步和异步 I/O 句柄</a> 部分。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_POSIX_SEMANTICS</strong>0x01000000</td><td style="text-align:left">访问将根据 POSIX 规则进行。 这包括允许具有名称的多个文件，仅在支持该命名的文件系统时有所不同。 使用此选项时应小心，因为使用此标志创建的文件可能无法由为 MS-DOS 或 16 位 Windows 编写的应用程序访问。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_RANDOM_ACCESS</strong>0x10000000</td><td style="text-align:left">访问是随机的。 系统可将此选项用作优化文件缓存的提示。如果文件系统不支持缓存的 I/O 和 <strong>FILE_FLAG_NO_BUFFERING</strong>，则此标志无效。有关详细信息，请参阅本主题的 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_SESSION_AWARE</strong>0x00800000</td><td style="text-align:left">文件或设备正在使用会话感知打开。 如果未指定此标志，则会话中的每个会话设备 (（例如使用 RemoteFX USB 重定向的设备) ）无法由会话 0 中运行的进程打开。 对于不在会话 0 中的调用方，此标志无效。 此标志仅在 Windows 的服务器版本上受支持。<strong>Windows Server 2008 R2 和 Windows Server 2008：</strong> Windows Server 2012之前不支持此标志。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_SEQUENTIAL_SCAN</strong>0x08000000</td><td style="text-align:left">访问旨在从头到尾的顺序。 系统可将此选项用作优化文件缓存的提示。如果读取隐藏 (（即使用反向扫描) ），则不应使用此标志。如果文件系统不支持缓存的 I/O 和 <strong>FILE_FLAG_NO_BUFFERING</strong>，则此标志无效。有关详细信息，请参阅本主题的 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td></tr><tr><td style="text-align:left"><strong>FILE_FLAG_WRITE_THROUGH</strong>0x80000000</td><td style="text-align:left">写入操作不会经历任何中间缓存，它们将直接转到磁盘。有关详细信息，请参阅本主题的 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td></tr></tbody></table></div><p><em>dwFlagsAndAttributes</em> 参数还可以指定 SQOS 信息。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/impersonation-levels">模拟级别</a>。 当调用应用程序将 <strong>SECURITY_SQOS_PRESENT</strong> 标志指定为 <em>dwFlagsAndAttributes</em> 的一部分时，它还可以包含以下一个或多个值。</p><div class="table-container"><table><thead><tr><th style="text-align:left">安全标志</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>SECURITY_ANONYMOUS</strong></td><td style="text-align:left">模拟匿名模拟级别的客户端。</td></tr><tr><td style="text-align:left"><strong>SECURITY_CONTEXT_TRACKING</strong></td><td style="text-align:left">安全跟踪模式是动态的。 如果未指定此标志，则安全跟踪模式是静态的。</td></tr><tr><td style="text-align:left"><strong>SECURITY_DELEGATION</strong></td><td style="text-align:left">模拟委托模拟级别的客户端。</td></tr><tr><td style="text-align:left"><strong>SECURITY_EFFECTIVE_ONLY</strong></td><td style="text-align:left">只有客户端安全上下文的已启用方面可供服务器使用。 如果未指定此标志，则客户端安全上下文的所有方面都可用。这允许客户端限制服务器在模拟客户端时可以使用的组和特权。</td></tr><tr><td style="text-align:left"><strong>SECURITY_IDENTIFICATION</strong></td><td style="text-align:left">模拟标识模拟级别的客户端。</td></tr><tr><td style="text-align:left"><strong>SECURITY_IMPERSONATION</strong></td><td style="text-align:left">模拟模拟级别的客户端。 如果未指定其他标志以及 <strong>SECURITY_SQOS_PRESENT</strong> 标志，则这是默认行为。</td></tr></tbody></table></div><pre class="line-numbers language-none"><code class="language-none">[in, optional] hTemplateFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        具有 <strong>GENERIC_READ</strong> 访问权限的模板文件的有效句柄。 模板文件为正在创建的文件提供文件属性和扩展属性。</p><p>​        此参数可以为 NULL。</p><p>​        打开现有文件时， <strong>CreateFile</strong> 将忽略此参数。</p><p>​        打开新的加密文件时，该文件将从其父目录继承任意访问控制列表。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是指定文件、设备、命名管道或邮件槽的打开句柄。</p><p>​        如果函数失败，则返回值为 INVALID_HANDLE_VALUE。 要获得更多的错误信息，请调用 GetLastError。</p><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>​        <strong>CreateFile</strong> 最初专为文件交互而开发，但此后已扩展和增强，以包括 Windows 开发人员可用的大多数其他类型的 I/O 设备和机制。 本部分尝试介绍开发人员在不同上下文中使用不同的 I/O 类型使用 <strong>CreateFile</strong> 时可能遇到的各种问题。 仅当专门引用存储在文件系统上实际文件中的数据时，文本才会尝试使用单词 <em>文件</em> 。 但是，某些文件用法可能更普遍地引用支持类似 <em>文件的</em> I/O 对象。 由于前面提到的历史原因，这种自由使用术语 <em>文件</em> 在常量名称和参数名称中尤其普遍。</p><p>​        使用 <strong>CreateFile</strong> 返回的对象句柄完成应用程序后，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 函数关闭句柄。 这不仅释放了系统资源，而且可以对共享文件或设备以及将数据提交到磁盘等内容产生更广泛的影响。 本主题中会相应地说明具体内容。</p><p>​        <strong>Windows Server 2003 和 Windows XP：</strong> 如果尝试打开文件或目录以在远程计算机上删除，则发生共享冲突，当 <em>dwDesiredAccess</em> 参数的值是使用任何其他访问标志 (0x00010000) <strong>OR’ed</strong> 的 <strong>DELETE</strong> 访问标志，并且远程文件或目录尚未使用<strong>FILE_SHARE_DELETE</strong>打开。 为了避免此方案中的共享冲突，请仅打开具有 <strong>DELETE</strong> 访问权限的远程文件或目录，或者调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> ，而无需首先打开文件或目录进行删除。</p><p>​        某些文件系统（如 NTFS 文件系统）支持单个文件和目录的压缩或加密。 对于具有此支持的装载文件系统的卷，新文件继承其目录的压缩和加密属性。</p><p>​        不能使用 <strong>CreateFile</strong> 来控制文件或目录上的压缩、解压缩或解密。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">创建和打开文件</a>、 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-compression-and-decompression">文件压缩和解压缩</a>以及 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。</p><p>​        <strong>Windows Server 2003 和 Windows XP：</strong> 出于向后兼容性目的，在 <em>lpSecurityAttributes</em> 中指定安全描述符时，<strong>CreateFile</strong> 不会应用继承规则。 为了支持继承，以后查询此文件的安全描述符的函数可能会启发性地确定并报告继承是否有效。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">可继承 ACE 的自动传播</a>。</p><p>​        如前所述，如果 <em>lpSecurityAttributes</em> 参数为 <strong>NULL</strong>，则应用程序可能创建的任何子进程都无法继承 <strong>CreateFile</strong> 返回的句柄。 有关此参数的以下信息也适用：</p><ul><li>如果 <strong>bInheritHandle</strong> 成员变量不是 <strong>FALSE</strong>，这是任何非零值，则可以继承句柄。 因此，如果不希望句柄可继承，则此结构成员必须正确初始化为 <strong>FALSE</strong> 。</li><li>访问控制列表 (文件或目录的默认安全描述符中的 ACL) 继承自其父目录。</li><li>目标文件系统必须支持 <strong>lpSecurityDescriptor</strong> 成员对文件和目录的安全性，才能对其产生影响，这可以通过 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">使用 GetVolumeInformation</a> 来确定。</li></ul><p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">技术</th><th style="text-align:left">支持</th></tr></thead><tbody><tr><td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td><td style="text-align:left">请参阅备注</td></tr><tr><td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td><td style="text-align:left">请参阅备注</td></tr><tr><td style="text-align:left">群集共享卷文件系统 (CsvFS)</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">弹性文件系统 (ReFS)</td><td style="text-align:left">是</td></tr></tbody></table></div><p>​        请注意，如果对已打开的备用数据流的文件执行，具有取代处置的 <strong>CreateFile</strong> 将失败。</p><h4 id="符号链接行为"><a href="#符号链接行为" class="headerlink" title="符号链接行为"></a>符号链接行为</h4><p>​        如果对此函数的调用创建文件，则行为没有变化。 此外，请考虑有关 <strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>的以下信息：</p><ul><li>如果指定了FILE_FLAG_OPEN_REPARSE_POINT<ul><li>如果打开现有文件并且它是符号链接，则返回的句柄是符号链接的句柄。</li><li>如果指定 <strong>了TRUNCATE_EXISTING</strong> 或 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> ，则受影响的文件是符号链接。</li></ul></li><li>如果未指定FILE_FLAG_OPEN_REPARSE_POINT：<ul><li>如果打开现有文件并且它是符号链接，则返回的句柄是目标句柄。</li><li>如果指定 <strong>CREATE_ALWAYS</strong>、 <strong>TRUNCATE_EXISTING</strong>或 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> ，则受影响的文件是目标。</li></ul></li></ul><h4 id="缓存行为"><a href="#缓存行为" class="headerlink" title="缓存行为"></a>缓存行为</h4><p><strong>CreateFile</strong> 使用 <em>dwFlagsAndAttributes</em> 参数的多个可能值来控制或影响系统缓存与句柄关联的数据的方式。 它们是：</p><ul><li><strong>FILE_FLAG_NO_BUFFERING</strong></li><li><strong>FILE_FLAG_RANDOM_ACCESS</strong></li><li><strong>FILE_FLAG_SEQUENTIAL_SCAN</strong></li><li><strong>FILE_FLAG_WRITE_THROUGH</strong></li><li><strong>FILE_ATTRIBUTE_TEMPORARY</strong></li></ul><p>如果未指定这些标志，系统将使用默认的常规用途缓存方案。 否则，系统缓存的行为与为每个标志指定。</p><p>不应合并其中一些标志。 例如，将 <strong>FILE_FLAG_RANDOM_ACCESS</strong> 与 <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong> 相结合是自败。</p><p>指定 <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong> 标志可以提高使用顺序访问读取大型文件的应用程序的性能。 对于主要按顺序读取大型文件的应用程序，性能提升可能更加明显，但偶尔会跳过小范围的字节。 如果应用程序移动文件指针进行随机访问，则很可能不会发生最佳缓存性能。 但是，仍可以保证正确的操作。</p><p><strong>标志FILE_FLAG_WRITE_THROUGH</strong>和<strong>FILE_FLAG_NO_BUFFERING</strong>是独立的，可以组合在一起。</p><p>如果使用 <strong>FILE_FLAG_WRITE_THROUGH</strong> 但 <strong>未指定FILE_FLAG_NO_BUFFERING</strong> ，以便系统缓存生效，则数据会写入系统缓存，但不会延迟地刷新到磁盘。</p><p>如果 <strong>同时指定了FILE_FLAG_WRITE_THROUGH</strong> 和 <strong>FILE_FLAG_NO_BUFFERING</strong> ，以便系统缓存无效，则数据会立即刷新到磁盘，而无需通过 Windows 系统缓存。 操作系统还会向永久性媒体请求硬盘本地硬件缓存的写入。</p><p><strong>注意</strong> 并非所有硬盘硬件都支持此写通功能。</p><p>正确使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志需要特殊的应用程序注意事项。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</p><p>通过 <strong>FILE_FLAG_WRITE_THROUGH</strong> 的写通请求还会导致 NTFS 刷新任何元数据更改，例如时间戳更新或重命名操作，这会导致处理请求。 因此， <strong>FILE_FLAG_WRITE_THROUGH</strong> 标志通常与 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志一起使用，作为每次写入后调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 函数的替代项，这可能会导致不必要的性能损失。 将这些标志一起使用可避免这些处罚。 有关文件和元数据缓存的一般信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-caching">文件缓存</a>。</p><p><strong>当FILE_FLAG_NO_BUFFERING</strong>与<strong>FILE_FLAG_OVERLAPPED</strong>结合使用时，标志提供最大的异步性能，因为 I/O 不依赖于内存管理器的同步操作。 但是，某些 I/O 操作需要更多时间，因为缓存中未保留数据。 此外，在创建空文件) 时，文件元数据仍可能 (缓存。 若要确保元数据刷新到磁盘，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 函数。</p><p>如果有足够的缓存内存可用，则指定 <strong>FILE_ATTRIBUTE_TEMPORARY</strong> 属性会导致文件系统避免将数据写回到大容量存储，因为应用程序在关闭句柄后删除临时文件。 在这种情况下，系统可以完全避免写入数据。 尽管它不直接控制数据缓存的方式与前面提到的标志相同， <strong>但FILE_ATTRIBUTE_TEMPORARY</strong> 属性确实会告知系统在系统缓存中尽可能多地保留，而无需写入，因此可能对某些应用程序感到担忧。</p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>如果重命名或删除文件，然后在不久后还原该文件，系统将在缓存中搜索要还原的文件信息。 缓存信息包括其短/长名称对和创建时间。</p><p>如果在之前调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> 时挂起删除的文件上调用 <strong>CreateFile</strong>，该函数将失败。 操作系统会延迟文件删除，直到文件的所有句柄都关闭。 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_ACCESS_DENIED</strong>。</p><p><em>dwDesiredAccess</em> 参数可以是零，允许应用程序在不访问文件的情况下查询文件属性（如果应用程序正在运行且具有足够的安全设置）。 这可用于测试文件是否存在，而无需打开该文件进行读取和/或写入访问，或获取有关文件或目录的其他统计信息。 请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/obtaining-and-setting-file-information">获取和设置文件信息和</a><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a>。</p><p>如果指定 <strong>了CREATE_ALWAYS</strong> 和 <strong>FILE_ATTRIBUTE_NORMAL</strong> ， <strong>则 CreateFile</strong> 将失败，并将最后一个错误设置为 <strong>ERROR_ACCESS_DENIED</strong> （如果文件存在并且具有 <strong>FILE_ATTRIBUTE_HIDDEN</strong> 或 <strong>FILE_ATTRIBUTE_SYSTEM</strong> 属性）。 若要避免此错误，请指定与现有文件相同的属性。</p><p>当应用程序跨网络创建文件时，最好将 <em>dwDesiredAccess 用于 dwDesiredAccess</em>，而不是单独使用 <strong>GENERIC_WRITE</strong>。<code>GENERIC_READ | GENERIC_WRITE</code> 生成的代码速度更快，因为重定向程序可以使用缓存管理器，并发送更少的 SMB 和更多数据。 这种组合还避免了写入网络中的文件偶尔会返回 <strong>ERROR_ACCESS_DENIED</strong>的问题。</p><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”。</p><h4 id="同步和异步-I-O-句柄"><a href="#同步和异步-I-O-句柄" class="headerlink" title="同步和异步 I/O 句柄"></a>同步和异步 I/O 句柄</h4><p><strong>CreateFile</strong> 用于创建同步或异步的文件或设备句柄。 同步句柄的行为使使用该句柄的 I/O 函数调用被阻止，直到它们完成，而异步文件句柄使系统能够立即从 I/O 函数调用返回，无论它们是否完成了 I/O 操作。 如前所述，此同步与异步行为通过指定 <em>dwFlagsAndAttributes</em> 参数中的<strong>FILE_FLAG_OVERLAPPED</strong>来确定。 使用异步 I/O 时存在多种复杂性和潜在缺陷;有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">同步和异步 I/O</a>。</p><h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><p>在 NTFS 文件系统上，可以使用 <strong>CreateFile</strong> 在文件中创建单独的流。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-streams">文件流</a>。</p><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>应用程序无法使用 <strong>CreateFile</strong> 创建目录，因此对于此用例，只有 <strong>OPEN_EXISTING</strong> 值对 <em>dwCreationDisposition</em> 有效。 若要创建目录，应用程序必须调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> 或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a>。</p><p>若要使用 <strong>CreateFile</strong> 打开目录，请将 <strong>FILE_FLAG_BACKUP_SEMANTICS</strong> 标志指定为 <em>dwFlagsAndAttributes</em> 的一部分。 在没有 <strong>SE_BACKUP_NAME</strong> 和 <strong>SE_RESTORE_NAME</strong> 特权的情况下使用此标志时，仍适用适当的安全检查。</p><p>使用 <strong>CreateFile</strong> 在对 FAT 或 FAT32 文件系统卷进行碎片整理期间打开目录时，请不要指定 <strong>MAXIMUM_ALLOWED</strong> 访问权限。 如果这样做，则拒绝对目录的访问。 请改为指定 <strong>GENERIC_READ</strong> 访问权限。</p><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/about-directory-management">“关于目录管理</a>”。</p><h4 id="物理磁盘和卷"><a href="#物理磁盘和卷" class="headerlink" title="物理磁盘和卷"></a>物理磁盘和卷</h4><p>对磁盘或卷的直接访问受到限制。</p><p><strong>Windows Server 2003 和 Windows XP：</strong> 以这种方式不限制对磁盘或卷的直接访问。</p><p>可以使用 <strong>CreateFile</strong> 函数打开物理磁盘驱动器或卷，该驱动器返回直接访问存储设备 (DASD) 句柄，该句柄可与 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 函数一起使用。 这样，便可以直接访问磁盘或卷，例如分区表等磁盘元数据。 但是，这种类型的访问也会向潜在的数据丢失公开磁盘驱动器或卷，因为使用此机制对磁盘进行不正确的写入可能会使其内容无法访问操作系统。 为了确保数据完整性，请务必熟悉 <strong>DeviceIoControl</strong> ，以及其他 API 的行为方式与直接访问句柄不同，而不是文件系统句柄。</p><p>必须满足以下要求才能成功进行此类调用：</p><ul><li>调用方必须具有管理权限。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecBP/running-with-special-privileges">使用特殊特权运行</a>。</li><li><em>dwCreationDisposition</em> 参数必须具有<strong>OPEN_EXISTING</strong>标志。</li><li>打开卷或软盘时， <em>dwShareMode</em> 参数必须具有 <strong>FILE_SHARE_WRITE</strong> 标志。</li></ul><p><strong>注意*</strong>dwDesiredAccess* 参数可以是零，允许应用程序在不访问设备的情况下查询设备属性。 这适用于应用程序来确定软盘驱动器的大小及其支持的格式，而无需驱动器中的软盘磁盘，例如。 它还可用于读取统计信息，而无需更高级别的数据读取/写入权限。</p><p>打开物理驱动器 <em>x</em>：时， <em>lpFileName</em> 字符串应采用以下形式：“.\PhysicalDrive<em>X</em>”。 硬盘编号从零开始。 下表显示了物理驱动器字符串的一些示例。</p><div class="table-container"><table><thead><tr><th style="text-align:left">String</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">“\.\PhysicalDrive0”</td><td style="text-align:left">打开第一个物理驱动器。</td></tr><tr><td style="text-align:left">“\.\PhysicalDrive2”</td><td style="text-align:left">打开第三个物理驱动器。</td></tr></tbody></table></div><p>若要获取卷的物理驱动器标识符，请打开卷的句柄，并使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-ioctl_volume_get_volume_disk_extents">IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS</a> 调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 函数。 此控制代码返回每个卷的一个或多个盘区的磁盘数和偏移量;卷可以跨越多个物理磁盘。</p><p>有关打开物理驱动器的示例，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/calling-deviceiocontrol">调用 DeviceIoControl</a>。</p><p>例如，打开卷或可移动媒体驱动器 (时，软盘驱动器或闪存内存拇指驱动器) ， <em>lpFileName</em> 字符串应采用以下形式：“.*X*：”。 请勿使用尾随反斜杠 () ，指示驱动器的根目录。 下表显示了驱动器字符串的一些示例。</p><div class="table-container"><table><thead><tr><th style="text-align:left">String</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">“\.\A：”</td><td style="text-align:left">打开软盘驱动器 A。</td></tr><tr><td style="text-align:left">“\.\C：”</td><td style="text-align:left">打开 C： 卷。</td></tr><tr><td style="text-align:left">“\.\C：\”</td><td style="text-align:left">打开 C： 卷的文件系统。</td></tr></tbody></table></div><p>还可以通过引用其卷名称打开卷。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-volume">命名卷</a>。</p><p>卷包含一个或多个装载的文件系统。 即使 <strong>CreateFile</strong> 中未指定非缓存选项，也可以按特定文件系统的任意方式打开卷句柄。 应假定所有 Microsoft 文件系统都以非缓存的形式打开卷句柄。 对文件的非缓存 I/O 的限制也适用于卷。</p><p>即使数据未缓存，文件系统也可能不需要缓冲区对齐。 但是，如果在打开卷时指定了非缓存选项，则会强制实施缓冲区对齐方式，而不管卷上的文件系统如何。 建议在所有文件系统上以非缓存方式打开卷句柄，并遵循非缓存 I/O 限制。</p><p><strong>注意</strong> 若要读取或写入卷的最后几个扇区，必须调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 并指定 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-fsctl_allow_extended_dasd_io">FSCTL_ALLOW_EXTENDED_DASD_IO</a>。 这表示文件系统驱动程序不会对分区读取或写入调用执行任何 I/O 边界检查。 相反，边界检查由设备驱动程序执行。</p><h4 id="更改器设备"><a href="#更改器设备" class="headerlink" title="更改器设备"></a>更改器设备</h4><p><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 的 <strong>IOCTL_CHANGER_*</strong> 控制代码接受变更器设备的句柄。 若要打开变更器设备，请使用以下格式的文件名：“\.\Changer<em>x</em>”，其中 <em>x</em> 是一个数字，指示要打开的设备，从零开始。 若要在用 C 或 C++ 编写的应用程序中打开变更器设备零，请使用以下文件名：“\\.\\Changer0”。</p><h4 id="磁带驱动器"><a href="#磁带驱动器" class="headerlink" title="磁带驱动器"></a>磁带驱动器</h4><p>可以使用以下格式的文件名打开磁带驱动器：“\.\TAPE<em>x</em>”，其中 <em>x</em> 是一个数字，指示要打开的驱动器，从磁带驱动器零开始。 若要在以 C 或 C++ 编写的应用程序中打开磁带驱动器零，请使用以下文件名：“\\.\\TAPE0”。</p><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/Backup/backup">备份</a>。</p><h4 id="通信资源"><a href="#通信资源" class="headerlink" title="通信资源"></a>通信资源</h4><p><strong>CreateFile</strong> 函数可以创建通信资源的句柄，例如串行端口 COM1。 对于通信资源， <em>dwCreationDisposition</em> 参数必须 <strong>OPEN_EXISTING</strong>， <em>dwShareMode</em> 参数必须是零 (独占访问) ， <em>并且 hTemplateFile</em> 参数必须为 <strong>NULL</strong>。 可以指定读取、写入或读/写访问权限，并且可以为重叠 I/O 打开句柄。</p><p>若要指定大于 9 的 COM 端口号，请使用以下语法：“.\COM10”。 此语法适用于允许指定 COM 端口号的所有端口号和硬件。</p><p>有关通信的详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/communications-resources">通信</a>。</p><h4 id="机"><a href="#机" class="headerlink" title="机"></a>机</h4><p><strong>CreateFile</strong> 函数可以创建控制台输入 (CONIN$) 句柄。 如果进程由于继承或重复而具有打开的句柄，则它还可以创建活动屏幕缓冲区 (CONOUT$) 的句柄。 调用进程必须附加到继承的控制台或 <a href="https://learn.microsoft.com/zh-cn/windows/console/allocconsole">由 AllocConsole</a> 函数分配的控制台。 对于控制台句柄，请按如下所示设置 <strong>CreateFile</strong> 参数。</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">值</th></tr></thead><tbody><tr><td style="text-align:left">lpFileName</td><td style="text-align:left">使用 CONIN$ 值指定控制台输入。使用 CONOUT$ 值指定控制台输出。CONIN$ 获取控制台输入缓冲区的句柄，即使 <a href="https://learn.microsoft.com/zh-cn/windows/console/setstdhandle">SetStdHandle</a> 函数重定向标准输入句柄。 若要获取标准输入句柄，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/console/getstdhandle">GetStdHandle</a> 函数。CONOUT$ 获取活动屏幕缓冲区的句柄，即使 <a href="https://learn.microsoft.com/zh-cn/windows/console/setstdhandle">SetStdHandle</a> 重定向标准输出句柄。 若要获取标准输出句柄，请使用 <a href="https://learn.microsoft.com/zh-cn/windows/console/getstdhandle">GetStdHandle</a>。</td></tr><tr><td style="text-align:left">dwDesiredAccess</td><td style="text-align:left">`GENERIC_READ</td><td>GENERIC_WRITE` 首选，但任一限制访问。</td></tr><tr><td style="text-align:left">dwShareMode</td><td style="text-align:left">打开 CONIN$时，请指定 <strong>FILE_SHARE_READ</strong>。 打开 CONOUT$时，请指定 <strong>FILE_SHARE_WRITE</strong>。如果调用进程继承控制台，或者子进程应能够访问控制台，则必须是 `FILE_SHARE_READ</td><td>FILE_SHARE_WRITE`此参数。</td></tr><tr><td style="text-align:left">lpSecurityAttributes</td><td style="text-align:left">如果希望继承控制台，<a href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85">SECURITY_ATTRIBUTES结构的</a>)<strong>bInheritHandle</strong> 成员必须为 <strong>TRUE</strong>。</td></tr><tr><td style="text-align:left">dwCreationDisposition</td><td style="text-align:left">使用 <strong>CreateFile</strong> 打开控制台时，应指定<strong>OPEN_EXISTING</strong>。</td></tr><tr><td style="text-align:left">dwFlagsAndAttributes</td><td style="text-align:left">已忽略。</td></tr><tr><td style="text-align:left">hTemplateFile</td><td style="text-align:left">已忽略。</td></tr></tbody></table></div><p>下表显示了 <em>dwDesiredAccess</em> 和 <em>lpFileName</em> 的各种设置。</p><div class="table-container"><table><thead><tr><th style="text-align:left">lpFileName</th><th style="text-align:left">dwDesiredAccess</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td style="text-align:left">“CON”</td><td style="text-align:left"><strong>GENERIC_READ</strong></td><td style="text-align:left">打开用于输入的控制台。</td></tr><tr><td style="text-align:left">“CON”</td><td style="text-align:left"><strong>GENERIC_WRITE</strong></td><td style="text-align:left">打开用于输出的控制台。</td></tr><tr><td style="text-align:left">“CON”</td><td style="text-align:left">`GENERIC_READ</td><td style="text-align:left">GENERIC_WRITE`</td><td>导致 <strong>CreateFile</strong> 失败; <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_FILE_NOT_FOUND</strong>。</td></tr></tbody></table></div><h4 id="Mailslots"><a href="#Mailslots" class="headerlink" title="Mailslots"></a>Mailslots</h4><p>如果 <strong>CreateFile</strong> 打开 mailslot 的客户端端，则函数将返回 <strong>INVALID_HANDLE_VALUE</strong> 如果 mailslot 客户端尝试在 mailslot 服务器使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createmailslota">CreateMailSlot 函数创建本地 mailslot 之前打开本地 mailslot</a> 。</p><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/mailslots">Mailslots</a>。</p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>如果 <strong>CreateFile</strong> 打开命名管道的客户端端，该函数将使用处于侦听状态的命名管道的任何实例。 打开过程可以根据需要多次复制句柄，但在打开该句柄之后，另一个客户端无法打开命名管道实例。 打开管道时指定的访问必须与 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> 函数的 <em>dwOpenMode</em> 参数中指定的访问兼容。</p><p>如果在此操作之前未在服务器上成功调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> 函数，则管道将不存在， <strong>并且 CreateFile</strong> 将失败 <strong>并出现ERROR_FILE_NOT_FOUND</strong>。</p><p>如果至少有一个活动管道实例，但服务器上没有可用的侦听器管道，这意味着所有管道实例当前都已连接， <strong>则 CreateFile</strong> 会失败 <strong>并ERROR_PIPE_BUSY</strong>。</p><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/pipes">管道</a>。</p><h3 id="ReadFile-函数-fileapi-h"><a href="#ReadFile-函数-fileapi-h" class="headerlink" title="ReadFile 函数 (fileapi.h)"></a>ReadFile 函数 (fileapi.h)</h3><p>从指定的文件或输入/输出 (I/O) 设备读取数据。 如果设备支持，则读取发生在文件指针指定的位置。</p><p>此函数适用于同步操作和异步操作。 有关专为异步操作设计的类似函数，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a>。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">ReadFile</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>                HANDLE       hFile<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">]</span>               LPVOID       lpBuffer<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>                DWORD        nNumberOfBytesToRead<span class="token punctuation">,</span>  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>     LPDWORD      lpNumberOfBytesRead<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPOVERLAPPED lpOverlapped<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] hFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设备句柄 (例如文件、文件流、物理磁盘、卷、控制台缓冲区、磁带驱动器、套接字、通信资源、mailslot 或管道) 。</p><p>必须使用读取访问权限创建 <em>hFile</em> 参数。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/generic-access-rights">通用访问权限</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-security-and-access-rights">文件安全性和访问权限</a>。</p><p>对于异步读取操作，<em>hFile</em> 可以是使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 函数的<strong>FILE_FLAG_OVERLAPPED</strong>标志打开的任何句柄，也可以是套接字或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> 函数返回的<a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock2/nf-winsock2-socket">套接字</a>句柄。</p><pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向接收从文件或设备读取数据的缓冲区的指针。</p><p>此缓冲区必须在读取操作期间保持有效。 在读取操作完成之前，调用方不得使用此缓冲区。</p><pre class="line-numbers language-none"><code class="language-none">[in] nNumberOfBytesToRead<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要读取的最多字节数。</p><pre class="line-numbers language-none"><code class="language-none">[out, optional] lpNumberOfBytesRead<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指向使用同步 <em>hFile</em> 参数时接收读取的字节数的变量的指针。 <strong>ReadFile</strong> 将此值设置为零，然后再执行任何工作或错误检查。 如果这是一个异步操作，请对此参数使用 <strong>NULL</strong> ，以避免潜在的错误结果。</p><p>仅当 <em>lpOverlapped</em> 参数不为 <strong>NULL</strong> 时，此参数才可为 <strong>NULL</strong>。</p><p><strong>Windows 7：</strong> 此参数不能为 <strong>NULL</strong>。</p><p>有关详细信息，请参见“备注”部分。</p><pre class="line-numbers language-none"><code class="language-none">[in, out, optional] lpOverlapped<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong> 打开 <em>hFile</em> 参数，则需要指向 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的指针，否则可为 <strong>NULL</strong>。</p><p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong>打开 <em>hFile</em>，<em>则 lpOverlapped</em> 参数必须指向有效且唯一的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构，否则该函数无法错误地报告读取操作已完成。</p><p>对于支持字节偏移量的 <em>hFile</em> ，如果使用此参数，则必须指定从文件或设备开始读取的字节偏移量。 通过设置 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的 <strong>Offset</strong> 和 <strong>OffsetHigh</strong> 成员来指定此偏移量。 对于不支持字节偏移量的 <em>hFile</em>，将忽略 <strong>Offset 和 OffsetHigh</strong>。</p><p>有关 <em>lpOverlapped</em> 和 <strong>FILE_FLAG_OVERLAPPED</strong>的不同组合的详细信息，请参阅“备注”部分和 <strong>“同步和文件位置</strong> ”部分。</p><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>如果函数成功，则返回值为非零 (<strong>TRUE</strong>) 。</p><p>如果函数失败或异步完成，则返回值为零， (<strong>FALSE</strong>) 。 若要获取扩展的错误信息，请调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数。</p><p><strong>注意</strong><a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 代码<strong>ERROR_IO_PENDING</strong>不是失败;它指定读取操作正在异步等待完成。 有关详细信息，请参阅“备注”。</p><h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><p>发生以下情况之一时， <strong>ReadFile</strong> 函数将返回：</p><ul><li></li><li><p>读取请求的字节数。</p></li><li>写入操作在管道的写入端完成。</li><li>正在使用异步句柄，读取正在异步发生。</li><li>发生错误。</li></ul><p>每当有过多未完成的异步 I/O 请求时，<strong>ReadFile</strong> 函数可能会失败<strong>，**</strong>ERROR_INVALID_USER_BUFFER或ERROR_NOT_ENOUGH_MEMORY**。</p><p>若要取消所有挂起的异步 I/O 操作，请使用以下任一操作：</p><ul><li></li><li><p><a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelio">CancelIo</a> - 此函数仅取消由指定文件句柄的调用线程发出的操作。</p></li><li><a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelioex-func">CancelIoEx</a> - 此函数取消指定文件句柄的线程发出的所有操作。</li></ul><p>使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</a> 取消挂起的同步 I/O 操作。</p><p>取消的 I/O 操作已完成，错误 <strong>ERROR_OPERATION_ABORTED</strong>。</p><p><strong>ReadFile</strong> 函数可能会失败<strong>，ERROR_NOT_ENOUGH_QUOTA</strong>，这意味着调用进程的缓冲区无法锁定页。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-setprocessworkingsetsize">SetProcessWorkingSetSize</a>。</p><p>如果某个文件的一部分被另一个进程锁定，并且读取操作与锁定部分重叠，则此函数将失败。</p><p>读取操作使用缓冲区时访问输入缓冲区可能会导致读取到该缓冲区的数据损坏。 在读取操作完成之前，应用程序不得读取、写入、重新分配或释放读取操作使用的输入缓冲区。 使用异步文件句柄时，这尤其有问题。 有关同步与异步文件句柄的其他信息，可以在 <a href="https://learn.microsoft.com/zh-cn/">“同步和文件位置</a> ”部分以及 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 参考主题中找到。</p><p>可以使用具有控制台输入句柄的 <strong>ReadFile</strong> 从控制台输入缓冲区读取字符。 控制台模式确定 <strong>ReadFile</strong> 函数的确切行为。 默认情况下，控制台模式 <strong>ENABLE_LINE_INPUT</strong>，指示 <strong>ReadFile</strong> 应在到达回车前读取。 如果按 Ctrl+C，则调用成功，但 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_OPERATION_ABORTED</strong>。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>。</p><p>从通信设备读取时， <strong>ReadFile</strong> 的行为由当前通信超时确定为集，并使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-setcommtimeouts">SetCommTimeouts</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-getcommtimeouts">GetCommTimeouts</a> 函数进行检索。 如果无法设置超时值，则可能会出现不可预知的结果。 有关通信超时的详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/ns-winbase-commtimeouts">COMMTIMEOUTS</a>。</p><p>如果 <strong>ReadFile</strong> 尝试从具有太小缓冲区的邮件图中读取，则函数返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_INSUFFICIENT_BUFFER</strong>。</p><p>使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志成功使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 打开的文件有严格的要求。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</p><p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong> 打开 <em>hFile</em>，则以下条件有效：</p><ul><li></li><li><p><em>lpOverlapped</em> 参数必须指向有效且唯一的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构，否则该函数可以错误地报告读取操作已完成。</p></li><li><em>lpNumberOfBytesRead</em> 参数应设置为 <strong>NULL</strong>。 使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> 函数获取读取的实际字节数。 如果 <em>hFile</em> 参数与 I/O 完成端口相关联，则还可以通过调用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> 函数获取读取的字节数。</li></ul><h4 id="同步和文件位置"><a href="#同步和文件位置" class="headerlink" title="同步和文件位置"></a>同步和文件位置</h4><p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong>打开 <em>hFile</em>，则它是异步文件句柄;否则为同步。 使用 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的规则对每个结构略有不同，如前所述。</p><p><strong>注意</strong> 如果为异步 I/O 打开文件或设备，则使用该句柄对 <strong>ReadFile</strong> 等函数的后续调用通常会立即返回，但对于被阻止的执行，也可以同步执行。 有关更多信息，请参见<a href="https://support.microsoft.com/kb/156932">http://support.microsoft.com/kb/156932</a>。</p><p>使用异步文件句柄的注意事项：</p><ul><li><p><strong>ReadFile</strong> 可能会在读取操作完成之前返回。 在此方案中， <strong>ReadFile</strong> 返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数返回 <strong>ERROR_IO_PENDING</strong>，这允许调用进程在系统完成读取操作时继续。</p></li><li><p>lpOverlapped</p></li></ul><p>  参数不得为</p><p>  NULL</p><p>  ，应与以下事实一起使用：</p><ul><li>尽管 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件由系统自动设置和重置，但 <strong>在 OVERLAPPED</strong> 结构中指定的偏移量不会自动更新。</li><li><strong>ReadFile</strong> 在开始 I/O 操作时将事件重置为非对齐状态。</li><li>在 READ 操作完成时， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件设置为信号状态;直到该时间，读取操作被视为挂起。</li><li>由于读取操作从 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的偏移量开始，并且 <strong>ReadFile</strong> 可能会在系统级读取操作完成 (读取挂起) 之前返回，因此，应用程序不应修改、释放或重用结构的任何其他部分，直到向事件发出信号 (（即） 读取完成) 。</li><li>如果在异步操作期间检测到文件结束 (EOF) ，则对该操作的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> 的调用将返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_HANDLE_EOF</strong>。</li></ul><p>使用同步文件句柄的注意事项：</p><ul><li>如果 <em>lpOverlapped</em> 为 <strong>NULL</strong>，则读取操作从当前文件位置开始， <strong>ReadFile</strong> 在操作完成之前不会返回，并且系统会在 <strong>ReadFile</strong> 返回之前更新文件指针。</li><li>如果 <em>lpOverlapped</em> 不是 <strong>NULL</strong>，则读取操作从 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的偏移量开始， <strong>ReadFile</strong> 在读取操作完成之前不会返回。 系统在 <strong>ReadFile</strong> 返回之前更新 <strong>OVERLAPPED</strong> 偏移量和文件指针。</li><li>如果 <em>lpOverlapped</em> 为 <strong>NULL</strong>，则当同步读取操作到达文件末尾时， <strong>ReadFile</strong> 将返回 <strong>TRUE</strong> 并将设置为 <code>*lpNumberOfBytesRead</code> 零。</li><li>如果 <em>lpOverlapped</em> 不是 <strong>NULL</strong>，则当同步读取操作到达文件末尾时， <strong>ReadFile</strong> 将返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_HANDLE_EOF</strong>。</li></ul><p>有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 和 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">同步和异步 I/O</a>。</p><h4 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a>管道</h4><p>如果使用匿名管道并且写入句柄已关闭，则 <strong>当 ReadFile</strong> 尝试使用管道的相应读取句柄进行读取时，函数将返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_BROKEN_PIPE</strong>。</p><p>如果在消息模式下读取命名管道，并且下一条消息的长度超过 <em>nNumberOfBytesToRead</em> 参数指定， <strong>ReadFile</strong> 将返回 <strong>FALSE</strong> ， <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_MORE_DATA</strong>。 后续调用 <strong>ReadFile</strong> 或 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe">PeekNamedPipe</a> 函数可以读取消息的其余部分。</p><p>如果 <strong>ReadFile</strong> 在管道上返回 <strong>TRUE</strong> 时<em>，lpNumberOfBytesRead</em> 参数为零，则管道的另一端称为 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> 函数，<em>nNumberOfBytesToWrite</em> 设置为零。</p><p>有关管道的详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/pipes">管道</a>。</p><h4 id="事务处理的操作"><a href="#事务处理的操作" class="headerlink" title="事务处理的操作"></a>事务处理的操作</h4><p>如果存在绑定到文件句柄的事务，则该函数将从文件的事务处理视图中返回数据。 保证事务处理读取句柄在句柄期间显示文件的相同视图。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/about-transactional-ntfs">关于事务 NTFS</a>。</p><p>在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Windows 32API </tag>
            
            <tag> 摸鱼ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摸鱼ing（1）-Windows-API-程序设计初探（2）</title>
      <link href="/2023/05/16/%E6%91%B8%E9%B1%BCing%EF%BC%881%EF%BC%89-Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%9D%E6%8E%A2%EF%BC%882%EF%BC%89/"/>
      <url>/2023/05/16/%E6%91%B8%E9%B1%BCing%EF%BC%881%EF%BC%89-Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%9D%E6%8E%A2%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-API-编程初探2"><a href="#Windows-API-编程初探2" class="headerlink" title="Windows API 编程初探2"></a>Windows API 编程初探2</h1><h2 id="字符串主题"><a href="#字符串主题" class="headerlink" title="字符串主题"></a>字符串主题</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>​        下面我们开始入门简单的字符串主题：啥意思呢？回顾我们C语言的API。我们是如下声明一个char类型或基于char类型的数组</p><pre class="line-numbers language-none"><code class="language-none">char typicalChar &#x3D; &#39;A&#39;;char* TCPtr &#x3D; &quot;Hello!My friend~&quot;;char arrayCPtr &#x3D; &quot;hello,my frined~&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        我们马上可以看到，char是一份字节大小，那么下面的arrayCPtr就指明需要17个字节来存储。</p><h3 id="wchar-t类型"><a href="#wchar-t类型" class="headerlink" title="wchar_t类型"></a>wchar_t类型</h3><p>​        可是，仅仅使用char可能存储不下如今丰富的字符。所以，转向扩展char是必要的，wchar,也就是widechar应运而生。在Windows 2000之后所有的Windows系统都在底层上支持Unicode字符集。</p><p>​        我们这样声明与初始化一个wchar变量：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t wideChar &#x3D; L&#39;A&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230505135217906.png" alt="image-20230505135217906"></p><p>​        类似的：</p><pre class="line-numbers language-none"><code class="language-none">wchar* ptrW &#x3D; &quot;Hello&quot;;wchar ptr[7] &#x3D; &quot;Hello!&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        但是注意：如果我们还是选择</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%s&quot;, ptrW);printf(&quot;%s&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        则只会打印首元素，这是因为字符串类型不匹配，人话讲就是：wchar字符串不用%s打印，而是ls</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%ls&quot;, ptrW);printf(&quot;%ls&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        或者是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t* WPTR &#x3D; &#123;&#39;a&#39;,&#39;\0&#39;&#125;; wprintf(&quot;%s&quot;,WPTR);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        或是直接调用setlocal函数做默认的设置！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;locale.h&gt;int main()&#123;&#x2F;&#x2F;使用系统默认的设置调用setlocale(LC_ALL, &quot;&quot;);setlocale(LC_ALL, &quot;&quot;);const wchar_t * chWord &#x3D; L&quot;疯狂程序人—码农哈哥&quot;;printf(&quot;%s&quot;,chWord);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Windows下的字符和宽字符"><a href="#Windows下的字符和宽字符" class="headerlink" title="Windows下的字符和宽字符"></a>Windows下的字符和宽字符</h3><p>​        Windows整理自己的活：他们定义了他们自己的字符类型：在winnt.h文件下可以找到：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;&#x2F;&#x2F; Basics&#x2F;&#x2F;#ifndef VOID#define VOID voidtypedef char CHAR;typedef short SHORT;typedef long LONG;#if !defined(MIDL_PASS)typedef int INT;#endif#endif&#x2F;&#x2F;&#x2F;&#x2F; UNICODE (Wide Character) types&#x2F;&#x2F;#ifndef _MACtypedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#else&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a chartypedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#endiftypedef WCHAR *PWCHAR, *LPWCH, *PWCH;typedef CONST WCHAR *LPCWCH, *PCWCH;typedef _Null_terminated_ WCHAR *NWPSTR, *LPWSTR, *PWSTR;typedef _Null_terminated_ PWSTR *PZPWSTR;typedef _Null_terminated_ CONST PWSTR *PCZPWSTR;typedef _Null_terminated_ WCHAR UNALIGNED *LPUWSTR, *PUWSTR;typedef _Null_terminated_ CONST WCHAR *LPCWSTR, *PCWSTR;typedef _Null_terminated_ PCWSTR *PZPCWSTR;typedef _Null_terminated_ CONST PCWSTR *PCZPCWSTR;typedef _Null_terminated_ CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;typedef _NullNull_terminated_ WCHAR *PZZWSTR;typedef _NullNull_terminated_ CONST WCHAR *PCZZWSTR;typedef _NullNull_terminated_ WCHAR UNALIGNED *PUZZWSTR;typedef _NullNull_terminated_ CONST WCHAR UNALIGNED *PCUZZWSTR;typedef  WCHAR *PNZWCH;typedef  CONST WCHAR *PCNZWCH;typedef  WCHAR UNALIGNED *PUNZWCH;typedef  CONST WCHAR UNALIGNED *PCUNZWCH;#if _WIN32_WINNT &gt;&#x3D; 0x0600 || (defined(__cplusplus) &amp;&amp; defined(WINDOWS_ENABLE_CPLUSPLUS))typedef CONST WCHAR *LPCWCHAR, *PCWCHAR;typedef CONST WCHAR UNALIGNED *LPCUWCHAR, *PCUWCHAR;&#x2F;&#x2F;&#x2F;&#x2F;  UCS (Universal Character Set) types&#x2F;&#x2F;typedef unsigned long UCSCHAR;&#x2F;&#x2F;&#x2F;&#x2F;  Even pre-Unicode agreement, UCS values are always in the&#x2F;&#x2F;  range U+00000000 to U+7FFFFFFF, so we&#39;ll pick an obvious&#x2F;&#x2F;  value.#define UCSCHAR_INVALID_CHARACTER (0xffffffff)#define MIN_UCSCHAR (0)&#x2F;&#x2F;&#x2F;&#x2F;  We&#39;ll assume here that the ISO-10646 &#x2F; Unicode agreement&#x2F;&#x2F;  not to assign code points after U+0010FFFF holds so that&#x2F;&#x2F;  we do not have to have separate &quot;UCSCHAR&quot; and &quot;UNICODECHAR&quot;&#x2F;&#x2F;  types.&#x2F;&#x2F;#define MAX_UCSCHAR (0x0010FFFF)typedef UCSCHAR *PUCSCHAR;typedef const UCSCHAR *PCUCSCHAR;typedef UCSCHAR *PUCSSTR;typedef UCSCHAR UNALIGNED *PUUCSSTR;typedef const UCSCHAR *PCUCSSTR;typedef const UCSCHAR UNALIGNED *PCUUCSSTR;typedef UCSCHAR UNALIGNED *PUUCSCHAR;typedef const UCSCHAR UNALIGNED *PCUUCSCHAR;#endif &#x2F;&#x2F; _WIN32_WINNT &gt;&#x3D; 0x0600&#x2F;&#x2F;&#x2F;&#x2F; ANSI (Multi-byte Character) types&#x2F;&#x2F;typedef CHAR *PCHAR, *LPCH, *PCH;typedef CONST CHAR *LPCCH, *PCCH;typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;typedef _Null_terminated_ PSTR *PZPSTR;typedef _Null_terminated_ CONST PSTR *PCZPSTR;typedef _Null_terminated_ CONST CHAR *LPCSTR, *PCSTR;typedef _Null_terminated_ PCSTR *PZPCSTR;typedef _Null_terminated_ CONST PCSTR *PCZPCSTR;typedef _NullNull_terminated_ CHAR *PZZSTR;typedef _NullNull_terminated_ CONST CHAR *PCZZSTR;typedef  CHAR *PNZCH;typedef  CONST CHAR *PCNZCH;&#x2F;&#x2F;&#x2F;&#x2F; Neutral ANSI&#x2F;UNICODE types and macros&#x2F;&#x2F;#ifdef  UNICODE                     &#x2F;&#x2F; r_winnt#ifndef _TCHAR_DEFINEDtypedef WCHAR TCHAR, *PTCHAR;typedef WCHAR TBYTE , *PTBYTE ;#define _TCHAR_DEFINED#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;typedef LPWCH LPTCH, PTCH;typedef LPCWCH LPCTCH, PCTCH;typedef LPWSTR PTSTR, LPTSTR;typedef LPCWSTR PCTSTR, LPCTSTR;typedef LPUWSTR PUTSTR, LPUTSTR;typedef LPCUWSTR PCUTSTR, LPCUTSTR;typedef LPWSTR LP;typedef PZZWSTR PZZTSTR;typedef PCZZWSTR PCZZTSTR;typedef PUZZWSTR PUZZTSTR;typedef PCUZZWSTR PCUZZTSTR;typedef PZPWSTR PZPTSTR;typedef PNZWCH PNZTCH;typedef PCNZWCH PCNZTCH;typedef PUNZWCH PUNZTCH;typedef PCUNZWCH PCUNZTCH;#define __TEXT(quote) L##quote      &#x2F;&#x2F; r_winnt#else   &#x2F;* UNICODE *&#x2F;               &#x2F;&#x2F; r_winnt#ifndef _TCHAR_DEFINEDtypedef char TCHAR, *PTCHAR;typedef unsigned char TBYTE , *PTBYTE ;#define _TCHAR_DEFINED#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;typedef LPCH LPTCH, PTCH;typedef LPCCH LPCTCH, PCTCH;typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;typedef PZZSTR PZZTSTR, PUZZTSTR;typedef PCZZSTR PCZZTSTR, PCUZZTSTR;typedef PZPSTR PZPTSTR;typedef PNZCH PNZTCH, PUNZTCH;typedef PCNZCH PCNZTCH, PCUNZTCH;#define __TEXT(quote) quote         &#x2F;&#x2F; r_winnt#endif &#x2F;* UNICODE *&#x2F;                &#x2F;&#x2F; r_winnt#define TEXT(quote) __TEXT(quote)   &#x2F;&#x2F; r_winnttypedef SHORT *PSHORT;  typedef LONG *PLONG;    #define ALL_PROCESSOR_GROUPS        0xffff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在这里我们找到了两个东西：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef _MACtypedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#else&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a chartypedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        首先是wchar_t被重写位WCHAR。对于一些甚至没有wchar的编译器直接对unsigned short起别名。</p><p>​        其次是TEXT宏，这个宏便捷的帮助我们直接将普通的字符串升级为宽字符串，其做法不是强制转换，而是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define __TEXT(quote) L##quote#define TEXT(quote) __TEXT(quote)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        ##是令牌粘贴，就是直接把L和字符串连接在一起返回，比若说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TEXT(&quot;Hello&quot;)--- Compiler----&gt; L&quot;Hello&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们看到，上面的定义给出了：PSTR和LPSTR的小东西。他们都是CHAR（本质上就是Char），而P C STR 和 LP C STR则是Const类型的字符串。也就是常字符串！</p><p>​        那对于TCHAR这样Windows自己给出了字符串，我们应该怎么处理呢了，答案是万能的WIndows又帮我们干好了。使用P T STR和LP T STR就可以胜任这些工作！</p><h2 id="常见的字符串处理工作"><a href="#常见的字符串处理工作" class="headerlink" title="常见的字符串处理工作"></a>常见的字符串处理工作</h2><h3 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h3><p>​        下面我们要说的是如何获取字符串的长度，请看strlen和wstrlen.</p><pre class="line-numbers language-none"><code class="language-none">size_t strlen(const char* str);size_t wstrlen(const wchar_t* str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        size_t，如其所说的那样，衡量的是大小的类型。其定义查看建议自行搜索，这里做阐述。因为不是重点我想说的！</p><p>​        来试试看：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;tchar.h&gt;int main() &#123;CHAR str[] &#x3D; &quot;C语言\0&quot;; &#x2F;&#x2F; 这个函数返回占比字节的大小WCHAR wstr[] &#x3D; L&quot;C语言&quot;; &#x2F;&#x2F; 这个函数返回的是宽字符的个数_tprintf(TEXT(&quot;strlen(str) &#x3D; %d\n wcslen(wstr) &#x3D; %d&quot;), strlen(str), wcslen(wstr));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <img src="image-20230505235033338.png" alt="image-20230505235033338"></p><p>​        注意到_tprintf是一个随系统环境而改变的宏函数，在支持UNICODE字符集的情况下，系统将会自动的转化之成为wprintf！</p><p>​        类似的：我们还有一个叫做tcslen这个函数，他是这样被定义的：</p><p><img src="image-20230505235214903.png" alt="image-20230505235214903"></p><p>​        好鸡肋啊，那如果我们改一下不支持Unicode子集呢？仍然是右键项目——属性，转到这个地方：</p><p><img src="image-20230505235414875.png" alt="image-20230505235414875"></p><p>​        改成</p><p><img src="image-20230505235429080.png" alt="image-20230505235429080"></p><p>​        发现变灰了！转向再看发现跳转到了：&gt;</p><p><img src="image-20230505235350688.png" alt="image-20230505235350688"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Windows 32API </tag>
            
            <tag> 摸鱼ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT-new-6</title>
      <link href="/2023/05/14/QT-new-6/"/>
      <url>/2023/05/14/QT-new-6/</url>
      
        <content type="html"><![CDATA[<h1 id="QT-NEW6"><a href="#QT-NEW6" class="headerlink" title="QT NEW6"></a>QT NEW6</h1><p>​        QMainWindow是一个为用户提供主窗口程序的类，它包含一个菜单栏，多个工具栏，多个铆接部件，一个状态栏和一个中心部件，是多个应用程序的基础，如文本编辑器，图片编辑器等等</p><p><img src="image-20230425213236864.png" alt="image-20230425213236864"></p><p>​        现在我们尝试创建一个QMainWindow，并运行之：</p><p><img src="image-20230425213429856.png" alt="image-20230425213429856"></p><p>​        好小！调整一下，在MainWindow里头resize一下完事！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)&#123;resize(640,480);&#125;MainWindow::~MainWindow()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230425213559077.png" alt="image-20230425213559077"></p><p>​        下面创建一个菜单栏，他是QMenuBar类的</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QMenuBar* bar &#x3D; menuBar();&#x2F;&#x2F; 设置当前窗口的菜单栏setMenuBar(bar);&#x2F;&#x2F; 设定名称&#x2F;&#x2F; 事实上不是这样用的，但是为了展示效果如此bar-&gt;addMenu(&quot;文件&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230425214129151.png" alt="image-20230425214129151"></p><p>​        好吧，事实上是我们是使用一个菜单对象来接受之：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QMenu<span class="token operator">*</span> fileMenu <span class="token operator">=</span> bar<span class="token operator">-></span><span class="token function">addMenu</span><span class="token punctuation">(</span><span class="token string">"文件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们这样做是为了后续的其他操作！比如说，现在我们想点击它让他下拉一个菜单来，那就</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">fileMenu<span class="token operator">-></span><span class="token function">addAction</span><span class="token punctuation">(</span><span class="token string">"新建"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//添加一个分割符</span>fileMenu<span class="token operator">-></span><span class="token function">addSeparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   fileMenu<span class="token operator">-></span><span class="token function">addAction</span><span class="token punctuation">(</span><span class="token string">"打开"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230425214843993.png" alt="image-20230425214843993"></p><h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;工具栏 QToolBar* toolBar &#x3D; new QToolBar(this); addToolBar(toolBar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​            这个流程为我们的窗口添加了一个工具栏</p><p><img src="image-20230425215242772.png" alt="image-20230425215242772"></p><p>​        看到有变化！是的就是我们的工具栏。</p><p>​        工具栏是允许有多个的！我们再仔细瞧瞧其他的add重载函数！</p><p>​        这个引起了我们的注意</p><p><img src="image-20230425215627044.png" alt="image-20230425215627044"></p><p>​        这个函数究竟实现了啥功能呢？把这个函数扔进QT  帮助手册里</p><p><img src="image-20230425215808333.png" alt="image-20230425215808333"></p><p>​        这个地方，点击第一个参数的类去</p><p><img src="image-20230425215834180.png" alt="image-20230425215834180"></p><p>​        很明显了！就是再说这个工具栏初始时停靠在哪里！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">addToolBar(Qt::LeftToolBarArea,toolBar);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230425215957733.png" alt="image-20230425215957733"></p><p>​        这是设计默认区域。总结一下</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include&lt;QMenuBar&gt;#include&lt;QToolBar&gt;#include&lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)&#123;    &#x2F;&#x2F;重置窗口大小    resize(640,480);    &#x2F;&#x2F;创建菜单栏，最多只能有一个    QMenuBar* bar&#x3D; menuBar();    &#x2F;&#x2F;设置显示窗口为当前窗口    setMenuBar(bar);    &#x2F;&#x2F;菜单    QMenu* fileMenu &#x3D; bar-&gt;addMenu(&quot;文件&quot;);    QMenu* editMenu &#x3D; bar-&gt;addMenu(&quot;编辑&quot;);    &#x2F;&#x2F;添加菜单项    fileMenu-&gt;addAction(&quot;新建&quot;);    &#x2F;&#x2F;添加分隔符    fileMenu-&gt;addSeparator();    fileMenu-&gt;addAction(&quot;打开&quot;);    &#x2F;&#x2F;添加工具栏    QToolBar* toolBar &#x3D; new QToolBar(this);    addToolBar(Qt::LeftToolBarArea,toolBar);        &#125;MainWindow::~MainWindow()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面说说它只允许停靠在一个方向。我们可以查看QToolBar的成员函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; constructorQToolBar(const QString &amp;title, QWidget *parent &#x3D; Q_NULLPTR)QToolBar(QWidget *parent &#x3D; Q_NULLPTR)&#x2F;&#x2F; destructor~QToolBar()QAction *actionAt(const QPoint &amp;p) constQAction *actionAt(int x, int y) constQAction *addAction(const QString &amp;text)QAction *addAction(const QIcon &amp;icon, const QString &amp;text)QAction *addAction(const QString &amp;text, const QObject *receiver, const char *member)QAction *addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *receiver, const char *member)QAction *addAction(const QString &amp;text, const QObject *receiver, PointerToMemberFunction method)QAction *addAction(const QString &amp;text, Functor functor)QAction *addAction(const QString &amp;text, const QObject *context, Functor functor)QAction *addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *receiver, PointerToMemberFunction method)QAction *addAction(const QIcon &amp;icon, const QString &amp;text, Functor functor)QAction *addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *context, Functor functor)QAction *addSeparator()QAction *addWidget(QWidget *widget)Qt::ToolBarAreas allowedAreas() constvoid clear()QSize iconSize() constQAction *insertSeparator(QAction *before)QAction *insertWidget(QAction *before, QWidget *widget)bool isAreaAllowed(Qt::ToolBarArea area) constbool isFloatable() constbool isFloating() constbool isMovable() constQt::Orientation orientation() constvoid setAllowedAreas(Qt::ToolBarAreas areas)void setFloatable(bool floatable)void setMovable(bool movable)void setOrientation(Qt::Orientation orientation)QAction *toggleViewAction() constQt::ToolButtonStyle toolButtonStyle() constQWidget *widgetForAction(QAction *action) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        看到</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool isAreaAllowed(Qt::ToolBarArea area) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        不正是表明停靠范围！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setAllowedAreas(Qt::RightToolBarArea|Qt::LeftToolBarArea);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        以及设置是否可以浮动：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setFloatable(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        甚至可以设置是否可以移动！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setMovable(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        下面设置内容：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;addAction(&quot;这是action 1&quot;);toolBar-&gt;addAction(&quot;这是action2&quot;);&#x2F;&#x2F;使用这个方法表明的是跟菜单栏是公用同一个功能的！&#x2F;&#x2F;需要接受返回值&#x2F;&#x2F;QAction* newAct &#x3D; fileMenu-&gt;addAction(&quot;新建&quot;);toolBar-&gt;addAction(openAct);&#x2F;&#x2F;其他类似toolBar-&gt;addAction(newAct);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        工具栏也可以添加分割线：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;addSeparator();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        还可以添加控件！！！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QPushButton* btn &#x3D; new QPushButton(&quot;a btn for the toolBar&quot;,this);toolBar-&gt;addWidget(btn);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>​        最多也只能有一个</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QStatusBar* stbar &#x3D; statusBar();setStatusBar(stbar);QLabel* lab &#x3D; new QLabel(&quot;a mentions&quot;,this);&#x2F;&#x2F; QLable是Widget控件stbar-&gt;addWidget(lab);&#x2F;&#x2F; 左侧QLabel* lab2 &#x3D; new QLabel(&quot;2 mentions&quot;,this);stbar-&gt;addPermanentWidget(lab2);&#x2F;&#x2F;右侧<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        也可以添加铆接部件，可以有多个</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;铆接部件（可以一大堆）QDockWidget* dock &#x3D; new QDockWidget(this);addDockWidget(Qt::BottomDockWidgetArea,dock);&#x2F;&#x2F;设置中心部件.可以别让浮动窗口占据窗口QTextEdit* edit &#x3D; new QTextEdit(this);setCentralWidget(edit);dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于全局者，都是set,只能有一个，反之可以多个（add_）</p><p>​        回顾一下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;#include&lt;QMenuBar&gt;#include&lt;QToolBar&gt;#include&lt;QDebug&gt;#include&lt;QPushButton&gt;#include&lt;QStatusBar&gt;#include&lt;QLabel&gt;#include&lt;QDockWidget&gt;#include&lt;QTextEdit&gt;MainWindow::MainWindow(QWidget *parent)    : QMainWindow(parent)&#123;    &#x2F;&#x2F;重置窗口大小    resize(1640,880);    &#x2F;&#x2F;创建菜单栏，最多只能有一个    QMenuBar* bar&#x3D; menuBar();    &#x2F;&#x2F;设置显示窗口为当前窗口    setMenuBar(bar);    &#x2F;&#x2F;菜单    QMenu* fileMenu &#x3D; bar-&gt;addMenu(&quot;文件&quot;);    QMenu* editMenu &#x3D; bar-&gt;addMenu(&quot;编辑&quot;);    &#x2F;&#x2F;添加菜单项    QAction* newAct&#x3D; fileMenu-&gt;addAction(&quot;新建&quot;);    &#x2F;&#x2F;添加分隔符    fileMenu-&gt;addSeparator();     QAction* openAct&#x3D; fileMenu-&gt;addAction(&quot;打开&quot;);    &#x2F;&#x2F;添加工具栏    QToolBar* toolBar &#x3D; new QToolBar(this);    addToolBar(Qt::LeftToolBarArea,toolBar);    &#x2F;&#x2F;设置允许停靠区域    toolBar-&gt;setAllowedAreas(Qt::RightToolBarArea|Qt::LeftToolBarArea);    &#x2F;&#x2F;设置行为    toolBar-&gt;addAction(&quot;这是action 1&quot;);    toolBar-&gt;addAction(&quot;这是action2&quot;);    toolBar-&gt;addAction(openAct);    toolBar-&gt;addSeparator();    toolBar-&gt;addAction(newAct);    &#x2F;&#x2F;放置控件    QPushButton* btn &#x3D; new QPushButton(&quot;a btn for the toolBar&quot;,this);    toolBar-&gt;addWidget(btn);    &#x2F;&#x2F;状态栏    QStatusBar* stbar &#x3D; statusBar();    setStatusBar(stbar);    &#x2F;&#x2F;加点东西    QLabel* lab &#x3D; new QLabel(&quot;a mentions&quot;,this);    &#x2F;&#x2F; QLable是Widget控件    stbar-&gt;addWidget(lab);    QLabel* lab2 &#x3D; new QLabel(&quot;2 mentions&quot;,this);    stbar-&gt;addPermanentWidget(lab2);    &#x2F;&#x2F;铆接部件（可以一大堆）    QDockWidget* dock &#x3D; new QDockWidget(this);    addDockWidget(Qt::BottomDockWidgetArea,dock);    &#x2F;&#x2F;设置中心部件.可以别让浮动窗口占据窗口    QTextEdit* edit &#x3D; new QTextEdit(this);    setCentralWidget(edit);    dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea);&#125;MainWindow::~MainWindow()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加资源文件"><a href="#添加资源文件" class="headerlink" title="添加资源文件"></a>添加资源文件</h2><p>​        我们现在打开UI设计一栏，现在可以直接开始先设计后构建代码逻辑了</p><p><img src="image-20230514102111415.png" alt="image-20230514102111415"></p><p>​        菜单项必须必须输入英文，这是因为跟变量命名有关，可以后续改动text 值来改变显示</p><p><img src="image-20230514101928675.png" alt="image-20230514101928675"></p><p>​        其他就不多阐述了，类似的。</p><p>​        如何使用代码访问ui呢？会带mainwindow.cpp</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this); &#x2F;&#x2F; 类似于这样的！&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        添加一个图标吧：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;D:&#x2F;QT projects&#x2F;9&#x2F;source&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        首先先把资源放到项目目录路径下，不然肯定找不到！</p><p>​        如何快速的在项目中添加文件呢？先去右键项目：添加性文件，选择QT下的Qt resource files</p><p>​        然后，添加：会发现要求你写一个前缀，这是为了分类资源文件。可以偷懒直接写一个\</p><p>​        在项目中引用只需要按照格式：</p><pre class="line-numbers language-none"><code class="language-none">: + prefix + fileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也即是: + 前缀加上文件名即可</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;:&#x2F;source&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab-SystematicallyLearn1</title>
      <link href="/2023/05/13/Matlab-SystematicallyLearn1/"/>
      <url>/2023/05/13/Matlab-SystematicallyLearn1/</url>
      
        <content type="html"><![CDATA[<h1 id="Matlab基础学习"><a href="#Matlab基础学习" class="headerlink" title="Matlab基础学习"></a>Matlab基础学习</h1><p>(先看先前的Matlab版本)</p><p>Matlab是一门语言：</p><p><img src="image-20230513075306507.png" alt="image-20230513075306507"></p><p>一些注意点：</p><p><img src="image-20230513075357872.png" alt="image-20230513075357872"></p><h2 id="开始入门"><a href="#开始入门" class="headerlink" title="开始入门"></a>开始入门</h2><p>首先，Matlab自己也是一门编程语言。这意味着它可以有变量的命名。同其他编程语言类似，</p><p>1.Matlab区分大小写，</p><p>2.变量名长度不得超过63位，</p><p>3.并且由字母，数字和下划线组成。但不可以使用标点。</p><p>By the way。同其他命名规则一致——变量名应当简洁明了！</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>有以下几种类形：</p><p>数字，字符和字符串，<strong>矩阵（数组）</strong>，元胞数据，结构体（对，C语言那种）。</p><h2 id="demo与散记"><a href="#demo与散记" class="headerlink" title="demo与散记"></a>demo与散记</h2><p>1.在Matlab里，我们用%%表达注释，我们开一个脚本看看：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token comment">%% I. 清空环境变量及其Command Window的所有命令</span>clear allclc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.变量名规则展示</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token comment">%% II. </span>A <span class="token operator">=</span> <span class="token number">2</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token comment">%% abcdefgjfpwoejfoba4ett4gbamjofwoFP3VN0R92UDX023gag3w523cd2n3o823apc7i$3rc7i34vc98p = 2</span><span class="token comment">%% 取消注释看看</span><span class="token comment">%% 3b = 4 (x)</span>a_2 <span class="token operator">=</span> <span class="token number">5</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.几种常见的类型</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token comment">%% 数字</span>s <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token comment">%% 字符</span><span class="token function">abs</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token comment">%% 返回字符的ASCII码值</span><span class="token function">char</span><span class="token punctuation">(</span><span class="token number">65</span><span class="token punctuation">)</span> <span class="token comment">%% 返回对应的ASCII：A</span><span class="token function">num2str</span><span class="token punctuation">(</span><span class="token number">65</span><span class="token punctuation">)</span> <span class="token comment">%%返回字符串的65</span>str <span class="token operator">=</span> <span class="token string">'Learning matlabs machine learning'</span><span class="token function">length</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>doc num2str<span class="token punctuation">;</span> <span class="token comment">%% 快速查看文档</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230513080824005.png" alt="image-20230513080824005"></p><h2 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h2><h3 id="定义-初始化"><a href="#定义-初始化" class="headerlink" title="定义+初始化"></a>定义+初始化</h3><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token number">4</span> <span class="token number">5</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token number">3</span> <span class="token number">2</span> <span class="token number">7</span><span class="token punctuation">]</span> <span class="token comment">%%可以直接赋值指定</span>B <span class="token operator">=</span> A<span class="token operator">'</span> <span class="token comment">%%转置</span>C <span class="token operator">=</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token comment">%%降维至一个列向量</span>D <span class="token operator">=</span> <span class="token function">inv</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token comment">%%求解逆矩阵</span>A<span class="token operator">*</span>D <span class="token comment">%%计算精度问题，往往可能会有-0.0000出现</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h2><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">E <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">%% 10*5*3的数组</span><span class="token function">E</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token function">E</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">randi</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token function">E</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">randn</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230513081459200.png" alt="image-20230513081459200"></p><pre class="line-numbers language-none"><code class="language-none">X &#x3D; rand 返回一个在区间 (0,1) 内均匀分布的随机数。X &#x3D; rand(n) 返回一个 n×n 的随机数矩阵。X &#x3D; rand(sz1,...,szN) 返回由随机数组成的 sz1×...×szN 数组，其中 sz1,...,szN 指示每个维度的大小。例如：rand(3,4) 返回一个 3×4 的矩阵。X &#x3D; rand(sz) 返回由随机数组成的数组，其中大小向量 sz 指定 size(X)。例如：rand([3 4]) 返回一个 3×4 的矩阵。X &#x3D; rand(___,typename) 返回由 typename 数据类型的随机数组成的数组。typename 输入可以是 &#39;single&#39; 或 &#39;double&#39;。您可以使用上述语法中的任何输入参数。X &#x3D; rand(___,&#39;like&#39;,p) 返回由 p 等随机数组成的数组；也就是与 p 同一对象类型。您可以指定 typename 或 &#39;like&#39;，但不能同时指定两者。X &#x3D; rand(s,___) 从随机数流 s 而不是默认全局流生成数字。要创建一个流，请使用 RandStream。指定 s，后跟上述语法中的任意参数组合，但涉及 &#39;like&#39; 的组合除外。此语法不支持 &#39;like&#39; 输入。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X &#x3D; randi(imax) 返回一个介于 1 和 imax 之间的伪随机整数标量。X &#x3D; randi(imax,n) 返回 n×n 矩阵，其中包含从区间 [1,imax] 的均匀离散分布中得到的伪随机整数。X &#x3D; randi(imax,sz1,...,szN) 返回 sz1×...×szN 数组，其中 sz1,...,szN 指示每个维度的大小。例如，randi(10,3,4) 返回一个由介于 1 和 10 之间的伪随机整数组成的 3×4 数组。X &#x3D; randi(imax,sz) 返回一个数组，其中大小向量 sz 定义 size(X)。例如，randi(10,[3,4]) 返回一个由介于 1 和 10 之间的伪随机整数组成的 3×4 数组。X &#x3D; randi(imax,classname) 返回一个伪随机整数，其中 classname 指定数据类型。classname 可以为 &#39;single&#39;、&#39;double&#39;、&#39;int8&#39;、&#39;uint8&#39;、&#39;int16&#39;、&#39;uint16&#39;、&#39;int32&#39; 或 &#39;uint32&#39;。X &#x3D; randi(imax,n,classname) 返回数据类型为 classname 的 n×n 数组。X &#x3D; randi(imax,sz1,...,szN,classname) 返回数据类型为 classname 的 sz1×...×szN 数组。X &#x3D; randi(imax,sz,classname) 返回一个数组，其中大小向量 sz 定义 size(X)，classname 定义 class(X)。X &#x3D; randi(imax,&#39;like&#39;,p) 返回一个类如 p 的伪随机整数；即，具有相同的数据类型（类）。X &#x3D; randi(imax,n,&#39;like&#39;,p) 返回一个类如 p 的 n×n 数组。X &#x3D; randi(imax,sz1,...,szN,&#39;like&#39;,p) 返回一个类如 p 的 sz1×...×szN 数组。X &#x3D; randi(imax,sz,&#39;like&#39;,p) 返回一个类如 p 的数组，其中大小向量 sz 定义 size(X)。X &#x3D; randi([imin,imax],___) 使用以上任何语法返回一个数组，其中包含从区间 [imin,imax] 的均匀离散分布中得到的整数。X &#x3D; randi(s,___) 从随机数流 s 而不是默认全局流生成整数。要创建一个流，请使用 RandStream。指定 s，后跟上述语法中的任意参数组合，但涉及 &#39;like&#39; 的组合除外。此语法不支持 &#39;like&#39; 输入。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">X &#x3D; randn 返回一个从标准正态分布中得到的随机标量。X &#x3D; randn(n) 返回由正态分布的随机数组成的 n×n 矩阵。X &#x3D; randn(sz1,...,szN) 返回由随机数组成的 sz1×...×szN 数组，其中 sz1,...,szN 指示每个维度的大小。例如：randn(3,4) 返回一个 3×4 的矩阵。X &#x3D; randn(sz) 返回由随机数组成的数组，其中大小向量 sz 定义 size(X)。例如：randn([3 4]) 返回一个 3×4 的矩阵。X &#x3D; randn(___,typename) 返回由 typename 数据类型的随机数组成的数组。typename 输入可以是 &#39;single&#39; 或 &#39;double&#39;。您可以使用上述语法中的任何输入参数。X &#x3D; randn(___,&#39;like&#39;,p) 返回由 p 等随机数组成的数组；也就是与 p 同一对象类型。您可以指定 typename 或 &#39;like&#39;，但不能同时指定两者。X &#x3D; randn(s,___) 从随机数流 s 而不是默认全局流生成数字。要创建一个流，请使用 RandStream。指定 s，后跟上述语法中的任意参数组合，但涉及 &#39;like&#39; 的组合除外。此语法不支持 &#39;like&#39; 输入。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token function">cell</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span>A<span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">eye</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>A<span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">magic</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>B <span class="token operator">=</span> A<span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230513082005943.png" alt="image-20230513082005943"></p><p>​        元胞数组是一种包含名为元胞的索引数据容器的数据类型，其中的每个元胞都可以包含任意类型的数据。元胞数组通常包含文本列表、文本和数字的组合或者不同大小的数值数组。通过将索引括在圆括号 () 中可以引用元胞集。使用花括号 {} 进行索引来访问元胞的内容。</p><p>​        结构体不多用，可以参看C的结构体怎样操作的，一样的。</p><pre class="line-numbers language-matla" data-language="matla"><div class="caption"><span>b</span></div><code class="language-matla">B &#x3D; 1:2:9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        生成一个列向量：使之从1起到9停，间隔为2 的列向量！</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">repmat</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        拷贝B至三行一列</p><p><img src="image-20230513082352045.png" alt="image-20230513082352045"></p><p>​        矩阵里有六种常见操做：加减，矩阵乘(<em>)，矩阵除( / )（求逆），对应元素相乘(.\</em>)，相除(./)</p><h2 id="程序控制模块"><a href="#程序控制模块" class="headerlink" title="程序控制模块"></a>程序控制模块</h2><p><img src="image-20230513082823827.png" alt="image-20230513082823827"></p><pre class="line-numbers language-none"><code class="language-none">if expression    statementselseif expression    statementselse    statementsendif expression, statements, end 计算表达式并在表达式为 true 时执行一组语句。表达式的结果非空并且仅包含非零元素（逻辑值或实数值）时，该表达式为 true。否则，表达式为 false。elseif 和 else 模块是可选的。这些语句仅在 if...end 块中前面的表达式为 false 时才会执行。if 块可以包含多个 elseif 块。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">switch switch_expression   case case_expression      statements   case case_expression      statements    ...   otherwise      statementsendswitch switch_expression, case case_expression, end 计算表达式并选择执行多组语句中的一组。每个选项为一个 case。switch 块会测试每个 case，直至一个 case 表达式为 true。case 在以下情况下为 true：对于数字，case_expression &#x3D;&#x3D; switch_expression。对于字符向量，strcmp(case_expression,switch_expression) &#x3D;&#x3D; 1。对于支持 eq 函数的对象，case_expression &#x3D;&#x3D; switch_expression。重载的 eq 函数的输出必须为逻辑值或可转换为逻辑值。对于元胞数组 case_expression，元胞数组的至少一个元素与 switch_expression 匹配，如上述对数字、字符向量和对象的定义。当 case 表达式为 true 时，MATLAB® 执行对应的语句，然后退出 switch 块。计算的 switch_expression 必须为标量或字符向量。计算的 case_expression 必须为标量、字符向量或者标量或字符向量的元胞数组。otherwise 块是可选的。仅当没有 case 为 true 时，MATLAB 才会执行这些语句。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">for index &#x3D; values   statementsendfor index &#x3D; values, statements, end 在循环中将一组语句执行特定次数。values 为下列形式之一：initVal:endVal - index 变量从 initVal 至 endVal 按 1 递增，重复执行 statements 直到 index 大于 endVal。initVal:step:endVal - 每次迭代时按值 step 对 index 进行递增，或在 step 是负数时对 index 进行递减。valArray - 每次迭代时从数组 valArray 的后续列创建列向量 index。例如，在第一次迭代时，index &#x3D; valArray(:,1)。循环最多执行 n 次，其中 n 是 valArray 的列数，由 numel(valArray(1,:)) 给定。输入 valArray 可属于任何 MATLAB® 数据类型，包括字符向量、元胞数组或结构体。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">语法while expression    statementsendwhile expression, statements, end 计算一个表达式，并在该表达式为 true 时在一个循环中重复执行一组语句。表达式的结果非空并且仅包含非零元素（逻辑值或实数值）时，该表达式为 true。否则，表达式为 false。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        很是类似，哈哈。</p><h2 id="基本绘图"><a href="#基本绘图" class="headerlink" title="基本绘图"></a>基本绘图</h2><p>​        重点讲过了先前，就略过了</p><pre class="line-numbers language-none"><code class="language-none">plot(X,Y)plot(X,Y,LineSpec)plot(X1,Y1,...,Xn,Yn)plot(X1,Y1,LineSpec1,...,Xn,Yn,LineSpecn)plot(Y)plot(Y,LineSpec)plot(___,Name,Value)plot(ax,___)h &#x3D; plot(___)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>plot(X,Y)</code> 创建 <code>Y</code> 中数据对 <code>X</code> 中对应值的二维线图。</p><ul><li>如果 <code>X</code> 和 <code>Y</code> 都是向量，则它们的长度必须相同。<code>plot</code> 函数绘制 <code>Y</code> 对 <code>X</code> 的图。</li><li>如果 <code>X</code> 和 <code>Y</code> 均为矩阵，则它们的大小必须相同。<code>plot</code> 函数绘制 <code>Y</code> 的列对 <code>X</code> 的列的图。</li><li>如果 <code>X</code> 或 <code>Y</code> 中的一个是向量而另一个是矩阵，则矩阵的各维中必须有一维与向量的长度相等。如果矩阵的行数等于向量长度，则 <code>plot</code> 函数绘制矩阵中的每一列对向量的图。如果矩阵的列数等于向量长度，则该函数绘制矩阵中的每一行对向量的图。如果矩阵为方阵，则该函数绘制每一列对向量的图。</li><li>如果 <code>X</code> 或 <code>Y</code> 之一为标量，而另一个为标量或向量，则 <code>plot</code> 函数会绘制离散点。但是，要查看这些点，您必须指定标记符号，例如 <code>plot(X,Y,&#39;o&#39;)</code>。</li></ul><p><code>plot(X,Y,LineSpec)</code> 设置线型、标记符号和颜色。</p><p><code>plot(X1,Y1,...,Xn,Yn)</code> 绘制多个 <code>X</code>、<code>Y</code> 对组的图，所有线条都使用相同的坐标区。</p><p><code>plot(X1,Y1,LineSpec1,...,Xn,Yn,LineSpecn)</code> 设置每个线条的线型、标记符号和颜色。您可以混用 <code>X</code>、<code>Y</code>、<code>LineSpec</code> 三元组和 <code>X</code>、<code>Y</code> 对组：例如，<code>plot(X1,Y1,X2,Y2,LineSpec2,X3,Y3)</code>。</p><p><code>plot(Y)</code> 创建 <code>Y</code> 中数据对每个值索引的二维线图。</p><ul><li>如果 <code>Y</code> 是向量，<em>x</em> 轴的刻度范围是从 1 至 <code>length(Y)</code>。</li><li>如果 <code>Y</code> 是矩阵，则 <code>plot</code> 函数绘制 <code>Y</code> 中各列对其行号的图。<em>x</em> 轴的刻度范围是从 1 到 <code>Y</code> 的行数。</li><li>如果 <code>Y</code> 是复数，则 <code>plot</code> 函数绘制 <code>Y</code> 的虚部对 <code>Y</code> 的实部的图，使得 <code>plot(Y)</code> 等效于 <code>plot(real(Y),imag(Y))</code>。</li></ul><p><code>plot(Y,LineSpec)</code> 设置线型、标记符号和颜色。</p><p><code>plot(___,Name,Value)</code> 使用一个或多个 <code>Name,Value</code> 对组参数指定线条属性。有关属性列表，请参阅 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.chart.primitive.line-properties.html">Line 属性</a>。可以将此选项与前面语法中的任何输入参数组合一起使用。名称-值对组设置将应用于绘制的所有线条。</p><p><code>plot(ax,___)</code> 将在由 <code>ax</code> 指定的坐标区中，而不是在当前坐标区 (<code>gca</code>) 中创建线条。选项 <code>ax</code> 可以位于前面的语法中的任何输入参数组合之前。</p><p><code>h = plot(___)</code> 返回由图形线条对象组成的列向量。在创建特定的图形线条后，可以使用 <code>h</code> 修改其属性。有关属性列表，请参阅 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.chart.primitive.line-properties.html">Line 属性</a>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="创建线图"><a href="#创建线图" class="headerlink" title="创建线图"></a>创建线图</h3><p>将 <code>x</code> 创建为由 0 和 2<em>π</em> 之间的线性间隔值组成的向量。在各值之间使用递增量 <em>π</em>/100。将 <code>y</code> 创建为 <code>x</code> 的正弦值。创建数据的线图。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; 0:pi&#x2F;100:2*pi;y &#x3D; sin(x);plot(x,y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="createlineplotexample_01_zh_CN.png" alt="img"></p><h3 id="绘制多个线条"><a href="#绘制多个线条" class="headerlink" title="绘制多个线条"></a>绘制多个线条</h3><p>   (matlab:openExample(‘graphics/PlotMultipleLinesExample’))</p><p>将 <code>x</code> 定义为 100 个介于 −2<em>π</em> 和 2<em>π</em> 之间的线性间隔值。将 <code>y1</code> 和 <code>y2</code> 定义为 <code>x</code> 的正弦和余弦值。创建上述两个数据集的线图。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; linspace(-2*pi,2*pi);y1 &#x3D; sin(x);y2 &#x3D; cos(x);figureplot(x,y1,x,y2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="plotmultiplelinesexample_01_zh_CN.png" alt="img"></p><h3 id="根据矩阵创建线图"><a href="#根据矩阵创建线图" class="headerlink" title="根据矩阵创建线图"></a>根据矩阵创建线图</h3><p>将 <code>Y</code> 定义为 <code>magic</code> 函数返回的 4×4 矩阵。</p><pre class="line-numbers language-none"><code class="language-none">Y &#x3D; magic(4)Y &#x3D; 4×4    16     2     3    13     5    11    10     8     9     7     6    12     4    14    15     1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建 <code>Y</code> 的二维线图。MATLAB® 将矩阵的每一列绘制为单独的线条。</p><pre class="line-numbers language-none"><code class="language-none">figureplot(Y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="createlineplotfrommatrixexample_01_zh_CN.png" alt="img"></p><h3 id="指定线型"><a href="#指定线型" class="headerlink" title="指定线型"></a>指定线型</h3><p>绘制三条正弦曲线，每条曲线之间存在较小的相移。第一条曲线使用默认的线型。为第二条曲线指定虚线样式，为第三条曲线指定点线样式。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; 0:pi&#x2F;100:2*pi;y1 &#x3D; sin(x);y2 &#x3D; sin(x-0.25);y3 &#x3D; sin(x-0.5);figureplot(x,y1,x,y2,&#39;--&#39;,x,y3,&#39;:&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="specifylinestyleexample_01_zh_CN.png" alt="img"></p><p>MATLAB® 按默认的色序循环使用线条颜色。</p><h3 id="指定线型、颜色和标记"><a href="#指定线型、颜色和标记" class="headerlink" title="指定线型、颜色和标记"></a>指定线型、颜色和标记</h3><p>绘制三条正弦曲线，每条曲线之间存在较小的相移。第一条正弦曲线使用绿色线条，不带标记。第二条正弦曲线使用蓝色虚线，带圆形标记。第三条正弦曲线只使用青蓝色星号标记。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; 0:pi&#x2F;10:2*pi;y1 &#x3D; sin(x);y2 &#x3D; sin(x-0.25);y3 &#x3D; sin(x-0.5);figureplot(x,y1,&#39;g&#39;,x,y2,&#39;b--o&#39;,x,y3,&#39;c*&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="specifylinestylecolorandmarkerexample_01_zh_CN.png" alt="img"></p><h3 id="在特定的数据点显示标记"><a href="#在特定的数据点显示标记" class="headerlink" title="在特定的数据点显示标记"></a>在特定的数据点显示标记</h3><p>通过指定标记符号并将 <code>MarkerIndices</code> 属性设置为名称-值对组，创建一个线图并每隔四个数据点显示一个标记。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; linspace(0,10);y &#x3D; sin(x);plot(x,y,&#39;-o&#39;,&#39;MarkerIndices&#39;,1:5:length(y))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="displaymarkersatspecificdatapointsexample_01_zh_CN.png" alt="img"></p><h3 id="指定线宽、标记大小和标记颜色"><a href="#指定线宽、标记大小和标记颜色" class="headerlink" title="指定线宽、标记大小和标记颜色"></a>指定线宽、标记大小和标记颜色</h3><p>   (matlab:openExample(‘graphics/SpecifyLineWidthMarkerSizeAndMarkerColorExample’))</p><p>创建线图并使用 <code>LineSpec</code> 选项指定带正方形标记的绿色虚线。使用 <code>Name,Value</code> 对组来指定线宽、标记大小和标记颜色。将标记边颜色设置为蓝色，并使用 RGB 颜色值设置标记面颜色。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; -pi:pi&#x2F;10:pi;y &#x3D; tan(sin(x)) - sin(tan(x));figureplot(x,y,&#39;--gs&#39;,...    &#39;LineWidth&#39;,2,...    &#39;MarkerSize&#39;,10,...    &#39;MarkerEdgeColor&#39;,&#39;b&#39;,...    &#39;MarkerFaceColor&#39;,[0.5,0.5,0.5])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="specifylinewidthmarkersizeandmarkercolorexample_01_zh_CN.png" alt="img"></p><h3 id="添加标题和轴标签"><a href="#添加标题和轴标签" class="headerlink" title="添加标题和轴标签"></a>添加标题和轴标签</h3><p>使用 <code>linspace</code> 函数将 <code>x</code> 定义为 0 到 10 之间 150 个值组成的向量。将 <code>y</code> 定义为 <code>x</code> 的余弦值。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; linspace(0,10,150);y &#x3D; cos(5*x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建余弦曲线的二维线图。使用 RGB 颜色值将线条颜色更改为蓝绿色。使用 <code>title</code>、<code>xlabel</code> 和 <code>ylabel</code> 函数为图形添加标题和轴标签。</p><pre class="line-numbers language-none"><code class="language-none">figureplot(x,y,&#39;Color&#39;,[0,0.7,0.9])title(&#39;2-D Line Plot&#39;)xlabel(&#39;x&#39;)ylabel(&#39;cos(5x)&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="addtitleandaxislabelsexample_01_zh_CN.png" alt="img"></p><h3 id="绘制持续时间并指定刻度格式"><a href="#绘制持续时间并指定刻度格式" class="headerlink" title="绘制持续时间并指定刻度格式"></a>绘制持续时间并指定刻度格式</h3><p>将 <code>t</code> 定义为 7 个介于 0 到 3 分钟之间的 <code>duration</code> 线性间隔值。绘制随机数据并使用 <code>&#39;DurationTickFormat&#39;</code> 名称-值对组参数指定 <code>duration</code> 刻度线的格式。</p><pre class="line-numbers language-none"><code class="language-none">t &#x3D; 0:seconds(30):minutes(3);y &#x3D; rand(1,7);plot(t,y,&#39;DurationTickFormat&#39;,&#39;mm:ss&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="specifydurationtickformatsexample_01_zh_CN.png" alt="img"></p><h3 id="指定线图的坐标区"><a href="#指定线图的坐标区" class="headerlink" title="指定线图的坐标区"></a>指定线图的坐标区</h3><p>​        可以使用 <code>tiledlayout</code> 和 <code>nexttile</code> 函数显示分块图。调用 <code>tiledlayout</code> 函数以创建一个 2×1 分块图布局。调用 <code>nexttile</code> 函数创建一个坐标区对象，并将该对象返回为 <code>ax1</code>。通过将 <code>ax1</code> 传递给 <code>plot</code> 函数来创建顶部绘图。通过将坐标区传递给 <code>title</code> 和 <code>ylabel</code> 函数，为图添加标题和 <em>y</em> 轴标签。重复该过程以创建底部绘图。</p><pre class="line-numbers language-none"><code class="language-none">% Create data and 2-by-1 tiled chart layoutx &#x3D; linspace(0,3);y1 &#x3D; sin(5*x);y2 &#x3D; sin(15*x);tiledlayout(2,1)% Top plotax1 &#x3D; nexttile;plot(ax1,x,y1)title(ax1,&#39;Top Plot&#39;)ylabel(ax1,&#39;sin(5x)&#39;)% Bottom plotax2 &#x3D; nexttile;plot(ax2,x,y2)title(ax2,&#39;Bottom Plot&#39;)ylabel(ax2,&#39;sin(15x)&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="plotspecifyaxes19bexample_01_zh_CN.png" alt="img"></p><h3 id="创建并修改线条"><a href="#创建并修改线条" class="headerlink" title="创建并修改线条"></a>创建并修改线条</h3><p>将 <code>x</code> 定义为 100 个介于 −2<em>π</em> 和 2<em>π</em> 之间的线性间隔值。将 <code>y1</code> 和 <code>y2</code> 定义为 <code>x</code> 的正弦和余弦值。为上述两个数据集分别创建线图，并在 <code>p</code> 中返回两个图形线条。</p><pre class="line-numbers language-none"><code class="language-none">x &#x3D; linspace(-2*pi,2*pi);y1 &#x3D; sin(x);y2 &#x3D; cos(x);p &#x3D; plot(x,y1,x,y2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="changelinepropertiesusinghandlesexample_01_zh_CN.png" alt="img"></p><p>将第一个线条的线宽更改为 2。向第二行添加星形标记。使用圆点表示法设置属性。</p><pre class="line-numbers language-none"><code class="language-none">p(1).LineWidth &#x3D; 2;p(2).Marker &#x3D; &#39;*&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="changelinepropertiesusinghandlesexample_02_zh_CN.png" alt="img"></p><h3 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h3><p>绘制以点 (4,3) 为中心以 2 为半径的圆。使用 <code>axis equal</code> 可沿每个坐标方向使用相等的数据单位。</p><pre class="line-numbers language-none"><code class="language-none">r &#x3D; 2;xc &#x3D; 4;yc &#x3D; 3;theta &#x3D; linspace(0,2*pi);x &#x3D; r*cos(theta) + xc;y &#x3D; r*sin(theta) + yc;plot(x,y)axis equal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="plotcircleexample_01_zh_CN.png" alt="img"></p><h2 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h2><h3 id="Y-y-值-标量-向量-矩阵"><a href="#Y-y-值-标量-向量-矩阵" class="headerlink" title="Y - y 值 标量 | 向量 | 矩阵"></a><code>Y</code> - y 值 标量 | 向量 | 矩阵</h3><p><em>y</em> 值，指定为标量、向量或矩阵。要根据特定的 <em>x</em> 值绘图，还必须指定 <code>X</code>。</p><p><strong>数据类型：</strong> <code>single</code> | <code>double</code> | <code>int8</code> | <code>int16</code> | <code>int32</code> | <code>int64</code> | <code>uint8</code> | <code>uint16</code> | <code>uint32</code> | <code>uint64</code> | <code>categorical</code> | <code>datetime</code> | <code>duration</code></p><h3 id="X-x-值-标量-向量-矩阵"><a href="#X-x-值-标量-向量-矩阵" class="headerlink" title="X - x 值 标量 | 向量 | 矩阵"></a><code>X</code> - x 值 标量 | 向量 | 矩阵</h3><p><em>x</em> 值，指定为标量、向量或矩阵。</p><p><strong>数据类型：</strong> <code>single</code> | <code>double</code> | <code>int8</code> | <code>int16</code> | <code>int32</code> | <code>int64</code> | <code>uint8</code> | <code>uint16</code> | <code>uint32</code> | <code>uint64</code> | <code>categorical</code> | <code>datetime</code> | <code>duration</code></p><h3 id="LineSpec-线型、标记和颜色-字符向量-字符串"><a href="#LineSpec-线型、标记和颜色-字符向量-字符串" class="headerlink" title="LineSpec - 线型、标记和颜色 字符向量 | 字符串"></a><code>LineSpec</code> - 线型、标记和颜色 字符向量 | 字符串</h3><p>线型、标记和颜色，指定为包含符号的字符向量或字符串。符号可以按任意顺序显示。您不需要同时指定所有三个特征（线型、标记和颜色）。例如，如果忽略线型，只指定标记，则绘图只显示标记，不显示线条。</p><p><strong>示例：</strong> <code>&#39;--or&#39;</code> 是带有圆形标记的红色虚线</p><div class="table-container"><table><thead><tr><th style="text-align:left">线型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">实线</td></tr><tr><td style="text-align:left"><code>--</code></td><td style="text-align:left">虚线</td></tr><tr><td style="text-align:left"><code>:</code></td><td style="text-align:left">点线</td></tr><tr><td style="text-align:left"><code>-.</code></td><td style="text-align:left">点划线</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">标记</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;o&#39;</code></td><td style="text-align:left">圆圈</td></tr><tr><td style="text-align:left"><code>&#39;+&#39;</code></td><td style="text-align:left">加号</td></tr><tr><td style="text-align:left"><code>&#39;*&#39;</code></td><td style="text-align:left">星号</td></tr><tr><td style="text-align:left"><code>&#39;.&#39;</code></td><td style="text-align:left">点</td></tr><tr><td style="text-align:left"><code>&#39;x&#39;</code></td><td style="text-align:left">叉号</td></tr><tr><td style="text-align:left"><code>&#39;_&#39;</code></td><td style="text-align:left">水平线条</td></tr><tr><td style="text-align:left">`’</td><td style="text-align:left">‘`</td><td>垂直线条</td></tr><tr><td style="text-align:left"><code>&#39;s&#39;</code></td><td style="text-align:left">方形</td></tr><tr><td style="text-align:left"><code>&#39;d&#39;</code></td><td style="text-align:left">菱形</td></tr><tr><td style="text-align:left"><code>&#39;^&#39;</code></td><td style="text-align:left">上三角</td></tr><tr><td style="text-align:left"><code>&#39;v&#39;</code></td><td style="text-align:left">下三角</td></tr><tr><td style="text-align:left"><code>&#39;&gt;&#39;</code></td><td style="text-align:left">右三角</td></tr><tr><td style="text-align:left"><code>&#39;&lt;&#39;</code></td><td style="text-align:left">左三角</td></tr><tr><td style="text-align:left"><code>&#39;p&#39;</code></td><td style="text-align:left">五角形</td></tr><tr><td style="text-align:left"><code>&#39;h&#39;</code></td><td style="text-align:left">六角形</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">颜色</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>y</code></td><td style="text-align:left">黄色</td></tr><tr><td style="text-align:left"><code>m</code></td><td style="text-align:left">品红色</td></tr><tr><td style="text-align:left"><code>c</code></td><td style="text-align:left">青蓝色</td></tr><tr><td style="text-align:left"><code>r</code></td><td style="text-align:left">红色</td></tr><tr><td style="text-align:left"><code>g</code></td><td style="text-align:left">绿色</td></tr><tr><td style="text-align:left"><code>b</code></td><td style="text-align:left">蓝色</td></tr><tr><td style="text-align:left"><code>w</code></td><td style="text-align:left">白色</td></tr><tr><td style="text-align:left"><code>k</code></td><td style="text-align:left">黑色</td></tr></tbody></table></div><h3 id="ax-目标坐标区-Axes-对象-PolarAxes-对象-GeographicAxes-对象"><a href="#ax-目标坐标区-Axes-对象-PolarAxes-对象-GeographicAxes-对象" class="headerlink" title="ax - 目标坐标区 Axes 对象 | PolarAxes 对象 | GeographicAxes 对象"></a><code>ax</code> - 目标坐标区 <code>Axes</code> 对象 | <code>PolarAxes</code> 对象 | <code>GeographicAxes</code> 对象</h3><p>目标坐标区，指定为 <code>Axes</code> 对象、<code>PolarAxes</code> 对象或 <code>GeographicAxes</code> 对象。如果不指定坐标区或当前坐标区是笛卡尔坐标区，<code>plot</code> 函数将使用当前坐标区。要在极坐标区上绘图，请指定 <code>PolarAxes</code> 对象作为第一个输入参数，或者使用 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/polarplot.html"><code>polarplot</code></a> 函数。要在地理坐标区上绘图，请指定 <code>GeographicAxes</code> 对象作为第一个输入参数，或者使用 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/geoplot.html"><code>geoplot</code></a> 函数。</p><h3 id="名称-值对组参数"><a href="#名称-值对组参数" class="headerlink" title="名称-值对组参数"></a>名称-值对组参数</h3><p>指定可选的、以逗号分隔的 <code>Name,Value</code> 对组参数。<code>Name</code> 为参数名称，<code>Value</code> 为对应的值。<code>Name</code> 必须放在引号中。您可采用任意顺序指定多个名称-值对组参数，如 <code>Name1,Value1,...,NameN,ValueN</code> 所示。</p><p><strong>示例：</strong> <code>&#39;Marker&#39;,&#39;o&#39;,&#39;MarkerFaceColor&#39;,&#39;red&#39;</code></p><p>此处列出的图形线条属性只是一个子集。有关完整列表，请参阅 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.chart.primitive.line-properties.html">Line 属性</a>。</p><h3 id="39-Color-39-线条颜色-0-0-4470-0-7410-（默认）-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…"><a href="#39-Color-39-线条颜色-0-0-4470-0-7410-（默认）-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…" class="headerlink" title="&#39;Color&#39; - 线条颜色 [0 0.4470 0.7410] （默认） | RGB 三元组 | 十六进制颜色代码 | &#39;r&#39; | &#39;g&#39; | &#39;b&#39; | …"></a><code>&#39;Color&#39;</code> - 线条颜色 <code>[0 0.4470 0.7410]</code> （默认） | RGB 三元组 | 十六进制颜色代码 | <code>&#39;r&#39;</code> | <code>&#39;g&#39;</code> | <code>&#39;b&#39;</code> | …</h3><p>线条颜色，指定为 RGB 三元组、十六进制颜色代码、颜色名称或短名称。</p><p>对于自定义颜色，请指定 RGB 三元组或十六进制颜色代码。</p><ul><li>RGB 三元组是包含三个元素的行向量，其元素分别指定颜色中红、绿、蓝分量的强度。强度值必须位于 <code>[0,1]</code> 范围内，例如 <code>[0.4 0.6 0.7]</code>。</li><li>十六进制颜色代码是字符向量或字符串标量，以井号 (<code>#</code>) 开头，后跟三个或六个十六进制数字，范围可以是 <code>0</code> 到 <code>F</code>。这些值不区分大小写。因此，颜色代码 <code>&#39;#FF8800&#39;</code> 与 <code>&#39;#ff8800&#39;</code>、<code>&#39;#F80&#39;</code> 与 <code>&#39;#f80&#39;</code> 是等效的。</li></ul><p>此外，还可以按名称指定一些常见的颜色。下表列出了命名颜色选项、等效 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">颜色名称</th><th style="text-align:left">短名称</th><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;red&#39;</code></td><td style="text-align:left"><code>&#39;r&#39;</code></td><td style="text-align:left"><code>[1 0 0]</code></td><td style="text-align:left"><code>&#39;#FF0000&#39;</code></td><td style="text-align:left"><img src="hg_red.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;green&#39;</code></td><td style="text-align:left"><code>&#39;g&#39;</code></td><td style="text-align:left"><code>[0 1 0]</code></td><td style="text-align:left"><code>&#39;#00FF00&#39;</code></td><td style="text-align:left"><img src="hg_green.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;blue&#39;</code></td><td style="text-align:left"><code>&#39;b&#39;</code></td><td style="text-align:left"><code>[0 0 1]</code></td><td style="text-align:left"><code>&#39;#0000FF&#39;</code></td><td style="text-align:left"><img src="hg_blue.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;cyan&#39;</code></td><td style="text-align:left"><code>&#39;c&#39;</code></td><td style="text-align:left"><code>[0 1 1]</code></td><td style="text-align:left"><code>&#39;#00FFFF&#39;</code></td><td style="text-align:left"><img src="hg_cyan.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;magenta&#39;</code></td><td style="text-align:left"><code>&#39;m&#39;</code></td><td style="text-align:left"><code>[1 0 1]</code></td><td style="text-align:left"><code>&#39;#FF00FF&#39;</code></td><td style="text-align:left"><img src="hg_magenta.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;yellow&#39;</code></td><td style="text-align:left"><code>&#39;y&#39;</code></td><td style="text-align:left"><code>[1 1 0]</code></td><td style="text-align:left"><code>&#39;#FFFF00&#39;</code></td><td style="text-align:left"><img src="hg_yellow.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;black&#39;</code></td><td style="text-align:left"><code>&#39;k&#39;</code></td><td style="text-align:left"><code>[0 0 0]</code></td><td style="text-align:left"><code>&#39;#000000&#39;</code></td><td style="text-align:left"><img src="hg_black.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;white&#39;</code></td><td style="text-align:left"><code>&#39;w&#39;</code></td><td style="text-align:left"><code>[1 1 1]</code></td><td style="text-align:left"><code>&#39;#FFFFFF&#39;</code></td><td style="text-align:left"><img src="hg_white.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;none&#39;</code></td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">无颜色</td></tr></tbody></table></div><p>以下是 MATLAB® 在许多类型的绘图中使用的默认颜色的 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>[0 0.4470 0.7410]</code></td><td style="text-align:left"><code>&#39;#0072BD&#39;</code></td><td style="text-align:left"><img src="colororder1.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.8500 0.3250 0.0980]</code></td><td style="text-align:left"><code>&#39;#D95319&#39;</code></td><td style="text-align:left"><img src="colororder2.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.9290 0.6940 0.1250]</code></td><td style="text-align:left"><code>&#39;#EDB120&#39;</code></td><td style="text-align:left"><img src="colororder3.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4940 0.1840 0.5560]</code></td><td style="text-align:left"><code>&#39;#7E2F8E&#39;</code></td><td style="text-align:left"><img src="colororder4.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4660 0.6740 0.1880]</code></td><td style="text-align:left"><code>&#39;#77AC30&#39;</code></td><td style="text-align:left"><img src="colororder5.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.3010 0.7450 0.9330]</code></td><td style="text-align:left"><code>&#39;#4DBEEE&#39;</code></td><td style="text-align:left"><img src="colororder6.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.6350 0.0780 0.1840]</code></td><td style="text-align:left"><code>&#39;#A2142F&#39;</code></td><td style="text-align:left"><img src="colororder7.png" alt="img"></td></tr></tbody></table></div><p><strong>示例：</strong> <code>&#39;blue&#39;</code></p><p><strong>示例：</strong> <code>[0 0 1]</code></p><p><strong>示例：</strong> <code>&#39;#0000FF&#39;</code></p><h3 id="39-LineStyle-39-线型-39-39-（默认）-39-39-39-39-39-39-39-none-39"><a href="#39-LineStyle-39-线型-39-39-（默认）-39-39-39-39-39-39-39-none-39" class="headerlink" title="&#39;LineStyle&#39; - 线型 &#39;-&#39; （默认） | &#39;--&#39; | &#39;:&#39; | &#39;-.&#39; | &#39;none&#39;"></a><code>&#39;LineStyle&#39;</code> - 线型 <code>&#39;-&#39;</code> （默认） | <code>&#39;--&#39;</code> | <code>&#39;:&#39;</code> | <code>&#39;-.&#39;</code> | <code>&#39;none&#39;</code></h3><p>线型，指定为下表中列出的选项之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">线型</th><th style="text-align:left">说明</th><th style="text-align:left">表示的线条</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;-&#39;</code></td><td style="text-align:left">实线</td><td style="text-align:left"><img src="linestyle_solid.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;--&#39;</code></td><td style="text-align:left">虚线</td><td style="text-align:left"><img src="linestyle_dashed.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;:&#39;</code></td><td style="text-align:left">点线</td><td style="text-align:left"><img src="linestyle_dotted.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;-.&#39;</code></td><td style="text-align:left">点划线</td><td style="text-align:left"><img src="linestyle_dashdotted.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;none&#39;</code></td><td style="text-align:left">无线条</td><td style="text-align:left">无线条</td></tr></tbody></table></div><h3 id="39-LineWidth-39-线条宽度-0-5-（默认）-正值"><a href="#39-LineWidth-39-线条宽度-0-5-（默认）-正值" class="headerlink" title="&#39;LineWidth&#39; - 线条宽度 0.5 （默认） | 正值"></a><code>&#39;LineWidth&#39;</code> - 线条宽度 <code>0.5</code> （默认） | 正值</h3><p>线宽，指定为以磅为单位的正值，其中 1 磅 = 1/72 英寸。如果该线条具有标记，则线条宽度也会影响标记边。</p><p>线宽不能小于像素的宽度。如果将线宽设置为小于系统上像素宽度的值，则线条显示为一个像素的宽度。</p><h3 id="39-Marker-39-标记符号-39-none-39-（默认）-39-o-39-39-39-39-39-39-39-…"><a href="#39-Marker-39-标记符号-39-none-39-（默认）-39-o-39-39-39-39-39-39-39-…" class="headerlink" title="&#39;Marker&#39; - 标记符号 &#39;none&#39; （默认） | &#39;o&#39; | &#39;+&#39; | &#39;*&#39; | &#39;.&#39; | …"></a><code>&#39;Marker&#39;</code> - 标记符号 <code>&#39;none&#39;</code> （默认） | <code>&#39;o&#39;</code> | <code>&#39;+&#39;</code> | <code>&#39;*&#39;</code> | <code>&#39;.&#39;</code> | …</h3><p>标记符号，指定为下表中列出的值之一。默认情况下，对象不显示标记。指定标记符号可在每个数据点或顶点添加标记。</p><div class="table-container"><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;o&#39;</code></td><td style="text-align:left">圆圈</td></tr><tr><td style="text-align:left"><code>&#39;+&#39;</code></td><td style="text-align:left">加号</td></tr><tr><td style="text-align:left"><code>&#39;*&#39;</code></td><td style="text-align:left">星号</td></tr><tr><td style="text-align:left"><code>&#39;.&#39;</code></td><td style="text-align:left">点</td></tr><tr><td style="text-align:left"><code>&#39;x&#39;</code></td><td style="text-align:left">叉号</td></tr><tr><td style="text-align:left"><code>&#39;_&#39;</code></td><td style="text-align:left">水平线条</td></tr><tr><td style="text-align:left">`’</td><td style="text-align:left">‘`</td><td>垂直线条</td></tr><tr><td style="text-align:left"><code>&#39;square&#39;</code> 或 <code>&#39;s&#39;</code></td><td style="text-align:left">方形</td></tr><tr><td style="text-align:left"><code>&#39;diamond&#39;</code> 或 <code>&#39;d&#39;</code></td><td style="text-align:left">菱形</td></tr><tr><td style="text-align:left"><code>&#39;^&#39;</code></td><td style="text-align:left">上三角</td></tr><tr><td style="text-align:left"><code>&#39;v&#39;</code></td><td style="text-align:left">下三角</td></tr><tr><td style="text-align:left"><code>&#39;&gt;&#39;</code></td><td style="text-align:left">右三角</td></tr><tr><td style="text-align:left"><code>&#39;&lt;&#39;</code></td><td style="text-align:left">左三角</td></tr><tr><td style="text-align:left"><code>&#39;pentagram&#39;</code> 或 <code>&#39;p&#39;</code></td><td style="text-align:left">五角星（五角形）</td></tr><tr><td style="text-align:left"><code>&#39;hexagram&#39;</code> 或 <code>&#39;h&#39;</code></td><td style="text-align:left">六角星（六角形）</td></tr><tr><td style="text-align:left"><code>&#39;none&#39;</code></td><td style="text-align:left">无标记</td></tr></tbody></table></div><h3 id="39-MarkerIndices-39-要显示标记的数据点的索引-1-length-YData-（默认）-正整数向量-正整数标量"><a href="#39-MarkerIndices-39-要显示标记的数据点的索引-1-length-YData-（默认）-正整数向量-正整数标量" class="headerlink" title="&#39;MarkerIndices&#39; - 要显示标记的数据点的索引 1:length(YData) （默认） | 正整数向量 | 正整数标量"></a><code>&#39;MarkerIndices&#39;</code> - 要显示标记的数据点的索引 <code>1:length(YData)</code> （默认） | 正整数向量 | 正整数标量</h3><p>要显示标记的数据点的索引，指定为正整数向量。如果不指定索引，MATLAB 将在每个数据点显示一个标记。</p><p><strong>注意</strong></p><p>要查看标记，还必须指定标记符号。</p><p><strong>示例：</strong> <code>plot(x,y,&#39;-o&#39;,&#39;MarkerIndices&#39;,[1 5 10])</code> 在第一、第五和第十个数据点处显示圆形标记。</p><p><strong>示例：</strong> <code>plot(x,y,&#39;-x&#39;,&#39;MarkerIndices&#39;,1:3:length(y))</code> 每隔三个数据点显示一个交叉标记。</p><p><strong>示例：</strong> <code>plot(x,y,&#39;Marker&#39;,&#39;square&#39;,&#39;MarkerIndices&#39;,5)</code> 在第五个数据点显示一个正方形标记。</p><h3 id="39-MarkerEdgeColor-39-标记轮廓颜色-39-auto-39-（默认）-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…"><a href="#39-MarkerEdgeColor-39-标记轮廓颜色-39-auto-39-（默认）-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…" class="headerlink" title="&#39;MarkerEdgeColor&#39; - 标记轮廓颜色 &#39;auto&#39; （默认） | RGB 三元组 | 十六进制颜色代码 | &#39;r&#39; | &#39;g&#39; | &#39;b&#39; | …"></a><code>&#39;MarkerEdgeColor&#39;</code> - 标记轮廓颜色 <code>&#39;auto&#39;</code> （默认） | RGB 三元组 | 十六进制颜色代码 | <code>&#39;r&#39;</code> | <code>&#39;g&#39;</code> | <code>&#39;b&#39;</code> | …</h3><p>标记轮廓颜色，指定为 <code>&#39;auto&#39;</code>、RGB 三元组、十六进制颜色代码、颜色名称或短名称。默认值 <code>&#39;auto&#39;</code> 使用与 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/plot.html?searchHighlight=plot&amp;s_tid=doc_srchtitle#btzitot-Color"><code>Color</code></a> 属性相同的颜色。</p><p>对于自定义颜色，请指定 RGB 三元组或十六进制颜色代码。</p><ul><li>RGB 三元组是包含三个元素的行向量，其元素分别指定颜色中红、绿、蓝分量的强度。强度值必须位于 <code>[0,1]</code> 范围内，例如 <code>[0.4 0.6 0.7]</code>。</li><li>十六进制颜色代码是字符向量或字符串标量，以井号 (<code>#</code>) 开头，后跟三个或六个十六进制数字，范围可以是 <code>0</code> 到 <code>F</code>。这些值不区分大小写。因此，颜色代码 <code>&#39;#FF8800&#39;</code> 与 <code>&#39;#ff8800&#39;</code>、<code>&#39;#F80&#39;</code> 与 <code>&#39;#f80&#39;</code> 是等效的。</li></ul><p>此外，还可以按名称指定一些常见的颜色。下表列出了命名颜色选项、等效 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">颜色名称</th><th style="text-align:left">短名称</th><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;red&#39;</code></td><td style="text-align:left"><code>&#39;r&#39;</code></td><td style="text-align:left"><code>[1 0 0]</code></td><td style="text-align:left"><code>&#39;#FF0000&#39;</code></td><td style="text-align:left"><img src="hg_red.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;green&#39;</code></td><td style="text-align:left"><code>&#39;g&#39;</code></td><td style="text-align:left"><code>[0 1 0]</code></td><td style="text-align:left"><code>&#39;#00FF00&#39;</code></td><td style="text-align:left"><img src="hg_green.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;blue&#39;</code></td><td style="text-align:left"><code>&#39;b&#39;</code></td><td style="text-align:left"><code>[0 0 1]</code></td><td style="text-align:left"><code>&#39;#0000FF&#39;</code></td><td style="text-align:left"><img src="hg_blue.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;cyan&#39;</code></td><td style="text-align:left"><code>&#39;c&#39;</code></td><td style="text-align:left"><code>[0 1 1]</code></td><td style="text-align:left"><code>&#39;#00FFFF&#39;</code></td><td style="text-align:left"><img src="hg_cyan.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;magenta&#39;</code></td><td style="text-align:left"><code>&#39;m&#39;</code></td><td style="text-align:left"><code>[1 0 1]</code></td><td style="text-align:left"><code>&#39;#FF00FF&#39;</code></td><td style="text-align:left"><img src="hg_magenta.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;yellow&#39;</code></td><td style="text-align:left"><code>&#39;y&#39;</code></td><td style="text-align:left"><code>[1 1 0]</code></td><td style="text-align:left"><code>&#39;#FFFF00&#39;</code></td><td style="text-align:left"><img src="hg_yellow.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;black&#39;</code></td><td style="text-align:left"><code>&#39;k&#39;</code></td><td style="text-align:left"><code>[0 0 0]</code></td><td style="text-align:left"><code>&#39;#000000&#39;</code></td><td style="text-align:left"><img src="hg_black.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;white&#39;</code></td><td style="text-align:left"><code>&#39;w&#39;</code></td><td style="text-align:left"><code>[1 1 1]</code></td><td style="text-align:left"><code>&#39;#FFFFFF&#39;</code></td><td style="text-align:left"><img src="hg_white.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;none&#39;</code></td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">无颜色</td></tr></tbody></table></div><p>以下是 MATLAB 在许多类型的绘图中使用的默认颜色的 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>[0 0.4470 0.7410]</code></td><td style="text-align:left"><code>&#39;#0072BD&#39;</code></td><td style="text-align:left"><img src="colororder1.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.8500 0.3250 0.0980]</code></td><td style="text-align:left"><code>&#39;#D95319&#39;</code></td><td style="text-align:left"><img src="colororder2.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.9290 0.6940 0.1250]</code></td><td style="text-align:left"><code>&#39;#EDB120&#39;</code></td><td style="text-align:left"><img src="colororder3.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4940 0.1840 0.5560]</code></td><td style="text-align:left"><code>&#39;#7E2F8E&#39;</code></td><td style="text-align:left"><img src="colororder4.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4660 0.6740 0.1880]</code></td><td style="text-align:left"><code>&#39;#77AC30&#39;</code></td><td style="text-align:left"><img src="colororder5.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.3010 0.7450 0.9330]</code></td><td style="text-align:left"><code>&#39;#4DBEEE&#39;</code></td><td style="text-align:left"><img src="colororder6.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.6350 0.0780 0.1840]</code></td><td style="text-align:left"><code>&#39;#A2142F&#39;</code></td><td style="text-align:left"><img src="colororder7.png" alt="img"></td></tr></tbody></table></div><h3 id="39-MarkerFaceColor-39-标记填充颜色-39-none-39-（默认）-39-auto-39-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…"><a href="#39-MarkerFaceColor-39-标记填充颜色-39-none-39-（默认）-39-auto-39-RGB-三元组-十六进制颜色代码-39-r-39-39-g-39-39-b-39-…" class="headerlink" title="&#39;MarkerFaceColor&#39; - 标记填充颜色 &#39;none&#39; （默认） | &#39;auto&#39; | RGB 三元组 | 十六进制颜色代码 | &#39;r&#39; | &#39;g&#39; | &#39;b&#39; | …"></a><code>&#39;MarkerFaceColor&#39;</code> - 标记填充颜色 <code>&#39;none&#39;</code> （默认） | <code>&#39;auto&#39;</code> | RGB 三元组 | 十六进制颜色代码 | <code>&#39;r&#39;</code> | <code>&#39;g&#39;</code> | <code>&#39;b&#39;</code> | …</h3><p>标记填充颜色，指定为 <code>&#39;auto&#39;</code>、RGB 三元组、十六进制颜色代码、颜色名称或短名称。<code>&#39;auto&#39;</code> 选项使用与父坐标区的 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.axis.axes-properties.html#budumk7-Color"><code>Color</code></a> 属性相同的颜色。如果您指定 <code>&#39;auto&#39;</code>，并且坐标区图框不可见，则标记填充颜色为图窗的颜色。</p><p>对于自定义颜色，请指定 RGB 三元组或十六进制颜色代码。</p><ul><li>RGB 三元组是包含三个元素的行向量，其元素分别指定颜色中红、绿、蓝分量的强度。强度值必须位于 <code>[0,1]</code> 范围内，例如 <code>[0.4 0.6 0.7]</code>。</li><li>十六进制颜色代码是字符向量或字符串标量，以井号 (<code>#</code>) 开头，后跟三个或六个十六进制数字，范围可以是 <code>0</code> 到 <code>F</code>。这些值不区分大小写。因此，颜色代码 <code>&#39;#FF8800&#39;</code> 与 <code>&#39;#ff8800&#39;</code>、<code>&#39;#F80&#39;</code> 与 <code>&#39;#f80&#39;</code> 是等效的。</li></ul><p>此外，还可以按名称指定一些常见的颜色。下表列出了命名颜色选项、等效 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">颜色名称</th><th style="text-align:left">短名称</th><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;red&#39;</code></td><td style="text-align:left"><code>&#39;r&#39;</code></td><td style="text-align:left"><code>[1 0 0]</code></td><td style="text-align:left"><code>&#39;#FF0000&#39;</code></td><td style="text-align:left"><img src="hg_red.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;green&#39;</code></td><td style="text-align:left"><code>&#39;g&#39;</code></td><td style="text-align:left"><code>[0 1 0]</code></td><td style="text-align:left"><code>&#39;#00FF00&#39;</code></td><td style="text-align:left"><img src="hg_green.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;blue&#39;</code></td><td style="text-align:left"><code>&#39;b&#39;</code></td><td style="text-align:left"><code>[0 0 1]</code></td><td style="text-align:left"><code>&#39;#0000FF&#39;</code></td><td style="text-align:left"><img src="hg_blue.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;cyan&#39;</code></td><td style="text-align:left"><code>&#39;c&#39;</code></td><td style="text-align:left"><code>[0 1 1]</code></td><td style="text-align:left"><code>&#39;#00FFFF&#39;</code></td><td style="text-align:left"><img src="hg_cyan.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;magenta&#39;</code></td><td style="text-align:left"><code>&#39;m&#39;</code></td><td style="text-align:left"><code>[1 0 1]</code></td><td style="text-align:left"><code>&#39;#FF00FF&#39;</code></td><td style="text-align:left"><img src="hg_magenta.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;yellow&#39;</code></td><td style="text-align:left"><code>&#39;y&#39;</code></td><td style="text-align:left"><code>[1 1 0]</code></td><td style="text-align:left"><code>&#39;#FFFF00&#39;</code></td><td style="text-align:left"><img src="hg_yellow.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;black&#39;</code></td><td style="text-align:left"><code>&#39;k&#39;</code></td><td style="text-align:left"><code>[0 0 0]</code></td><td style="text-align:left"><code>&#39;#000000&#39;</code></td><td style="text-align:left"><img src="hg_black.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;white&#39;</code></td><td style="text-align:left"><code>&#39;w&#39;</code></td><td style="text-align:left"><code>[1 1 1]</code></td><td style="text-align:left"><code>&#39;#FFFFFF&#39;</code></td><td style="text-align:left"><img src="hg_white.png" alt="img"></td></tr><tr><td style="text-align:left"><code>&#39;none&#39;</code></td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">不适用</td><td style="text-align:left">无颜色</td></tr></tbody></table></div><p>以下是 MATLAB 在许多类型的绘图中使用的默认颜色的 RGB 三元组和十六进制颜色代码。</p><div class="table-container"><table><thead><tr><th style="text-align:left">RGB 三元组</th><th style="text-align:left">十六进制颜色代码</th><th style="text-align:left">外观</th></tr></thead><tbody><tr><td style="text-align:left"><code>[0 0.4470 0.7410]</code></td><td style="text-align:left"><code>&#39;#0072BD&#39;</code></td><td style="text-align:left"><img src="colororder1.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.8500 0.3250 0.0980]</code></td><td style="text-align:left"><code>&#39;#D95319&#39;</code></td><td style="text-align:left"><img src="colororder2.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.9290 0.6940 0.1250]</code></td><td style="text-align:left"><code>&#39;#EDB120&#39;</code></td><td style="text-align:left"><img src="colororder3.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4940 0.1840 0.5560]</code></td><td style="text-align:left"><code>&#39;#7E2F8E&#39;</code></td><td style="text-align:left"><img src="colororder4.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.4660 0.6740 0.1880]</code></td><td style="text-align:left"><code>&#39;#77AC30&#39;</code></td><td style="text-align:left"><img src="colororder5.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.3010 0.7450 0.9330]</code></td><td style="text-align:left"><code>&#39;#4DBEEE&#39;</code></td><td style="text-align:left"><img src="colororder6.png" alt="img"></td></tr><tr><td style="text-align:left"><code>[0.6350 0.0780 0.1840]</code></td><td style="text-align:left"><code>&#39;#A2142F&#39;</code></td><td style="text-align:left"><img src="colororder7.png" alt="img"></td></tr></tbody></table></div><h3 id="39-MarkerSize-39-标记大小-6-（默认）-正值"><a href="#39-MarkerSize-39-标记大小-6-（默认）-正值" class="headerlink" title="&#39;MarkerSize&#39; - 标记大小 6 （默认） | 正值"></a><code>&#39;MarkerSize&#39;</code> - 标记大小 <code>6</code> （默认） | 正值</h3><p>标记大小，指定为以磅为单位的正值，其中 1 磅 = 1/72 英寸。</p><h3 id="39-DatetimeTickFormat-39-datetime-刻度标签的格式-字符向量-字符串"><a href="#39-DatetimeTickFormat-39-datetime-刻度标签的格式-字符向量-字符串" class="headerlink" title="&#39;DatetimeTickFormat&#39; - datetime 刻度标签的格式 字符向量 | 字符串"></a><code>&#39;DatetimeTickFormat&#39;</code> - <code>datetime</code> 刻度标签的格式 字符向量 | 字符串</h3><p><code>datetime</code> 刻度标签的格式，指定为以逗号分隔的对组，该对组由 <code>&#39;DatetimeTickFormat&#39;</code> 和一个包含日期格式的字符向量或字符串组成。可使用字母 <code>A-Z</code> 和 <code>a-z</code> 构造一个自定义格式。这些字母对应于日期的 Unicode® 区域设置数据标记语言 (LDML) 标准。可以使用连字符、空格或冒号等非 ASCII 字母字符来分隔字段。</p><p>如果未为 <code>&#39;DatetimeTickFormat&#39;</code> 指定值，则 <code>plot</code> 将基于坐标轴范围自动优化和更新刻度标签。</p><p>下表列举了多种常见的显示格式和纽约市 2014 年 4 月 19 日（星期六）下午 9:41:06 的格式化输出示例。</p><div class="table-container"><table><thead><tr><th style="text-align:left"><code>DatetimeTickFormat</code> 的值</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;yyyy-MM-dd&#39;</code></td><td style="text-align:left"><code>2014-04-19</code></td></tr><tr><td style="text-align:left"><code>&#39;dd/MM/yyyy&#39;</code></td><td style="text-align:left"><code>19/04/2014</code></td></tr><tr><td style="text-align:left"><code>&#39;dd.MM.yyyy&#39;</code></td><td style="text-align:left"><code>19.04.2014</code></td></tr><tr><td style="text-align:left"><code>&#39;yyyy年 MM月 dd日&#39;</code></td><td style="text-align:left"><code>2014年 04月 19日</code></td></tr><tr><td style="text-align:left"><code>&#39;MMMM d, yyyy&#39;</code></td><td style="text-align:left"><code>April 19, 2014</code></td></tr><tr><td style="text-align:left"><code>&#39;eeee, MMMM d, yyyy HH:mm:ss&#39;</code></td><td style="text-align:left"><code>Saturday, April 19, 2034 21:41:06</code></td></tr><tr><td style="text-align:left"><code>&#39;MMMM d, yyyy HH:mm:ss Z&#39;</code></td><td style="text-align:left"><code>April 32, 2023 11:45:14 -0400</code></td></tr></tbody></table></div><p>有关有效字母标识符的完整列表，请参阅日期时间数组的 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/datetime.html#buhzxmk-1-Format"><code>Format</code></a> 属性。</p><p><code>DatetimeTickFormat</code> 不是图形线条属性。创建绘图时，必须使用名称-值对组参数设置刻度格式。或者，使用 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/xtickformat.html"><code>xtickformat</code></a> 和 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/ytickformat.html"><code>ytickformat</code></a> 函数设置格式。</p><p>日期时间标尺的 <code>TickLabelFormat</code> 属性存储格式。</p><h3 id="39-DurationTickFormat-39-duration-刻度标签的格式-字符向量-字符串"><a href="#39-DurationTickFormat-39-duration-刻度标签的格式-字符向量-字符串" class="headerlink" title="&#39;DurationTickFormat&#39; - duration 刻度标签的格式 字符向量 | 字符串"></a><code>&#39;DurationTickFormat&#39;</code> - <code>duration</code> 刻度标签的格式 字符向量 | 字符串</h3><p><code>duration</code> 刻度标签的格式，指定为以逗号分隔的对组，该对组由 <code>&#39;DurationTickFormat&#39;</code> 和一个包含持续时间格式的字符向量或字符串组成。</p><p>如果未为 <code>&#39;DurationTickFormat&#39;</code> 指定值，则 <code>plot</code> 将基于坐标轴范围自动优化和更新刻度标签。</p><p>要将持续时间显示为包含小数部分的单个数字，例如 1.234 小时，请指定下表中的值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left"><code>DurationTickFormat</code> 的值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>&#39;y&#39;</code></td><td style="text-align:left">精确定长年的数目。固定长度的一年等于 365.2425 天。</td></tr><tr><td style="text-align:left"><code>&#39;d&#39;</code></td><td style="text-align:left">精确定长天的数目。固定长度的一天等于 24 小时。</td></tr><tr><td style="text-align:left"><code>&#39;h&#39;</code></td><td style="text-align:left">小时数</td></tr><tr><td style="text-align:left"><code>&#39;m&#39;</code></td><td style="text-align:left">分钟数</td></tr><tr><td style="text-align:left"><code>&#39;s&#39;</code></td><td style="text-align:left">秒数</td></tr></tbody></table></div><p><strong>示例：</strong> <code>&#39;DurationTickFormat&#39;,&#39;d&#39;</code> 以固定长度的天数显示持续时间值。</p><p>要以数字计时器的形式显示持续时间，请指定下列值之一。</p><ul><li><code>&#39;dd:hh:mm:ss&#39;</code></li><li><code>&#39;hh:mm:ss&#39;</code></li><li><code>&#39;mm:ss&#39;</code></li><li><code>&#39;hh:mm&#39;</code></li></ul><p>此外，可以通过附加多达 9 个 <code>S</code> 字符显示多达 9 位小数的秒位。</p><p><strong>示例：</strong> <code>&#39;DurationTickFormat&#39;,&#39;hh:mm:ss.SSS&#39;</code> 以三位数显示持续时间的毫秒数。</p><p><code>DurationTickFormat</code> 不是图形线条属性。创建绘图时，必须使用名称-值对组参数设置刻度格式。或者，使用 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/xtickformat.html"><code>xtickformat</code></a> 和 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/ytickformat.html"><code>ytickformat</code></a> 函数设置格式。</p><p>持续时间标尺的 <code>TickLabelFormat</code> 属性存储格式。</p><h3 id="h-一个或多个图形线条对象-标量-向量"><a href="#h-一个或多个图形线条对象-标量-向量" class="headerlink" title="h - 一个或多个图形线条对象 标量 | 向量"></a><code>h</code> - 一个或多个图形线条对象 标量 | 向量</h3><p>一个或多个图形线条对象，以标量或向量的形式返回。这些是唯一标识符，可以用来查询和修改特定图形线条的属性。有关属性列表，请参阅 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.chart.primitive.line-properties.html">Line 属性</a>。</p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li><p>使用 <code>NaN</code> 和 <code>Inf</code> 值将行断开。例如，以下代码绘制前两个元素，跳过第三个元素，并使用最后两个元素绘制另一线条：</p><pre class="line-numbers language-none"><code class="language-none">plot([1,2,NaN,4,5])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><ul><li><p><code>plot</code> 基于坐标区的 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.axis.axes-properties.html#budumk7_sep_shared-ColorOrder"><code>ColorOrder</code></a> 和 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/matlab.graphics.axis.axes-properties.html#budumk7_sep_shared-LineStyleOrder"><code>LineStyleOrder</code></a> 属性选用颜色和线型。<code>plot</code> 先对第一种线型依序使用每种颜色，直至用尽。然后，再对下一个线型依序使用每种颜色，以此类推。</p><p>从 R2019b 开始，通过在坐标区中设置 <code>ColorOrder</code> 或 <code>LineStyleOrder</code> 属性，可以在绘图后更改颜色和线型。可以调用 <a href="https://www.mathworks.com/help/releases/R2021a/matlab/ref/colororder.html"><code>colororder</code></a> 函数来更改图窗中所有坐标区的色序。</p></li></ul><h2 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h2><h3 id="tall-数组-对行数太多而无法放入内存的数组进行计算。"><a href="#tall-数组-对行数太多而无法放入内存的数组进行计算。" class="headerlink" title="tall 数组 对行数太多而无法放入内存的数组进行计算。"></a>tall 数组 对行数太多而无法放入内存的数组进行计算。</h3><p>用法说明和限制：</p><ul><li>对于 tall 数组 <code>X</code> 和 <code>Y</code>，支持的语法包括：<ul><li><code>plot(X,Y)</code></li><li><code>plot(Y)</code></li><li><code>plot(___,LineSpec)</code></li><li><code>plot(___,Name,Value)</code></li><li><code>plot(ax,___)</code></li></ul></li><li><code>X</code> 必须为单调递增顺序。</li><li>不支持分类输入。</li><li>tall 输入必须为实数列向量。</li><li>处理 tall 数组时，<code>plot</code> 函数将以迭代方式逐步绘图，一边读取数据，一边添加到绘图中。在更新过程中，进度指示条显示已绘制数据的比例。在绘图完成之前，支持在更新过程中进行缩放和平移。要停止更新过程，请按进度指示条中的暂停按钮。</li></ul><p>（from MathWork）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Essential-cpp阅读笔记4</title>
      <link href="/2023/05/11/Essential-cpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B04/"/>
      <url>/2023/05/11/Essential-cpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B04/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础编程4"><a href="#C-基础编程4" class="headerlink" title="C++基础编程4"></a>C++基础编程4</h1><h2 id="面对对象的编程风格"><a href="#面对对象的编程风格" class="headerlink" title="面对对象的编程风格"></a>面对对象的编程风格</h2><p>​        我们面对对象的程序语言风格的主要两大特质是：继承和多态。前者让一群相关的类组织起来，使之可以共享共同的数据和操作行为，后者让我们在这些类上进行编程时，像是在操纵一个单一的个体，赋予我们更多的弹性加入或者移除任何特定的类。</p><p>​        继承产生了父类和子类的说法，父类定义了子类的共同之处和私有实现，而每一个子类都可以增加或者覆盖继承而来的东西，从而实现自身独特的行为。举个例子： AudioBook 从更大的父类 BOOK 继承了作者和标题之外，还有脸属于自己的播讲者和其他东西。</p><p>​        父类在C++中还有基类之称， 而子类则是作为派生类出现的。我们可以绘制一幅图来展示类之间的层级关系，如图所示：</p><p><img src="1.jpg" alt="1"></p><p>​        那啥是多态呢：来看一个程序：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void general_check_in(LibMat&amp; mat)&#123;    &#x2F;&#x2F; 但是我们不会传入一个基类 libmat，而是传入一个具体的派生类，如Magazines,AudioBook, Book这类的    mat.check_in();        if(mat.is_late())&#123;        mat.assess_fine();    &#125;    if(mat.waitinglist())&#123;        mat.notify_available();    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        demo:&gt;</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class LibMat &#123;public:virtual void isCheckIn() &#123; cout &lt;&lt; &quot;is a LibMat\n&quot;; &#125;;&#125;;class Book : public LibMat &#123;public:void isCheckIn() &#123; cout &lt;&lt; &quot;is a Book\n&quot;; &#125;&#125;;class Magazine :public LibMat &#123;public:void isCheckIn() &#123; cout &lt;&lt; &quot;is a magazine\n&quot;; &#125;&#125;;void isChecked(LibMat&amp; Mat) &#123;Mat.isCheckIn();&#125;int main() &#123;&#x2F;&#x2F; 继承LibMat libmat;libmat.isCheckIn();Book book;book.isCheckIn();Magazine mag;mag.isCheckIn();&#x2F;&#x2F; 多态isChecked(book);isChecked(mag);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的程序很有意思，我们的Interface分明要求的是LibMat，但是我们传入的是它的若干子类，程序却能正确的运行！只是因为编译器在运行时候确定具体应该调啥函数，而不是在编写程序时才指定！</p><h2 id="面向对象的编程运作流程"><a href="#面向对象的编程运作流程" class="headerlink" title="面向对象的编程运作流程"></a>面向对象的编程运作流程</h2><p>​        上面的例子太过简单，我们复杂一点：为了持续的跟踪个对象的构造，调用和析构，我们给个行为塞上向控制台打印Debug信息的语句</p><p>​        virtual这个关键字表明当下的被修饰函数时虚函数，可以被子类改写：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class LibMat:&#123;public:        LibMat()&#123;cout&lt;&lt;&quot; calling for the libmat constructor&quot;;&#125;    virtual ~LibMat()&#123;cout&lt;&lt;&quot; calling for the LibMat destructor&quot;;&#125;        virtual void printInfo const&#123; cout &lt;&lt;&quot;LibMat!&quot;;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是一个类，我们跟踪一下这个对象的流程：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;class LibMat&#123;public:    LibMat() &#123; cout &lt;&lt; &quot; calling for the libmat constructor\n&quot;; &#125;    virtual ~LibMat() &#123; cout &lt;&lt; &quot; calling for the LibMat destructor\n&quot;; &#125;    virtual void printInfo() const&#123; cout &lt;&lt; &quot;[printInfo] LibMat!\n&quot;; &#125;&#125;;void callPrint(LibMat&amp; aLib) &#123;    cout &lt;&lt; &quot;Call relevant functions\n&quot;;    aLib.printInfo();&#125;int main()&#123;    LibMat lib;    callPrint(lib);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230510091108469.png" alt="image-20230510091108469"></p><p>​        下面呢，我们派生一个类。叫Book（先前似乎用过，但是这里改变层级关系）。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;&#x2F;&#x2F; 这是基类class LibMat&#123;public:    LibMat() &#123; cout &lt;&lt; &quot; calling for the libmat constructor\n&quot;; &#125;    virtual ~LibMat() &#123; cout &lt;&lt; &quot; calling for the LibMat destructor\n&quot;; &#125;    virtual void printInfo() const&#123; cout &lt;&lt; &quot;[printInfo] LibMat!\n&quot;; &#125;&#125;;&#x2F;&#x2F; 这是派生类class Book : public LibMat &#123;public:    Book() &#123; cout &lt;&lt; &quot; calling for the book constructor&quot;; &#125;    Book(string bookName, string authorWho) &#123;        cout &lt;&lt; &quot; calling for the book constructor&quot;;         this-&gt;authorWho &#x3D; authorWho;        this-&gt;bookName &#x3D; bookName;    &#125;    virtual ~Book() &#123; cout &lt;&lt; &quot; calling for book destructor&quot;; &#125;;    virtual void printInfo()const &#123; cout &lt;&lt; &quot;[printInfo] Book: Author  &quot;&lt;&lt;authorWho\        &lt;&lt;&quot;  and the title is:&quot;&lt;&lt;bookName&lt;&lt;endl; &#125;private:    string bookName;    string authorWho;&#125;;void callPrint(LibMat&amp; aLib) &#123;    cout &lt;&lt; &quot;Call relevant functions\n&quot;;    aLib.printInfo();&#125;int main()&#123;    Book book(&quot;A note for Essential C++&quot;, &quot;CharlieChen&quot;);    callPrint(book);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230511093009133.png" alt="image-20230511093009133"></p><p>​        这就是我们的调用结果！</p><p>​        首先我们高兴的发现：编译器自动识别了我们传入的是LibMat的一个子类 Book。从而在调用时调用了Book的Print Info。也就是说，我们在一个需要父类接口的函数处传入一个子类时，往往会调用子类重写父类的方法而隐藏其父类的方法！</p><p>​        其二，我们留意到，程序中我们并没有显示的构造父类，或者说是基类，但是运行程序的时候依旧调用了父类的构造函数！</p><p>​        我们不止步于此，继续派生Book类！我们的书本种类繁多，不如整一个AudioBook,他派生于Book，但是还多出来narrator！也就是播讲者。那就是说：我们的私有成员在其自己的直接父类中又多了narrator!</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;&#x2F;&#x2F; 基类class LibMat&#123;public:    LibMat() &#123; cout &lt;&lt; &quot; calling for the libmat constructor\n&quot;; &#125;    virtual ~LibMat() &#123; cout &lt;&lt; &quot; calling for the LibMat destructor\n&quot;; &#125;    virtual void printInfo() const&#123; cout &lt;&lt; &quot;[printInfo] LibMat!\n&quot;; &#125;&#125;;&#x2F;&#x2F; 直接父类class Book : public LibMat &#123;public:    Book() &#123; cout &lt;&lt; &quot; calling for the book constructor&quot;; &#125;    Book(string bookName, string authorWho) &#123;        cout &lt;&lt; &quot; calling for the book constructor\n&quot;;         this-&gt;authorWho &#x3D; authorWho;        this-&gt;bookName &#x3D; bookName;    &#125;    virtual ~Book() &#123; cout &lt;&lt; &quot; calling for book destructor\n&quot;; &#125;;    virtual void printInfo()const &#123; cout &lt;&lt; &quot;[printInfo] Book: Author  &quot;&lt;&lt;authorWho\        &lt;&lt;&quot;  and the title is:&quot;&lt;&lt;bookName&lt;&lt;endl; &#125;protected:    string bookName;    string authorWho;&#125;;&#x2F;&#x2F;子类class AudioBook : public Book &#123;public:    AudioBook(const string&amp; title, const string&amp; author, \        const string&amp; narrator) :Book(title, author), narrator(narrator) &#123;        cout &lt;&lt; &quot;calling for the audiobook construtor:\n&quot;;    &#125;    virtual void printInfo()const &#123;        cout &lt;&lt; &quot;[printInfo] AudioBook: Author &quot; &lt;&lt; authorWho &lt;&lt; \            &quot; bookName  &quot; &lt;&lt; bookName &lt;&lt; &quot;  narrator :&quot; &lt;&lt; narrator &lt;&lt; endl;    &#125;protected:    string narrator;&#125;;void callPrint(LibMat&amp; aLib) &#123;    cout &lt;&lt; &quot;Call relevant functions\n&quot;;    aLib.printInfo();&#125;int main()&#123;    AudioBook audioBook(&quot;A note for Essential C++&quot;, &quot;CharlieChen&quot;,&quot;Charliechen&quot;);    callPrint(audioBook);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            对于那些希望可以直接访问继承来的父类私有成员，有必要声明之为protected 的。而那些希望自己独有而不被其他甚至是自己子类访问，则声明之private！正如上面所示的那样！</p><h2 id="定义一个抽象的基类"><a href="#定义一个抽象的基类" class="headerlink" title="定义一个抽象的基类"></a>定义一个抽象的基类</h2><p>​        对于我们想要设计的若干类，不如找出他们的共同点，设计出来一个只有共同的成员和行为的——基类！现在，我们拿一个——叫做num  sequence 的基类来抽象出所有的数列的共同点！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class num_sequence &#123;public:&#x2F;*getElembyPos( pos ) offering a returned value by giving posgenerate_elem( pos ) create a subSequence that locates [0, pos]arrayType() return type of the arrayprint( os ) written all elements into ostreamcheck_integrity( pos ) whether the pos is validmax_pos() return the max position*&#x2F;int getElembyPos(int pos);void generate_elem(int pos);string arrayType();void print(ostream&amp; os);bool check_integrity(int pos);static int  max_pos();&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        随后，指定哪些行为，是子类可能需要重写的！我们把它抽象成virtual的虚函数！表明他们可以被子类重写！</p><p>​        下一步，指定哪些成员我们希望子类继承并直接可以访问！</p><p>​        我们把两步整合一下，再次修理：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class num_sequence &#123;public:&#x2F;*getElembyPos( pos ) offering a returned value by giving posgenerate_elem( pos ) create a subSequence that locates [0, pos]arrayType() return type of the arrayprint( os ) written all elements into ostreamcheck_integrity( pos ) whether the pos is validmax_pos() return the max position*&#x2F;virtual ~num_sequence() &#123;&#125;; &#x2F;&#x2F; diffrent type of sequence has different waysvirtual int getElembyPos(int pos) &#x3D; 0; &#x2F;&#x2F; absolute virtual, contemporily need to overwrite!virtual string arrayType() const &#x3D; 0;virtual ostream&amp; print(ostream&amp; os) &#x3D; 0;static int max_pos() &#123; return _max_elems; &#125;;    protected:virtual void generate_elem(int pos) const &#x3D; 0;bool check_integrity(int pos) const;const static int _max_elems &#x3D; 1024;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意到，如果想要程序员强制重写虚函数，可以指定之为纯虚函数：</p><pre class="line-numbers language-none"><code class="language-none">virtual type funcName(funcList) &#x3D; 0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        由于基类的接口不完整，编译器不允许为之产生对象！只能作为派生类的子对象使用！于是，一个拥有纯虚函数的基类<strong>没有必要，也不应该拥有构造函数</strong>，同时，不同的子类析构方式可能不一样，由此指定析构函数为virtual 的！</p><p>​        带上实现看看：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;class num_sequence &#123;public:&#x2F;*getElembyPos( pos ) offering a returned value by giving posgenerate_elem( pos ) create a subSequence that locates [0, pos]arrayType() return type of the arrayprint( os ) written all elements into ostreamcheck_integrity( pos ) whether the pos is validmax_pos() return the max position*&#x2F;virtual ~num_sequence() &#123;&#125;; &#x2F;&#x2F; diffrent type of sequence has different waysvirtual int getElembyPos(int pos) &#x3D; 0; &#x2F;&#x2F; absolute virtual, contemporily need to overwrite!virtual string arrayType()const &#x3D; 0;virtual ostream&amp; print(ostream&amp; os &#x3D; cout)&#x3D; 0;static int max_pos() &#123; return _max_elems; &#125;;protected:virtual void generate_elem(int pos) &#x3D; 0;bool check_integrity(int pos, int size);const static int _max_elems &#x3D; 1024;&#125;; bool num_sequence::check_integrity(int pos,int size) &#123;if (pos &lt; 0 || pos &gt; _max_elems) &#123;cerr &lt;&lt; &quot; invalid position! request rejected!&quot;;return false;&#125;return true;&#125;ostream&amp; operator&lt;&lt; (ostream &amp; os, num_sequence&amp; ns) &#123;return ns.print(os);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义一个派生类"><a href="#定义一个派生类" class="headerlink" title="定义一个派生类"></a>定义一个派生类</h2><p>​        下面开始使用num_sequence干活！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Fib :public num_sequence &#123;public:Fib(int len &#x3D; 1, int begin_pos &#x3D; 1) :length(len), begin_pos(begin_pos) &#123;&#125;;virtual int getElembyPos(int pos);virtual ostream&amp; print(ostream&amp; os &#x3D; cout;int getlength() const&#123; return length; &#125;;int getBeginPos() const &#123; return begin_pos; &#125;;protected:virtual void generate_elem(int pos) ;int length;int begin_pos;vector&lt;int&gt; _elems;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面继续实现！</p><p>​        我们先实现一个返回指定位置的值的函数，大致看起来这样！值得注意的是我们在写实现的时候不用带上virtual！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int Fib::getElembyPos(int pos) &#123;if (!check_integrity(pos)) &#123;return 0;&#125;if (pos &gt; _elems.size()) &#123;Fib::generate_elem(pos);&#125;return _elems[pos - 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意到：1. 我们使用public 继承下来的<code>check_integrity(pos)</code>可以直接使用！因为这正是protected的成员！其二，建议载函数前指定这是哪个类的！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Fib::generate_elem(int pos) &#123;if (_elems.empty()) &#123;_elems.push_back(1);_elems.push_back(1);&#x2F;&#x2F; the first two should be 1,1&#125;if (_elems.size() &lt;&#x3D; pos) &#123;int i &#x3D; _elems.size();int n2 &#x3D; _elems[i - 2];int n1 &#x3D; _elems[i - 1];for (; i &lt; pos; i++) &#123;int elem &#x3D; n1 + n2;_elems.push_back(elem);n2 &#x3D; n1;n1 &#x3D; elem;&#125;&#125;&#125;ostream&amp; Fib::print(ostream&amp; os) &#123;int elem_pos &#x3D; begin_pos - 1;int end_pos &#x3D; elem_pos + length;if (end_pos &gt; _elems.size()) &#123;Fib::generate_elem(end_pos);&#125;while (elem_pos &lt; end_pos)os &lt;&lt; _elems[elem_pos++] &lt;&lt; &quot; &quot;;return os;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            下面综合一下实现+小小的调整</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;class num_sequence &#123;public:&#x2F;*getElembyPos( pos ) offering a returned value by giving posgenerate_elem( pos ) create a subSequence that locates [0, pos]arrayType() return type of the arrayprint( os ) written all elements into ostreamcheck_integrity( pos ) whether the pos is validmax_pos() return the max position*&#x2F;virtual ~num_sequence() &#123;&#125;; &#x2F;&#x2F; diffrent type of sequence has different waysvirtual int getElembyPos(int pos) &#x3D; 0; &#x2F;&#x2F; absolute virtual, contemporily need to overwrite!virtual string arrayType()const &#x3D; 0;virtual ostream&amp; print(ostream&amp; os &#x3D; cout)&#x3D; 0;static int max_pos() &#123; return _max_elems; &#125;;protected:virtual void generate_elem(int pos) &#x3D; 0;bool check_integrity(int pos, int size);const static int _max_elems &#x3D; 1024;&#125;; bool num_sequence::check_integrity(int pos,int size) &#123;if (pos &lt; 0 || pos &gt; _max_elems) &#123;cerr &lt;&lt; &quot; invalid position! request rejected!&quot;;return false;&#125;return true;&#125;ostream&amp; operator&lt;&lt; (ostream &amp; os, num_sequence&amp; ns) &#123;return ns.print(os);&#125;class Fib :public num_sequence &#123;public:Fib(int len &#x3D; 1, int begin_pos &#x3D; 1) :length(len), begin_pos(begin_pos) &#123;&#125;;virtual int getElembyPos(int pos);virtual ostream&amp; print(ostream&amp; os &#x3D; cout);int getlength() const&#123; return length; &#125;;int getBeginPos() const &#123; return begin_pos; &#125;;string arrayType()const;protected:virtual void generate_elem(int pos) ;int length;int begin_pos;vector&lt;int&gt; _elems;bool check_integrity(int pos, int size);&#125;;string Fib::arrayType() const&#123;return &quot;Fib&quot;;&#125;int Fib::getElembyPos(int pos) &#123;if (!check_integrity(pos,_elems.size())) &#123;return 0;&#125;if (pos &gt; _elems.size()) &#123;Fib::generate_elem(pos);&#125;return _elems[pos - 1];&#125;void Fib::generate_elem(int pos) &#123;if (_elems.empty()) &#123;_elems.push_back(1);_elems.push_back(1);&#x2F;&#x2F; the first two should be 1,1&#125;if (_elems.size() &lt;&#x3D; pos) &#123;int i &#x3D; _elems.size();int n2 &#x3D; _elems[i - 2];int n1 &#x3D; _elems[i - 1];for (; i &lt; pos; i++) &#123;int elem &#x3D; n1 + n2;_elems.push_back(elem);n2 &#x3D; n1;n1 &#x3D; elem;&#125;&#125;&#125;ostream&amp; Fib::print(ostream&amp; os) &#123;int elem_pos &#x3D; begin_pos - 1;int end_pos &#x3D; elem_pos + length;if (end_pos &gt; _elems.size()) &#123;Fib::generate_elem(end_pos);&#125;while (elem_pos &lt; end_pos)os &lt;&lt; _elems[elem_pos++] &lt;&lt; &quot; &quot;;return os;&#125;bool Fib::check_integrity(int pos, int size) &#123;if (pos &lt;&#x3D; 0 || pos &gt; _max_elems) &#123;cerr &lt;&lt; &quot; invalid position! request rejected!&quot;;return false;&#125;if (pos &gt; size) &#123;generate_elem(pos);&#125;return true;&#125;int main()&#123;Fib fib;cout &lt;&lt; fib&lt;&lt;endl;Fib fib2(16);cout &lt;&lt; fib2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始化，析构和复制"><a href="#初始化，析构和复制" class="headerlink" title="初始化，析构和复制"></a>初始化，析构和复制</h2><p>​        我再重复一遍：对于一个派生类的构造，他总是先递归的调用父类的构造函数！最后调用自己的构造函数！如果没有指定，则父类构造调用默认构造！对于复制，也是一样的，可以重写 operator = 来实现有效的深拷贝</p><h2 id="覆盖，定义虚函数"><a href="#覆盖，定义虚函数" class="headerlink" title="覆盖，定义虚函数"></a>覆盖，定义虚函数</h2><p>​        注意到，假使我们重写虚函数，特别是纯虚函数，必须在：参数列表，返回类型，常量性等<strong>完全</strong>跟父类一致！！！</p><p>​        对于虚函数的静态解析，当（1）基类的constructor和destructor （2）调用基类对象而不是对象的pointer 或者引用！</p><p>​        也就是说，如果我们的父类构造函数调用了一个虚函数，则会调用父类自己的而不是派生类的！！！（很好理解，先有鸡还是先有蛋的问题）</p><h2 id="运行时的类型鉴定机制"><a href="#运行时的类型鉴定机制" class="headerlink" title="运行时的类型鉴定机制"></a>运行时的类型鉴定机制</h2><p>​        C++中有一个接口函数叫typeid，可以在动态运行时查看类的类型是什么！需要引用头文件#include&lt; typeinfo &gt;</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if(typeid(*ps) &#x3D;&#x3D; typeid(Fib))...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 文件流基本快速复习</title>
      <link href="/2023/05/09/C-%E6%96%87%E4%BB%B6%E6%B5%81%E5%9F%BA%E6%9C%AC%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/05/09/C-%E6%96%87%E4%BB%B6%E6%B5%81%E5%9F%BA%E6%9C%AC%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言快速复习——文件流"><a href="#C语言快速复习——文件流" class="headerlink" title="C语言快速复习——文件流"></a>C语言快速复习——文件流</h1><p>​        我们现在开始作简单的文件操作的复习</p><h2 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数"></a>fopen函数</h2><p>​        打开文件的函数，也就是说我们需要创建一个<code>FILE*</code>指针来接受文件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct _iobuf &#123;        char *_ptr;        int   _cnt;        char *_base;        int   _flag;        int   _file;        int   _charbuf;        int   _bufsiz;        char *_tmpfname;        &#125;;typedef struct _iobuf FILE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        为了方便我们的接受文件，我们选择使用这个fopen函数.</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">FILE* fp &#x3D; fopen(fileAddr,Reading mode)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        那么，这就是一个重要的问题：我们应该怎么样打开文件呢？</p><div class="table-container"><table><thead><tr><th>w</th><th>open for writing (file need not exist)  如果文件不存在，就创建一个新的。</th></tr></thead><tbody><tr><td>a</td><td>open for appending (file need not exist)</td></tr><tr><td>r+</td><td>open for reading and writing, start at beginning</td></tr><tr><td>w+</td><td>open for reading and writing (overwrite file)</td></tr><tr><td>a+</td><td>open for reading and writing (append if file exists)</td></tr><tr><td>r</td><td>open for reading</td></tr></tbody></table></div><h2 id="fclose函数"><a href="#fclose函数" class="headerlink" title="fclose函数"></a>fclose函数</h2><p>​        对于文件指针，我们需要注意的是文件使用完毕之后，需要关闭文件指针。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">fclose(FILE* filePointer);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    </p><h2 id="fgetc-fputc"><a href="#fgetc-fputc" class="headerlink" title="fgetc fputc"></a>fgetc fputc</h2><p>​        跟getc 和 putchar 是一回事情！向指定的文件读入或者输出一个字符</p><h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek"></a>fseek</h2><p>​        我们在流中定位一个指针的位置：这只是适用在 fseek 里头！</p><pre class="line-numbers language-none"><code class="language-none">SEEK_SET 0&#x2F;&#x2F; AT THE BEGINNING OF THE FILESEEK_CUR 1&#x2F;&#x2F; AT THE CURRENT PLACE OF THE FILESEEK_END 2&#x2F;&#x2F; AT THE END OF THE FILE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="fputs-fgets-fprintf-fscanf"><a href="#fputs-fgets-fprintf-fscanf" class="headerlink" title="fputs fgets fprintf fscanf"></a>fputs fgets fprintf fscanf</h2><p>​        还是我们说的，跟<code>puts gets printf scanf</code>一回事</p><h2 id="feof"><a href="#feof" class="headerlink" title="feof()"></a>feof()</h2><p>​        到达文件尾时返回真值</p><h2 id="rewind"><a href="#rewind" class="headerlink" title="rewind()"></a>rewind()</h2><p>​        复位文件定位器到文件开始处</p><h2 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h2><p>​        从流中读指定个数的字符</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Essencial-cpp阅读笔记3</title>
      <link href="/2023/05/09/Essencial-cpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B03/"/>
      <url>/2023/05/09/Essencial-cpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B03/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础编程３"><a href="#C-基础编程３" class="headerlink" title="C++基础编程３"></a>C++基础编程３</h1><h2 id="泛型编程风格"><a href="#泛型编程风格" class="headerlink" title="泛型编程风格"></a>泛型编程风格</h2><p>​        STL,就是泛型编程的良好体现,它由两个基本组件组成.1是容器, 2是泛型算法.</p><h3 id="从指针运算讲起"><a href="#从指针运算讲起" class="headerlink" title="从指针运算讲起"></a>从指针运算讲起</h3><p>​        我们现在考虑从一个容器里找到一个元素,  比如说在一个vector容器中找到我们想要的整数: int. 算法是轻而易举就可以写出来的:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int* find(const vector&lt;int&gt; &amp;r_vec,int&amp; val)&#123;for(int i &#x3D; 0 ; i &lt; r_vec.size();i++)&#123;                if(vec[i] &#x3D;&#x3D; value)&#123;            return &amp;vec[i];        &#125;            &#125;return nullptr;&#x2F;&#x2F; same as NULL in C &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果,我们的容器时任何什么东西又该怎么办呢?</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename elem&gt;&#x3D;elem* find(const vector&lt;elem&gt;&amp; r_vec, elem&amp; val)&#123;for(int i &#x3D; 0 ; i &lt; r_vec.size();i++)&#123;                if(vec[i] &#x3D;&#x3D; value)&#123;&#x2F;&#x2F; 当然要求elem存在 equal 方法或者是重载了 &#x3D;&#x3D;            return &amp;vec[i];        &#125;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是,貌似若我们不是在vector里找,而是list里找,那又该怎么办呢. 我们没办法对list找下标的(list 是离散容器)</p><h2 id="采用纯指针访问"><a href="#采用纯指针访问" class="headerlink" title="采用纯指针访问"></a>采用纯指针访问</h2><p>​        anyway, 我们想一下啊: 本质上[]就是一个语法糖,对于一个连续容器的, 本质上讲:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">array[i]  &lt;----------&gt; (array+i)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这样就启发我们这样书写当传入类型是array类型的时候(经典数组)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">elem* find(elem* begin,int elemSize,elem&amp; befoundElem)&#123;if(begin &amp;&amp; elemSize &lt; 0)&#123;        return nullptr;    &#125;        for(int i &#x3D; 0; i &lt; size; i++,begin++)&#123;        if(*begin &#x3D;&#x3D; beFoundElem)&#123;                        return begin;                    &#125;    &#125;return nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        嗯,但是传入要访问多少个,不如试试全部传入指针?</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">elem* find(elem* begin,elem* end,elem&amp; befoundElem)&#123;if(begin &amp;&amp; elemSize &lt; 0)&#123;        return nullptr;    &#125;        for(; begin !- end; i++,begin++)&#123;        if(*begin &#x3D;&#x3D; beFoundElem)&#123;                        return begin;                    &#125;    &#125;return nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在我们发现,我们无意的抽象出来一个对象, 什么意思?我们抽象出来一个指针类型,使之可以有 ++ — * -&gt;等若干行为,我们的容器只需要提供begin 和 end就可以使用最广泛的泛型算法!这就是 iterator迭代器的来源!</p><h2 id="泛型指针-迭代器"><a href="#泛型指针-迭代器" class="headerlink" title="泛型指针:迭代器"></a>泛型指针:迭代器</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">vector&lt;string&gt; :: iterator IT &#x3D; svec.begin()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        就是一个指针指向了begin!如果我们希望是一个常指针帮助我们做事情,那使用const_iterator会好很多!</p><p>​        为了可以让iterator正常工作,有必要指出与实现:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1 -&gt; equlity( &#x3D;&#x3D; ) and inequlity ( !&#x3D; )2 -&gt; assignment(&#x3D; 赋值)3. empty(空)4. size(衡量元素大小)5.clear()删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始化一个容器的基本五大接口"><a href="#初始化一个容器的基本五大接口" class="headerlink" title="初始化一个容器的基本五大接口"></a>初始化一个容器的基本五大接口</h2><ol><li>初始化默认的空容器</li><li>产生特定的容器,并且所有的成员都要有默认的初始值</li><li>产生特定大小的容器,并为之赋初始值</li><li>通过iterator给与值</li><li>复制构造</li></ol><h2 id="基于对象的编程风格"><a href="#基于对象的编程风格" class="headerlink" title="基于对象的编程风格"></a>基于对象的编程风格</h2><p>​        我们在先前已经体验过class了，就像vector一样。</p><p>​        首先，我们知道：类必须要声明！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;string&gt;string pooh[4] &#x3D;&#123;&quot;winnie&quot;,    &quot;robin&quot;,    &quot;eeyole&quot;,    &quot;piglet&quot;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        class 名称将会被视作类型（type）名称，就像内置类型int, double一样。 class object的初始化做法有很多种！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;vector&gt;string path(&quot;dummy&quot;);vector&lt;string&gt; svc1(4);vector&lt;string&gt; svc2(4,&quot;dummy&quot;);vector&lt;string&gt; svc3(pooh,pooh+4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        每个class都会提供一组操作数，让我们可以作用之在object.比如说，我们提供函数func(), </p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class sth;sth Sth;Sth.func(obj object)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        一般的, class有三个部分组成，我更愿意说：class里的成员是分为三个类别的：private的，protected的，和 public 的。Public区域下的成员和对象都是对外开放。Private则只能在类内访问！举个例子：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class aClass&#123;public:int pub_Val; &#x2F;&#x2F; can be used in public space    int* returnAIntVal();&#123;        return new int(10); &#x2F;&#x2F; can be used in public space    &#125;int returnPri_Val()&#123;        return pri_Val; &#x2F;&#x2F; valid    &#125;;private:    int pri_Val;     int* returnSomethong();&#123;        return new int(11);    &#125;&#125;int main()&#123;        aClass sth;    int a &#x3D; sth.pub_Val; &#x2F;&#x2F; valid     int* pa &#x3D; sth.returnPri_Val();&#x2F;&#x2F; valid     int priAVal &#x3D; sth.rereturnPri_Val();        &#x2F;&#x2F; Also valid! This is the Interface of private.             &#x2F;&#x2F; followings are invalid        int wrongA &#x3D; sth.pri_Val; &#x2F;&#x2F; Invalid!!! cannot visit private    int* wrongB &#x3D; sth.returnSomethong();&#x2F;&#x2F; Invalid!!! cannot visit private &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现一个Class"><a href="#实现一个Class" class="headerlink" title="实现一个Class"></a>实现一个Class</h3><p>​        我们的main topic 在使用C++手写一个stack！关键在于怎么写</p><p><img src="image-20230506140557771.png" alt="image-20230506140557771"></p><p>​        这是一个声明！</p><p><img src="image-20230506140519165.png" alt="image-20230506140519165"></p><p>​        这是一个Stack的标准声明与定义。</p><p>​        下面，编写接口：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;class Stack &#123;public:bool push(const string&amp; pString);bool pop(string&amp; pString);bool peek(string&amp; pString);bool isEmpty();bool isFull();int size() &#123; return _stack.size(); &#125;;private:vector&lt;string&gt; _stack;&#125;;void fill_stack(Stack&amp; stack, istream&amp; is &#x3D; cin) &#123;string str;while (is &gt;&gt; str &amp;&amp; !stack.isFull()) &#123;stack.push(str);&#125;cout &lt;&lt; &quot;Read in&quot; &lt;&lt; stack.size() &lt;&lt; &quot;elements\n&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是接口没有实现！那怎么办！</p><p>​        我们是这样书写类内的成员函数的：只需要声明这是哪个类的函数。。。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool Stack::pop(string&amp; elem) &#123;if (empty()) &#123;return false;&#125;elem &#x3D; _stack.back();_stack.pop_back();return true;&#125;inline bool Stack::empty() &#123;return this-&gt;_stack.empty();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        类和其成员函数的定义和实现是，应当放在头文件里去。</p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>​        我们先不说的这样抽象！转向直接阐述：构造函数是一种初始化函数，同</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int a &#x3D; new int;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        是一回事。但是由于我们的类是若干基础变量组合产生。有必要使用函数来包装！比如说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Tri&#123;private:m_Val1;m_Val2;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Tri::Tri()&#123;        m_Val1 &#x3D; 10;    m_Val2 &#x3D; 20;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的函数就是一个构造函数，我们初始化了类内的变量！</p><p>​        构造函数是可以重载的！我们可以重载构造函数，使之给用户提供不同的初始化方式。</p><pre class="line-numbers language-none"><code class="language-none">Tri::Tri(int mVal1, int mVal2)&#123;        m_Val1 &#x3D; mVal1;    m_Val2 &#x3D; mVal2;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>​        我们对于一些变量可以使之直接在表内初始化</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Tri::Tri(int mVal1, int mVal2): m_Val1(mVal1),m_Val2(mVal2)&#123;    &#x2F;&#x2F; ... other things    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们会在程序的结尾调用析构器。事实上，在上面的函数中没有必须调用析构器！因为对象都是简单对象，直接释放即可。这就说明一件事情：对于简单的类和简单的尚未在堆上开辟内存的类，可以直接调用析构器从而实现内存释放</p><h2 id="逐一初始化的"><a href="#逐一初始化的" class="headerlink" title="逐一初始化的"></a>逐一初始化的</h2><p>​        下面想要说的是浅拷贝的知识点：这是在我们使用等号赋值的一种较为常见的错误</p><p>​        对于一些简单的类，那些成员不在堆上的类，我们当然可以选择浅拷贝来解决问题：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Easy&#123;        public: anSample(int val1, int val2);       int m_Val1;    int m_Val2;        &#x2F;&#x2F;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样的行为被称为浅拷贝：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Easy anSample(1, 2);&#x2F;&#x2F; call the anSample(int,int)Easy aCopy &#x3D; anSample;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        本质上，我们实际上调用了这样一个被编译器隐藏起来的函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Easy&amp; operator&#x3D;(Easy&amp; beCopied)&#123;        this-&gt;m_Val1 &#x3D; beCopied-&gt;m_Val1;    this-&gt;m_Val2 &#x3D; beCopied-&gt;m_Val2;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        那也就意味着，假使我们这样操作：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Diff&#123;    public:    diff(int val)&#123;                this-&gt;m_Val1 &#x3D; val;                this-&gt;m_inHeapArray &#x3D; new int[10];    &#125;                int m_Val1;        int* m_inHeapArray;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        而这样的话，就意味着我们在赋值的时候</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Diff dif(10);Diff copy &#x3D; dif;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        调用的是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Easy&amp; operator&#x3D;(Easy&amp; beCopied)&#123;        this-&gt;m_Val1 &#x3D; beCopied-&gt;m_Val1;    this-&gt;m_inHeapArray &#x3D; beCopied-&gt;m_inHeapArray;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这分明是开了两个指针指向同一块内存，这就意味着，只需要我们的被拷贝对象或者是拷贝对象被调用了正确的（就是说我们的程序员正确的释放了内存）析构函数，那么，当程序结束或者是准备析构另一个对象的时候，我们就会拿起来它，释放（危险行为），但是先前这块地方已经被释放过了！坏了，这下寄了，程序就会崩溃！</p><p>​        解决办法是：自己老老实实重写，比如说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Diff&amp; operator&#x3D;(Diff&amp; beCopied)&#123;        this-&gt;m_Val1 &#x3D; beCopied-&gt;m_Val1;        this-&gt;m_inHeapArray &#x3D; new int[10];        memcpy(this-&gt;m_inHeapArray,beCopied-&gt;m_inHeapArray,10*sizeof(int));        return *this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TIPS：小心坑"><a href="#TIPS：小心坑" class="headerlink" title="TIPS：小心坑"></a>TIPS：小心坑</h2><p>​        由于引用的出现，我们赋值方式很多，但是这样的等号赋值，编译器调用哪一个呢？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Diff copy &#x3D; sample; &#x2F;&#x2F; 调用了默认的还是自己重载的？&#x2F;&#x2F;Diff copy2;copy2 &#x3D; sample; &#x2F;&#x2F; sample is already inited<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        答案是，上面的调用的是默认的拷贝构造函数（构！造！），下面调用的是自己手动重载的函数。这是等号赋值函数。这是我们需要注意的！！！</p><p>​        下面供一个小小的DEMO给大伙看看：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;cstdlib&gt;class Diff &#123;public:Diff();Diff(int val);~Diff();Diff&amp; operator&#x3D;(Diff&amp; dif);void showDetail()const;private:int m_Val;int* m_inHeap;&#125;;Diff::Diff() &#123;this-&gt;m_Val &#x3D; 0;this-&gt;m_inHeap &#x3D; NULL;&#125;Diff::Diff(int val) &#123;this-&gt;m_Val &#x3D; val;this-&gt;m_inHeap &#x3D; new int[10];&#125;Diff::~Diff() &#123;delete[] this-&gt;m_inHeap;std::cout &lt;&lt; &quot;Finished calling the destructor!&quot; &lt;&lt; &#39;\n&#39;;&#125;Diff&amp; Diff::operator&#x3D;(Diff&amp; dif) &#123;this-&gt;m_Val &#x3D; dif.m_Val;this-&gt;m_inHeap &#x3D; new int[10];memcpy(this-&gt;m_inHeap, dif.m_inHeap, 10 * sizeof(int));return *this;&#125;void Diff::showDetail()const &#123;std::cout &lt;&lt; &quot;the Val &gt;&quot; &lt;&lt; this-&gt;m_Val &lt;&lt; &quot;   &quot; \&lt;&lt; &quot; the addr name :&gt;&quot; &lt;&lt; this-&gt;m_inHeap &lt;&lt; &quot;   &quot; &lt;&lt; std::endl;&#125;int main() &#123;Diff sample(10);Diff copy;copy &#x3D; sample;copy.showDetail();sample.showDetail();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="mutable-和-const"><a href="#mutable-和-const" class="headerlink" title="mutable 和 const"></a>mutable 和 const</h2><p>​        查阅你的英文字典，哈哈一笑，一个是可变的，一个不是可变。</p><p>​        我们来看一个Demo函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;class wrapArray &#123;public:wrapArray();wrapArray(size_t size);inline size_t getSize() const &#123; return this-&gt;arrSize; &#125;;inline int* getAddr(int* emptySpace &#x3D; nullptr)const &#123; int* space &#x3D; new int[arrSize]; memcpy(space, this-&gt;arr, sizeof(int) * arrSize); return space; &#125;;void simpleInitArr();long addSum()const;private:int* arr;size_t arrSize;&#125;;wrapArray::wrapArray() &#123;this-&gt;arrSize &#x3D; 0;this-&gt;arr &#x3D; nullptr;&#125;wrapArray::wrapArray(size_t size) &#123;this-&gt;arrSize &#x3D; size;this-&gt;arr &#x3D; new int[size];&#125;void wrapArray::simpleInitArr() &#123;for (int i &#x3D; 0; i &lt; this-&gt;arrSize; i++) &#123;this-&gt;arr[i] &#x3D; i;&#125;return;&#125;long wrapArray::addSum()const &#123;long sum &#x3D; 0;int* arr &#x3D; getAddr();for (auto i &#x3D; 0; i &lt; getSize(); i++) &#123;sum +&#x3D; arr[i];&#125;return sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <strong>类</strong>的成员函数后面加 const，表明这个函数不会对这个类对象的 数据成员（准确地说是非静态数据成员）作任何改变 。 在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加 const，而对于改变数据成员的成员函数不能加 const。</p><p>​        可以看到上面的函数就是这样做的！</p><p>​        但是注意到！一些函数虽然是 const 的，向编译器承诺不会改变成员的值的。但是他们有可能返回一个 non-const接口，对于那些拿起这些接口的对象，他们是<strong>可以</strong>改变对象的值的！这是十分不好的！最好的办法是设计一个non-const类型从而分别处理比较好</p><p>​        那mutable呢？他们用在这样希望其他不变而就这个改变的变量上，比如说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;class Person &#123;public:    Person();    ~Person();    int getAge() const; &#x2F;*调用方法*&#x2F;    int getCallingTimes() const; &#x2F;*获取上面的getAge()方法被调用了多少次*&#x2F;private:    int age;    char* name;    float score;    mutable int m_nums;            &#x2F;*用于统计次数*&#x2F;&#125;;Person::Person()&#123;    m_nums &#x3D; 0;&#125;Person::~Person() &#123;&#125;int Person::getAge() const&#123;    std::cout &lt;&lt; &quot;Calling the method&quot; &lt;&lt; std::endl;    m_nums++; &#x2F;&#x2F; 你看这个就突破了const 的修饰    &#x2F;&#x2F;age &#x3D; 4; 仍然无法修改该成员变量    return age;&#125;int Person::getCallingTimes()const&#123;    return m_nums;&#125;int main()&#123;    Person* person &#x3D; new Person();    for (int i &#x3D; 0; i &lt; 10; i++) &#123;        person-&gt;getAge();    &#125;    std::cout &lt;&lt; &quot;getAge()方法被调用了&quot; &lt;&lt; person-&gt;getCallingTimes() &lt;&lt; &quot;次&quot; &lt;&lt; std::endl;    delete person;    getchar();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>​        什么是this指针？其实，它就相当于一个self!也就是说指向他自己的一个指针！</p><p>​        by the way, 针对拷贝构造函数的时候注意一定要查看这两个对象是不是一致的。这是一个好习惯。</p><h2 id="静态类成员与函数"><a href="#静态类成员与函数" class="headerlink" title="静态类成员与函数"></a>静态类成员与函数</h2><p>​        什么是静态类的呢?我们回想一下静态类变量：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static int times &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        一回事情！而且，static变量可以定义在类的外面：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class isSomeThing&#123;    &#x2F;&#x2F;...    inline static getAStaticVal()&#123;return aStaticVal;&#125;&#125;int isSomeThing:: aStaticVal &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        值得注意的是：静态成员函数是只可以访问静态变量成员的，为什么呢？</p><p>​        在类中，static 除了可以声明静态成员变量，还可以声明静态成员函数。普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。</p><p>​        编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。</p><p>​        普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。</p><p>​        普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。</p><p>​        静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Essencial_cpp阅读笔记（2）</title>
      <link href="/2023/05/06/Essencial-cpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/"/>
      <url>/2023/05/06/Essencial-cpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础编程2"><a href="#C-基础编程2" class="headerlink" title="C++ 基础编程2"></a>C++ 基础编程2</h1><h2 id="面向过程的函数编程"><a href="#面向过程的函数编程" class="headerlink" title="面向过程的函数编程"></a>面向过程的函数编程</h2><p>​        为了更好的开发更大的程序，我们往往采用函数来完成我们的编程任务，从而提高代码的复用性。</p><h2 id="如何编写一个函数"><a href="#如何编写一个函数" class="headerlink" title="如何编写一个函数"></a>如何编写一个函数</h2><p>​        每一个函数都必须由下面四个部分构成：</p><p>​        1）返回类型 returnType : 简单的讲就是函数返回啥的问题</p><p>​        2）函数名： 函数的命名也有讲究，如何给函数命名是一门艺术，简单的讲：使用名称来告诉用户程序员这个函数的功能！</p><p>​        3）参数列表： 函数需要什么？这就是参数列表的用处了，参数列表列出了函数需要什么！</p><p>​        4）函数体： 函数是怎么实现的？结构如何，从这里看</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">returnType funcName(typePackage parameters)&#123;        &#x2F;&#x2F; do things here    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        比如说，我们对一个vector里的元素寻求最大值</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long findMax(vector&lt;int&gt; vec)&#123;long curMax &#x3D; vec[0];    for(auto i &#x3D; vec.begin(); i !&#x3D; vec.end(); i++)&#123;                if(*i &gt; curMax)&#123;            curMax &#x3D; *i;        &#125;            &#125;    return curMax;&#x2F;&#x2F; return the val back in here.&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们就这样把函数抽象做子程序了！在这些子程序中，一个重要的issue就是异常处理，这里是一个简单的demo</p><p>​        我们来看这个函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long getElemFromVector(vector&lt;int&gt; vector, int pos)&#123;if(pos &lt; 0 || pos &gt; vector.size())&#123;                exit( -1 );            &#125;        return vector[pos];    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        很显然这是一个返回第pos位置上的元素的函数。那哪里是异常处理被？就是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if(pos &lt; 0 || pos &gt; vector.size())&#123;                exit( -1 );&#x2F;&#x2F; should include the &lt;cstdlib&gt; to use the functions        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="传参方法：passByReference"><a href="#传参方法：passByReference" class="headerlink" title="传参方法：passByReference"></a>传参方法：passByReference</h2><p>​        先别说！看一个这个玩意：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void swapInt(int a, int b)&#123;int temp &#x3D; b    b &#x3D; a;    a &#x3D; temp;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        函数可以成功交换两数嘛，答案是否定的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;   int a &#x3D; 10;   int b &#x3D;20;   swap(a,b);       cout &lt;&lt; a &lt;&lt;&quot; &quot; &lt;&lt; b;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&gt;&gt; a.out&gt;&gt; 10 20 &#x2F;&#x2F; sadly make no swap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        这是因为调用函数的时候，只是把a,b的拷贝传入到函数的内部而不是他们本身，这样就意味着非常坏的事情：做无用功，玩弄形参而已，现在我们使用 reference 这个C++概念 。实际上，当我们使用引用的时候就意味着我们是传入它的地址：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; new type of codingvoid swap(int&amp; a, int&amp; b)&#123;        int temp &#x3D; a;    a &#x3D; b;    b &#x3D; temp;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们为什么传参传引用呢？原因是简单的：对于值传递，编译器必须复制传入对象，有时，这样的工作被证明是复杂耗时的。并不利于我们的程序性能的提升。其次，使用引用传递使的函数的作用可以有效地反馈至程序！当然，那为什么不用指针呢？区别在于，可以简单的理解为引用是特殊的常指针。而且在写法上更为简便。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>​        我们下面要说的是作用域的问题。我们为什么函数结束后一些临时变量会被销毁？就是因为我们的变量到达了他们的生命周期而被释放。一个变量的生命周期正是从他被创造开始到他被释放的实践间隔。这就是为什么传回函数临时变量的地址是非法的。因为我们拿到的是已经还给操作系统的内存——换而言之，我们在非法访问！于是，如果我们真的想返回函数的什么东西，应当使用值返回（return by val），这是因为函数此时返回了变量的副本。抑或是选择在内存中开辟！也就是说：在堆上开辟数据，他们会存留到程序结束为止，抑或是选择程序员自动释放。</p><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><p>​        一个big issue! 我们需要在堆上放置数据，就很有必要使用操作符 new.</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Type* pobj &#x3D; new Type(Initial Val)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int* pInt &#x3D; new int(1024);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        使用delete来删除我们在堆上开辟的内存！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">delete pobj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果我们开辟的是一个数组，那就记得：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">delete[] pArray<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="提供默认的参数值"><a href="#提供默认的参数值" class="headerlink" title="提供默认的参数值"></a>提供默认的参数值</h2><p>​        我们有时候一些函数的参数总是使用一个默认的值，只在另一个时候才会使用别的值，那我们可不可以使用默认的值来减轻我们的开发负担呢？答案是可以的。</p><p>​        现在我们来考虑使用冒泡排序，在默认的情况下我们是要向控制台输出。但是有时候还是会向其他地方输出。怎么办？如何有效的设计这个函数？</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void bubbleSort(vector&lt;int&gt; &amp;vec, ofstream *ofil &#x3D; 0)&#123;    for(int i &#x3D; 0; i &lt; vec.size(); i++)&#123;                for(int j &#x3D; i+1 ; j &lt; vec.size(); j++)&#123;            if(vec[i] &gt; vec[j])&#123;                                if(ofil !&#x3D; 0)&#123;                    (*ofil)&lt;&lt; &quot;About to call the debug&quot;;                &#125;                swap(vec[i],vec[j],ofil);            &#125;                    &#125;            &#125;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意到我们为了提供默认使之给ofil对象使用的是指针传递。这是因为我们如果是使用的引用传递，就意味着我们无法置0. 不太好设置初始值！</p><p>​        关于默认值，值得注意的是有两个基本的注意点：首先是默认值必须放在最右边，不可以插入中间指定默认值而后面不指定</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a(int a &#x3D; 5, int b);&#x2F;&#x2F; invalid!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        注意还有，必须只能指定一次默认值！不可以指定两次！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int a(int a, int b &#x3D; 2);int a(int a, int b &#x3D; 3);&#x2F;&#x2F;编译器不知道调用哪一个！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="使用局部静态变量"><a href="#使用局部静态变量" class="headerlink" title="使用局部静态变量"></a>使用局部静态变量</h2><p>​        一些常用的东西，可以存在静态区，我们使用的是static关键字完成这项工作的！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int someFunc(...)&#123;static int a &#x3D; 10;&#x2F;&#x2F;当这里被定义了过后。。。下一次再次调用直接取先前被创造出的地方a++;&#x2F;&#x2F;第一次调11 第二次调用12.。。以此类推&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="可以考虑inline"><a href="#可以考虑inline" class="headerlink" title="可以考虑inline"></a>可以考虑inline</h2><p>​        对于一些频繁调用的函数，我们加上inline声明。编译器调用的时候选择在调用点处用一份函数代码副本代替。也就是说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int f1()&#123;        ...        f2();        ...            f3();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，本来是编译器要跳转三次到其他函数，现在加上inline声明，f2,f3的代码直接移动到f1内部，编译器之跳转到f1工作完毕再跳出！我们由此获得了性能提升。</p><p>​        但是这只是一种请求，编译器会根据自己运行的情况进行判断！一般而言，我们倾向于选择体积小，常被调用和从事工作不复杂的函数加上inline。</p><h2 id="提供重载函数"><a href="#提供重载函数" class="headerlink" title="提供重载函数"></a>提供重载函数</h2><p>​        有时候，我们的函数只是因为工作相同，但是参数不同而不得不命名不同的函数。这不方便我们的工作！于是我们选择使用重载函数来完成我们的操作</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void display(string a);void display(int a);&#x2F;&#x2F;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        注意到参数类型要不同！</p><h2 id="定义并使用模板"><a href="#定义并使用模板" class="headerlink" title="定义并使用模板"></a>定义并使用模板</h2><p>​        但是重载函数面对太多不同的类型，也不能写那么多重载函数，怎么办呢？使用模板就好了！</p><p>​        模板的格式定义是： template&lt; typename name&gt;</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename nameType&gt;void display(nameType msg);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>      当我们传一个string的时候，编译器把这里解释成string，如果传入一个int 就是int。</code></pre><h2 id="使用头文件"><a href="#使用头文件" class="headerlink" title="使用头文件"></a>使用头文件</h2><p>​        我们可以分离 声明——实现这个抽象工作，只需要我们把声明放到头文件就可以了！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;#include&quot;MyFile.h&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        简单来讲，&lt;&gt; 和“”的区别在于。 尖括号包下的文件被认为是标准的或者是项目专属的文件，编译器回去默认磁盘项目里去找，而“”被认为是用户头文件，编译器从当下的文件目录开始找！</p><h2 id="泛型编程风格"><a href="#泛型编程风格" class="headerlink" title="泛型编程风格"></a>泛型编程风格</h2><p>​        STL,就是泛型编程的良好体现,它由两个基本组件组成.1是容器, 2是泛型算法.</p><h3 id="从指针运算讲起"><a href="#从指针运算讲起" class="headerlink" title="从指针运算讲起"></a>从指针运算讲起</h3><p>​        我们现在考虑从一个容器里找到一个元素,  比如说在一个vector容器中找到我们想要的整数: int. 算法是轻而易举就可以写出来的:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int* find(const vector&lt;int&gt; &amp;r_vec,int&amp; val)&#123;for(int i &#x3D; 0 ; i &lt; r_vec.size();i++)&#123;                if(vec[i] &#x3D;&#x3D; value)&#123;            return &amp;vec[i];        &#125;            &#125;return nullptr;&#x2F;&#x2F; same as NULL in C &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果,我们的容器时任何什么东西又该怎么办呢?</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename elem&gt;&#x3D;elem* find(const vector&lt;elem&gt;&amp; r_vec, elem&amp; val)&#123;for(int i &#x3D; 0 ; i &lt; r_vec.size();i++)&#123;                if(vec[i] &#x3D;&#x3D; value)&#123;&#x2F;&#x2F; 当然要求elem存在 equal 方法或者是重载了 &#x3D;&#x3D;            return &amp;vec[i];        &#125;            &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是,貌似若我们不是在vector里找,而是list里找,那又该怎么办呢. 我们没办法对list找下标的(list 是离散容器)</p><h2 id="采用纯指针访问"><a href="#采用纯指针访问" class="headerlink" title="采用纯指针访问"></a>采用纯指针访问</h2><p>​        anyway, 我们想一下啊: 本质上[]就是一个语法糖,对于一个连续容器的, 本质上讲:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">array[i]  &lt;----------&gt; (array+i)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这样就启发我们这样书写当传入类型是array类型的时候(经典数组)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">elem* find(elem* begin,int elemSize,elem&amp; befoundElem)&#123;if(begin &amp;&amp; elemSize &lt; 0)&#123;        return nullptr;    &#125;        for(int i &#x3D; 0; i &lt; size; i++,begin++)&#123;        if(*begin &#x3D;&#x3D; beFoundElem)&#123;                        return begin;                    &#125;    &#125;return nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        嗯,但是传入要访问多少个,不如试试全部传入指针?</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">elem* find(elem* begin,elem* end,elem&amp; befoundElem)&#123;if(begin &amp;&amp; elemSize &lt; 0)&#123;        return nullptr;    &#125;        for(; begin !- end; i++,begin++)&#123;        if(*begin &#x3D;&#x3D; beFoundElem)&#123;                        return begin;                    &#125;    &#125;return nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在我们发现,我们无意的抽象出来一个对象, 什么意思?我们抽象出来一个指针类型,使之可以有 ++ — * -&gt;等若干行为,我们的容器只需要提供begin 和 end就可以使用最广泛的泛型算法!这就是 iterator迭代器的来源!</p><h2 id="泛型指针-迭代器"><a href="#泛型指针-迭代器" class="headerlink" title="泛型指针:迭代器"></a>泛型指针:迭代器</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">vector&lt;string&gt; :: iterator IT &#x3D; svec.begin()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        就是一个指针指向了begin!如果我们希望是一个常指针帮助我们做事情,那使用const_iterator会好很多!</p><p>​        为了可以让iterator正常工作,有必要指出与实现:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">1 -&gt; equlity( &#x3D;&#x3D; ) and inequlity ( !&#x3D; )2 -&gt; assignment(&#x3D; 赋值)3. empty(空)4. size(衡量元素大小)5.clear()删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="初始化一个容器的基本五大接口"><a href="#初始化一个容器的基本五大接口" class="headerlink" title="初始化一个容器的基本五大接口"></a>初始化一个容器的基本五大接口</h2><ol><li>初始化默认的空容器</li><li>产生特定的容器,并且所有的成员都要有默认的初始值</li><li>产生特定大小的容器,并为之赋初始值</li><li>通过iterator给与值</li><li>复制构造</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摸鱼ing（1） Windows API 程序设计初探（1）</title>
      <link href="/2023/05/04/%E6%91%B8%E9%B1%BCing%EF%BC%881%EF%BC%89-Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%9D%E6%8E%A2%EF%BC%881%EF%BC%89/"/>
      <url>/2023/05/04/%E6%91%B8%E9%B1%BCing%EF%BC%881%EF%BC%89-Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%9D%E6%8E%A2%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-API-编程初探1"><a href="#Windows-API-编程初探1" class="headerlink" title="Windows API 编程初探1"></a>Windows API 编程初探1</h1><p>​        写在前面：这是本菜鸟首次对一个大的topic有巨大的兴趣，正好，本人对桌面应用开发有动力研究，这里就以Windows API　编程作为自己串起来操作系统，并发编程，C++基本程序设计应用，以及底层QT开发的一个Application demo了！</p><h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><p>​        还记得你在实验课上使用老古董 VS2010，当你选择了空项目开发后必须手动使用</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">system(&quot;pause&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个函数嘛？不错，他就是我们Windows API的一个。目的是让程序暂停在此句！我们应用的头文件是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们的主角来了哈哈哈</p><h2 id="小试一手"><a href="#小试一手" class="headerlink" title="小试一手"></a>小试一手</h2><p>​        创建你的一个项目，不够今天，我们创建的是一个桌面向导项目，随后，我们选择空项目创建，将：</p><p><img src="image-20230504215411467.png" alt="image-20230504215411467"></p><p>改成：</p><p><img src="image-20230504215354973.png" alt="image-20230504215354973"></p><p>​    以及转到：（右键项目选择属性）</p><p>​    把控制台改成窗口输出！不然编译器会在下面的程序中报错！</p><p><img src="image-20230504215458663.png" alt="image-20230504215458663"></p><p>​        我们书写一个简单的C++程序！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)&#123;MessageBox(NULL, TEXT(&quot;Hello, World&quot;), TEXT(&quot;Captions&quot;), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        F5一下：</p><p><img src="image-20230504215640299.png" alt="image-20230504215640299"></p><p>​        6！</p><h2 id="逐一解释"><a href="#逐一解释" class="headerlink" title="逐一解释"></a>逐一解释</h2><h3 id="include-lt-Windows-h-gt"><a href="#include-lt-Windows-h-gt" class="headerlink" title="#include&lt; Windows.h &gt;"></a>#include&lt; Windows.h &gt;</h3><p>​        我们老规矩，先来看看Windows.h装了啥：</p><p><img src="image-20230504220523073.png" alt="image-20230504220523073"></p><p>​        反正一大堆，但是核心就这些，这是我们需要注意的！</p><h3 id="int-WINAPI-WinMain-HINSTANCE-hInstance-HINSTANCE-hPrevInstance-LPSTR-ipCmdLine-int-nCmdShow"><a href="#int-WINAPI-WinMain-HINSTANCE-hInstance-HINSTANCE-hPrevInstance-LPSTR-ipCmdLine-int-nCmdShow" class="headerlink" title="int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)"></a>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)</h3><p>​        </p><p>​        一个函数！有些人奇怪了，什么玩意？C++程序没有int main(), 就像西方没有耶路撒冷一样！不是的！</p><p>​        在Windows桌面开发下，他就是我们的main函数。在Microsoft API Platform SDK下，我们查阅到：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int WINAPI WinMain(  HINSTANCE hInstance,      &#x2F;&#x2F; handle to current instance   HINSTANCE hPrevInstance,  &#x2F;&#x2F; handle to previous instance   LPSTR lpCmdLine,        &#x2F;&#x2F; command line  int nCmdShow        &#x2F;&#x2F;  show stat)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230504222032978.png" alt="image-20230504222032978"></p><h4 id="What-is-WINAPI"><a href="#What-is-WINAPI" class="headerlink" title="What is WINAPI"></a>What is WINAPI</h4><p>​        光标移动到上面： __stdcall 这是啥呢？标准调用！</p><p>​        被这个关键字修饰的函数，其参数都是从右向左通过堆栈传递的(__fastcall 的前面部分由ecx,edx传)， 函数调用在返回前要由被调用者清理堆栈。</p><p>​        啥？你不相信？反汇编我们产生的EXE文件就OK了：在MessageW处打一个断点，运行之找到</p><p><img src="image-20230504231052021.png" alt="image-20230504231052021"></p><p>​        大多数电脑采用的是大端法，也就是说可以理解为：参数在右边的，先被推送进函数里去</p><h4 id="批注？"><a href="#批注？" class="headerlink" title="批注？"></a>批注？</h4><p><img src="image-20230504231254737.png" alt="image-20230504231254737"></p><p>​        什么是批注呢请看我们函数和头文件下的：</p><p><img src="image-20230504231338650.png" alt="image-20230504231338650"></p><p>​        看看_ In _这个宏，他就是一个说明参数性质的宏！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++"> &#x2F;&#x2F; from sal.h_In_     : input parameter to a function, unmodified by called function      _Out_    : output parameter, written to by called function, pointed-to                 location not expected to be initialized prior to call      _Outptr_ : like _Out_ when returned variable is a pointer type                 (so param is pointer-to-pointer type). Called function                 provides&#x2F;allocated space.      _Outref_ : like _Outptr_, except param is reference-to-pointer type.      _Inout_  : inout parameter, read from and potentially modified by                 called function.      _Ret_    : for return values      _Field_  : class&#x2F;struct field invariants<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        In 表明他是一个输入参数，有点像const 一样，函数读取值但是不可以修改它！</p><p>​        InOut就是表示这是一个这样的值：传入又传出，值会被修改</p><p>​        Out表示这个值会被这个函数设置</p><p>​        OutPtr 表示返回这个值的指针</p><p>​        Microsoft对参数合理性做出了更多的解释：类似于main函数一样</p><pre class="line-numbers language-none"><code class="language-none">[in] hInstance类型： HINSTANCE应用程序的当前实例的句柄。[in] hPrevInstance类型： HINSTANCE应用程序的上一个实例的句柄。 此参数始终为 NULL。 如果需要检测另一个实例是否已存在，请使用 CreateMutex 函数创建唯一命名的互斥体。 即使互斥体已存在，CreateMutex 也会成功，但函数将返回ERROR_ALREADY_EXISTS。 这表示应用程序的另一个实例存在，因为它首先创建了互斥体。 但是，恶意用户可以在执行之前创建此互斥体，并阻止应用程序启动。 为防止这种情况，请创建一个随机命名的互斥体并存储名称，以便它只能由授权用户获取。 或者，可以使用文件进行此目的。 若要将应用程序限制为每个用户的一个实例，请在用户配置文件目录中创建锁定的文件。[in] lpCmdLine类型： LPSTR应用程序的命令行，不包括程序名称。 若要检索整个命令行，请使用 GetCommandLine 函数。[in] nShowCmd类型： int控制窗口的显示方式。 此参数可以是可在 ShowWindow 函数的 nCmdShow 参数中指定的任何值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示一个模式对话框，其中包含系统图标、一组按钮和一条简短的应用程序特定消息，例如状态或错误信息。 消息框返回一个整数值，该值指示用户单击的按钮。</p><h3 id="MessageBox函数"><a href="#MessageBox函数" class="headerlink" title="MessageBox函数"></a>MessageBox函数</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">MessageBox</span><span class="token punctuation">(</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> HWND    hWnd<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPCTSTR lpText<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPCTSTR lpCaption<span class="token punctuation">,</span>  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           UINT    uType<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] hWnd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型：<strong>HWND</strong></p><p>要创建的消息框的所有者窗口的句柄。 如果此参数为 <strong>NULL</strong>，则消息框没有所有者窗口。</p><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpText<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>LPCTSTR</strong></p><p>要显示的消息。 如果字符串包含多个行，则可以使用回车符和/或换行符分隔每行之间的行。</p><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpCaption<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>LPCTSTR</strong></p><p>对话框标题。 如果此参数为 <strong>NULL</strong>，则默认标题为 <strong>Error</strong>。</p><pre class="line-numbers language-none"><code class="language-none">[in] uType<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型： <strong>UINT</strong></p><p>对话框的内容和行为。 此参数可以是以下标志组中的标志的组合。</p><p>若要指示消息框中显示的按钮，请指定以下值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_ABORTRETRYIGNORE</strong>0x00000002L</td><td style="text-align:left">消息框包含三个推送按钮： <strong>中止</strong>、 <strong>重试</strong>和 <strong>忽略</strong>。</td></tr><tr><td style="text-align:left"><strong>MB_CANCELTRYCONTINUE</strong>0x00000006L</td><td style="text-align:left">消息框包含三个按下按钮： <strong>“取消</strong>”、“ <strong>重试</strong>”、“ <strong>继续</strong>”。 使用此消息框类型，而不是MB_ABORTRETRYIGNORE。</td></tr><tr><td style="text-align:left"><strong>MB_HELP</strong>0x00004000L</td><td style="text-align:left">向消息框添加 <strong>“帮助</strong> ”按钮。 当用户单击 <strong>“帮助</strong> ”按钮或按 F1 时，系统会向所有者发送 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/shell/wm-help">WM_HELP</a> 消息。</td></tr><tr><td style="text-align:left"><strong>MB_OK</strong>0x00000000L</td><td style="text-align:left">消息框包含一个按钮： <strong>确定</strong>。 这是默认值。</td></tr><tr><td style="text-align:left"><strong>MB_OKCANCEL</strong>0x00000001L</td><td style="text-align:left">消息框包含两个推送按钮： <strong>“确定</strong> ”和 <strong>“取消</strong>”。</td></tr><tr><td style="text-align:left"><strong>MB_RETRYCANCEL</strong>0x00000005L</td><td style="text-align:left">消息框包含两个按下按钮： <strong>重试</strong> 和 <strong>取消</strong>。</td></tr><tr><td style="text-align:left"><strong>MB_YESNO</strong>0x00000004L</td><td style="text-align:left">消息框包含两个按下按钮： <strong>是</strong> 和 <strong>否</strong>。</td></tr><tr><td style="text-align:left"><strong>MB_YESNOCANCEL</strong>0x00000003L</td><td style="text-align:left">消息框包含三个按钮： <strong>是</strong>、 <strong>否</strong>和 <strong>取消</strong>。</td></tr></tbody></table></div><p>若要在消息框中显示图标，请指定以下值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_ICONEXCLAMATION</strong>0x00000030L</td><td style="text-align:left">消息框中会显示一个感叹号图标。</td></tr><tr><td style="text-align:left"><strong>MB_ICONWARNING</strong>0x00000030L</td><td style="text-align:left">消息框中会显示一个感叹号图标。</td></tr><tr><td style="text-align:left"><strong>MB_ICONINFORMATION</strong>0x00000040L</td><td style="text-align:left">图标由圆圈中的小写字母 <em>i</em> 组成，显示在消息框中。</td></tr><tr><td style="text-align:left"><strong>MB_ICONASTERISK</strong>0x00000040L</td><td style="text-align:left">图标由圆圈中的小写字母 <em>i</em> 组成，显示在消息框中。</td></tr><tr><td style="text-align:left"><strong>MB_ICONQUESTION</strong>0x00000020L</td><td style="text-align:left">消息框中会显示一个问号图标。 不再建议使用问号消息图标，因为这种图标无法清楚地表示特定类型的消息，并且作为问题的消息表述可应用于任何消息类型。 此外，用户可能会将问号消息符号与帮助信息混淆。 因此，不要在消息框中使用问号消息符号。 系统继续支持它包含的内容，只为满足反向兼容性。</td></tr><tr><td style="text-align:left"><strong>MB_ICONSTOP</strong>0x00000010L</td><td style="text-align:left">消息框中会显示一个停止符号图标。</td></tr><tr><td style="text-align:left"><strong>MB_ICONERROR</strong>0x00000010L</td><td style="text-align:left">消息框中会显示一个停止符号图标。</td></tr><tr><td style="text-align:left"><strong>MB_ICONHAND</strong>0x00000010L</td><td style="text-align:left">消息框中会显示一个停止符号图标。</td></tr></tbody></table></div><p>若要指示默认按钮，请指定以下值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_DEFBUTTON1</strong>0x00000000L</td><td style="text-align:left">第一个按钮是默认按钮。除非指定<strong>了MB_DEFBUTTON2</strong>、MB_DEFBUTTON3或<strong>MB_DEFBUTTON4</strong>，<strong>否则</strong>MB_DEFBUTTON1<strong>是默认值</strong>。</td></tr><tr><td style="text-align:left"><strong>MB_DEFBUTTON2</strong>0x00000100L</td><td style="text-align:left">第二个按钮是默认按钮。</td></tr><tr><td style="text-align:left"><strong>MB_DEFBUTTON3</strong>0x00000200L</td><td style="text-align:left">第三个按钮是默认按钮。</td></tr><tr><td style="text-align:left"><strong>MB_DEFBUTTON4</strong>0x00000300L</td><td style="text-align:left">第四个按钮是默认按钮。</td></tr></tbody></table></div><p>若要指示对话框的形式，请指定以下值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_APPLMODAL</strong>0x00000000L</td><td style="text-align:left">在 <em>hWnd</em> 参数标识的窗口中继续工作之前，用户必须响应消息框。 但是，用户可以移动到其他线程的窗口，并在这些窗口中工作。根据应用程序中的窗口层次结构，用户可能能够移动到线程中的其他窗口。 消息框父级的所有子窗口都将自动禁用，但弹出窗口不是。如果未指定<strong>MB_SYSTEMMODAL</strong>或<strong>MB_TASKMODAL</strong>，<strong>则MB_APPLMODAL</strong>为默认值。</td></tr><tr><td style="text-align:left"><strong>MB_SYSTEMMODAL</strong>0x00001000L</td><td style="text-align:left">与MB_APPLMODAL相同，消息框具有 <strong>WS_EX_TOPMOST</strong> 样式。 使用系统模式消息框通知用户严重、潜在的破坏性错误，例如， (立即引起注意，) 内存不足。 此标志不会影响用户与 <em>与 hWnd</em> 关联的窗口以外的窗口交互的能力。</td></tr><tr><td style="text-align:left"><strong>MB_TASKMODAL</strong>0x00002000L</td><td style="text-align:left">与 <strong>MB_APPLMODAL</strong> 相同，如果 <em>hWnd</em> 参数为 <strong>NULL</strong>，则禁用属于当前线程的所有顶级窗口。 当调用应用程序或库没有可用的窗口句柄时，请使用此标志，但仍需要防止输入到调用线程中的其他窗口，而不会挂起其他线程。</td></tr></tbody></table></div><p>若要指定其他选项，请使用以下一个或多个值。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Value</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left"><strong>MB_DEFAULT_DESKTOP_ONLY</strong>0x00020000L</td><td style="text-align:left">与交互式窗口工作站的桌面相同。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/winstation/window-stations">窗口工作站</a>。如果当前输入桌面不是默认桌面，则在用户切换到默认桌面之前， <strong>MessageBox</strong> 不会返回。</td></tr><tr><td style="text-align:left"><strong>MB_RIGHT</strong>0x00080000L</td><td style="text-align:left">文本是右对齐的。</td></tr><tr><td style="text-align:left"><strong>MB_RTLREADING</strong>0x00100000L</td><td style="text-align:left">在希伯来语和阿拉伯语系统上使用从右到左阅读顺序显示消息和标题文本。</td></tr><tr><td style="text-align:left"><strong>MB_SETFOREGROUND</strong>0x00010000L</td><td style="text-align:left">消息框将成为前台窗口。 在内部，系统调用消息框的 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> 函数。</td></tr><tr><td style="text-align:left"><strong>MB_TOPMOST</strong>0x00040000L</td><td style="text-align:left">消息框是使用 <strong>WS_EX_TOPMOST</strong> 窗口样式创建的。</td></tr><tr><td style="text-align:left"><strong>MB_SERVICE_NOTIFICATION</strong>0x00200000L</td><td style="text-align:left">调用方是通知用户某个事件的服务。 该函数在当前活动桌面上显示一个消息框，即使没有用户登录到计算机也是如此。<strong>终端服务：</strong> 如果调用线程具有模拟令牌，该函数会将消息框定向到模拟令牌中指定的会话。如果设置了此标志， <em>则 hWnd</em> 参数必须为 <strong>NULL</strong>。 这样，消息框可以出现在桌面上，而不是与 <em>hWnd</em> 对应的桌面。有关使用此标志的安全注意事项的信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/windows/desktop/Services/interactive-services">Interactive Services</a>。 具体而言，请注意，此标志可以在锁定的桌面上生成交互式内容，因此应仅用于一组非常有限的方案，例如资源耗尽。</td></tr></tbody></table></div><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>类型： <strong>int</strong></p><p>如果消息框有 <strong>“取消</strong> ”按钮，则函数返回 <strong>IDCANCEL</strong> 值（如果按下 ESC 键或选中 <strong>“取消</strong> ”按钮）。 如果消息框没有 <strong>“取消</strong> ”按钮，则按 ESC 将不起作用 -除非存在MB_OK按钮。 如果显示MB_OK按钮，并且用户按 ESC，则返回值为 <strong>IDOK</strong>。</p><p>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p><p>如果函数成功，则返回值为以下菜单项值之一。</p><div class="table-container"><table><thead><tr><th style="text-align:left">返回代码/值</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>IDABORT</strong>3</td><td style="text-align:left">已选择 <strong>“中止</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDCANCEL</strong>2</td><td style="text-align:left">已选择“ <strong>取消</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDCONTINUE</strong>11</td><td style="text-align:left">已选择 <strong>“继续</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDIGNORE</strong>5</td><td style="text-align:left">已选择 <strong>“忽略</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDNO</strong>7</td><td style="text-align:left">已选择 <strong>“无</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDOK</strong>1</td><td style="text-align:left">已选择 <strong>“确定</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDRETRY</strong>4</td><td style="text-align:left">已选择 <strong>“重试</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDTRYAGAIN</strong>10</td><td style="text-align:left">已选择 <strong>“重试</strong> ”按钮。</td></tr><tr><td style="text-align:left"><strong>IDYES</strong>6</td><td style="text-align:left">已选择 <strong>“是</strong> ”按钮。</td></tr></tbody></table></div><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>通过将 <em>uType</em> 参数设置为相应的标志值，可以在消息框中使用以下系统图标。</p><div class="table-container"><table><thead><tr><th style="text-align:left">图标</th><th style="text-align:left">标志值</th></tr></thead><tbody><tr><td style="text-align:left"><img src="mb_iconhand.png" alt="MB_ICONHAND、MB_ICONSTOP和MB_ICONERROR图标"></td><td style="text-align:left"><strong>MB_ICONHAND</strong>、 <strong>MB_ICONSTOP</strong>或 <strong>MB_ICONERROR</strong></td></tr><tr><td style="text-align:left"><img src="mb_iconquestion.png" alt="MB_ICONQUESTION图标"></td><td style="text-align:left"><strong>MB_ICONQUESTION</strong></td></tr><tr><td style="text-align:left"><img src="mb_iconexclamation.png" alt="MB_ICONEXCLAMATION和MB_ICONWARNING图标"></td><td style="text-align:left"><strong>MB_ICONEXCLAMATION</strong> 或 <strong>MB_ICONWARNING</strong></td></tr><tr><td style="text-align:left"><img src="mb_iconasterisk.png" alt="MB_ICONASTERISK和MB_ICONINFORMATION图标"></td><td style="text-align:left"><strong>MB_ICONASTERISK</strong> 或 <strong>MB_ICONINFORMATION</strong></td></tr></tbody></table></div><p>在 MessageBox 显示字符串开头的 Unicode 格式字符 U+200F 表示 (RL) M 添加两个从右到左标记，以便使 MessageBox 的读取顺序呈现为从右到左 (RTL) 。</p><p>使用系统模式消息框指示系统内存不足时， <em>lpText</em> 和 <em>lpCaption</em> 参数指向的字符串不应从资源文件中获取，因为尝试加载资源可能会失败。</p><p>如果在对话框存在时创建消息框，请使用对话框的句柄作为 <em>hWnd</em> 参数。 <em>hWnd</em> 参数不应标识子窗口，如对话框中的控件。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在以下示例中，应用程序显示一个消息框，该消息框在出现错误条件后提示用户执行操作。 消息框显示描述错误条件以及如何解决错误条件的消息。 <strong>MB_CANCELTRYCONTINUE</strong>样式指示 <strong>MessageBox</strong> 提供三个按钮，用户可以选择如何继续操作。 <strong>MB_DEFBUTTON2</strong>样式将默认焦点设置为消息框的第二个按钮，在本例中为<strong>“重试”</strong>按钮。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;Windows.h></span></span><span class="token keyword">void</span> WINAPI <span class="token function">doSomethingHalt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> usrChoice <span class="token operator">=</span> <span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"Are you sure to move forward? That is supposed to be invalid... I convinced!"</span><span class="token punctuation">)</span>\<span class="token punctuation">,</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"Warning"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>MB_ICONWARNING<span class="token operator">|</span>MB_CANCELTRYCONTINUE<span class="token operator">|</span>MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>usrChoice<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> IDCANCEL<span class="token operator">:</span><span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"good"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"afterWard"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MB_OKCANCEL <span class="token operator">|</span> MB_ICONINFORMATION <span class="token operator">|</span> MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> IDRETRY<span class="token operator">:</span><span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"I mean: that is not good!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"afterWard"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MB_OKCANCEL <span class="token operator">|</span> MB_ICONINFORMATION <span class="token operator">|</span> MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> IDCONTINUE<span class="token operator">:</span><span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"I mean: that is not good!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"afterWard"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MB_OKCANCEL <span class="token operator">|</span> MB_ICONINFORMATION <span class="token operator">|</span> MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> WINAPI <span class="token function">WinMain</span><span class="token punctuation">(</span>HINSTANCE hInstance<span class="token punctuation">,</span> HINSTANCE hPrevInstance<span class="token punctuation">,</span> LPSTR ipCmdLine<span class="token punctuation">,</span> <span class="token keyword">int</span> nCmdShow<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//MessageBox(NULL, TEXT("Hello, World"), TEXT("Captions"), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);</span><span class="token function">doSomethingHalt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// design by CharlieChen</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串主题"><a href="#字符串主题" class="headerlink" title="字符串主题"></a>字符串主题</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>​        下面我们开始入门简单的字符串主题：啥意思呢？回顾我们C语言的API。我们是如下声明一个char类型或基于char类型的数组</p><pre class="line-numbers language-none"><code class="language-none">char typicalChar &#x3D; &#39;A&#39;;char* TCPtr &#x3D; &quot;Hello!My friend~&quot;;char arrayCPtr &#x3D; &quot;hello,my frined~&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        我们马上可以看到，char是一份字节大小，那么下面的arrayCPtr就指明需要17个字节来存储。</p><h3 id="wchar-t类型"><a href="#wchar-t类型" class="headerlink" title="wchar_t类型"></a>wchar_t类型</h3><p>​        可是，仅仅使用char可能存储不下如今丰富的字符。所以，转向扩展char是必要的，wchar,也就是widechar应运而生。在Windows 2000之后所有的Windows系统都在底层上支持Unicode字符集。</p><p>​        我们这样声明与初始化一个wchar变量：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t wideChar &#x3D; L&#39;A&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230505135217906.png" alt="image-20230505135217906"></p><p>​        类似的：</p><pre class="line-numbers language-none"><code class="language-none">wchar* ptrW &#x3D; &quot;Hello&quot;;wchar ptr[7] &#x3D; &quot;Hello!&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        但是注意：如果我们还是选择</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%s&quot;, ptrW);printf(&quot;%s&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        则只会打印首元素，这是因为字符串类型不匹配，人话讲就是：wchar字符串不用%s打印，而是ls</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%ls&quot;, ptrW);printf(&quot;%ls&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        或者是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t* WPTR &#x3D; &#123;&#39;a&#39;,&#39;\0&#39;&#125;; wprintf(&quot;%s&quot;,WPTR);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        或是直接调用setlocal函数做默认的设置！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;locale.h&gt;int main()&#123;&#x2F;&#x2F;使用系统默认的设置调用setlocale(LC_ALL, &quot;&quot;);setlocale(LC_ALL, &quot;&quot;);const wchar_t * chWord &#x3D; L&quot;疯狂程序人—码农哈哥&quot;;printf(&quot;%s&quot;,chWord);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Windows下的字符和宽字符"><a href="#Windows下的字符和宽字符" class="headerlink" title="Windows下的字符和宽字符"></a>Windows下的字符和宽字符</h3><p>​        Windows整理自己的活：他们定义了他们自己的字符类型：在winnt.h文件下可以找到：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;&#x2F;&#x2F; Basics&#x2F;&#x2F;#ifndef VOID#define VOID voidtypedef char CHAR;typedef short SHORT;typedef long LONG;#if !defined(MIDL_PASS)typedef int INT;#endif#endif&#x2F;&#x2F;&#x2F;&#x2F; UNICODE (Wide Character) types&#x2F;&#x2F;#ifndef _MACtypedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#else&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a chartypedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#endiftypedef WCHAR *PWCHAR, *LPWCH, *PWCH;typedef CONST WCHAR *LPCWCH, *PCWCH;typedef _Null_terminated_ WCHAR *NWPSTR, *LPWSTR, *PWSTR;typedef _Null_terminated_ PWSTR *PZPWSTR;typedef _Null_terminated_ CONST PWSTR *PCZPWSTR;typedef _Null_terminated_ WCHAR UNALIGNED *LPUWSTR, *PUWSTR;typedef _Null_terminated_ CONST WCHAR *LPCWSTR, *PCWSTR;typedef _Null_terminated_ PCWSTR *PZPCWSTR;typedef _Null_terminated_ CONST PCWSTR *PCZPCWSTR;typedef _Null_terminated_ CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;typedef _NullNull_terminated_ WCHAR *PZZWSTR;typedef _NullNull_terminated_ CONST WCHAR *PCZZWSTR;typedef _NullNull_terminated_ WCHAR UNALIGNED *PUZZWSTR;typedef _NullNull_terminated_ CONST WCHAR UNALIGNED *PCUZZWSTR;typedef  WCHAR *PNZWCH;typedef  CONST WCHAR *PCNZWCH;typedef  WCHAR UNALIGNED *PUNZWCH;typedef  CONST WCHAR UNALIGNED *PCUNZWCH;#if _WIN32_WINNT &gt;&#x3D; 0x0600 || (defined(__cplusplus) &amp;&amp; defined(WINDOWS_ENABLE_CPLUSPLUS))typedef CONST WCHAR *LPCWCHAR, *PCWCHAR;typedef CONST WCHAR UNALIGNED *LPCUWCHAR, *PCUWCHAR;&#x2F;&#x2F;&#x2F;&#x2F;  UCS (Universal Character Set) types&#x2F;&#x2F;typedef unsigned long UCSCHAR;&#x2F;&#x2F;&#x2F;&#x2F;  Even pre-Unicode agreement, UCS values are always in the&#x2F;&#x2F;  range U+00000000 to U+7FFFFFFF, so we&#39;ll pick an obvious&#x2F;&#x2F;  value.#define UCSCHAR_INVALID_CHARACTER (0xffffffff)#define MIN_UCSCHAR (0)&#x2F;&#x2F;&#x2F;&#x2F;  We&#39;ll assume here that the ISO-10646 &#x2F; Unicode agreement&#x2F;&#x2F;  not to assign code points after U+0010FFFF holds so that&#x2F;&#x2F;  we do not have to have separate &quot;UCSCHAR&quot; and &quot;UNICODECHAR&quot;&#x2F;&#x2F;  types.&#x2F;&#x2F;#define MAX_UCSCHAR (0x0010FFFF)typedef UCSCHAR *PUCSCHAR;typedef const UCSCHAR *PCUCSCHAR;typedef UCSCHAR *PUCSSTR;typedef UCSCHAR UNALIGNED *PUUCSSTR;typedef const UCSCHAR *PCUCSSTR;typedef const UCSCHAR UNALIGNED *PCUUCSSTR;typedef UCSCHAR UNALIGNED *PUUCSCHAR;typedef const UCSCHAR UNALIGNED *PCUUCSCHAR;#endif &#x2F;&#x2F; _WIN32_WINNT &gt;&#x3D; 0x0600&#x2F;&#x2F;&#x2F;&#x2F; ANSI (Multi-byte Character) types&#x2F;&#x2F;typedef CHAR *PCHAR, *LPCH, *PCH;typedef CONST CHAR *LPCCH, *PCCH;typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;typedef _Null_terminated_ PSTR *PZPSTR;typedef _Null_terminated_ CONST PSTR *PCZPSTR;typedef _Null_terminated_ CONST CHAR *LPCSTR, *PCSTR;typedef _Null_terminated_ PCSTR *PZPCSTR;typedef _Null_terminated_ CONST PCSTR *PCZPCSTR;typedef _NullNull_terminated_ CHAR *PZZSTR;typedef _NullNull_terminated_ CONST CHAR *PCZZSTR;typedef  CHAR *PNZCH;typedef  CONST CHAR *PCNZCH;&#x2F;&#x2F;&#x2F;&#x2F; Neutral ANSI&#x2F;UNICODE types and macros&#x2F;&#x2F;#ifdef  UNICODE                     &#x2F;&#x2F; r_winnt#ifndef _TCHAR_DEFINEDtypedef WCHAR TCHAR, *PTCHAR;typedef WCHAR TBYTE , *PTBYTE ;#define _TCHAR_DEFINED#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;typedef LPWCH LPTCH, PTCH;typedef LPCWCH LPCTCH, PCTCH;typedef LPWSTR PTSTR, LPTSTR;typedef LPCWSTR PCTSTR, LPCTSTR;typedef LPUWSTR PUTSTR, LPUTSTR;typedef LPCUWSTR PCUTSTR, LPCUTSTR;typedef LPWSTR LP;typedef PZZWSTR PZZTSTR;typedef PCZZWSTR PCZZTSTR;typedef PUZZWSTR PUZZTSTR;typedef PCUZZWSTR PCUZZTSTR;typedef PZPWSTR PZPTSTR;typedef PNZWCH PNZTCH;typedef PCNZWCH PCNZTCH;typedef PUNZWCH PUNZTCH;typedef PCUNZWCH PCUNZTCH;#define __TEXT(quote) L##quote      &#x2F;&#x2F; r_winnt#else   &#x2F;* UNICODE *&#x2F;               &#x2F;&#x2F; r_winnt#ifndef _TCHAR_DEFINEDtypedef char TCHAR, *PTCHAR;typedef unsigned char TBYTE , *PTBYTE ;#define _TCHAR_DEFINED#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;typedef LPCH LPTCH, PTCH;typedef LPCCH LPCTCH, PCTCH;typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;typedef PZZSTR PZZTSTR, PUZZTSTR;typedef PCZZSTR PCZZTSTR, PCUZZTSTR;typedef PZPSTR PZPTSTR;typedef PNZCH PNZTCH, PUNZTCH;typedef PCNZCH PCNZTCH, PCUNZTCH;#define __TEXT(quote) quote         &#x2F;&#x2F; r_winnt#endif &#x2F;* UNICODE *&#x2F;                &#x2F;&#x2F; r_winnt#define TEXT(quote) __TEXT(quote)   &#x2F;&#x2F; r_winnttypedef SHORT *PSHORT;  typedef LONG *PLONG;    #define ALL_PROCESSOR_GROUPS        0xffff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在这里我们找到了两个东西：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef _MACtypedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#else&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a chartypedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        首先是wchar_t被重写位WCHAR。对于一些甚至没有wchar的编译器直接对unsigned short起别名。</p><p>​        其次是TEXT宏，这个宏便捷的帮助我们直接将普通的字符串升级为宽字符串，其做法不是强制转换，而是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define __TEXT(quote) L##quote#define TEXT(quote) __TEXT(quote)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        ##是令牌粘贴，就是直接把L和字符串连接在一起返回，比若说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TEXT(&quot;Hello&quot;)--- Compiler----&gt; L&quot;Hello&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们看到，上面的定义给出了：PSTR和LPSTR的小东西。他们都是CHAR（本质上就是Char），而P C STR 和 LP C STR则是Const类型的字符串。也就是常字符串！</p><p>​        那对于TCHAR这样Windows自己给出了字符串，我们应该怎么处理呢了，答案是万能的WIndows又帮我们干好了。使用P T STR和LP T STR就可以胜任这些工作！</p><h2 id="常见的字符串处理工作"><a href="#常见的字符串处理工作" class="headerlink" title="常见的字符串处理工作"></a>常见的字符串处理工作</h2><h3 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h3><p>​        下面我们要说的是如何获取字符串的长度，请看strlen和wstrlen.</p><pre class="line-numbers language-none"><code class="language-none">size_t strlen(const char* str);size_t wstrlen(const wchar_t* str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        size_t，如其所说的那样，衡量的是大小的类型。其定义查看建议自行搜索，这里做阐述。因为不是重点我想说的！</p><p>​        来试试看：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;#include&lt;stdio.h&gt;#include&lt;tchar.h&gt;int main() &#123;CHAR str[] &#x3D; &quot;C语言\0&quot;; &#x2F;&#x2F; 这个函数返回占比字节的大小WCHAR wstr[] &#x3D; L&quot;C语言&quot;; &#x2F;&#x2F; 这个函数返回的是宽字符的个数_tprintf(TEXT(&quot;strlen(str) &#x3D; %d\n wcslen(wstr) &#x3D; %d&quot;), strlen(str), wcslen(wstr));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <img src="image-20230505235033338.png" alt="image-20230505235033338"></p><p>​        注意到_tprintf是一个随系统环境而改变的宏函数，在支持UNICODE字符集的情况下，系统将会自动的转化之成为wprintf！</p><p>​        类似的：我们还有一个叫做tcslen这个函数，他是这样被定义的：</p><p><img src="image-20230505235214903.png" alt="image-20230505235214903"></p><p>​        好鸡肋啊，那如果我们改一下不支持Unicode子集呢？仍然是右键项目——属性，转到这个地方：</p><p><img src="image-20230505235414875.png" alt="image-20230505235414875"></p><p>​        改成</p><p><img src="image-20230505235429080.png" alt="image-20230505235429080"></p><p>​        发现变灰了！转向再看发现跳转到了：&gt;</p><p><img src="image-20230505235350688.png" alt="image-20230505235350688"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Windows 32API </tag>
            
            <tag> 摸鱼ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS-正式开发-3</title>
      <link href="/2023/05/02/ROS-%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%8F%91-3/"/>
      <url>/2023/05/02/ROS-%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%8F%91-3/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS通信机制"><a href="#ROS通信机制" class="headerlink" title="ROS通信机制"></a>ROS通信机制</h1><p>​        机器人是一种高度复杂的系统性实现。在机器人上可能集成了各种传感器（雷达）等，为了解耦合，ROS的每一个功能点都是一个单独的进程，并且他们是可以独立运行的。ROS是进程的分布式框架。</p><p>ROS 实现通信机制的三种实现策略</p><p>1）话题发布 （发布订阅模式）</p><p>2）服务通信 （请求响应模式）</p><p>3）参数服务器 （参数共享模式）</p><h2 id="话题通信"><a href="#话题通信" class="headerlink" title="话题通信"></a>话题通信</h2><p>​        话题通信时ROS使用频率最高的一种通信模式，也是基于发布订阅模式的，也即：一个节点发布消息，另一个节点订阅信息：</p><p>​        如：机器人执行导航功能的时候使用的传感器时激光雷达，机器人会采集相关的信息并且完成计算，随后控制运动生成信息</p><p>​        这样通信的作用时用在不断更新的，少逻辑处理的数据传输场景。下面尝试实现一下！</p><p>​        在这个模型里头，有三条个主角：ROS MASTER（管理者），Talker（话题发出者），Listener（订阅者）</p><p><img src="image-20230426205058563.png" alt="image-20230426205058563"></p><p>​        master 根据话题建立发布者和订阅者之间的联系。</p><p>​        使用的协议时RPC和TCP， 并且Listener和Talker可以存在多个。talker和Listener建立连接以后，master就可以关闭了。当然这些流程已经被封装，我们没有必要去了解。</p><h2 id="实践1-ROS-in-C"><a href="#实践1-ROS-in-C" class="headerlink" title="实践1 - ROS in C++"></a>实践1 - ROS in C++</h2><p>​            例子：我们要以每秒10次的频率实现信息的发送！</p><p><img src="image-20230502192159071.png" alt="image-20230502192159071"></p><p>​        我们按照先前早就讲过的流程创建一遍工程，在已经完事了的CPP文件下书写如下的代码</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;ros&#x2F;ros.h&quot;#include&quot;std_msgs&#x2F;String.h&quot;&#x2F;*    publisher release:        1. incldue Files: ROS RO    2. init ROS node    3. create Handle of the node    4. create publisher    5,create publisher logic and the data*&#x2F;int main(int argc, char* argv[])&#123;    &#x2F;&#x2F; init a node    ros::init(argc,argv,&quot;such_a_node&quot;); &#x2F;&#x2F; 别带空格！这是涉及到命令行的    &#x2F;&#x2F; create a handle    ros::NodeHandle nodeHandle;    &#x2F;&#x2F; create Publisher    ros::Publisher pub &#x3D; nodeHandle.advertise&lt;std_msgs::String&gt;(&quot;this_is_a_topic&quot;,10);&#x2F;&#x2F; 别带空格！这是涉及到命令行的        std_msgs::String msg;    &#x2F;&#x2F; create the msg    while(ros::ok) &#x2F;&#x2F; this node is still available    &#123;           msg.data &#x3D; &quot;hello this is a msg&quot;; &#x2F;&#x2F; 设置字符串        pub.publish(msg); &#x2F;&#x2F; 向外广播    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    </p><p><img src="image-20230502193924014.png" alt="image-20230502193924014"></p><p>​        看到这个节点句柄的 advertise API了嘛，这就是一个广播函数第一个很好理解，就是话题名称，第二个是什么呢：我们的网络通信可能会有阻塞，于是ROS会将这些被阻塞的数据存储到队列里，等到网络稍微流畅的时候再发送出去！</p><p>​        当我们编完Ctrl + Shift + B结束编译之后，在一个命令行窗口处输入</p><pre class="line-numbers language-none"><code class="language-none">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        启动大环境</p><pre class="line-numbers language-none"><code class="language-none">rosrun publish demo_cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230502200757049.png" alt="image-20230502200757049"></p><p><img src="image-20230502200830424.png" alt="image-20230502200830424"></p><p>​        啥也没有！那就对了！</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 再开一个rostopic echo + &#39;topic_name&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        比如说我的就是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">rostopic echo this_is_a_topic<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        消息就这样打印出来了！</p><p>​        下面设置一下频率！和计数器的使用</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;ros&#x2F;ros.h&quot;#include&quot;std_msgs&#x2F;String.h&quot;#include&lt;sstream&gt;&#x2F;*    publisher release:        1. incldue Files: ROS RO    2. init ROS node    3. create Handle of the node    4. create publisher    5,create publisher logic and the data*&#x2F;int main(int argc, char* argv[])&#123;    &#x2F;&#x2F; init a node    ros::init(argc,argv,&quot;such_a_node&quot;);    &#x2F;&#x2F; create a handle    ros::NodeHandle nodeHandle;    &#x2F;&#x2F; create Publisher    ros::Publisher pub &#x3D; nodeHandle.advertise&lt;std_msgs::String&gt;(&quot;this_is_a_topic&quot;,10);        std_msgs::String msg;    &#x2F;&#x2F; create the msg    &#x2F;&#x2F; create a ratio obj    ros::Rate rate(10);    int count &#x3D; 1;    while(ros::ok) &#x2F;&#x2F; this node is still available    &#123;           &#x2F;&#x2F;msg.data &#x3D; &quot;hello this is a msg&quot;;        std::stringstream ss;        ss &lt;&lt; &quot;hello from -------&gt;&quot;&lt;&lt;count;        msg.data &#x3D; ss.str();        pub.publish(msg);        &#x2F;&#x2F; add log&#x2F;&#x2F; transform into C Style String        ROS_INFO(&quot;broadcast the msg : %s&quot;,ss.str().c_str());        rate.sleep();        count++;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个字符串的拼接使用扩展的ROS里的函数</p><p><img src="image-20230502203144864.png" alt="image-20230502203144864"></p><h2 id="订阅方的实现"><a href="#订阅方的实现" class="headerlink" title="订阅方的实现"></a>订阅方的实现</h2><p>​        我们这样实现一个如此的Demo!</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;ros&#x2F;ros.h&quot;#include&quot;std_msgs&#x2F;String.h&quot;#include&lt;sstream&gt;void doMsg(const std_msgs::String::ConstPtr &amp;msg)&#123;    &#x2F;&#x2F; by this const ptr to subscribe the msg    ROS_INFO(&quot;Have received the %s&quot;,msg-&gt;data.c_str());&#125;int main(int argc, char *argv[])&#123;    &#x2F;* same as before... *&#x2F;    ros::init(argc,argv,&quot;sub&quot;);    ros::NodeHandle nodeHandle;    &#x2F;&#x2F; the last var is the callBackFuncPointer    ros::Subscriber sub &#x3D; nodeHandle.subscribe(&quot;this_is_a_topic&quot;,10,doMsg);    &#x2F;&#x2F; nake sub receive the msg consistently    ros::spin();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        为了处理得到的信息，就是在这里的回调函数实现对信息的处理的！</p><p>​        当然，带上Cmakelists 的配置，不然系统不认识！</p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>​        ros 的python就简单很多，逻辑类似于C++，不做更多的解释：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#! /usr/bin/env python</span><span class="token keyword">import</span> rospy<span class="token keyword">from</span> std_msgs<span class="token punctuation">.</span>msg <span class="token keyword">import</span> String <span class="token triple-quoted-string string">"""message type"""</span><span class="token triple-quoted-string string">"""    load package    init ros node    create publisher    write the logic and broadcast"""</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    rospy<span class="token punctuation">.</span>init_node<span class="token punctuation">(</span><span class="token string">"pub"</span><span class="token punctuation">)</span>    pub <span class="token operator">=</span> rospy<span class="token punctuation">.</span>Publisher<span class="token punctuation">(</span><span class="token string">"topic"</span><span class="token punctuation">,</span>String<span class="token punctuation">,</span>queue_size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>    mag <span class="token operator">=</span> String<span class="token punctuation">(</span><span class="token punctuation">)</span>    rate <span class="token operator">=</span> rospy<span class="token punctuation">.</span>Rate<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    count <span class="token operator">=</span> <span class="token number">0</span>        rospy<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">//</span> 让之可以在后被启动的时候让sub完全接收到所有数据    <span class="token keyword">while</span> <span class="token keyword">not</span> rospy<span class="token punctuation">.</span>is_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                count <span class="token operator">+=</span> <span class="token number">1</span>        mag<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>        pub<span class="token punctuation">.</span>publish<span class="token punctuation">(</span>mag<span class="token punctuation">)</span>        rate<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">#! &#x2F;usr&#x2F;bin&#x2F;env python&quot;&quot;&quot;sub basic steps    1. import rospy std_msgs    2. init node    3. create a subscriber    4. using call back functions to deal with data    5. make spin() in python&quot;&quot;&quot;import rospyfrom std_msgs.msg import Stringdef doMsg(msg):    rospy.loginfo(&quot;The subscried data is:%s&quot;,msg.data)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    rospy.init_node(&quot;subscribe&quot;)    sub &#x3D; rospy.Subscriber(&quot;topic&quot;,String,doMsg,queue_size&#x3D;10)     &quot;&quot;&quot;need the name the same as publisher&quot;&quot;&quot;    rospy.spin()    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv in Visual Studio C(4)</title>
      <link href="/2023/04/26/Opencv-in-Visual-Studio-C-4/"/>
      <url>/2023/04/26/Opencv-in-Visual-Studio-C-4/</url>
      
        <content type="html"><![CDATA[<h1 id="Opencv-with-Visual-Studio4"><a href="#Opencv-with-Visual-Studio4" class="headerlink" title="Opencv with Visual Studio4"></a>Opencv with Visual Studio4</h1><p><img src="image-20230426214208705.png" alt="image-20230426214208705"></p><p>​        这是一个简单的图像，我们尝试来用之检测形状！</p><h2 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h2><p>​        现在我们想要检测形状的轮廓，是需要对图片做出若干预处理的！我们必须保证我们的图片经过开闭运算：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Mat&amp; preWork(Mat&amp; pic)&#123;Mat grey, blur, canny, dil, erode;cvtColor(pic, grey, COLOR_BGR2GRAY);GaussianBlur(grey, blur, Size(3, 3), 3, 0);Canny(blur, canny, 25, 75);Mat kernel &#x3D; getStructuringElement(MORPH_RECT, Size(3, 3));dilate(canny, dil, kernel);imshow(&quot;grey&quot;, grey);imshow(&quot;blur&quot;, blur);imshow(&quot;canny&quot;, canny);imshow(&quot;dil&quot;, dil);&#x2F;&#x2F;imshow(&quot;erode&quot;, erode);waitKey(0);Mat* work &#x3D; new Mat(dil);return *work;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们返回的就是经过预处理的图片了！下面开始重点讲轮廓！</p><p>​        我们的轮廓是用点来描述的，轮廓有若干层数，这就需要我们使用 vector<vector< int >&gt;</p><p>​        还有层级，这里我们使用 vector&lt; Vec4i &gt;来定义类型！它表明当前的每一个类型有四个整数构成，就不需要我们自己手动指定原生的C++类型了</p><p>​        这里是找到轮廓的函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;** @brief Finds contours in a binary image.The function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contoursare a useful tool for shape analysis and object detection and recognition. See squares.cpp in theOpenCV sample directory.@note Since opencv 3.2 source image is not modified by this function.@param image Source, an 8-bit single-channel image. Non-zero pixels are treated as 1&#39;s. Zeropixels remain 0&#39;s, so the image is treated as binary . You can use #compare, #inRange, #threshold ,#adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one.If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).@param contours Detected contours. Each contour is stored as a vector of points (e.g.std::vector&lt;std::vector&lt;cv::Point&gt; &gt;).@param hierarchy Optional output vector (e.g. std::vector&lt;cv::Vec4i&gt;), containing information about the image topology. It hasas many elements as the number of contours. For each i-th contour contours[i], the elementshierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indicesin contours of the next and previous contours at the same hierarchical level, the first childcontour and the parent contour, respectively. If for the contour i there are no next, previous,parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.@param mode Contour retrieval mode, see #RetrievalModes@param method Contour approximation method, see #ContourApproximationModes@param offset Optional offset by which every contour point is shifted. This is useful if thecontours are extracted from the image ROI and then they should be analyzed in the whole imagecontext. *&#x2F;CV_EXPORTS_W void findContours( InputArray image, OutputArrayOfArrays contours,                              OutputArray hierarchy, int mode,                              int method, Point offset &#x3D; Point());&#x2F;** @overload *&#x2F;CV_EXPORTS void findContours( InputArray image, OutputArrayOfArrays contours,                              int mode, int method, Point offset &#x3D; Point());&#x2F;** @example samples&#x2F;cpp&#x2F;squares.cppA program using pyramid scaling, Canny, contours and contour simplification to findsquares in a list of images (pic1-6.png). Returns sequence of squares detected on the image.*&#x2F;&#x2F;** @example samples&#x2F;tapi&#x2F;squares.cppA program using pyramid scaling, Canny, contours and contour simplification to findsquares in the input image.*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这里是一些参数的文档</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">enum RetrievalModes &#123;    &#x2F;** retrieves only the extreme outer contours. It sets &#96;hierarchy[i][2]&#x3D;hierarchy[i][3]&#x3D;-1&#96; for    all the contours. *&#x2F;    RETR_EXTERNAL  &#x3D; 0,    &#x2F;** retrieves all of the contours without establishing any hierarchical relationships. *&#x2F;    RETR_LIST      &#x3D; 1,    &#x2F;** retrieves all of the contours and organizes them into a two-level hierarchy. At the top    level, there are external boundaries of the components. At the second level, there are    boundaries of the holes. If there is another contour inside a hole of a connected component, it    is still put at the top level. *&#x2F;    RETR_CCOMP     &#x3D; 2,    &#x2F;** retrieves all of the contours and reconstructs a full hierarchy of nested contours.*&#x2F;    RETR_TREE      &#x3D; 3,    RETR_FLOODFILL &#x3D; 4 &#x2F;&#x2F;!&lt;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">enum ContourApproximationModes &#123;    &#x2F;** stores absolutely all the contour points. That is, any 2 subsequent points (x1,y1) and    (x2,y2) of the contour will be either horizontal, vertical or diagonal neighbors, that is,    max(abs(x1-x2),abs(y2-y1))&#x3D;&#x3D;1. *&#x2F;    CHAIN_APPROX_NONE      &#x3D; 1,    &#x2F;** compresses horizontal, vertical, and diagonal segments and leaves only their end points.    For example, an up-right rectangular contour is encoded with 4 points. *&#x2F;    CHAIN_APPROX_SIMPLE    &#x3D; 2,    &#x2F;** applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 *&#x2F;    CHAIN_APPROX_TC89_L1   &#x3D; 3,    &#x2F;** applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 *&#x2F;    CHAIN_APPROX_TC89_KCOS &#x3D; 4&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面是一些具体的参数说明！</p><p>​        我们的findCountours 取到轮廓之后呢，就向我们传入空的轮廓和层级输入数据。随后，我们在 原图像（很重要，不要画在二值化后的图里去了！！！）绘制轮廓，这样就好了！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)&#123;vector&lt;vector&lt;Point&gt;&gt; countours;vector&lt;Vec4i&gt; hierarchy;findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);Mat* workMat &#x3D; new Mat(org);drawContours(*workMat, countours, -1, Scalar(255, 0, 0), 3);return *workMat;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230426221756602.png" alt="image-20230426221756602"></p><p>​        但是一些原因我们的图片可能是有多个绘制的，他们是由图片的噪点 造成的，我们现在使用面积筛选法筛选！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)&#123;vector&lt;vector&lt;Point&gt;&gt; countours;vector&lt;Vec4i&gt; hierarchy;findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);Mat* workMat &#x3D; new Mat(org);for (int i &#x3D; 0; i &lt; countours.size(); i++) &#123;auto area &#x3D; contourArea(countours[i]);cout &lt;&lt; area &lt;&lt; endl;if (area &gt; 1000) &#123;drawContours(*workMat, countours, i, Scalar(255, 0, 0), 3);&#125;&#x2F;&#x2F; 第I个轮廓满足！&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面呢，我们使用矩形将找到的形状括起来！这就需要我们：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;** @brief Calculates a contour perimeter or a curve length.The function computes a curve length or a closed contour perimeter.@param curve Input vector of 2D points, stored in std::vector or Mat.@param closed Flag indicating whether the curve is closed or not. *&#x2F;CV_EXPORTS_W double arcLength( InputArray curve, bool closed );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">double peri &#x3D; arcLength(countours[i], true);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        以及我们之后可能需要通过多少个角点来判定他们是什么，就需要我们：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;** @brief Approximates a polygonal curve(s) with the specified precision.The function cv::approxPolyDP approximates a curve or a polygon with another curve&#x2F;polygon with lessvertices so that the distance between them is less or equal to the specified precision. It uses theDouglas-Peucker algorithm &lt;http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ramer-Douglas-Peucker_algorithm&gt;@param curve Input vector of a 2D point stored in std::vector or Mat@param approxCurve Result of the approximation. The type should match the type of the input curve.@param epsilon Parameter specifying the approximation accuracy. This is the maximum distancebetween the original curve and its approximation.@param closed If true, the approximated curve is closed (its first and last vertices areconnected). Otherwise, it is not closed. *&#x2F;CV_EXPORTS_W void approxPolyDP( InputArray curve,                                OutputArray approxCurve,                                double epsilon, bool closed );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        为此，我们需要一个跟轮廓一个数据结构的大小来接受结果，随后用之来绘制轮廓，那就是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)&#123;vector&lt;vector&lt;Point&gt;&gt; countours;vector&lt;Vec4i&gt; hierarchy;findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);Mat* workMat &#x3D; new Mat(org);vector&lt;vector&lt;Point&gt;&gt; conPoly(countours.size());for (int i &#x3D; 0; i &lt; countours.size(); i++) &#123;auto area &#x3D; contourArea(countours[i]);cout &lt;&lt; area &lt;&lt; endl;if (area &gt; 1000) &#123;double peri &#x3D; arcLength(countours[i], true);approxPolyDP(countours[i], conPoly[i], 0.02 * peri, true);drawContours(*workMat, conPoly, i, Scalar(255, 0, 0), 3);&#125;&#125;return *workMat;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230426223109977.png" alt="image-20230426223109977"></p><p>​        而框住矩形是由给出：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;** @brief Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image.The function calculates and returns the minimal up-right bounding rectangle for the specified point set ornon-zero pixels of gray-scale image.@param array Input gray-scale image or 2D point set, stored in std::vector or Mat. *&#x2F;CV_EXPORTS_W Rect boundingRect( InputArray array );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        函数每一次扫描ConPoly后返回最小矩形，我们用一个vector&lt; Rect &gt;接受就好了</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)&#123;vector&lt;vector&lt;Point&gt;&gt; countours;vector&lt;Vec4i&gt; hierarchy;findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);Mat* workMat &#x3D; new Mat(org);vector&lt;vector&lt;Point&gt;&gt; conPoly(countours.size());vector&lt;Rect&gt; boundRect(countours.size());for (int i &#x3D; 0; i &lt; countours.size(); i++) &#123;auto area &#x3D; contourArea(countours[i]);cout &lt;&lt; area &lt;&lt; endl;if (area &gt; 1000) &#123;double peri &#x3D; arcLength(countours[i], true);approxPolyDP(countours[i], conPoly[i], 0.02 * peri, true);boundRect[i]  &#x3D; boundingRect(conPoly[i]);drawContours(*workMat, conPoly, i, Scalar(255, 0, 0), 3);rectangle(*workMat, boundRect[i].tl(), boundRect[i].br(), Scalar(255, 0, 100),5);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230426223759367.png" alt="image-20230426223759367"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv in Visual Studio C(3)</title>
      <link href="/2023/04/26/Opencv-in-Visual-Studio-C-3/"/>
      <url>/2023/04/26/Opencv-in-Visual-Studio-C-3/</url>
      
        <content type="html"><![CDATA[<h1 id="Opencv-with-Visual-Studio3"><a href="#Opencv-with-Visual-Studio3" class="headerlink" title="Opencv with Visual Studio3"></a>Opencv with Visual Studio3</h1><p><img src="D:\Hexo-Blog\source\_posts\Opencv-in-Visual-Studio-C-3\image-20230423222216217.png" alt="image-20230423222216217"></p><p>​        看到这个图片了嘛，这个就是我们今天的任务！通过颜色来检测于识别小车！</p><h2 id="颜色检测"><a href="#颜色检测" class="headerlink" title="颜色检测"></a>颜色检测</h2><p>​        我们首先来转化一下这个图片，我们的图片都是采用BGR绘制的。但是还有另一套颜色系统，是用HSV来描述的：</p><pre class="line-numbers language-none"><code class="language-none">每一种颜色都是由色相（Hue，简H），饱和度（Saturation，简S）和色明度（Value，简V）所表示的。这个模型中颜色的参数分别是：色调（H），饱和度（S），亮度（V）。色调H参数表示色彩信息，即所处的光谱颜色的位置。该参数用一角度量来表示，取值范围为0°～360°。若从红色开始按逆时针方向计算，红色为0°，绿色为120°，蓝色为240°。它们的补色是：黄色为60°，青色为180°，紫色为300°；饱和度S：取值范围为0.0～1.0；亮度V：取值范围为0.0(黑色)～1.0(白色)。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在Opencv中，转化的方式同将图片二值化是一致的，都是cvtColor(),其调用的参数我想很容易猜：COLOR_BGR2HSV.</p><p><img src="image-20230423222747297.png" alt=""></p><p>​        但是，我们若是想要筛选，就必须要采用滑条的方式来搞！</p><p>​        怎么搞呢？</p><p>​        首先，我们创建滑动条，就必须要使用Scalar来搞，我们的HSV有上下限制，这就意味着。两个vector是被需要的：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lower<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> upper<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int arr[6] &#x3D; &#123; 0,0,0,255,255,255 &#125;;for (int i &#x3D; 0; i &lt; 3; i++) &#123;lower.push_back(arr[i]);upper.push_back(arr[i + 3]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        随后，使用由inRange函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS_W void inRange(InputArray src, InputArray lowerb,                          InputArray upperb, OutputArray dst);&#x2F;** @brief Performs the per-element comparison of two arrays or an array and scalar value.The function compares:*   Elements of two arrays when src1 and src2 have the same size:    \f[\texttt&#123;dst&#125; (I) &#x3D;  \texttt&#123;src1&#125; (I)  \,\texttt&#123;cmpop&#125;\, \texttt&#123;src2&#125; (I)\f]*   Elements of src1 with a scalar src2 when src2 is constructed from    Scalar or has a single element:    \f[\texttt&#123;dst&#125; (I) &#x3D;  \texttt&#123;src1&#125;(I) \,\texttt&#123;cmpop&#125;\,  \texttt&#123;src2&#125;\f]*   src1 with elements of src2 when src1 is constructed from Scalar or    has a single element:    \f[\texttt&#123;dst&#125; (I) &#x3D;  \texttt&#123;src1&#125;  \,\texttt&#123;cmpop&#125;\, \texttt&#123;src2&#125; (I)\f]When the comparison result is true, the corresponding element of outputarray is set to 255. The comparison operations can be replaced with theequivalent matrix expressions:@code&#123;.cpp&#125;    Mat dst1 &#x3D; src1 &gt;&#x3D; src2;    Mat dst2 &#x3D; src1 &lt; 8;    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        产生掩码：但是这里要求的时Scalar，我们先搞一下</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Scalar down(lower[0], lower[1], lower[2]);Scalar up(upper[0], upper[1], upper[2]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        现在可以了</p><pre class="line-numbers language-none"><code class="language-none">inRange(HSV, down, up, mask);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        但是，反复的调值太麻烦，我们使用滑动条调值！</p><p>​        先建立一个窗口，在基于这个窗口创立滑动条！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">namedWindow(&quot;TrackBars&quot;, (640, 480));createTrackbar(&quot;Hue Min&quot;, &quot;TrackBars&quot;, &amp;lower[0], 255);createTrackbar(&quot;Hue Max&quot;, &quot;TrackBars&quot;, &amp;upper[0], 255);createTrackbar(&quot;Sat Min&quot;, &quot;TrackBars&quot;, &amp;lower[1], 255);createTrackbar(&quot;Sat Max&quot;, &quot;TrackBars&quot;, &amp;upper[1], 255);createTrackbar(&quot;Val Min&quot;, &quot;TrackBars&quot;, &amp;lower[2], 255);createTrackbar(&quot;Val Max&quot;, &quot;TrackBars&quot;, &amp;upper[2], 255);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS_W void namedWindow(const String&amp; winname, int flags &#x3D; WINDOW_AUTOSIZE);&#x2F;** @brief Destroys the specified window.The function destroyWindow destroys the window with the given name.@param winname Name of the window to be destroyed. *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS int createTrackbar(const String&amp; trackbarname, const String&amp; winname,                              int* value, int count,                              TrackbarCallback onChange &#x3D; 0,                              void* userdata &#x3D; 0);&#x2F;** @brief Returns the trackbar position.The function returns the current position of the specified trackbar.@note[__Qt Backend Only__] winname can be empty if the trackbar is attached to the controlpanel.@param trackbarname Name of the trackbar.@param winname Name of the window that is the parent of the trackbar. *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，使用一个死循环来完成我们的工作：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">while(1)&#123;Scalar down(lower[0], lower[1], lower[2]);Scalar up(upper[0], upper[1], upper[2]);inRange(HSV, down, up, mask);imshow(&quot;work&quot;, mask);waitKey(1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样就好了。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;using namespace cv;string path &#x3D; &quot;D:\\My coding repositary\\learnopencv\\5\\source_file\\1.png&quot;;vector&lt;int&gt; lower;vector&lt;int&gt; upper;void showVec(vector&lt;int&gt; pVec) &#123;for (auto i &#x3D; pVec.begin(); i !&#x3D; pVec.end(); i++) &#123;cout &lt;&lt; *i &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; &#39;\n&#39;;&#125;Mat HSV , mask;int main()&#123;int arr[6] &#x3D; &#123; 0,0,0,255,255,255 &#125;;for (int i &#x3D; 0; i &lt; 3; i++) &#123;lower.push_back(arr[i]);upper.push_back(arr[i + 3]);&#125;showVec(lower);showVec(upper);Mat workPng &#x3D; imread(path);if (workPng.empty()) &#123;return -1;&#125;cvtColor(workPng, HSV, COLOR_BGR2HSV);namedWindow(&quot;TrackBars&quot;, (640, 480));createTrackbar(&quot;Hue Min&quot;, &quot;TrackBars&quot;, &amp;lower[0], 255);createTrackbar(&quot;Hue Max&quot;, &quot;TrackBars&quot;, &amp;upper[0], 255);createTrackbar(&quot;Sat Min&quot;, &quot;TrackBars&quot;, &amp;lower[1], 255);createTrackbar(&quot;Sat Max&quot;, &quot;TrackBars&quot;, &amp;upper[1], 255);createTrackbar(&quot;Val Min&quot;, &quot;TrackBars&quot;, &amp;lower[2], 255);createTrackbar(&quot;Val Max&quot;, &quot;TrackBars&quot;, &amp;upper[2], 255);while(1)&#123;Scalar down(lower[0], lower[1], lower[2]);Scalar up(upper[0], upper[1], upper[2]);inRange(HSV, down, up, mask);imshow(&quot;work&quot;, mask);waitKey(1);&#125;waitKey();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230426213925062.png" alt="image-20230426213925062"></p><p><img src="image-20230426214024473.png" alt="image-20230426214024473"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv in Visual Studio C(2)</title>
      <link href="/2023/04/26/Opencv-in-Visual-Studio-C-2/"/>
      <url>/2023/04/26/Opencv-in-Visual-Studio-C-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Opencv-with-Visual-Studio"><a href="#Opencv-with-Visual-Studio" class="headerlink" title="Opencv with Visual Studio"></a>Opencv with Visual Studio</h1><h2 id="纯图像应用"><a href="#纯图像应用" class="headerlink" title="纯图像应用"></a>纯图像应用</h2><p>​        Opencv当然可以创建纯色的图片。只需要我们指定图像的种类和每一位的BGR值</p><pre class="line-numbers language-none"><code class="language-none">Mat img(height,width,imgType,bkColorScalar);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        今为了创建一个彩色图像，选择 CV_8UC3，表明是CV下的8bit unsigned char（就是0~255）下的3通道图.</p><p>​        太单调了，画个圆：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;&#x2F;&#x2F; create a blank img&#x2F;&#x2F; CV_8bits(2~255) Unsigned Char 3dims Mat img(512, 512, CV_8UC3, Scalar(255,0,0));&#x2F;&#x2F;create a circlecircle(img, Point(256, 256), 155,Scalar(0,255,0),10);imshow(&quot;blue one&quot;, img);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230322220017113.png" alt="image-20230322220017113"></p><p>​        当然可以玩其他东西：不过，也就是可以查看API自己搞定：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;&#x2F;&#x2F; create a blank img&#x2F;&#x2F; CV_8bits(2~255) Unsigned Char 3dims Mat img(512, 512, CV_8UC3, Scalar(255,0,0));&#x2F;&#x2F;create a circlecircle(img, Point(256, 256), 155,Scalar(0,255,0),10);&#x2F;&#x2F; rectangle createrectangle(img, Point(150, 150), Point(300, 300), Scalar(255, 255, 255), FILLED);&#x2F;&#x2F; lineline(img, Point(200, 400), Point(400, 400), Scalar(100, 100, 100), 20);&#x2F;&#x2F; putTextputText(img, &quot;hello,world&quot;, Point(100, 100), FONT_HERSHEY_DUPLEX, 2, Scalar(0, 0, 0));imshow(&quot;blue one&quot;, img);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230322221142413.png" alt="image-20230322221142413"></p><h2 id="Warp我们的图像：图像变换1"><a href="#Warp我们的图像：图像变换1" class="headerlink" title="Warp我们的图像：图像变换1"></a>Warp我们的图像：图像变换1</h2><p>​        下面我们继续！</p><p>​        <img src="1-16825202276533.png" alt="1"></p><p>​        现在，我们想要变换这中间的一个扑克牌使之正立！我们转向：先把目标放到一个Demo 上，就是King这张牌。现在，我们找出它的四个点！不必打开画图，我们使用 <code>setMouseCallBack</code>这个函数！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setMouseCallback(const String&amp; winname, MouseCallback onMouse, void* userdata &#x3D; 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        winname就是目标窗口名称，那这个 MouseCallback是啥呢？进一步去看</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef void (*MouseCallback)(int event, int x, int y, int flags, void* userdata);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        再明显不过了，我们重写一个函数，其原型是如上的，我们编写一个！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void onMouse(int event, int x, int y, int flags, void*) &#123;if(event &#x3D;&#x3D; EVENT_LBUTTONDOWN)cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y&lt;&lt;endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;string path &#x3D; &quot;C:\\Users\\usr\\Desktop\\My coding repositary\\learnopencv\\2\\source_file\\1.png&quot;;Mat warp &#x3D; imread(path);if (warp.empty()) &#123;return -1;&#125;imshow(&quot;1&quot;, warp);setMouseCallback(&quot;1&quot;, onMouse);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        啊哈！</p><p><img src="image-20230419220733947.png" alt="image-20230419220733947"></p><p>​        这几个点收下了！</p><p>​        然后，我们想要立正之后，图片的宽和高也应当要给出来！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">float w &#x3D; 250, h &#x3D; 350;Point2f points[4] &#x3D; &#123; &#123;575 ,195&#125;,&#123;440 ,465&#125;,&#123;733 ,528&#125;,&#123;833 ,247&#125; &#125;;Point2f after[4] &#x3D; &#123; &#123;0,0&#125;,&#123;w ,0&#125;,&#123;0 ,h&#125;,&#123;w ,h&#125; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后转向API的调用！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">mat &#x3D; getPerspectiveTransform(points, after);warpPerspective(warp,imgWarp, mat, Point(w, h));imshow(&quot;Warp&quot;, imgWarp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <img src="image-20230419222906918.png" alt="image-20230419222906918"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Essential cpp 阅读笔记1</title>
      <link href="/2023/04/25/Essential-cpp-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/"/>
      <url>/2023/04/25/Essential-cpp-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础编程"><a href="#C-基础编程" class="headerlink" title="C++基础编程"></a>C++基础编程</h1><p>​        下面，我们开始正式的入门Ｃ++这个语言，通过一些简单的分析来了解一些简单的概念！我们将会在这些sections中认识</p><p>​        基本的数据类型：不二之，自负，证书，浮点数等概念</p><p>​        还要认识算术运算符，关系运算符和逻辑运算符，用在操作上树基础数据类型。这些运算符包括诸如+ ,==, &lt;=等，还会有赋值，也包括Ｃ/Ｃ++的++自增运算，条件运算（？：）和复合赋值运算（+=）</p><p>​        一些基本结构语句，比如说ifwhile等来改变程序的流程</p><p>​        一些复合类型、比如说指针和数组。</p><p>​        一套标准而又通用的抽象化库，比如字符串（string）和向量(vector)</p><h2 id="1-1简单程序的书写"><a href="#1-1简单程序的书写" class="headerlink" title="1.1简单程序的书写"></a>1.1简单程序的书写</h2><p>​        下面开始书写简单的程序，我们的要求是将一小段信息发送到用户的终端，是请求用户输入一小段自己的姓名，程序读取后用这个姓名来跟用户打招呼。</p><p>​        在Ｃ/C++中，程序是从一个叫做main()的地方开始入手执行程序的，格式如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;    &#x2F;&#x2F; this is he place you input the code &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        int是Ｃ++程序的一个关键字，什么是关键字呢？就是程序语言预先定义好了的具有特殊含义的名称。言之：int是用来表示内置的数据类型的，它表明这一个整形。</p><p>​        函数是一块独立的程序代码序列，main函数返回一个整形，事实上，它的逻辑含义正式说明程序是否正确允许运行，原则上正确运行返回0，否则返回其他值。这表达出程序产生了其他错误需要处理！</p><p>​        当然，其他函数的名称可以由程序员自己选择，当然，最好名称是让人一下子就明白这是要干什么的！比如对于一个实现了排序的函数，你给他起名字叫sort()也比叫他q()强的多</p><p>​        函数的参数列表，是函数执行时候可能用到的参数，我们把它放在（）里面，比如：void sort(int* arr, unsigned int arrLen)，而当你直接书写（）表明函数不接受参数！</p><p>​        随后，当我们制定完函数的返回类型，参数列表函数名称之后，就用一个大括号将实现代码阔起来{}</p><p>​        // 是C/C++的注释符号！</p><p>​        下面我们开始完成任务：第一个工作就是向用户给出提示输入！事实上，在Ｃ++中，我们是调用面对对象的类层次体系来完成这个工作的</p><p>​        所谓的类就是用户自己定义的数据类型，在Ｃ++中这个关键字就是class。我们使用基本的数据类型将他们组合起来构成新的自定义的对象！比如说：我们选择三个浮点型来表现一个点的空间坐标！等等。</p><p>​        class给我们了抽象事物的能力！虽然说还是没到该使用class的时候，但还是先要声明一下，我妈实现一个class类即要声明又要实现！它们要被放在不同的文件下。想要使用这些类呢，就要引用他们的声明文件，也就是头文件！标准格式如下：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这里，有标准库已经封装好C++了的控制台输出对象：cout，这样的使用，就可以把我们想要输入的东西输出到控制台上：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cout&lt;&lt; “offer me your name please!”;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这就是一条单独的语句。如果我们书写这样的代码，C++用户就会看见一条信息了！但是先别急，还没讲完，这个时候运行会报错的。</p><p>​        我们要找一个东西来储存用户的输入，不错，选取标准库的string 是一个汗不错的主意。声明的方式可以类比：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string usr_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是止步于此系统不认识你的string是什么，于是声明一下头文件就好了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;string&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        以后运用cin来输入东西读入进程序就好了！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cin &gt;&gt; usr_name; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而在我们读取成功之后，我们利用收集到的信息，来完成打招呼：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cout&lt;&lt;“hello,” &lt;&lt;usr_name&lt;&lt;“ nice to meet you!”&lt;&lt;“\n”;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        是的，我们的Cout可以这样使用来达到连续输出的效果！</p><p>​        下面我们组合起来，完成我们第一个大程序：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;string&gt; using namespace std; &#x2F;&#x2F; using in declaring the functions that belongs to which! int main()&#123;string usr_namel;cout &lt;&lt; “sbmit your first name”; cin &gt;&gt; usr_name; cout &lt;&lt; “ hello !”&lt;&lt; usr_name&lt;&lt; “nice to meet you\n”; ,&#x2F;&#x2F; 表示换行return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们的程序会在后面很成功的完成我们的任务。</p><p>​        程序中间的有一行，是我们需要留心的，那就是C++</p><p>​        using namespace std;</p><p>​        这一行程序将标准库里的函数所在的空间暴露给我们的程序，意味着我们不再需要指明这是哪里的某函数便可以直接使用之！</p><h2 id="对象的定义和初始化问题"><a href="#对象的定义和初始化问题" class="headerlink" title="对象的定义和初始化问题"></a>对象的定义和初始化问题</h2><p>​        下面想要集中说明的是关于对象初始化和定义的问题！</p><p>​        这是一块内存地址对于我们程序员的抽象！换而言之，我们给这块内存地址取一个名字，映射这块内存地址，赋予它数据类型。注意的是名称是任何字母，数字和下划线_的若干组合！大小写是区分的！！！对象名称也不可以由名字打头！比如说1_User是一个不合法的名称。</p><p>​        每个对象都有自己的数据类型，他们决定了这个对象有多大，范围如何。一个标准的声明对象的格式是：</p><pre class="line-numbers language-CPP" data-language="CPP"><code class="language-CPP">int usr_val &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也就是</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typename varName &#x3D; Val;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在这行语句里，我们实际上做了两件事情：对象的定义和初始化，我们都做了！定义只是声明了这个变量是什么，赋值，也就是初始化的具体行为，是用assignment这个行为，使用= 这个运算符完成的。</p><p>​        简单的对象只需要一次复制就可以有效的完成。但是对于复杂的对象，也就是比如说复数：学过几本数学的都知道，复数是由实数和虚数构成的。那么，这样的行为大多数情况下就是未定义的！</p><pre class="line-numbers language-C++C++" data-language="C++C++"><code class="language-C++C++">complex anError &#x3D; 1; &#x2F;&#x2F; Error ,this is a compound variable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那，我们就需要使用这样的方式，比如说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Complex ok(10,20);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>标准库是怎么说的呢？标准库是使用了模版来进行编程的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;complex&gt;C++Complex&lt;double&gt; aComplex(10,29);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        好好好，那这个<double>又是几个意思呢？事实上这涉及到另一个高级的概念叫做模版编程。对于一类大对象，我们需要知道具体的（用户和用户程序员给出才能完全确定的）数据结构才能进行完全的初始化。这个是模版</p><p>​        当然，对于一些常量，我们使用const修饰符来让编译器知道这个变量是不允许修改的！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> typeName varName <span class="token operator">=</span> initialVal<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="书写表达式"><a href="#书写表达式" class="headerlink" title="书写表达式"></a>书写表达式</h2><p>​        下面我们来开始另一个Ｃ++编程的主要活动，也就是书写表达式指挥编译器，从而间接的指挥CPU等各个硬件来完成我们希望完成的工作。事实上，我们刚刚阐述的赋值就是一种赋值表达式。</p><p>​        表达式可以是简单的：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">i <span class="token operator">+=</span> <span class="token number">2</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也可以是复杂的，比如说下面的式子实现了自动检测行数来实现自动换行的语句</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout <span class="token operator">&lt;&lt;</span> textInLine <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>cnt <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">?</span> ‘’ <span class="token operator">:</span> ‘\n’ <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        %这个运算符是取余操作符，同时，还有一个崭新的三目操作符</p><pre class="line-numbers language-none"><code class="language-none">EXPR1 ? EXPR2 : EXPR3;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是什么意思呢？我换一下：你吃饭了吗？ 吃了：没吃也就是说，只有对着EXPR1 求值返回的是真，才会执行EXPR2 ，否则就是执行3</p><pre><code>     表达式的核心是运算符，对于赋值行为我们常常会遇到自己操作自己的情况。Ｃ++使用+=，++ 等行为来简化我们的自增行为。</code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cnt <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        特别的 ++ 和 — 是递增递减运算符，专门的，有前置的与后置的运算符。</p><p>​        前置是先加后用，也就是说</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// demo </span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>val<span class="token punctuation">;</span><span class="token comment">// On console , we see the res is 11</span>cout <span class="token operator">&lt;&lt;</span> val<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// On console , we see the res is 11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        除了赋值运算符，我们还有关系运算符。这里有== != &lt; &gt; &lt;= &gt;= 这个关系式返回的是布尔值。这样的特性使之可以用在if 等结构语句。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if( BOOL_EXPR)&#123;&#x2F;&#x2F; the statements that executing only when EXPR is true.&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个经典的应用我想就是用户反馈判断的代码了！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if(usr_choice &#x3D;&#x3D; ‘Y’)&#123;usr_more &#x3D; false;&#125;else&#123;usr_more &#x3D; true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值的我们反复警示的是！很多人上手就会写好玩的</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if(choice &#x3D; ‘Y’)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这样就是一个赋值行为，表达式返回赋值的结果，也就是说，除非是赋值0，否则这个if判断将会是永远成立的！而且choice的值将会被赋值‘Y’，灾难！</p><p>​        在if中的表达式可以使用&amp;&amp; || !等运算符来避免不必要的嵌套if从句，后者对于阅读代码的人来讲是一个灾难。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">if(password &amp;&amp; validate( password) &amp;&amp; (get_account &#x3D; retrieve_account_info(password)  )  )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如上，我们首先看password是不是false，是的话，后面的表达式不执行直接跳过！</p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>我们运算符也有优先级的，运算符从上到下运算符优先级逐步降低：</p><p>NOT ！</p><p>算术运算符 * / %</p><p>算术运算符 + -</p><p>关系运算符 &lt; &gt; &lt;= &gt;=</p><p>关系运算符 == !=</p><p>逻辑运算符AND</p><p>逻辑运算符 OR</p><p>赋值运算符 =</p><p>因此，当我们试图判断 i可不可以被2惩整除的时候，不可以写作：</p><p>if(!i %2)</p><p>因为！i会被先计算，所以，这样才是合适的：</p><p>if（!(i%2)）</p><p>条件语句和循环语句</p><p>下面要讲述简单的循环语句和条件语句。</p><p>条件语句很简单，就是if ,else ,else if三件套，这个我们不再多说，没有新鲜的东西！</p><p>但是值得一提的是switch语句！我们如果发现可以使用一系列的整数来代替选择的话就不妨使用switch语句，其格式是这样的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">switch(num)&#123;case 1:cout &lt;&lt; “this is the case 1”;break; &#x2F;&#x2F; break is using to jump out the structure .case 2:cout &lt;&lt; “this is the case 2”;break;default:break;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>循环语句</p><p>我们如果希望程序在某一个条件之下一直做一些什么事情，那while for do{}while什么的最合适了。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">while(get_Correct)&#123;get_Correct &#x3D; usrInput();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>while循环表达式会在开始执行循环体的时候先计算（）内部的表达式是不是真，若果是真循环体执行一直到表达式循环为假，这就强迫我们提供循环的出口！</p><p>当然，有的时候可以用break 直接干掉循环，或者是使用 continue结束当前循环。</p><p>比如说</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">while(cin &gt;&gt; word)&#123; if(word.size() &lt; min_size)&#123;continue; &#x2F;&#x2F; 只是不再收录小于 min 长度的字符串&#125;if(word.size() &gt;&#x3D; max_size)&#123;break; &#x2F;&#x2F; 则是遇到大于最大长度的直接跳出循环继续执行其他的程序&#125;Proceed_text(word)&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用标准库的array-和vector"><a href="#使用标准库的array-和vector" class="headerlink" title="使用标准库的array 和vector"></a>使用标准库的array 和vector</h2><p>我们的程序经常需要存储一系列的元素，这需要我们使用数组来完成这个工作，在Ｃ++中，前辈们已经帮我们封装好了 array 和 vector使用。</p><p>想要使用之，就必须首先引用头文件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;array&gt;#include&lt;vector&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在初始化的时候，就需要注意到我们首先要指明存什么</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int sq_size &#x3D; 10;vector&lt;int&gt; pell_seq(sq_size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>你瞧，这样就好了，int指明了我们的动态数组（vector是动态数组）存储整形的，而pell_seq 是这个动态数组的名字，（）里面提供的是初始化时提供的参数。</p><p>对于数组的赋值，我们使用[]，里头提供下标来作为在数组哪里赋值的依据。</p><p>这里为了方便使用for语句来赋值</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">for(init-statement; condition_of_continueForLoop; expression)&#123; &#125; for(int i &#x3D; 0; i &lt; 10; i++)&#123;pell_seq[i] &#x3D; i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你看这样就好了。至于如何打印我们将在后面学习！</p><p>array是类似的，不过，array是静态的数组，不支持动态扩展，这是我们需要注意的。</p><h2 id="指针小论"><a href="#指针小论" class="headerlink" title="指针小论"></a>指针小论</h2><p>我们可以通过被告知元素在哪里而不是他叫什么来访问元素。这正是指针的用处！声明一个指针，赋予其地址，也就是他在计算机内存的何处。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> pVal <span class="token operator">=</span> <span class="token operator">&amp;</span>Val<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用这个方法拿到一个元素的地址，这下，指针就像钥匙一般找到元素本身来对其本身进行操作了：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"> <span class="token keyword">if</span>（<span class="token operator">*</span>pVal <span class="token operator">!=</span> <span class="token number">1024</span>）<span class="token punctuation">&#123;</span><span class="token operator">*</span>pVal <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们不在声明中对指针变量使用*时，正是解引用的意思。</p><p>我们需要指出的是，在指针本身，也可以存在：指针不指向任何东西，在习惯上赋值为NULL，当然在后面的Ｃ++中又使用nullptr作为不指向任何东西的指针。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">*</span> pVec <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> pVec <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，这也提醒我们，在我们通过指针来对对象进行若干操作的时候，就需要首先了解一下这个指针是不是空：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>pVec <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>pVec<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// pVec 有效吗 &amp;&amp; pVec指向的对象元素是不是空    </span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文件流操作"><a href="#文件流操作" class="headerlink" title="文件流操作"></a>文件流操作</h2><p>操纵文件，对文件输入输出东西在Ｃ++中十分常见！</p><p>来看一个DEMO。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ofstream <span class="token function">outfile</span><span class="token punctuation">(</span>“something<span class="token punctuation">.</span>txt”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这行代码的作用效果是：打开一个文件，它是something.txt 如果文件并不存在，那我们就创建一个叫something的文本文件。并且让他处于打开的状态，从而程序可以对之输入。</p><p>但是，如我们每次都这样书写，带来的作用是新的会覆盖旧的书写，如果我们不想这样，那就提供一个参数： ios_base::app表明我们现在对文件施以追加输入。现在，可以通过outfile这个对象来给文件重定向内容了！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>outfile <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cerr <span class="token operator">&lt;&lt;</span> “Sadly unable to open <span class="token operator">and</span> write something <span class="token keyword">int</span> the file <span class="token operator">:</span><span class="token punctuation">(</span>”<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>outfile <span class="token operator">&lt;&lt;</span> usr_name <span class="token operator">&lt;&lt;</span> “is ” <span class="token operator">&lt;&lt;</span> someString <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件的输入到程序中至可读，我们使用的是ifstream, 定义个ifstream 类的对象</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ifstream <span class="token function">infile</span><span class="token punctuation">(</span>“seq<span class="token punctuation">.</span>txt”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>infile<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cerr <span class="token operator">&lt;&lt;</span> “Oops<span class="token punctuation">,</span> seemingly you are <span class="token keyword">new</span> here…”<span class="token punctuation">;</span><span class="token comment">// do others</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>infile <span class="token operator">>></span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>cout <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>           <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern-C-SmartPtr-2-SharedPtrAndWeakPtr</title>
      <link href="/2023/04/22/Modern-C-SmartPtr-2-SharedPtrAndWeakPtr/"/>
      <url>/2023/04/22/Modern-C-SmartPtr-2-SharedPtrAndWeakPtr/</url>
      
        <content type="html"><![CDATA[<h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h1><h2 id="shared-ptr-与计数机制"><a href="#shared-ptr-与计数机制" class="headerlink" title="shared_ptr 与计数机制"></a>shared_ptr 与计数机制</h2><p>​        <code>shared_ptr</code>作为现代C++智能指针的一种，又被译作计数指针（按照原名是共享指针），于是，不同于<code>unique_ptr</code>那样， <code>shared_ptr</code>字如其名的——可以共享数据！我们可以复制这个指针，让多个指针都指向同一块内存！</p><p>​        但是让<code>shared_ptr</code>独特于裸指针的是：它引入了计数机制！也就是说，wrap了一个计数器与类对象所指向的内存相关联起来！</p><p>​        我们对其的copy行为在运行中发生一侧，计数器就+1，销毁一次就-1，对外界的接口就是调用方法：<code>use_count()</code>来查看</p><h3 id="常量类型的shared-ptr"><a href="#常量类型的shared-ptr" class="headerlink" title="常量类型的shared_ptr"></a>常量类型的shared_ptr</h3><p>​        下面呢：我们来搞一下shared_ptr来指向经典对象的demo:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">shared_ptr&lt;int&gt; i_pInt1 &#x3D; make_shared&lt;int&gt;(10);cout &lt;&lt; &quot;val:&gt;&quot; &lt;&lt; *i_pInt1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <img src="image-20230422212238727.png" alt="image-20230422212238727"></p><p>​        试试use_count:</p><pre class="line-numbers language-none"><code class="language-none">cout &lt;&lt;&quot;use_count:&gt;&quot;&lt;&lt;i_pInt1.use_count()&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230422212438039.png" alt="image-20230422212438039"></p><p>​        那我们说的copy究竟是啥呢？正是类似于浅拷贝那样，announce 一个指针，直接将地址复制给这个新指针，只是将地址传递给了新指针而没有为这块数据本身做任何拷贝！</p><p><img src="image-20230422212644498.png" alt="image-20230422212644498"></p><p>​        可以看到，这下<code>use_count</code>变成2了！</p><p>​        那就显然了！如果我们通过i_pInt1来改变值，当我们解析i_pInt2的时候，值一定也会变！    </p><pre><code>//change the val by Path *pVal1 = 20;*i_pInt1 = 1000;cout &lt;&lt; &quot;val:&gt;&quot; &lt;&lt; *i_pInt2 &lt;&lt; endl;</code></pre><p><img src="image-20230422212859311.png" alt="image-20230422212859311"></p><p>​        那现在我们的指针的计数还是2，怎么让他减少呢？让其中一个不再指向这块内存就好了！</p><pre class="line-numbers language-none"><code class="language-none">i_pInt2 &#x3D; nullptr;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt1.use_count() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230422213103231.png" alt="image-20230422213103231"></p><p>​        同时，我们注意，那个被指向nullptr的共享指针，他的计数就是0了！因为他这个时候不在指向任何东西！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">shared_ptr&lt;int&gt; i_pInt3 &#x3D; i_pInt1;shared_ptr&lt;int&gt; i_pInt4 &#x3D; i_pInt1;shared_ptr&lt;int&gt; i_pInt5 &#x3D; i_pInt1;shared_ptr&lt;int&gt; i_pInt6 &#x3D; i_pInt1;&#x2F;&#x2F; erase i_pInt2;i_pInt2 &#x3D; nullptr;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt2.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt1.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt3.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt4.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt5.use_count() &lt;&lt; endl;cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt6.use_count() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422213428144.png" alt="image-20230422213428144"></p><h3 id="自定义类型的shared-ptr"><a href="#自定义类型的shared-ptr" class="headerlink" title="自定义类型的shared_ptr"></a>自定义类型的shared_ptr</h3><pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;dog&gt; pDog1 &#x3D; make_shared&lt;dog&gt;(dog(&quot;111&quot;, 100));*pDog1 &lt;&lt; *pDog1;shared_ptr&lt;dog&gt; pDog2 &#x3D; pDog1;shared_ptr&lt;dog&gt; pDog3 &#x3D; pDog1;shared_ptr&lt;dog&gt; pDog4 &#x3D; pDog1;cout &lt;&lt; pDog1.use_count() &lt;&lt; &quot; &quot; &lt;&lt; pDog2.use_count() &lt;&lt; &quot; &quot; &lt;&lt; pDog3.use_count() &lt;&lt; &quot; &quot; &lt;&lt; pDog4.use_count();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422214020516.png" alt="image-20230422214020516"></p><p>​        当shared_ptr 中没人指向内存的时候自动释放内存！可以使用reset方法来置空指针为 nullptr!</p><h2 id="shared-ptr与函数"><a href="#shared-ptr与函数" class="headerlink" title="shared_ptr与函数"></a>shared_ptr与函数</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>​        我们使用值传递的时候，我们是使用了copy的，这个时候在函数内部来use_count就会发现计数器+1了，但是当函数结束调用时，指针析构，计数器-1！</p><p><img src="image-20230422214825448.png" alt="image-20230422214825448"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;dog.h&quot;#include&lt;iostream&gt;using namespace std;void passByVal(shared_ptr&lt;dog&gt; pDog)&#123;pDog-&gt;showDogInfo();cout &lt;&lt; pDog.use_count() &lt;&lt; endl;return;&#125;int main()&#123;shared_ptr&lt;dog&gt; pDog1 &#x3D; make_shared&lt;dog&gt;(&quot;111&quot;, 100);cout &lt;&lt; pDog1.use_count() &lt;&lt; endl;passByVal(pDog1);cout &lt;&lt; pDog1.use_count() &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p><img src="image-20230422215220588.png" alt="image-20230422215220588"></p><p>​        </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"dog.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">passByVal</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> pDog<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pDog<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> pDog<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">passByRef</span><span class="token punctuation">(</span>shared_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span><span class="token operator">&amp;</span> pDog<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pDog<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pDog<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"222"</span><span class="token punctuation">,</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>shared_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> pDog1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>dog<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> pDog1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">passByVal</span><span class="token punctuation">(</span>pDog1<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> pDog1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">passByRef</span><span class="token punctuation">(</span>pDog1<span class="token punctuation">)</span><span class="token punctuation">;</span>pDog1<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        显然，我们使用引用并更改之（reset方法）后，资源本身也被更改！因此，倘若我们不想让程序无意间更改资源本身，请在函数参数列表中做出如下的修改，那就是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void passByRef(const shared_ptr&lt;dog&gt;&amp; pDog)&#123;pDog-&gt;showDogInfo();&#x2F;&#x2F; pDog.reset(new dog(&quot;222&quot;,222));return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422215456331.png" alt="image-20230422215456331"></p><p>​        这样就修改不了了！</p><h3 id="做返回值"><a href="#做返回值" class="headerlink" title="做返回值"></a>做返回值</h3><p>​        同普通指针类似，这里不做过多的讲解</p><h2 id="和unique-ptr的区别"><a href="#和unique-ptr的区别" class="headerlink" title="和unique_ptr的区别"></a>和unique_ptr的区别</h2><p>​        我们可以将unique_ptr转化为shared_ptr,只需使用std::move就好了！但是反之不能！就像只指向一个内存的一个指针可以用多个指针一同指向它！而反之不能！这里，当我们的函数需要返回一个开辟的地址时，强烈建议返回的指针时unique_ptr！这样方便我们使用！随时可以转化为shared_ptr或者给其他指针赋值，反之很困难！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"dog.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>unique_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> <span class="token function">getUniPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>dog<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>unique_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> pUniDog <span class="token operator">=</span> <span class="token function">getUniPtr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>shared_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> pSharedDog <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pUniDog<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还是值得注意的是：unique_ptr向shared_ptr 转化的时候是隐式转化的！</p><p><img src="image-20230422220750213.png" alt="image-20230422220750213"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;dog.h&quot;#include&lt;iostream&gt;using namespace std;unique_ptr&lt;dog&gt; getUniPtr() &#123;return make_unique&lt;dog&gt;(&quot;111&quot;, 100);&#125;int main()&#123;unique_ptr&lt;dog&gt; pUniDog &#x3D; getUniPtr();shared_ptr&lt;dog&gt; pSharedDog &#x3D; std::move(pUniDog);shared_ptr&lt;dog&gt; pTransform &#x3D; getUniPtr();if (!pTransform) &#123;return -1;&#125;pTransform-&gt;showDogInfo();cout &lt;&lt; pTransform.use_count() &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ ptr"></a>weak_ ptr</h2><p>​        这是弱指针！很有趣的是 weak_ptr不可以调用-&gt;和*，因为它压根就没有内存的所有权！那他为什么存在？</p><h3 id="一个循环引用的例子"><a href="#一个循环引用的例子" class="headerlink" title="一个循环引用的例子"></a>一个循环引用的例子</h3><p>​        下面我们修改dog.h</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setFriend(std::shared_ptr&lt;dog&gt; dog) &#123;this-&gt;friends &#x3D; dog;&#125;&#x2F;&#x2F;private:std::shared_ptr&lt;dog&gt; friends;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;dog.h&quot;#include&lt;iostream&gt;&#x2F;&#x2F;ERROR!!!!!!!!!!!!!!!!!!!!!using namespace std;int main()&#123;shared_ptr&lt;dog&gt; pDog1 &#x3D; make_shared&lt;dog&gt;(&quot;111&quot;, 111);weak_ptr&lt;dog&gt; weak_one(pDog1);cout &lt;&lt; &quot;see:&gt;weak_ptr:&quot; &lt;&lt; weak_one.use_count() &lt;&lt; &quot; while:&gt; &quot; &lt;&lt; pDog1.use_count()&lt;&lt;endl;shared_ptr&lt;dog&gt; pDogLock &#x3D; weak_one.lock();cout &lt;&lt; pDog1.use_count() &lt;&lt; endl;cout &lt;&lt; weak_one.use_count() &lt;&lt; endl;cout &lt;&lt; pDogLock.use_count() &lt;&lt; endl;shared_ptr&lt;dog&gt; pDog3 &#x3D; make_shared&lt;dog&gt;(&quot;333&quot;, 3);shared_ptr&lt;dog&gt; pDog4 &#x3D; make_shared&lt;dog&gt;(&quot;444&quot;, 4);pDog3-&gt;setFriend(pDog4);pDog4-&gt;setFriend(pDog3);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422223254134.png" alt="image-20230422223254134"></p><p>​        马上发现问题了！好家伙，333和444没被析构！正确的，因为此时他们循环调用导致计数器失灵！</p><p>​        上述问题可以简化为：</p><p>​        当我们有一个类A，需要存储其他A类的对象的信息的时候，倘若我们使用shared_ptr，就会在销毁的时候遇到循环依赖的问题！比若说</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class A &#123;public:std::shared_ptr&lt;B&gt; bptr;~A() &#123;cout &lt;&lt; &quot;A is deleted&quot; &lt;&lt; endl;&#125;&#125;;class B &#123;public:std::shared_ptr&lt;A&gt; aptr;~B() &#123;cout &lt;&lt; &quot;B is deleted&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;    &#123;std::shared_ptr&lt;A&gt; ap(new A);std::shared_ptr&lt;B&gt; bp(new B);ap-&gt;bptr &#x3D; bp;bp-&gt;aptr &#x3D; ap;&#125;    cout&lt;&lt; &quot;Job unfinished,but sadly quit!&quot; endl; &#x2F;&#x2F; 循环引用导致ap bp退出了作用域都没有析构!return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        那怎么办？使用weak_ptr就好了</p><p><img src="image-20230422223544954.png" alt="image-20230422223544954"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;std::shared_ptr&lt;dog&gt; friends;std::weak_ptr&lt;dog&gt; friends;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="构造一个weak-ptr"><a href="#构造一个weak-ptr" class="headerlink" title="构造一个weak_ptr"></a>构造一个weak_ptr</h3><p>​        我们注意到，weak_ptr作为shared_ptr的伴生物，其构造从shared_ptr来！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>shared_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> pDog1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>dog<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>weak_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> <span class="token function">weak_one</span><span class="token punctuation">(</span>pDog1<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"see:>weak_ptr:"</span> <span class="token operator">&lt;&lt;</span> weak_one<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" while:> "</span> <span class="token operator">&lt;&lt;</span> pDog1<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422222035184.png" alt="image-20230422222035184"></p><p>​        看到了嘛。我们的weak_ptr当被赋予了同样的地址之后，两者的计数器都不会+1！于是，想要解决上面的问题，只需要把其中一个指针改成weak_ptr就好了！</p><p>​        那么，weak_ptr可不可以转化成shared_ptr呢？可以！调用方法lock() 就OK了！</p><p><img src="image-20230422222447965.png" alt="image-20230422222447965"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 正式开发 2</title>
      <link href="/2023/04/22/ROS-%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%8F%91-2/"/>
      <url>/2023/04/22/ROS-%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%8F%91-2/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS架构"><a href="#ROS架构" class="headerlink" title="ROS架构"></a>ROS架构</h1><p>​        现在我们开始讲解ROS的架构</p><h2 id="设计者"><a href="#设计者" class="headerlink" title="设计者"></a>设计者</h2><p>​        ROS的设计者将ROS表述为“ROS = Plumbing + Tools + Capabilities + Ecosystem”</p><p>​        Plumbing 是通讯机制（实现ROS不同节点）</p><p>​        Tools 是工具软件包（ROS开发和调试工具）</p><p>​        Capabilities 机器人高层技能（导航）</p><p>​        EcoSystem 机器人生态</p><h2 id="维护角度"><a href="#维护角度" class="headerlink" title="维护角度"></a>维护角度</h2><p>​        main:核心部分</p><p>​        universe: 一些扩展的代码</p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>​        ROS可以有三层</p><p>​        （1）OS层 ，也就是经典操作系统 ，ROS是一个元操作系统</p><p>​        （2）中间层：封装了一些机器人开发的中间件</p><p>​                如：基于TCP/UDP 继续封装的TCPROS/UDPROS系统</p><p>​        （3）应用层</p><h2 id="自身结构"><a href="#自身结构" class="headerlink" title="自身结构"></a>自身结构</h2><p>​        文件系统：ROS文件系统指的是硬盘上面查看ROS源代码的组织形式。</p><p>​        计算图： 不同进程需要的进行数据交互。计算图可以良好的表现他们的作用关系</p><p>​        开源社区：略</p><h2 id="ROS文件系统"><a href="#ROS文件系统" class="headerlink" title="ROS文件系统"></a>ROS文件系统</h2><p><img src="image-20230419190503178.png" alt="image-20230419190503178"></p><p>​        如上图，这就是一个ROS的文件结构。</p><p><img src="image-20230419190959393.png" alt="image-20230419190959393"></p><p>​        下面详细重点的介绍如下的文件</p><h3 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h3><p>​        这个文件是自动生成的，他在这里：</p><p><img src="mage-20230419191623848.png" alt="image-20230419191623848"></p><p>​        是的，就在SRC文件夹下面</p><p>​        打开看看，就会发现这里有软件包名称，版本号，作者，维护者以及其他信息。</p><p><img src="image-20230419191807747.png" alt="image-20230419191807747"></p><p>​        <img src="image-20230419191842956.png" alt="image-20230419191842956"></p><p>​        这里可以查看依赖。</p><h3 id="CmakeLists-txt"><a href="#CmakeLists-txt" class="headerlink" title="CmakeLists.txt"></a>CmakeLists.txt</h3><p>​        隔壁就是CmakeLists.txt。大量的对象我们用到再说，先不说过多！</p><h2 id="ROS文件系统的相关命令"><a href="#ROS文件系统的相关命令" class="headerlink" title="ROS文件系统的相关命令"></a>ROS文件系统的相关命令</h2><p>​        下面我们来看一些常见的指令：</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>​        catkin_create_pkg 自定义的包名 依赖的包 == 创建新的ROS功能包</p><p>​        sudo apt install xxx ==安装ROS功能包 （后期经常用）</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>​        sudo apt purge xxx == 删除功能包</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>​        rospack list == 列出所有的功能包</p><p>​        rospack find 包名 == 查询寻包名是否存在，存在返回安装路径</p><p>​        roscd 包名 == 进入摸一个包</p><p>​        rosis 包名 == 列出包下的文件</p><p>​        apt search xxx == 搜索包</p><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>​        rosed 包名 文件名 === 修改功能包文件</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>​        roscore === 是ROS系统先决条件和程序的集合，必须先启动ROScore</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roscore//roscore <span class="token parameter variable">-p</span> xxxx <span class="token comment"># 指定端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230419192925843.png" alt="image-20230419192925843"></p><p>​        启动发现产生了大量的信息，这是熟知英文就可以读懂了，以及这个</p><p><img src="image-20230419193030054.png" alt="image-20230419193030054"></p><p>​        这个是输出日志的Linux地址，可以查看这里。</p><p>​        </p><pre class="line-numbers language-none"><code class="language-none">rosrun 包名 可执行文件名 &#x3D;&#x3D;&#x3D; 运行指定的ROS节点<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        尝试一下：（rospack list）</p><p><img src="image-20230419193647318.png" alt="image-20230419193647318"></p><p>​        cd 一下</p><p>​        <img src="image-20230419193838171.png" alt="image-20230419193838171"></p><p>​        在全网搜寻一下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> search ros-noetic-*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230419194007901.png" alt="image-20230419194007901"></p><p>​        当然，这不好，我们grep检索一下、</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> search ros-noetic-* <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-i</span> gmapping<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230419194126253.png" alt="image-20230419194126253"></p><h2 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h2><p>​        下面要说的是显示个节点关系的一个有效的动态展示图，他就是rqt_graph，用来展示错综复杂的节点关系！</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>​        直接先跑一下这个玩意</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun rqt_graph rqt_graph <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果告诉你没安装，装一下就好了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> ros-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-rqt<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> ros-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-rqt-common-plugins-<span class="token operator">&lt;</span>distro<span class="token operator">></span>-用ROS你自己安装的版本替代！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230422205657970.png" alt=""></p><p>​        注意开的时候先把环境给开了！</p><p>​        然后，启动一下我们之前写的Launch脚本，这样，再次运行rosrun rqt_graph rqt_graph ：</p><p><img src="image-20230422210243852.png" alt="image-20230422210243852"></p><p>​        好了，基础的ROS认识就到这里，之后我们开始讲授核心！ROS的通讯机制！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern_C++_SmartPtr(1)_UniquePtr</title>
      <link href="/2023/04/19/Modern-C-SmartPtr-1-UniquePtr/"/>
      <url>/2023/04/19/Modern-C-SmartPtr-1-UniquePtr/</url>
      
        <content type="html"><![CDATA[<h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++ 智能指针"></a>C++ 智能指针</h1><p>​        突发奇想，准备来点CPP狠活（）</p><h2 id="CPP智能指针类型"><a href="#CPP智能指针类型" class="headerlink" title="CPP智能指针类型"></a>CPP智能指针类型</h2><p>​    ·    就三个：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::unique_ptrstd::shared_ptrstd::weak_ptr    std::auto_ptr 已经被废弃！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面就开始一些简单的讲述</p><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>​        在CPP智能指针诞生之后，CPP的指针就包括两类了： raw pointer裸指针和智能指针 smart_pointer。我们的cpp对指针进行了封装，优点就是可以自动分配内存，不需要你来干，不需要你来释放。</p><p>​        不过，需要知道的是：更多的时候裸指针会更加的方便而不是智能指针！在使用频率上，还是：原始指针 &gt; unique_ptr = shared_ptr &gt; weak_ptr的</p><p>​        对了，事实上我们的智能指针并没有完全解决内存安全！这是我们需要注意的。智能指针解决了所有权指针的释放和传输！因此，不是在开发中无脑的使用智能指针就完事了！否则还会造成内存安全隐患。</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>​        人话：在任何给定时刻只有一个指针管理这片内存！并且，当这个指针出了作用域之后自动释放内存。BTW，因为只能一个指针管，因此不能复制，智能移动。</p><p>​        我们有三种创建方式。</p><p>​        1）现有的裸指针来创建（建议设置为空nullptr）</p><p>​        2）new一个</p><p>​        3）std::make_unique整一个（推介）</p><p>​        by the way我们使用get（）方法来获取地址</p><p>​        其余的-&gt;和 . 都跟裸指针都是一样的，下面来看下demo</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; create a file of dog class::.h:&gt;#pragma once#include&lt;string&gt;#include&lt;iostream&gt;class dog&#123;public:dog(std::string name, unsigned int age);dog() &#x3D; default; &#x2F;&#x2F; using in C++11, to avoid being mistaken while you just simply write &quot;dog a&quot;~dog();void showDogInfo() const &#123;std::cout &lt;&lt; &quot;the dog&#39;s name is: &quot; &lt;&lt; name &lt;&lt; &quot;and it&#39;s &quot; &lt;&lt; age &lt;&lt; &quot;years old&quot; &lt;&lt; &#39;\n&#39;;&#125;void setInfo(const std::string name,const unsigned int age)&#123;this-&gt;name &#x3D; name;this-&gt;age &#x3D; age;return;&#125;std::string getInfoofName() &#123;return this-&gt;name;&#125;unsigned int getAge() &#123;return this-&gt;age;&#125;private:std::string name;unsigned int age;&#125;;.cpp:&gt;   #include &quot;dog.h&quot;dog::dog(std::string name, unsigned int age)&#123;std::cout &lt;&lt; &quot;building a dog actually...&quot;;this-&gt;name &#x3D; name;this-&gt;age &#x3D; age;return;&#125;dog::~dog() &#123;std::cout &lt;&lt; &quot;is being erased of...  &quot; &lt;&lt;this-&gt;name&lt;&lt; &#39;\n&#39;;&#125;:&gt; in main.cpp    #include&lt;iostream&gt;#include&lt;memory&gt;#include&quot;dog.h&quot;using namespace std;int main()&#123;&#x2F;&#x2F; creating in stackdog c1(&quot;yes&quot;, 10);c1.showDogInfo();&#123;&#x2F;&#x2F; using in limited areadog c1(&quot;yep!!!&quot;, 200);c1.showDogInfo();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230416205015394.png" alt="image-20230416205015394"></p><p>​        那在裸指针的接收吧！</p><p><img src="image-20230416205243842.png" alt="image-20230416205243842"></p><p>​        出问题了，他没有调用析构，意味着内存泄漏</p><p>​        在CPP11之前，我们需要手动的delete！</p><p>​        但是就算如此还是会出现这样的问题！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">dog<span class="token operator">*</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"heap"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c2<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#123;</span>c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"heap"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c2<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">delete</span> c2<span class="token punctuation">;</span><span class="token comment">// FATAL ERROR!!!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们发现指针的转移造成了一个内存不被指针记住！</p><p>​        那这样呢？</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">dog<span class="token operator">*</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"heap"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c2<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#123;</span>c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"heap"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c2<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> c2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">delete</span> c2<span class="token punctuation">;</span><span class="token comment">// SO how???</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还是错的！从这个变量已被改变开始，就找不回去了！所有，这个代码会崩溃。因此我们在这样的复杂场合下不应该使用裸指针。</p><h2 id="demo-of-智能指针创建"><a href="#demo-of-智能指针创建" class="headerlink" title="demo of 智能指针创建"></a>demo of 智能指针创建</h2><p><img src="image-20230416210214902.png" alt="image-20230416210214902"></p><p>​        你看，现在我们使用智能指针。没有调用delete还是成功的删除了dog在堆上的内存</p><p>​        但是还有一个大问题：我们就这样跑路了对不对？不对，没有对原始的空指针进行销毁：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Correct one:...dog* c2 &#x3D; new dog(&quot;heap&quot;, 1000);c2-&gt;showDogInfo();unique_ptr&lt;dog&gt; uni_dogPtr(c2);c2 &#x3D; nullptr;uni_dogPtr-&gt;showDogInfo();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我觉得不如这样写更加好：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> <span class="token function">uni_dogPtr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">dog</span><span class="token punctuation">(</span><span class="token string">"smart"</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>uni_dogPtr<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        但官方推介的是这个：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span>dog<span class="token operator">></span> recommend <span class="token operator">=</span> <span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>dog<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token string">"recommend"</span><span class="token punctuation">,</span><span class="token number">114514</span><span class="token punctuation">)</span><span class="token punctuation">;</span>recommend<span class="token operator">-></span><span class="token function">showDogInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        显然这个更简洁。</p><p>​        下面是get()方法的应用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"\nthe data's addr is :> "</span><span class="token operator">&lt;&lt;</span>recommend<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        也有可以对这个智能指针直接解引用的方式来处理问题：当然要预先定义解引用后怎么处置对象的问题。</p><p><img src="image-20230416212757013.png" alt="image-20230416212757013"></p><h2 id="unique-ptr和函数调用"><a href="#unique-ptr和函数调用" class="headerlink" title="unique_ptr和函数调用"></a>unique_ptr和函数调用</h2><p>​        注意！这个玩意不可以copy，而且在做函数参数或者是的时候一定要留心所有权的问题！</p><p>​        1）值传递</p><p>​        需要使用std::move来转移内存的拥有权</p><p>​        若参数直接传入到std::make_unique语句，那就自动转化成move!</p><p>​        2）引用传递</p><p>​        若设置了const就不能改变指针的指向！这是需要我们注意的！</p><p>​        3）返回值</p><p>​        指向一个local object</p><p>​        当然用于链式函数！</p><p>​        下面来看一个Demo, 现在我们来看一下，我们现在设计一个如下的函数！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void do_WithDog(std::unique_ptr&lt;dog&gt; pDog)&#123;pDog-&gt;showInfo();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但是很快，我们试图去传送的时候也，给你爆一个匪夷所思的错误：</p><p><img src="image-20230419214313273.png" alt="image-20230419214313273"></p><p>​        这个时候，其实就是ptr的权限不够，现在我们来用std::move来解决问题</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void do_WithDog(std::move(pDog))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        此后留意到，不可以再次使用这个指针来访问，因为以及被移动了！</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3MxMXNob3dfMTYz,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>（本质上讨论！就是把左值变为右值）</p><p>​        能不能简单点？可以，但是注意到，这里发生了隐式类型转换！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void do_WithDog(std::make_unique&lt;dog&gt;());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        2)引用传递</p><p>​        现在我们重新设计一下！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void doWithRefDof(std::unique_ptr&lt;dog&gt;&amp; pDog) &#123;pDog-&gt;setInfo(&quot;111&quot;, 100);pDog-&gt;showDogInfo();pDog.reset();&#x2F;&#x2F; 把pDog的指向转向0&#125;doWithRefDof(recommend);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是后面再次使用recommend的时候会发现代码会在运行的时候崩溃，因为</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">recommend.get() --&gt; 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是需要注意的！那这样呢？</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void doWithRefDof(const std::unique_ptr&lt;dog&gt;&amp; pDog) &#123;pDog-&gt;setInfo(&quot;111&quot;, 100);pDog-&gt;showDogInfo();pDog.reset();&#x2F;&#x2F; 把pDog的指向转向0&#125;doWithRefDof(recommend);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后发现爆了新错，不是因为setInfo不能使用，而是Reset 出了问题</p><p><img src="image-20230419214405927.png" alt="image-20230419214405927"></p><p>​        就像常指针一样了！</p><p>​        下面，我们来设计一个返回unique_ptr 的函数 ，他正是：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">std::unique_ptr&lt;dog&gt; getUniDogPtr(const std::string name,const unsigned int age)&#123;std::unique_ptr&lt;dog&gt; p_Dog &#x3D; std::make_unique&lt;dog&gt;(name,age);        return p_Dog;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        或者再简洁一点！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">std::unique_ptr&lt;dog&gt; getUniqueDogPtr(const std::string name,const unsigned int age) &#123;return std::make_unique&lt;dog&gt;(name, age);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT NEW 4</title>
      <link href="/2023/04/19/QT-NEW-4/"/>
      <url>/2023/04/19/QT-NEW-4/</url>
      
        <content type="html"><![CDATA[<h1 id="QT-NEW-4"><a href="#QT-NEW-4" class="headerlink" title="QT NEW 4"></a>QT NEW 4</h1><p>复习一下：</p><p>​        1）信号可以链接信号</p><p>​        2）一个信号可以链接多个槽函数</p><p>​        3）多个信号可以链接同一个槽函数</p><p>​        4）但是信号与槽函数的参数必须一一对应</p><p>这是我们练习生活实际是不难发现的！关于四，仔细看看！</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        可以看到必须一 一对应！</p><p>​        5）信号的参数个数是可以多于槽的参数，也就是说，信号携带的信息必须多余槽需要的！</p><pre class="line-numbers language-none"><code class="language-none">void(A::*sig)(QString,int) &#x3D; &amp;A::singals;void(B::*slot)(QString,int) &#x3D; &amp;B::slots;(√)void(A::*sig)(QString,int) &#x3D; &amp;A::singals;void(B::*slot)(int，QString) &#x3D; &amp;B::slots;(×)必须一一对应<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        而在QT4之前，我们使用SIGNAL,SLOT宏链接的。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">connect(sig1,SIGNAL(signals()),slot1,SLOT(slot()))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="补充Lambda表达式"><a href="#补充Lambda表达式" class="headerlink" title="补充Lambda表达式"></a>补充Lambda表达式</h2><p>​        这是C++11的产物，我们由此创建一个匿名的函数以简化编程工作：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[capture](parameters)mutable-&gt;return-type&#123;statements&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        人话：[函数对象参数]（操作符重载函数参数）mutable-&gt;返回值{函数体实现}</p><h3 id="1-函数对象参数"><a href="#1-函数对象参数" class="headerlink" title="1.函数对象参数"></a>1.函数对象参数</h3><p>​        [ ]，这标志Lambda表达式的开始，不允许省略！其中，空表示没有使用任何函数对象。</p><p>​        [=] : 函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this），并且传递方式是值传递</p><p>​        [&amp;]： 函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this），并且传递方式是引用传递。</p><p>​        这是一个修改的demo.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[&#x3D;]()&#123;   btn2-&gt;setText(&quot;Lol&quot;);&#125;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        最后的（）表示的是当地声明马上调用</p><p>​        [this] :函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this和内部成员的变量），并且传递方式是值传递</p><p>​        [varName] 只认识varName，其他都看不见到，用于仅操作一个变量的匿名表达式</p><p><img src="image-20230419202055676.png" alt="image-20230419202055676"></p><p>​        当然后面的很少使用！</p><p>​        mutable关键字：可以修改按值传递进来的拷贝</p><p>​        可以观察这个代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QPushButton<span class="token operator">*</span> btn2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"this is a btn2"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>btn2<span class="token punctuation">,</span><span class="token operator">&amp;</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span><span class="token punctuation">&#123;</span>n<span class="token operator">=</span><span class="token number">110</span><span class="token punctuation">,</span><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>QPushButton<span class="token operator">*</span> btn3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"this is a btn3"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn3<span class="token operator">-></span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>btn3<span class="token punctuation">,</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span><span class="token punctuation">&#123;</span><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        你会发现，点击btn2之后又点击btn3，发现并没有修改n，说明确实只是更改了拷贝而已！</p><p>​        下面来用一下，复盘一下我们学习的知识，那就是设计一个按钮，位于图片中学附近，且点击之后可以使传入的一个值+=10，同时打印信息：From lambda’s reactions!</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;Widget::Widget(QWidget *parent)    : QWidget(parent)&#123;    QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);    resize(640,480);    btn-&gt;move(320,240);    connect(btn,&amp;QPushButton::clicked,this,[]()&#123;qDebug()&lt;&lt;&quot;From lambda&#39;s reactions!&quot;;&#125;);    unsigned int m &#x3D; 10;    connect(btn,&amp;QPushButton::clicked,this,[m]()mutable&#123;m+&#x3D;10;qDebug()&lt;&lt;m;&#125;);&#125;Widget::~Widget()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        返回值：就是在（）后写 -&gt; type随后写实现！</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[]()-&gt;int&#123;return 1000&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int in &#x3D; 10;  int res &#x3D; [&#x3D;]()-&gt;int&#123;return in*in;&#125;();  qDebug() &lt;&lt; res;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        又如点击按钮关闭窗口的demo:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);resize(640,480);btn-&gt;move(320,240);connect(btn,&amp;QPushButton::clicked,this,&amp;Widget::close);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        好吧，那又加一个打印log?转向Lambda就好了</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);resize(640,480);btn-&gt;move(320,240);connect(btn,&amp;QPushButton::clicked,this,[this]()&#123;this-&gt;close();qDebug()&lt;&lt;&quot;Windows is closed!&quot;;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS正式开发1</title>
      <link href="/2023/04/18/ROS%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%8F%911/"/>
      <url>/2023/04/18/ROS%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%8F%911/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS入门"><a href="#ROS入门" class="headerlink" title="ROS入门"></a>ROS入门</h1><p>​        ROS：Robot operating System</p><p>​        他是一个开源元操作系统，类似于我们经典意义的操作系统，有大量的工具，库与协议，还可以在多台计算机上获取，构建编写和运行代码的工具和库。</p><p><img src="image-20230329203952156.png" alt="image-20230329203952156"></p><p>​        至于ROS 的安装，这就不在阐述！</p><p>​        还是决定提供一个简单的方式测试一下你的ROS有没有安装成功。启动Linux虚拟机，随后开三个终端！</p><p>​        第一个终端启动ros环境，输入</p><pre class="line-numbers language-none"><code class="language-none">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        第二个输入</p><pre class="line-numbers language-none"><code class="language-none">rosrun turtlesim turtlesim_node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        第三个输入</p><pre class="line-numbers language-none"><code class="language-none">rosrun turtlesim turtle_teleop_key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        看看小乌龟可不可以跑！注意第三个终端要在最上面！（焦点必须在第三个终端）</p><h2 id="体验经典：hello-world"><a href="#体验经典：hello-world" class="headerlink" title="体验经典：hello world"></a>体验经典：hello world</h2><p>​        ROS工作的程序有C++ 和 Python。</p><p>​        首先，我们需要让Linux认识一下ROS的库！这需要我们来初始化工作环境！其基本步骤如下：</p><ol><li><p>先创建一个工作空间</p></li><li><p>创建一个工作包</p></li><li><p>编辑源文件</p></li><li><p>编辑配置文件</p></li><li><p>编译并执行</p></li></ol><p>​        当然，真正的差异就在第四步，那我们先来看前几步！</p><p>第一步：</p><p>​        简而言之，找个地方！安装当下的文件，今天我们先创建一个RosLearn 文件夹吧，以及我们的第一个实验：Learn1,注意，还要整一个 src 文件夹，并且必须是这个名字！！！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> Roslearn/learn1/src<span class="token builtin class-name">cd</span> Roslearn/learn1catkin_make <span class="token comment">#this instructions aims to init the workspace!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="1-16806218690051.png" alt="1"></p><p><img src="1 (2" alt="1 (2)">-16806218769883.png)</p><p>​        这些正是Cmake的日志，下面开始第二部，创建一些简单的package!</p><p>​        我们把我们一切的源文件放到src文件夹下，随后，在命令行下输入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如是，创建功能节点即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">catkin_create_pkg <span class="token string">'packName'</span> <span class="token string">'dependency'</span> <span class="token comment">#when writing , you are no need to add ''!</span><span class="token comment"># examples</span>catkin_create_pkg helloWorld roscpp rospy std_msgs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        会发现：</p><p><img src="4-16806218814825.png" alt="4"></p><p><img src="5-16806218834477.png" alt="5"></p><p>​        多了很多文件，我们不予理会，还没到时候！</p><p>​        roscpp是C++的实现库，rospy是 python库的，这点需要注意！</p><p>​        好了，开始第三步！！！cd到包里的src文件</p><p><img src="10.png" alt="10"></p><p>​        如果熟悉 vim, 可以直接 vim helloworld_cpp.cpp来一个！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> helloworld_cpp.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        书写这些代码！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;ros&#x2F;ros.h&quot;int main(int argc,char* argv[])&#123;    ros::init(argc,argv,&quot;hello&quot;);        ROS_INFO(&quot;hello world!!!&quot;);        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        摁esc退出insert模式，随后:wq退出vim。</p><p>​        随后，更改CmakeLists 配置文件，注意到是这里的</p><p><img src="image-20230404230008119.png" alt="image-20230404230008119"></p><p>​        找到第136行的 add_executable,和第149行的target_link_library做出这样的更改</p><p><img src="image-20230404230318106.png" alt="image-20230404230318106"></p><p>​        这个haha是Cmake下的临时变量，注意到149行的name必须和136行的name一致</p><p>​        最后一步就是编译！！！</p><p>​        退回到最顶层工作文件夹，再次编译，若有错，按照报错改！</p><p><img src="image-20230404231553533.png" alt="image-20230404231553533"></p><p>​        没有错的话，是这样的 </p><p><img src="image-20230404231631732.png" alt="image-20230404231631732"></p><p>​        开一个新端</p><p>​        先让ros环境启动一下！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        回到原来的终端，注意是原来的！！！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ./devel/setup.bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        不知道啥情况的找到这个文件然后source一下。</p><p>​        下面，就可以有</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun helloworld haha<span class="token comment">#helloworld包下的haha</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        至于集成的开发环境，可以考虑VScode+插件，具体的配置方法在我的博客已经讲述过了！不再讲述！</p><h2 id="ROS节点说明"><a href="#ROS节点说明" class="headerlink" title="ROS节点说明"></a>ROS节点说明</h2><p>​        我们大多数时候需要启动多个ROS节点，这就需要我们写Launch文件来完成这个工作！</p><p>​        其实现如下：(以经典乌龟为例)</p><p>​        1)选定功能包右击—&gt;添加launch文件夹</p><p>​        2)选定launch文件邮寄—&gt;添加launch文件(xml文件)</p><p>​        3)书写</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">...</span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        node : 节点</p><p>​        pkg 功能包</p><p>​        type: 被运行的节点文件</p><p>​        name 为节点命名</p><p>​        output 设置日志的输出目标</p><pre class="line-numbers language-none"><code class="language-none">roslaunch 包名 launch文件名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="撸代码"><a href="#撸代码" class="headerlink" title="撸代码"></a>撸代码</h2><p>​        下面,在一个节点下新建一个launch文件夹,随后在这个文件夹下面新建xml文件        </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- add nodes here--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        不要急着就写下面,先保存,后跑一下可不可以跑!</p><p>​        摁 ctrl + ~打开bash ,先搞一下环境变量 source ./devel/setup.bash</p><p>​        然后跑一下</p><p><img src="image-20230418221943490.png" alt="image-20230418221943490"></p><p>​        这个Launch标签就是启动环境的,下面开始书写</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- add nodes here--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim_node<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>GUI<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtlesim<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>turtle_teleop_key<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>Key<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello_cpp<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hello_cpp_c<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>try<span class="token punctuation">"</span></span> <span class="token attr-name">output</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- pkg是包名 type就是运行文件!切记--></span><span class="token comment">&lt;!-- output 表示的是输出的日志输出在哪里--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT NEW (3)</title>
      <link href="/2023/04/18/QT-NEW-3/"/>
      <url>/2023/04/18/QT-NEW-3/</url>
      
        <content type="html"><![CDATA[<h1 id="QT-NEW-3"><a href="#QT-NEW-3" class="headerlink" title="QT NEW 3"></a>QT NEW 3</h1><h2 id="信号与槽的基础概念"><a href="#信号与槽的基础概念" class="headerlink" title="信号与槽的基础概念"></a>信号与槽的基础概念</h2><p>​        我们现在开始关联我们的行为和效果！比若说：我希望点击按钮后就帮我关闭窗口！于是</p><p><img src="image-20230412232937449.png" alt="image-20230412232937449"></p><p>​        这就是我们分解完后发现就是这样的，现在开始关联他们：</p><p>​        英语里：connect就是连接的，结合上图发现，想要表达一个链接，无非就是：</p><pre class="line-numbers language-none"><code class="language-none">connect(sender, sendSignal, receiver, slogAsActionReact)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        注意了：注意！我们点击按钮，不一定是去关闭窗口，而窗口关闭了不一定时我点击了按钮导致的</p><p>​        于是，信号槽的优点就是：松散耦合的！他们之间本来没啥关联！但是现在我们直接用connect函数来耦合在一起！</p><p>​        QT里，就是connect函数完成我们的工作！先来看发送者：按钮！那信号呢？</p><p><img src="image-20230412233514694.png" alt="image-20230412233514694"></p><p>​        于是找到一个信号clicked. </p><p><img src="image-20230412233547084.png" alt="image-20230412233547084"></p><p>​        所以传入一个函数的地址！&amp;QPushButton::clicked</p><p>​        接收者同理！：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">connect(mine, &amp;QPushButton::clicked,this,&amp;QWidget::close);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这一思想十分重要！还是需要好好消化！</p><p>​        现在尝试自己来书写两个类，来建立相应的关系！</p><p>​        现在构建程序如下：</p><p>​        在最大工程文件之下添加两个类！，首先是 Teacher类。 随后是学生类。假设这一场景！老师要求学生交作业！学生听到老师的要求来拿出作业，老师看到学生拿出作业之后再上前收取。这个行为我们使用 QT 的槽与信号来完成我们的实现。</p><p>​        选择新建两个类： Student 和 Teacher. 注意到为了能够使用 QT系统的一些性质，有必要来选择继承QT类。</p><p>​        当我们完成了新建，马上就发现，它同我们所想象的不太一样！</p><p><img src="image-20230414145816352.png" alt="image-20230414145816352"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef TEACHER_H#define TEACHER_H#include &lt;QObject&gt;class Teacher : public QObject &#x2F;&#x2F; QObject 是 Teacher 的一个基类&#123;    Q_OBJECT &#x2F;&#x2F; 这是QObject宏，声明启用Slot - Signals关系的public:    explicit Teacher(QObject *parent &#x3D; nullptr);        &#x2F;&#x2F; 只有在有 Q_OBJECT下才生效signals:&#x2F;&#x2F; 我们在这里书写 signals 作为信号函数public slots:        &#x2F;&#x2F; 我们在这里书写 slots 作为响应信号的槽函数&#125;;#endif &#x2F;&#x2F; TEACHER_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意到我们在这里完成槽函数和信号函数的书写！</p><p>​        以及这里需要提醒的是：槽函数在这里是一个实现的占位函数，这是在底层的文件中，QT为我们实现了函数了，不要在定义实现文件里再次定义信号函数，否则会发生报错。</p><p>​        但是，槽函数需要实现，这是需要在实现文件里自己重写的！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void student::reactions()&#123;qDebug() &lt;&lt; &quot;Yep, I think I will help you!&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        书写完响应之后，我们现在可以来干活了（在Widget.cpp）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include&quot;student.h&quot;#include&quot;teacher.h&quot;Widget::Widget(QWidget *parent)    : QWidget(parent)&#123;    Teacher* t &#x3D; new Teacher(this);    student* s &#x3D; new student(this);    &#x2F;&#x2F; 这里是链接信号和槽，但是这又这样是不行的，英文不是所有的这个函数都是信号，只有当我们认为指定他是信号的时候才需要出发槽函数    connect(t,&amp;Teacher::announceHungry,s,&amp;s-&gt;reactions);&#x2F;&#x2F; 而emit就是声命这是这是一个信号函数且需要调用s-&gt;reactions    emit t-&gt;announceHungry();&#125;Widget::~Widget()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，只要我们一开始运行程序，就会发现</p><p><img src="image-20230418202145548.png" alt="image-20230418202145548"></p><p>​        嗯，打印了（如果跑的是我的那个demo就是Yep, I think I will help you!）</p><h2 id="槽函数的重载版本"><a href="#槽函数的重载版本" class="headerlink" title="槽函数的重载版本"></a>槽函数的重载版本</h2><p>​        下面，我们进一步的探索可以重载版本的槽函数</p><p>​        以上一小节的场景为例子，加上槽函数的重载版本！</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; in .hslots:void reactions(QString s); &#x2F;&#x2F; .cppvoid student::reactions(QSrting s)&#123;qDebug() &lt;&lt; &quot;yep, I think it is&quot; &lt;&lt; s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，注释掉原先的emit 就可以发现智能提示上函数有重载版本！</p><p>​        但是，当我们直接单击运行的时候，QT报错了！原因很简单！QT不知道你要那个回应！于是，我们转向传专门到具体的函数的指针！也就是直接传重载版本的函数指针！</p><p>​        但是，我们的信号来源信息是需要从信号函数那里来的，于是还要重载Signal函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//.h</span>signal<span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">announceHungry</span><span class="token punctuation">(</span>QString s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// .cpp</span><span class="token keyword">void</span> <span class="token class-name">Teacher</span><span class="token double-colon punctuation">::</span><span class="token function">announceHungry</span><span class="token punctuation">(</span>QString s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 仍然不实现！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，告诉引发的信号是来自：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">emit t<span class="token operator">-></span><span class="token function">announceHungry</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从这里编译器判断函数类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>StringOne<span class="token punctuation">,</span>s<span class="token punctuation">,</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230418210445433.png" alt="image-20230418210445433"></p><h2 id="令人恼火的是："><a href="#令人恼火的是：" class="headerlink" title="令人恼火的是："></a>令人恼火的是：</h2><p>​        马上强迫症发现了：不对啊，我们的111不应该打印“” 啊！，这是因为类型是QString导致的，这个时候只要我们进行转化就好了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">toUtf8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// QString -> ByteArray -> const char*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230418211415114.png" alt="image-20230418211415114"></p><h2 id="高级一点的信号与槽"><a href="#高级一点的信号与槽" class="headerlink" title="高级一点的信号与槽"></a>高级一点的信号与槽</h2><p>​        现在，让我们点击按钮，连续的触发事件来让样例复杂起来。</p><p>​        信号与槽的一个重要的要求就是信号和槽的函数的参数必须一致(有参的信号和QPushButton的clicked信号的参数不匹配就会编译报错)，于是，包装一个Emit函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Widget::Emit()&#123;&#x2F;&#x2F; 预先在Widget里添加成员t，并且初始化Emit t-&gt;announcement(&quot;111&quot;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，开始关联：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QPushButton<span class="token operator">*</span> btn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"Press me"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>btn<span class="token operator">-></span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>btn<span class="token punctuation">,</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>Widget<span class="token double-colon punctuation">::</span>Emit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span class="token punctuation">;</span><span class="token function">connect</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>StringOne<span class="token punctuation">,</span>s<span class="token punctuation">,</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230418213636339.png" alt="image-20230418213636339"></p><p>​        对了，信号也可以来连接信号，就是：</p><p><img src="image-20230418214613353.png" alt="image-20230418214613353"></p><p><img src="image-20230418214631458.png" alt="image-20230418214631458"></p><h2 id="断开链接"><a href="#断开链接" class="headerlink" title="断开链接"></a>断开链接</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">disconnect</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>signalF<span class="token punctuation">,</span>sloter<span class="token punctuation">,</span>slotF<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT NEW (2)</title>
      <link href="/2023/04/18/QT-NEW-2/"/>
      <url>/2023/04/18/QT-NEW-2/</url>
      
        <content type="html"><![CDATA[<h1 id="QT开发-NEW2"><a href="#QT开发-NEW2" class="headerlink" title="QT开发_NEW2"></a>QT开发_NEW2</h1><h2 id="创建一个按钮"><a href="#创建一个按钮" class="headerlink" title="创建一个按钮"></a>创建一个按钮</h2><p>​        我们查询帮助文档，得到这些信息</p><pre class="line-numbers language-none"><code class="language-none">QPushButton ClassThe QPushButton widget provides a command button. More...Header:#include &lt;QPushButton&gt; qmake:QT +&#x3D; widgetsInherits:QAbstractButtonInherited By:QCommandLinkButton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        当然要留意是什么模块，如果 pro 文件里没有，那需要我们手动添加，在</p><p><img src="image-20230301221926786.png" alt="image-20230301221926786"></p><p>​        的QT += 处 添加模块。</p><p>​        当然可以看看函数的功能</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">QPushButton</span><span class="token punctuation">(</span>QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span><span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span><span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token keyword">const</span> QIcon <span class="token operator">&amp;</span>icon<span class="token punctuation">,</span> <span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span><span class="token operator">~</span><span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>bool <span class="token function">autoDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>bool <span class="token function">isDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>bool <span class="token function">isFlat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>QMenu <span class="token operator">*</span><span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token keyword">void</span> <span class="token function">setAutoDefault</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">setDefault</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">setFlat</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token keyword">void</span> <span class="token function">setMenu</span><span class="token punctuation">(</span>QMenu <span class="token operator">*</span>menu<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是可以在 widget.cpp 中书写如下代码：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;#include&lt;QPushButton&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)&#123;    QPushButton* btn &#x3D; new QPushButton;    btn-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点    btn-&gt;setText(&quot;hello world&quot;);&#125;Widget::~Widget()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230301222534315.png" alt="image-20230301222534315"></p><p>​        如果我们重新设置一下窗口大小，那就</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> Height<span class="token punctuation">,</span><span class="token keyword">int</span> Width<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        但是如果我们直接创建第二个按钮，那就会覆盖第一个，那怎么办？使用 move 方法！</p><pre class="line-numbers language-none"><code class="language-none">btn-&gt;move(int x_pos,int y_pos)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        当然啊，我们可以设置窗口的名字：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">setWindowTitle(&quot;My first windows&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        以及可以固定窗口大小：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">setFixedSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> Height<span class="token punctuation">,</span><span class="token keyword">int</span> Width<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230301223238957.png" alt="image-20230301223238957"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include&lt;QPushButton&gt;Widget::Widget(QWidget *parent)    : QWidget(parent)&#123;    QPushButton* btn &#x3D; new QPushButton;    btn-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点    btn-&gt;setText(&quot;hello world&quot;);    QPushButton* btn2 &#x3D; new QPushButton;    btn2-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点    btn2-&gt;move(100,100);    setWindowTitle(&quot;My first Window&quot;);    resize(600,400);    setFixedSize(600,400);&#125;Widget::~Widget()&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="QT对象树"><a href="#QT对象树" class="headerlink" title="QT对象树"></a>QT对象树</h2><p>​        我们发现，程序结束后，不需要一个一个手动的释放对象，这是因为，我们调用构造函数指定了一个Parent父对象，其父对象会把我们自己搞的子对象挂到对象树上，</p><p><img src="image-20230411202327161.png" alt="image-20230411202327161"></p><p>​        （补充：一个类创建时需要调用一个函数来构造初始化这个类，这叫构造函数。当类的什么周期结束时需要调用一个删除函数，释放类占用的空间，这叫析构函数。类默认有这两个函数）于是在QT中只要指定好父对象就会帮助管理！不需要我们手动释放，很是方便</p><p>​        现在，我们来创建一个新类：MyPushBtn</p><p>​        右键工程-&gt; 添加新文件-&gt;C++ Class -&gt;选择 QWedget就好了。</p><p>​        随后，就发现多了一些文件</p><p><img src="image-20230411203853556.png" alt="image-20230411203853556"></p><p>​        pro文件下多了我们自己定义的类的cpp文件和头文件</p><p><img src="image-20230411204458973.png" alt="image-20230411204458973"></p><p><img src="image-20230411204545650.png" alt="image-20230411204545650"></p><p>​        现在我们调一下自己写的：</p><p><img src="image-20230411205908628.png" alt="image-20230411205908628"></p><p>​        可以看到我们自己的按钮产生了！</p><h2 id="QT-坐标系"><a href="#QT-坐标系" class="headerlink" title="QT 坐标系"></a>QT 坐标系</h2><p>​        QT的坐标原点在窗口的最左上角，这是值得注意的一点，同时：X向右增大，向左减小，而Y 向下增大，向上减小。对于嵌套窗口，则是以父窗口为例子的！</p><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>High Quality of C_Cpp programming in formats(1)</title>
      <link href="/2023/04/17/High-Quality-of-C-Cpp-programming-in-formats-1/"/>
      <url>/2023/04/17/High-Quality-of-C-Cpp-programming-in-formats-1/</url>
      
        <content type="html"><![CDATA[<h1 id="高质量的C-C-规程规范"><a href="#高质量的C-C-规程规范" class="headerlink" title="高质量的C/C++规程规范"></a>高质量的C/C++规程规范</h1><h2 id="笔记篇"><a href="#笔记篇" class="headerlink" title="笔记篇"></a>笔记篇</h2><p>​        每个C++/C 程序通常分为两个文件。一个文件用于保存程序的声明（declaration），这被称之为头文件，另一个文件用于保存程序的实现，这是被称之为定义文件。</p><p>​        为此，我们选择了使用后缀来作为文件的区分。在C/C++中，我们选择使用.h/.hpp来作为头文件，而.c文件是C语言源文件，.cpp是C++源文件.</p><p>​        下面是头文件的开门格式</p><h2 id="头文件的结构"><a href="#头文件的结构" class="headerlink" title="头文件的结构"></a>头文件的结构</h2><p>​        三个基本结构: 开头的的版权和版本声明</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;**Copyright (c) * All rights reserved. * * 文件名称：filename.h * 文件标识：见配置管理计划书 * 摘 要：简要描述本文件的内容 * * 当前版本：1.1 * 作 者：输入作者（或修改者）名字 * 完成日期：2001年7月20日 * * 取代版本：1.0 * 原作者 ：输入原作者（或修改者）名字 * 完成日期：2001年5月10日*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        预处理块。</p><pre class="line-numbers language-none"><code class="language-none">#define ...#ifdef ...#ifndef ...#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        函数和类结构声明等。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Some announcements hear<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假设头文件名称为 graphics.h，头文件的结构参见示例 1-2。 </p><p><strong>【规则 1-2-1</strong>】为了防止头文件被重复引用，应当用ifndef/define/endif 结构产生预</p><p>处理块。</p><p><strong>【规则 1-2-2</strong>】用 #include <filename.h> 格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。</p><p><strong>【规则 1-2-3</strong>】用 #include “filename.h” 格式来引用非标准库的头文件（编译器将</p><p>从用户的工作目录开始搜索）。</p><p><strong>【建议 1-2-1</strong>】头文件中只存放“声明”而不存放“定义”<br>        在 C++ 语法中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。这虽然会带来书写上的方便，但却造成了风格不一致，弊大于利。建议将成员函数的定义与声明分开，不论该函数体有多么小。<br><strong>【建议 1-2-2】</strong>不提倡使用全局变量，尽量不要在头文件中出现象 extern int value 这<br>类声明。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 版权和版本声明见示例 1-1，此处省略。</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">GRAPHICS_H </span><span class="token comment">// 防止 graphics.h 被重复引用 </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GRAPHICS_H</span> </span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span> <span class="token comment">// 引用标准库的头文件 </span></span>…<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token expression">“myheader<span class="token punctuation">.</span>h” </span><span class="token comment">// 引用非标准库的头文件 </span></span>… <span class="token keyword">void</span> <span class="token function">Function1</span><span class="token punctuation">(</span>…<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 全局函数声明 </span>… <span class="token keyword">class</span> <span class="token class-name">Box</span> <span class="token comment">// 类结构声明 </span><span class="token punctuation">&#123;</span> … <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        早期的编程语言如 Basic、Fortran 没有头文件的概念，C++/C 语言的初学者虽然会<br>用使用头文件，但常常不明其理。这里对头文件的作用略作解释：<br>​        （1）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。<br>​        （2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担</p><p>​        在目录结构上:如果一个软件的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。<br>例如可将头文件保存于 include 目录，将定义文件保存于 source 目录（可以是多级<br>目录）。<br>​        如果某些头文件是私有的，它不会被用户的程序直接引用，则没有必要公开其“声<br>明”。为了加强信息隐藏，这些私有的头文件可以和定义文件存放于同一个目录</p><h2 id="尽可能良好的书写程序"><a href="#尽可能良好的书写程序" class="headerlink" title="尽可能良好的书写程序"></a>尽可能良好的书写程序</h2><p>​        空行起着分隔程序段落的作用。空行得体（不过多也不过少）将使程序的布局更加清晰。空行不会浪费内存，虽然打印含有空行的程序是会多消耗一些纸张，但是值得。所以不要舍不得用空行。</p><p><img src="image-20230417143154203.png" alt="image-20230417143154203"></p><p>​        于是可以看到,在程序的逻辑模块之间, 我们采用空格来表明逻辑的独立性</p><p>【规则 2-2-1】一行代码只做一件事情，如只定义一个变量，或只写一条语句。这样<br>的代码容易阅读，并且方便于写注释。<br>【规则 2-2-2】if、for、while、do 等语句自占一行，执行语句不得紧跟其后。不论<br>执行语句有多少都要加{}。这样可以防止书写失误。</p><p>【建议 2-2-1】尽可能在定义变量的同时初始化该变量（就近原则）<br>如果变量的引用处和其定义处相隔比较远，变量的初始化很容易被忘记。如果引用<br>了未被初始化的变量，可能会导致程序错误。</p><p>2.3 代码行内的空格</p><p>【规则 2-3-1】关键字之后要留空格。象 const、virtual、inline、case 等关键字之<br>后至少要留一个空格，否则无法辨析关键字。象 if、for、while 等关键字之后应留<br>一个空格再跟左括号‘（’，以突出关键字。</p><p>【规则 2-3-2】函数名之后不要留空格，紧跟左括号‘（’，以与关键字区别。</p><p>【规则 2-3-3】‘（’向后紧跟，‘）’、‘，’、‘;’向前紧跟，紧跟处不留空格。</p><p>【规则 2-3-4】‘，’之后要留空格，如 Function(x, y, z)。如果‘;’不是一行的结束<br>符号，其后要留空格，如 for (initialization; condition; update)。</p><p>【规则 2-3-5】赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，<br>如“=”、“+=” “&gt;=”、“&lt;=”、“+”、“*”、“%”、“&amp;&amp;”、“||”、“&lt;&lt;”,“^”等二<br>元操作符的前后应当加空格。</p><p>【规则 2-3-6】一元操作符如“!”、“~”、“++”、“—”、“&amp;”（地址运算符）等前后不<br>加空格。</p><p>【规则 2-3-7】象“［］”、“.”、“-&gt;”这类操作符前后不加空格。</p><p>【建议 2-3-1】对于表达式比较长的 for 语句和 if 语句，为了紧凑起见可以适当地去<br>掉一些空格，如 for (i=0; i&lt;10; i++)和 if ((a&lt;=b) &amp;&amp; (c&lt;=d))</p><p><img src="image-20230417144044784.png" alt="image-20230417144044784"></p><p>对齐</p><p>​        【规则 2-4-1】程序的分界符‘{’和‘}’应独占一行并且位于同一列，同时与引用<br>它们的语句左对齐。</p><p>​        【规则 2-4-2】{ }之内的代码块在‘{’右边数格处左对齐。</p><p>长行的拆分</p><p>​    【规则 2-5-1】代码行最大长度宜控制在 70 至 80 个字符以内。代码行不要过长，否则眼睛看不过来，也不便于打印。<br>​    【规则 2-5-2】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读</p><p><img src="image-20230417144342762.png" alt="image-20230417144342762"></p><p>​        修饰符 <em> 和 ＆ 应该靠近数据类型还是该靠近变量名，是个有争议的活题。<br>​        若将修饰符 </em> 靠近数据类型，例如：int<em> x; 从语义上讲此写法比较直观，即 x<br>是 int 类型的指针 ,上述写法的弊端是容易引起误解，例如：int</em> x, y; 此处 y 容易被误解为指针变量。虽然将 x 和 y 分行定义可以避免误解，但并不是人人都愿意这样做。<br>​    【规则 2-6-1】应当将修饰符 <em> 和 ＆ 紧靠变量名<br>​        例如：<br>​        char </em>name;<br>         int *x, y; // 此处 y 不会被误s解为指针！</p><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LearnLinuxBasicNote</title>
      <link href="/2023/04/16/LearnLinuxBasicNote/"/>
      <url>/2023/04/16/LearnLinuxBasicNote/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux入门"><a href="#Linux入门" class="headerlink" title="Linux入门"></a>Linux入门</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><p>​        首先计算机由硬件和软件组成，这是大家都知道的。硬件，就是你看到到的实体。至于软件，就是用户和计算机硬件之间的接口和桥梁。我们这次的主题：操作系统，就是软件！他是用户和计算机硬件之间的桥梁，调度和管理计算机硬件进行工作。</p><p>​        当代计算机不能失去计算机，就像西方不能失去耶路撒冷一样（）</p><p><img src="image-20230411185638955.png" alt="image-20230411185638955"></p><p>​        操作系统可以：调度CPU和内存进行工作，使用硬盘来进行数据存储，来使用网卡进行网络通讯，调用音响发出声音，调用打印机打印东西等等。</p><p>​        这是一个操作系统调用网卡的过程：</p><p><img src="image-20230411190152332.png" alt="image-20230411190152332"></p><p>​        常见的操作系统有：Windows 11 ， Linux， macOS（PC操作系统）和android, IOS Harmony OS等等是移动端操作系统了。</p><h2 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h2><p>​        1991年，Linux从一个佬那里诞生，并且逐渐被世界所接受。</p><p>​        Linux由Linux系统内核和系统级应用程序组成。</p><p>​        内核提供系统最核心的功能：比如说：调度CPU，调度缓存，调度文件系统，调度网络通信，调度IO等。</p><p>​        系统应用：比如说图片查看等等</p><p>​        </p><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>​        Linux的目录结构是一个树形的结构，Linux不同于Windows，他只有一个根目录/，所有的文件都在它的下面</p><p><img src="image-20230411195709234.png" alt="image-20230411195709234"></p><p>​        首先，我们这个是在阐述文件路径的层级关系，打开你的Windows cmd (Win + R + Enter) ，发现这个：</p><p><img src="image-20230411195944592.png" alt="image-20230411195944592"></p><p>​        如果我们到Linux底下（不管是CentOS 还是 Ubuntu）都是 / 的</p><p><img src="image-20230411200155312.png" alt="image-20230411200155312"></p><p>​    （以Ubuntu 20.04作为示例）</p><p>​        于是，想要在文件中找到一个目标文件，在Windows中，我们已经很熟悉了：</p><pre class="line-numbers language-none"><code class="language-none">D:\data\work\hello.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        在Linux下就是</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;usr&#x2F;local&#x2F;hello.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        注意到<strong>Linux中，/出现在开头：根目录，/出现在中间：层次关系</strong></p><h2 id="第一个Linux命令：ls"><a href="#第一个Linux命令：ls" class="headerlink" title="第一个Linux命令：ls"></a>第一个Linux命令：ls</h2><p>​        先停！搞清楚什么是命令很重要：他是Linux的 Terminal，下命令提示符页面我们单纯的使用’字符’来操作系统，也就是使用各种字符指令来对系统发出操作指令。</p><p>​        而命令，本质上还是一个程序，只是没有图形化的相关界面。其反馈又以字符串的形式返回来。</p><p><img src="image-20230414222522060.png" alt="image-20230414222522060"></p><p>​        比如说在CentOS下，我们敲入字符ls 发现返回了东西。就是说明 ls 是程序，而下面的结果就是字符形式的返回</p><p>​        在Linux,命令具有相同的通用格式！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">command</span> <span class="token punctuation">[</span>-options<span class="token punctuation">]</span> <span class="token punctuation">[</span>parameters<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        command 即是命令本身，</p><p>​        （选填）而 -options 就是 控制行为的一些具体的设置细节</p><p>​        （选填）parameter 就是命令之下的参数</p><p>​        举个例子：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">-l</span> /home<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        ls 就是命令， -l 就是选项，表明如何执行这样的命令，/home表示参数。于是这条指令正是： 查看home文件夹下的内容，其显示方式使用列表</p><p><img src="image-20230414224112645.png" alt="image-20230414224112645"></p><p>​        现在主要看 ls ，他的格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token punctuation">[</span>-a <span class="token parameter variable">-l</span> -h<span class="token punctuation">]</span> <span class="token punctuation">[</span>/Linux/Path<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        直接使用ls 表明直接通过平铺的方式展示这一目录下的工作内容</p><p><img src="image-20230414224455558.png" alt="image-20230414224455558"></p><p><img src="image-20230414224618031.png" alt="image-20230414224618031"></p><p>​        还就是桌面上那个home文件夹的内容！于是 ls 就是等同于我们来看当前文件夹下的东西。</p><h2 id="什么是工作目录"><a href="#什么是工作目录" class="headerlink" title="什么是工作目录"></a>什么是工作目录</h2><p>​        当我们启动命令行时，默认我们的 home下的用户名为名称的目录正是工作目录：也就是我们准备执行若干操作的当下目录</p><p><img src="image-20230414225017894.png" alt="image-20230414225017894"></p><p><img src="image-20230414225600771.png" alt="image-20230414225600771"></p><h2 id="ls-参数详解"><a href="#ls-参数详解" class="headerlink" title="ls 参数详解"></a>ls 参数详解</h2><p>​        -a : all 的意思。于是。。。</p><p><img src="image-20230414231338693.png" alt="image-20230414231338693"></p><p>​        在 .Name 之类的就是Linux下的隐藏文件。总而言之，-a 就是展示所有的文件，包括那些被隐藏的文件</p><p>​        而在-l 下，就是以列表的方式展示我们的文件是怎样的。</p><p><img src="image-20230414232357814.png" alt="image-20230414232357814"></p><p>​        那如果我想： 既想展示所有的隐藏文件，又想用列表的方式展示，那就是可以有下面三种方式。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token parameter variable">-l</span> <span class="token parameter variable">-a</span> <span class="token function">ls</span> <span class="token parameter variable">-la</span><span class="token function">ls</span> <span class="token parameter variable">-al</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230414232421335.png" alt="image-20230414232421335"></p><p><img src="image-20230414232443582.png" alt="image-20230414232443582"></p><p><img src="image-20230414232507927.png" alt="image-20230414232507927"></p><p>​        最后是 -h, 他表示我们以一种方便阅读的方式来列出文件的大小！注意必须和-l 一同使用，否则不会显示相关的效果！ </p><p><img src="image-20230414232733351.png" alt="image-20230414232733351"></p><p>​        可以看到我们更容易阅读文件的大小了</p><h2 id="cd-pwd指令"><a href="#cd-pwd指令" class="headerlink" title="cd  -  pwd指令"></a>cd  -  pwd指令</h2><p>​        使用 cd 命令来切换工作目录（Change Directory）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /Linux/Path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        当我们不指定路径时，直接回到home目录</p><p><img src="image-20230415215546677.png" alt="image-20230415215546677"></p><p>​        ls并不是专门打印当下目录的正确指令，至少不恰当！事实上，还是pwd才合适，他就是 print work directory 的缩写</p><p><img src="image-20230415215936705.png" alt="image-20230415215936705"></p><p>​        只需要输入 pwd 就可以查看当下的目录了！·</p><h2 id="相对路径-绝对路径-特殊路径符"><a href="#相对路径-绝对路径-特殊路径符" class="headerlink" title="相对路径/绝对路径/特殊路径符"></a>相对路径/绝对路径/特殊路径符</h2><p>​        我们书写目录，一种是从根目录开始找： /usr/ Path，还有一种是从 当下的工作目录开始找： cd LinuxPath, 前者是就是从根目录找，称之为绝对路径，非常的绝对，代价即是很长。后者就是在当前目录去找！</p><p>​        下面是一些特殊的符号：</p><pre class="line-numbers language-none"><code class="language-none">. : 当前目录，常用的就是切换到当前目录下的文件夹，比如说：cd .&#x2F;Desktop&#x2F;SomeThing.. : 返回上一级目录 退两级：cd ..&#x2F;..~ : 直接回到home<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> LinuxPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        mkdir正如缩写所义：make directory。创建一个在父目录之下的子目录。而参数 -p 是可选的，他让我们可以创建一个递归的目录，适用于直接创建多层的文件夹，实际看一下就是这个意思！</p><p><img src="image-20230415221252797.png" alt="image-20230415221252797"></p><p><img src="image-20230415221608598.png" alt="image-20230415221608598"></p><h2 id="torch-cat-more"><a href="#torch-cat-more" class="headerlink" title="torch cat more"></a>torch cat more</h2><p>​        使用torch命令来创建文件，格式是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">touch</span> LinuxPath/Filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230415222041990.png" alt="image-20230415222041990"></p><p>​        随后，我们可以先给这个文件写点东西，会使用 vim 就用 vim：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; type in shell &gt;&gt;&gt;vim touch.txt&#x2F;&#x2F; press i to get into the insert mode&#x2F;&#x2F; write in file : Hello,welcome using cat to check the note off this file&#x2F;&#x2F; press ESC&#x2F;&#x2F; write :wq&#x2F;&#x2F; back to shell: &gt;&gt;&gt; cat touch.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230415222728934.png" alt="image-20230415222728934"></p><pre class="line-numbers language-none"><code class="language-none">cat Linux&#x2F;Path&#x2F;FileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        对于more命令，那表示的是如果文件内容过长，可以使用more命令来查看文档</p><p><img src="image-20230415223140319.png" alt="image-20230415223140319"></p><p>​        </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">more</span> Linux/Path/FileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        回车一行行查看，空格是一页一页看，退出是q</p><h2 id="cp-mv-rm"><a href="#cp-mv-rm" class="headerlink" title="cp mv rm"></a>cp mv rm</h2><p>​        cp是copy的缩写，就是复制文件的意思。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> <span class="token punctuation">[</span>-r<span class="token punctuation">]</span> LinuxPath_beCopied LinuxPath_toThePlace<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        -r 递归复制文件</p><p>​        第一个Path表明被复制的对象，第二个表示的是复制到何处。</p><p><img src="image-20230415223633861.png" alt="image-20230415223633861"></p><p>​        而mv:即是 move 的缩写了！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> LinuxPath/FileName<span class="token punctuation">(</span>or dirName<span class="token punctuation">)</span> LinuxPathDir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        当然目标不存在的话就会改名保证目标的存在</p><p><img src="image-20230415223930574.png" alt="image-20230415223930574"></p><p>​        <img src="image-20230415224110470.png" alt="image-20230415224110470"></p><p>​        看，1.txt就被改成3.txt了</p><p>​        rm命令就是remove，表明删除</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> <span class="token punctuation">[</span>-r -f<span class="token punctuation">]</span> file1 dir1 file2 dir2 <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        -r :递归删除，可以用来删除文件夹</p><p>​        -f: 强迫删除，不需要询问，都可以删！（force）</p><p>​        如此多的参数就是我们想要删除的内容，使用空格隔开</p><p><img src="image-20230415224446501.png" alt="image-20230415224446501"></p><p><img src="image-20230415224550942.png" alt="image-20230415224550942"></p><p>​        rm支持通配符*用来进行模糊搜索：如</p><p>​        test*表明以test开头的所有文件</p><p>​        *test表示以test结尾的所有文件</p><p>​        <em>test\</em>表所有包含了test这个子字符串的文件名</p><h2 id="which和find"><a href="#which和find" class="headerlink" title="which和find"></a>which和find</h2><p>​        我们知道，Linux下的大部分命令就是程序代码，which则会告诉我们这些程序的二进制代码在哪里</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">which</span> instName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230415225204867.png" alt="image-20230415225204867"></p><p>​        Find既是搜索指定的文件名查找</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> PathStart <span class="token parameter variable">-name</span> <span class="token string">"fileNameBeSearched"</span> // 文件名查找<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230415225404584.png" alt="image-20230415225404584"></p><p>​        (Permisson denied 表明权限不够，回开root的开root试试)</p><p><img src="image-20230415225529928.png" alt="image-20230415225529928"></p><p>​        这个也支持模糊查找！具体的不再演示</p><p>​        另一个find即是：按照大小查找：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> pathStart <span class="token parameter variable">-size</span> +<span class="token operator">|</span>- n<span class="token punctuation">[</span>KMG<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        +表大于 - 表小于，后面带上数字和单位表大小（k(小写！！)多少KB，MB，GB）</p><p><img src="image-20230415230150000.png" alt="image-20230415230150000"></p><h2 id="grep-与-wc"><a href="#grep-与-wc" class="headerlink" title="grep 与 wc"></a>grep 与 wc</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">grep</span> <span class="token punctuation">[</span>-n<span class="token punctuation">]</span> 关键字 文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        &gt;这里有可选参数 -n 表明在结果之中显示匹配的行的行号。</p><p>​        关键字参数时，表明查询的关键字，如果含有特殊符号请使用“”括起来</p><p>​        文件路径 表文件路径，可以作为内容输入端口</p><p><img src="image-20230416103713665.png" alt="image-20230416103713665"></p><p>​        wc做字符统计</p><pre class="line-numbers language-none"><code class="language-none">wc [-c -m -l -w] 文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        -c  : 统计bytes数量</p><p>​        -m 统计字符数量</p><p>​        -l 统计行数</p><p>​        -w 统计单词数量</p><p>​        文件路径那自然指向的时被统计文件，可以作为输入端的端口</p><p><img src="image-20230416105615266.png" alt="image-20230416105615266"></p><p>​        单词是用空格划分的！这是我们需要注意的。</p><h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h2><p>​        我们现在尝试管道符：他正是表示的是将左边命令的结果作为右边命令的输入。</p><p><img src="image-20230416110106424.png" alt="image-20230416110106424"></p><p><img src="image-20230416110206546.png" alt="image-20230416110206546"></p><p>​        这个表明的是将检索到的内容来统计行数</p><h2 id="echo命令输出内容"><a href="#echo命令输出内容" class="headerlink" title="echo命令输出内容"></a>echo命令输出内容</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> 输出的内容<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230416110707817.png" alt="image-20230416110707817"></p><p>​        当然有特殊符号请用 “ “来括起来。</p><p>​        想要让他作为命令输出，如输出pwd的内容，加上`</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">pwd</span><span class="token variable">`</span></span> // 没什么用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="重定向符号-gt-与-gt-gt"><a href="#重定向符号-gt-与-gt-gt" class="headerlink" title="重定向符号 &gt; 与&gt;&gt;"></a>重定向符号 &gt; 与&gt;&gt;</h2><p>​        &gt; :将左侧命令的结果覆盖到符号右侧的指定文件</p><p>​        &gt;&gt; : 将左侧命令的结果追加到符号右侧的指定文件</p><p><img src="image-20230416111428026.png" alt="image-20230416111428026"></p><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tail</span> <span class="token punctuation">[</span>-f -num<span class="token punctuation">]</span> LinuxPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数，Linux的路径，这表示的是被跟踪的文件路径</p><p>​        -f 表示持续跟踪</p><p>​        -num 表示查看多少行，不填就是10行</p><p><img src="image-20230416111911011.png" alt="image-20230416111911011"></p><p><img src="image-20230416111948298.png" alt="image-20230416111948298"></p><p><img src="image-20230416112026385.png" alt="image-20230416112026385"></p><p><img src="image-20230416112203086.png" alt="image-20230416112203086"></p><h2 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h2><p>​        这是最经典的文本编辑器</p><p>​        下面开始介绍：</p><p>​        Command mode命令模式：这里所有的输入编辑器都理解为命令，从而驱动执行不同的功能</p><p>​        Insert mode： 我们可以对文编编辑</p><p>​        Last Line mode : 用 : 作为起头，通常用在文件的保存和退出</p><p><img src="image-20230416112744542.png" alt="image-20230416112744542"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>// <span class="token function">vim</span> LinuxPath<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        如果文件不存在就会创建一个新的文件，要不就会打开已经存在的文件。</p><p>​        一般打开的时候，会默认在命令模式。想要编写文件，必须先敲入 i 进入插入模式。</p><p>编辑结束后 esc 即可</p><p><img src="image-20230416113105108.png" alt="image-20230416113105108"></p><p><img src="image-20230416113210159.png" alt="image-20230416113210159"></p><h2 id="Root权限"><a href="#Root权限" class="headerlink" title="Root权限"></a>Root权限</h2><p>​        拥有最大的权限就是root.我们几乎做任何事情都不会受到阻挠。进入的方式就是</p><pre class="line-numbers language-none"><code class="language-none">su root&gt;&gt;&gt; encode your password in the Linux[root@...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        su 就是账户切换的系统命令，switch user</p><pre class="line-numbers language-none"><code class="language-none">su [-] -usrName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个符号是可选的，是用来加载环境变量的，建议带上</p><p>​        可以用exit指令退回到上一个用户，快捷键是 ctrl + d</p><pre class="line-numbers language-none"><code class="language-none">sudo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        用户临时使用root权限。</p><p><img src="image-20230416114249475.png" alt="image-20230416114249475"></p><h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><p>​        我们可以配置多个用户和用户组。用户也可以加入多个用户组。在Linux下，权限管控分为针对用户的权限控制和针对用户组的权限控制。</p><h3 id="创建与删除用户组"><a href="#创建与删除用户组" class="headerlink" title="创建与删除用户组"></a>创建与删除用户组</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">groupadd</span> groupname <span class="token comment"># in root</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">groupdel groupname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="用户的操作"><a href="#用户的操作" class="headerlink" title="用户的操作"></a>用户的操作</h3><p>1）useradd [-g -d]用户名</p><p>-g 用于指定用户所在的组，不指定-g会创建同名的组并让其进入这个组，注意如果指定的了的话必须组是存在的</p><p>-d 用于指定home在哪里，不写就是: /home/usrname</p><p><img src="image-20230416115407673.png" alt="image-20230416115407673"></p><p>2)userdel [-r] usrname</p><p>​        -r就是同时删除其用户的home文件夹</p><p>3)id [usrname]</p><p>​        查看自己所在的用户组，带上可选参数usrname就是查看 usrname 的用户组</p><p>4）usermod -aG 将指定的用户加到指定的用户组</p><p>5）getend 查看当前系统有哪些用户。</p><h2 id="查看权限工作"><a href="#查看权限工作" class="headerlink" title="查看权限工作"></a>查看权限工作</h2><p>在root下，输入ls -l即可：</p><p><img src="image-20230416120246176.png" alt="image-20230416120246176"></p><p><img src="image-20230416120355916.png" alt="image-20230416120355916"></p><p>其中：r有读权限 w有写权限 x有执行权限</p><p>当然具体来说也可能会有写不同：</p><p><img src="image-20230416120458085.png" alt="image-20230416120458085"></p><h2 id="修改权限控制"><a href="#修改权限控制" class="headerlink" title="修改权限控制"></a>修改权限控制</h2><p>chmod</p><p><img src="image-20230416120610230.png" alt="image-20230416120610230"></p><p><img src="image-20230416120725024.png" alt="image-20230416120725024"></p><p>chown </p><p><img src="image-20230416120752474.png" alt="image-20230416120752474"></p><h2 id="一些快速操作快捷键"><a href="#一些快速操作快捷键" class="headerlink" title="一些快速操作快捷键"></a>一些快速操作快捷键</h2><p>Ctrl + c强制停止</p><p>Ctrl + d 退出账户</p><p>history: 查看历史执行的命令， !命令前缀，自动执行从后往前的找到第一个匹配前缀的指令</p><p><img src="image-20230416121054792.png" alt="image-20230416121054792"></p><p><img src="image-20230416121101651.png" alt="image-20230416121101651"></p><p><img src="image-20230416121123675.png" alt="image-20230416121123675"></p><p><img src="image-20230416121152194.png" alt="image-20230416121152194"></p><p><img src="image-20230416121219359.png" alt="image-20230416121219359"></p><p><img src="image-20230416121319303.png" alt="image-20230416121319303"></p><p><img src="image-20230416121350614.png" alt="image-20230416121350614"></p><p><img src="image-20230416121411677.png" alt="image-20230416121411677"></p><p><img src="image-20230416121432968.png" alt="image-20230416121432968"></p><p><img src="image-20230416121446642.png" alt="image-20230416121446642"></p><p><img src="image-20230416121528040.png" alt="image-20230416121528040"></p><p><img src="image-20230416121543781.png" alt="image-20230416121543781"></p><p><img src="image-20230416121622511.png" alt="image-20230416121622511"></p><p><img src="image-20230416121635041.png" alt="image-20230416121635041"></p><p><img src="image-20230416121702592.png" alt="image-20230416121702592"></p><p><img src="image-20230416121713490.png" alt="image-20230416121713490"></p><p><img src="image-20230416121736563.png" alt="image-20230416121736563"></p><p><img src="image-20230416121748284.png" alt="image-20230416121748284"></p><p><img src="image-20230416121823770.png" alt="image-20230416121823770"></p><p><img src="image-20230416121835516.png" alt="image-20230416121835516"></p><p><img src="image-20230416121849522.png" alt="image-20230416121849522"></p><p><img src="image-20230416121904518.png" alt="image-20230416121904518"></p><p><img src="image-20230416121932632.png" alt="image-20230416121932632"></p><p><img src="image-20230416121949219.png" alt="image-20230416121949219"></p><p><img src="image-20230416122008858.png" alt="image-20230416122008858"></p><p><img src="image-20230416122034234.png" alt="image-20230416122034234"></p><p>​        这个有点像Windows下的PATH</p><p><img src="image-20230416122057738.png" alt="image-20230416122057738"></p><p><img src="image-20230416122108863.png" alt="image-20230416122108863"></p><p><img src="image-20230416122125643.png" alt="image-20230416122125643"></p><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><p><img src="image-20230416122233062.png" alt="image-20230416122233062"></p><p><img src="image-20230416122248474.png" alt="image-20230416122248474"></p><p><img src="image-20230416122257252.png" alt="image-20230416122257252"></p><p><img src="image-20230416122319744.png" alt="image-20230416122319744"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解递归系列(2)</title>
      <link href="/2023/04/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97-2/"/>
      <url>/2023/04/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97-2/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解递归2"><a href="#深入理解递归2" class="headerlink" title="深入理解递归2"></a>深入理解递归2</h1><p>​        回忆一下，递归的本质就是函数的调用，而且特别的，是调用他自己，为了防止根本停不下来的调用，我们必须提供一个函数的递归出口——这正是我们之前所阐述的！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;&#x2F;&#x2F; 如果你忘记了的话，看看这个复习一下吧！void printRecur(const int* array, unsigned int start, unsigned int end)&#123;if (array &#x3D;&#x3D; NULL) &#123;return;&#125;if (start &gt;&#x3D; end)&#123;return;&#125;cout &lt;&lt; array[start] &lt;&lt; &quot; &quot;;printRecur(array, start + 1, end);&#125;int main()&#123;int arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;printRecur(arr, 0, 10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面继续哔哔新东西！</p><p>​        我们刚刚一直在说系统栈，可不可以书写一个函数来实现我们的系统栈功能呢？可以的：</p><p>​        改造上面的代码为如下，详细的解说请参看代码的注释！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void imitateSysRecur(const int* array, unsigned int start, unsigned int end)&#123;cout &lt;&lt; &#39;\n&#39;;stack&lt;int&gt;* sys &#x3D; new stack&lt;int&gt;();&#x2F;&#x2F; 创造一个空栈sys-&gt;push(array[start]);&#x2F;&#x2F; 这里等效做函数的第一次调用while (!sys-&gt;empty())&#x2F;&#x2F; 查看有没有弹出干净，没有继续弹出！&#123;int prt &#x3D; sys-&gt;top();&#x2F;&#x2F; 一下就弹出第一个任务if (start &gt;&#x3D; end)return;printf(&quot;%d &quot;, prt); &#x2F;&#x2F; 对之执行操作sys-&gt;push(array[++start]);&#x2F;&#x2F; 转向下一个&#125;&#125;int main()&#123;int arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;imitateSysRecur(arr, 0, 10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="虽说递归爽，但是注意到性能问题！"><a href="#虽说递归爽，但是注意到性能问题！" class="headerlink" title="虽说递归爽，但是注意到性能问题！"></a>虽说递归爽，但是注意到性能问题！</h2><p>​        递归也有代价：写的爽必然有代价。</p><p>​        首先函数调用就有时间的开销（注意到递归反复调用函数）</p><p>​        其次，这也存在空间上的开销！我们需要占一定的空间复杂度来运行我们的函数。</p><p>​        那么，什么时候使用递归呢？预告一下：正是那些非线性的数据结构我们使用递归来处理，这将会在树与图论中显的常见！</p><h2 id="练习1：递归求解线性表：如数组的和"><a href="#练习1：递归求解线性表：如数组的和" class="headerlink" title="练习1：递归求解线性表：如数组的和"></a>练习1：递归求解线性表：如数组的和</h2><p>​        首先，我们来看，对于一个线性表，我们若是想得知这些元素的和：</p><script type="math/tex; mode=display">A = \sum_{i=0}^{n-1}a[i]</script><p>​        然而马上发现，这个表达式可以写作：</p><script type="math/tex; mode=display">A = \sum_{i=0}^{n-1}a[i] = a[n-1] + \sum_{i=0}^{n-2}a[i]</script><p>​        啊哈！这递归就出来了：终止条件就是当取到 arr[0]时停止！，这样就可以开始设计递归了。</p><p>​        我们的结果可以存放在函数的参数列表里，这样的话递归不用开辟新的空间存放局部变量！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long getSumRecur(const int* arr, unsigned int arrSize,int curSum)&#x2F;&#x2F; 设计1&#123;if (arr &#x3D;&#x3D; nullptr) &#x2F;&#x2F; 不合法的数组return&#123;return -1;&#x2F;&#x2F; 这个地方放错误处理，可以是cstdlib下的exit!&#125;if (arrSize &#x3D;&#x3D; -1) &#x2F;&#x2F; 即将越界&#123;return curSum; &#x2F;&#x2F; 求和结束，直接返回当下参数的curSum就好了&#125;getSumRecur(arr, arrSize - 1, curSum + arr[arrSize]);    &#x2F;&#x2F; 递归！ 让arrSize减1， 表明arr[size-1]已经纳入和 curSum 了！    &#x2F;&#x2F; 同时，在参数列表中做出 curSum + arr[arrSize]的修改就好了&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样的递归适合与有前缀初始值的求和！</p><p>​        有没有别的形式的？有。直接注意到：没有必要新增一个参数，而是直接return掉局部和！就是说：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">return arr[size] + getCur2(arr,size-1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为为了返回，必须要把getCur2的值求出来，一直递归到函数不需要调用自己为止！那就很是容易了，只要curSize == 0,返回 arr[curSize]就好了！（其实就是arr[0]）</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">long getSumRecur2(const int* arr,int arrSize)&#123;if (arr &#x3D;&#x3D; nullptr) &#123;return -1;&#125;if (arrSize &#x3D;&#x3D; 0)&#123;return arr[0];&#125;return arr[arrSize] + getSumRecur2(arr, arrSize - 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        run 一下代码！</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;int arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;cout &lt;&lt; getSumRecur(arr, 9, 0)&lt;&lt; endl;cout &lt;&lt; getSumRecur2(arr, 9) &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230412214901272.png" alt="image-20230412214901272"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas in Python</title>
      <link href="/2023/04/13/Pandas-in-Python/"/>
      <url>/2023/04/13/Pandas-in-Python/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 这里是我随手写的Pandas API 的一些笔记，为了省事直接拷贝于此！</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> pandas<span class="token triple-quoted-string string">'''this is a pandas demoto show basic API of pandasto install the lib ...pip:    pip install pandas IN terminal    or if conda is available in your operating system, using    conda install pandas == version_you_want_to_install    '''</span><span class="token triple-quoted-string string">'''Pandas 1 : using this sentence to show the version of pandas:>'''</span><span class="token keyword">print</span><span class="token punctuation">(</span>pandas<span class="token punctuation">.</span>__version__<span class="token punctuation">)</span><span class="token comment"># Sections1: Series</span><span class="token triple-quoted-string string">'''Series in pandas is considered as a data structure with indexAs D &amp; Alg has already pointed out, index can be string or just numbersin pandas, it's the same'''</span><span class="token triple-quoted-string string">'''---------------------------------------------------------------------------------    the creation of series---------------------------------------------------------------------------------'''</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this is to create a series by using two ways'</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">''' to check, try to run it in terminal '''</span><span class="token comment"># this is a list</span>height_among_stu_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">131</span><span class="token punctuation">,</span> <span class="token number">141</span><span class="token punctuation">,</span> <span class="token number">182</span><span class="token punctuation">,</span> <span class="token number">109</span><span class="token punctuation">,</span> <span class="token number">178</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>height_among_stu_list<span class="token punctuation">)</span><span class="token comment"># this is a series</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Series is gonna printed:>\n"</span><span class="token punctuation">)</span>height_series <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>height_among_stu_list<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>height_series<span class="token punctuation">)</span><span class="token comment"># we can set a name of a series:></span>set_name <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'An Increasing subsequence'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>set_name<span class="token punctuation">)</span><span class="token comment"># Back to what I said before... series is a data structure with index... maybe hashSet or hash table?</span>val <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>label <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span>set_with_label <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>val<span class="token punctuation">,</span> index<span class="token operator">=</span>label<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>set_with_label<span class="token punctuation">)</span><span class="token comment"># if you are serious about the index list, use series.index to gain a result:></span><span class="token keyword">print</span><span class="token punctuation">(</span>set_with_label<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token comment"># another quick way to create a series is to use a dictionary as input</span>dic <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token number">111</span><span class="token punctuation">,</span>    <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token number">222</span><span class="token punctuation">,</span>    <span class="token string">'C'</span><span class="token punctuation">:</span> <span class="token number">333</span><span class="token punctuation">,</span>    <span class="token string">'D'</span><span class="token punctuation">:</span> <span class="token number">444</span><span class="token punctuation">&#125;</span>ser_dic <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>dic<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ser_dic<span class="token punctuation">)</span><span class="token comment"># here comes an interesting questions:> what if we have 3 inputs but owns four labels? have a try...</span>dic <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token string">'A'</span><span class="token punctuation">:</span> <span class="token number">111</span><span class="token punctuation">,</span>    <span class="token string">'B'</span><span class="token punctuation">:</span> <span class="token number">222</span><span class="token punctuation">,</span>    <span class="token string">'C'</span><span class="token punctuation">:</span> <span class="token number">333</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>ser_dic_loss <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>dic<span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>ser_dic_loss<span class="token punctuation">)</span><span class="token comment"># we get a nan as result! NAN in pandas means a loss of number. We are supposed to make a deal with it!</span><span class="token comment"># another creation , especially for vals, is to do in this way:>1</span>set_num <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>set_num<span class="token punctuation">)</span><span class="token comment"># we see the labels own the same value of 10...</span><span class="token triple-quoted-string string">'''-----------------------------------------------------------------------------------    the usage of index and its relative API-----------------------------------------------------------------------------------'''</span><span class="token comment"># usually, when we visit a hash set, we do visit elements by offering a label.</span><span class="token comment"># for example, we can get 'A' by inputting 1 in a hash set:></span><span class="token comment"># for series in pandas, things got the same...</span>dic_for_search <span class="token operator">=</span> dicsetSearch <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>dic_for_search<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Print the key by the visitor[]"</span><span class="token punctuation">)</span><span class="token comment"># this for loop is to visit elements in series</span>searchLabels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">[</span>searchLabels<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># but if the key is hard to get, while it's relatively easy to know the position,</span><span class="token comment"># this API is just for the case:> called 'iloc': i locations in other words...</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># differently, we can output the suitable value by just inputting the logical expression in []</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this key - val set is a set which the val is above 222"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">[</span>setSearch <span class="token operator">></span> <span class="token number">222</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># Also, if the val is supported to make basic calculations, we can operate all the elements by...</span>setSearch <span class="token operator">+=</span> <span class="token number">222</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># here comes a big difference comparing list in python and series in pandas</span>mylist <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>mylist<span class="token punctuation">)</span>mylist <span class="token operator">+=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>mylist<span class="token punctuation">)</span><span class="token comment"># See , we actually directly append the elements backward to the mylist</span><span class="token comment"># while this one is...</span>setSearch <span class="token operator">+=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># add the elements to all the vals instead of appending</span><span class="token triple-quoted-string string">'''----------------------------------------------------------------------------------------------            index----------------------------------------------------------------------------------------------'''</span><span class="token comment"># index has variety of types</span><span class="token comment"># when we do not offer a coefficient of index in the initialization, pandas will</span><span class="token comment"># automatically use RangeIndex</span>val <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>a <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>val<span class="token punctuation">)</span>b <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>val<span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">)</span>c <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'abcde'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>index<span class="token punctuation">)</span><span class="token triple-quoted-string string">''' VAlS in pandas '''</span><span class="token comment"># 1 iloc and loc</span><span class="token comment"># loc is [ ] while iloc is [ )</span><span class="token comment"># no examples... as they have been used previously</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is the size:> "</span><span class="token punctuation">,</span> setSearch<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token comment"># is_unique:> if there is the same elem in the set, return false, else return true</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">.</span>is_unique<span class="token punctuation">)</span><span class="token comment"># we can modify the elements by offering the key name:></span>setSearch<span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10000</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># also it can be multipy:></span>setSearch<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">:</span><span class="token string">'C'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">20000</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># back to the way of appending the series: by just offering a new key with value:></span>setSearch<span class="token punctuation">[</span><span class="token string">'E'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2000000</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># or using the api: append</span>appender <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10000000</span><span class="token punctuation">,</span><span class="token number">20000000</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'G'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>setSearch<span class="token punctuation">.</span>append<span class="token punctuation">(</span>appender<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''-----------------------------------------------------------------------------------------------------                                        del-----------------------------------------------------------------------------------------------------'''</span><span class="token comment"># use del directly to erase the elements</span><span class="token keyword">del</span> setSearch<span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># or use tha api in pandas:></span>setSearch<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>index<span class="token operator">=</span><span class="token string">'B'</span><span class="token punctuation">,</span> inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>setSearch<span class="token punctuation">)</span><span class="token comment"># if we want to erase the duplicate elements, use:></span>duplicate <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>index<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'abcdef'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>duplicate<span class="token punctuation">)</span>duplicate <span class="token operator">=</span> duplicate<span class="token punctuation">.</span>drop_duplicates<span class="token punctuation">(</span>keep<span class="token operator">=</span><span class="token string">'first'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>duplicate<span class="token punctuation">)</span><span class="token comment"># duel and check the NAN</span>aNAN <span class="token operator">=</span> pandas<span class="token punctuation">.</span>Series<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>NaN<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>NaN<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>NaN<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token string">'abcdef'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>aNAN<span class="token punctuation">.</span>isna<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># use dropna() can be a good choice to erase the invalid data</span>aNAN <span class="token operator">=</span> aNAN<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>aNAN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解递归系列（1）</title>
      <link href="/2023/04/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89/"/>
      <url>/2023/04/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解递归系列（1）"><a href="#深入理解递归系列（1）" class="headerlink" title="深入理解递归系列（1）"></a>深入理解递归系列（1）</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><a href="https://blog.csdn.net/charlie114514191/article/details/130049282">(43条消息) 深入理解递归系列（1）_charlie114514191的博客-CSDN博客</a></p><p>​        我们在学习与工作中，常常看到这样递归。是的，递归让代码变得简洁，复用率更高。但是我们往往不会很好的使用递归（包括我，QAQ）。 一般来讲，这可能是不知道递归的本质是函数调用，不清晰函数调用的本质造成的，其次，我们很容易陷入递归里去出不来了，搞不清楚当前的状态，也即是：搞错了方向。宏观把控更为重要（后面会细说）</p><p>​        简单来讲，函数体内一次递归是对线性数据结构的遍历处理，二次递归是对二叉树数据结构的递归处理。多次递归是对多叉树进行处理。但这样讲还是抽象，我们先不从应用层面而是转向原理层面来了解递归！</p><h2 id="从栈讲起！"><a href="#从栈讲起！" class="headerlink" title="从栈讲起！"></a>从栈讲起！</h2><p>​        有点莫名奇妙，我们为什么要从栈讲起呢？这是为了后面的系统函数调用栈做准备，如果对栈比自己喜欢吃啥都熟悉，建议移步到系统调用栈下面去。</p><p>​        其实他不是什么新东西，只是一个受到了限制的数据结构（数组，单链表）等。什么意思呢》以数组为例，数组可以在结构的两端插入元素，链表同理。但是现在我们规定我们只能从一端来操作数据结构。举个例子。现在我们要往一个数组里扔东西。对于一个一般的数组，我爱怎么扔怎么扔。但是对于栈来讲，他只能如下图所示的这样的放入数组或者弹出数组。这样受限的数据结构正是栈。</p><p><img src="image-20230409112854441.png" alt="image-20230409112854441"></p><p>​        可以看到，我们把插入和删除换成了 push back 和 pop out. 在栈里，这样的行为叫压栈和弹栈。</p><pre class="line-numbers language-none"><code class="language-none">往栈里放入元素的过程叫压栈往栈里弹出元素的过程叫弹栈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        而且，我们只可以对最上面的元素展开操作而不能对下面的元素操作。这样的特点从动态角度来看，不正是后进先出嘛！就是说，最后进入栈的必须第一个出栈</p><p><img src="image-20230409113920536.png" alt="image-20230409113920536"></p><p>​        至于栈的实现如何，这里不做说明，可以看我搞的其他博客或者自行查询怎样实现。</p><h2 id="系统函数调用栈"><a href="#系统函数调用栈" class="headerlink" title="系统函数调用栈"></a>系统函数调用栈</h2><p>​        可以说，栈的一个在操作系统级别的应用，就是系统函数的调用栈。话说的太抽象了，来看个例子！</p><p>​        今天我们需要书写一个程序，很简单，不难的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt; &#x2F;&#x2F; 不熟悉这个的，理解为python 的 import 包就可以了！int getModFrom2Int(int num1,int num2)&#123;    return a % b; &#x2F;&#x2F; 函数执行取余数的操作，并将其返回！&#125;int getAddOf2Int(int num1,int num2)&#123;    int resFromMod &#x3D; getModFrom2Int(num1,num2);    return resFromMod + b;&#125;int main() &#x2F;&#x2F; 程序入口&#123;    int a &#x3D; 3;    int b &#x3D; 2;    int c &#x3D; getAddOf2Int(a,b); &#x2F;&#x2F;     printf(&quot;%d&quot;,c); &#x2F;&#x2F; print the num on console控制台的打印    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是一份简单的C语言代码。从程序运行的顺序来看：程序从 main 进入，经过初始化 a,b的时候，准备初始 c ，但是注意到，c的初始化是由<code>getAddOf2Int</code>这个函数的返回值赋值的，意味着程序必须要进入函数当中。 当程序执行到<code>getAddOf2Int</code>里，他马上又发现， 里头的另一个变量 res ，需要调用函数<code>getModFrom2Int</code>来解决。程序又跳转到<code>getModFrom2Int</code>里去，终于我们不折腾了，对 作为实参的 a, b 取完余数就直接扔回去（优雅的讲叫返回结果指调用处），res 得到了值 3 % 2 = 1，随后，<code>getAddOf2Int</code>又把res和 b 再次相加， 作为<code>getAddOf2Int</code>返回去了，显然这是 3。分析结束，是不是这样呢？我们在Linux下跑一下代码！</p><p>​        如果不知道怎么搞，就这样</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 找到一个文件夹，进入到里面，打开终端 open in terminal</span><span class="token operator">>></span><span class="token operator">></span> <span class="token function">vim</span> runCode1.c<span class="token comment">#书写代码， 当然不熟悉的话，先摁i进入编辑模式随后输入代码</span><span class="token comment"># 写完了退出去，方法是：摁esc，输入:wq退出</span><span class="token operator">>></span><span class="token operator">></span> gcc runCode1 <span class="token comment">#没有就跟提示 sudo apt install gcc</span><span class="token comment"># 没有指定可执行文件，会自动生成 a.out</span><span class="token operator">>></span><span class="token operator">></span> ./a.outres: <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230409204340812.png" alt="image-20230409204340812"></p><p>​        找到你的可执行文件，不然就会出现如上图各种各样的报错。我们的分析没有大问题。</p><p>​        可是这跟我们的主题有什么关系呢？别着急，现在就来问你，怎么实现的？怎么让函数按部就班的调用，返回呢？答案就是系统调用函数栈</p><p>​        很好，我们遇到一个函数就把函数地址（函数在哪）压到里面去！直到程序不在调用新的函数（最后一个入栈的不调函数了！）开始逐级返回，函数出栈！</p><p><img src="image-20230409205354471.png" alt="image-20230409205354471"></p><p>​        这些函数在栈里，就用这里的属于说话吧！他们叫栈帧，如同视频一般，一帧一帧展示调用返回。</p><p>​        栈帧是一个复杂的复合体，一般而言他有三个部分构成！</p><p>​        1.函数参数，如 main 函数没有函数参数，而<code>getAddOf2Int</code>有两个参数 num1 ,num2</p><p>​        2.局部变量，如 main 函数里有 a, b ,c 三个在函数体内的变量，<code>getAddOf2Int</code>里有个res 来接受 Mod 函数的返回值。</p><p>​        3.(不好理解)返回地址。这是干嘛的呢？我们在文本编辑器里，可以直观的看到…</p><p><img src="image-20230409210330240.png" alt="image-20230409210330240"></p><p>但是对于CPU来讲，它进到getModFrom2Int里，再次出来的时候不知道下一条指令在哪里。于是，需要存储下一条指令（return resFromMod + num2）的指令地址，方便CPU从其他函数调用之后又再次回来时找到继续执行的地方.</p><p><img src="image-20230409210832275.png" alt="image-20230409210832275"></p><p>​        什么？口说无凭？上汇编！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">objdump <span class="token parameter variable">-S</span> a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>A</p><p><img src="image-20230409211229724.png" alt="image-20230409211229724"></p><p>​        留心到 callq 指令，这是函数调用的指令。函数执行完毕，CPU直接读取栈帧的存储返回地址继续走。</p><h2 id="步入正题！函数调用自己！（就是递归）"><a href="#步入正题！函数调用自己！（就是递归）" class="headerlink" title="步入正题！函数调用自己！（就是递归）"></a>步入正题！函数调用自己！（就是递归）</h2><p>​        我们学习完基本的函数调用之后，有没有一个大胆的想法：函数可不可以调他自己呢？试试！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std;int main()&#123;cout &lt;&lt; &quot;Lol, I am calling myself again and again!&quot;;Sleep(500); &#x2F;&#x2F; 加个这个，防止程序栈炸了main();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230409212333392.png" alt="image-20230409212333392"></p><p>​        是的，尝试自己调用自己！这个函数正在不停的调用他自己，直到函数调用栈溢出崩溃。</p><p><img src="image-20230409213106889.png" alt="image-20230409213106889"></p><p>​        歪！不能这样啊，那咋办，简单，来个中止条件就可以了！简单加个出口。方法就是引入一个计数器，来控制调用次数</p><p><img src="image-20230409213315526.png" alt="image-20230409213315526"></p><p>​        就调用了十次，很好！</p><p>​        当然，没人，除非是真的需要，会对主函数干这种事情。事实上，以递归执行的函数的调用计时器往往放在参数列表里，通过检测参数来停止函数调用</p><p>​        比如说，打印函数3次：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void PrintinLimits(int times)&#123;if (times &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; if time is used up,process exited by returning val directlyreturn;&#125;cout &lt;&lt; &quot;Calling for times:&gt;&quot; &lt;&lt; times &lt;&lt; &#39;\n&#39;;PrintinLimits(times - 1); &#x2F;&#x2F; 次数减1，趋向于停止（0就跳出去了）return;&#125;int main()&#123;PrintinLimits(3);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230409214645855.png" alt="image-20230409214645855"></p><p>所以，到底怎么回事，还是回到调用栈上</p><p><img src="image-20230409215339623.png" alt="image-20230409215339623"></p><p>​        比如说我们今天不好好写高斯求和函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;windows.h&gt;using namespace std;static int callLimits &#x3D; 10;long GaussainSumInRecurssion(int curAdder)&#123;if (curAdder &#x3D;&#x3D; 0) &#123;return 0;&#125;return curAdder + GaussainSumInRecurssion(curAdder-1);&#125;int main()&#123;cout &lt;&lt; GaussainSumInRecurssion(10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230409214756137.png" alt="image-20230409214756137"></p><p>​        是跟上面同理的，但是这个是尾递归，不好理解，我们先不去分析。</p><p>​        仿照这一思路，打印数组也有花样！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void printArrayInRecur(int* array, unsigned int arraySize)&#123;if (arraySize &#x3D;&#x3D; 0) &#123;return;&#125;cout &lt;&lt; array[arraySize - 1] &lt;&lt; &quot; &quot; ; &#x2F;&#x2F; for correctly print&#x2F;&#x2F; 数组下标从0开始，减个一！printArrayInRecur(array, arraySize - 1);return;&#125;int main()&#123;int array[4] &#x3D; &#123;1,2,3,4&#125;;printArrayInRecur(array, 4);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230409215928720.png" alt="image-20230409215928720"></p><p>​        手动实现了倒序打印！</p><p>​        那正序呢？</p><p><img src="image-20230409220243255.png" alt="image-20230409220243255"></p><p>​        就这样！下面的有空再开一个。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab自学专题1 -- 图像绘制(1)</title>
      <link href="/2023/04/07/Matlab%E8%87%AA%E5%AD%A6%E4%B8%93%E9%A2%981-%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6-1/"/>
      <url>/2023/04/07/Matlab%E8%87%AA%E5%AD%A6%E4%B8%93%E9%A2%981-%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Matlab自学专题1"><a href="#Matlab自学专题1" class="headerlink" title="Matlab自学专题1"></a>Matlab自学专题1</h1><h2 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h2><p>​        我们来做个假设，假设我们已经熟知了Matlab的矩阵操作，基础概念和基本编程框架。我们下面就开始来围绕Matlab的绘图展开说说。</p><h3 id="离散数据绘制"><a href="#离散数据绘制" class="headerlink" title="离散数据绘制"></a>离散数据绘制</h3><p>​        什么离散的数据呢？简而言之，就是单蹦的数据，而不是连续的数据。比若说【1，2，3，4，5，6】这就是离散的数据，而集合{x | 9 &gt; x &gt; 6}就不是离散的，而是连续的。换而言之，一个简单的说法，正是这些数据要是可数可列的，我们才说他们是离散的。</p><p>​        现在，打开我们的matlab，来尝试绘制一下离散的数据。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">clear all# 清除所有的变量X1 <span class="token operator">=</span> <span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span> # 产生一个从 <span class="token number">1</span> 到 <span class="token number">100</span> 的离散行向量Y1 <span class="token operator">=</span> <span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span> # 产生一个从 <span class="token number">2</span> 到 <span class="token number">200</span> 的离散行向量<span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span># 注意，这是指绘制在第一个弹窗上，可以用一个变量接受返回值！自行查看他是啥吧！<span class="token function">plot</span><span class="token punctuation">(</span>X1<span class="token punctuation">,</span>Y1<span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'MarkerSize'</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span> # 绘图关键指令，他表示绘制一个 Y <span class="token operator">-</span> X 离散关系图， 这个MarkerSize就是点画多大<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230407125527093.png" alt="image-20230407125527093"></p><h3 id="连续函数"><a href="#连续函数" class="headerlink" title="连续函数"></a>连续函数</h3><p>​        下面，我们来尝试一下，绘制连续的函数。</p><p>​        注意到，matlab没有那么聪明，可以不带脑子的直接传入函数就直接帮你开画的，我们回顾函数绘制的一般办法，那就是，转向通过化连续 为 离散的变量 的关系来绘制函数，说白了，就是使用足够密集的点来绘制图像。这不正是我们从离散推向连续的过程嘛！</p><p>​        我们只需要像手绘函数图像那样，离散的点出 $[X_i, Y_i ]$那样就好了。那样的话：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">clear all# 划定X的范围， Y的离散值（第一个函数）X1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">144</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">72</span><span class="token punctuation">;</span>Y1 <span class="token operator">=</span> <span class="token number">3</span><span class="token operator">*</span><span class="token function">cos</span><span class="token punctuation">(</span>X1<span class="token punctuation">)</span><span class="token punctuation">;</span># 划定X的范围， Y的离散值（第二个函数）X2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">1080</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">740</span><span class="token punctuation">;</span>Y2 <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>X2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span># subplot指令，这里是用来多图像绘制的，subplot正是子图像的意思<span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> # 一行几个？ 一共几行？ 这是第几个子图像？<span class="token function">plot</span><span class="token punctuation">(</span>X1<span class="token punctuation">,</span>Y1<span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'MarkerSize'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> # 函数用来限定X的绘制范围#下面雷同了。。。<span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token function">plot</span><span class="token punctuation">(</span>X1<span class="token punctuation">,</span>Y1<span class="token punctuation">,</span><span class="token string">'LineWidth'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token function">plot</span><span class="token punctuation">(</span>X2<span class="token punctuation">,</span>Y2<span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'MarkerSize'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token function">plot</span><span class="token punctuation">(</span>X2<span class="token punctuation">,</span>Y2<span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'LineWidth'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">xlim</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230407130913302.png" alt="image-20230407130913302"></p><p>​        当然，也不是那麽麻烦，实际上，这样也可以：</p><pre class="line-numbers language-none"><code class="language-none">X1 &#x3D; -pi&#x2F;2:0.001:pi&#x2F;2;Y1 &#x3D; x + sin(x) + exp(x);plot(X1,Y1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230407131223232.png" alt="image-20230407131223232"></p><p>​        好像这个不太好点对点啊，可不可以加上网格便于观察呢， 当然可以，加上点东西就好了！</p><p>​        首先介绍一下刚才一直没说的那个：plot里的那些’ xxx ‘是什么呢？ 查阅一下，发现是一个叫 PropertyName的东西，就是属性名称，比如说， MarkerSize 就是点的大小， 而 LineWidth 就是绘制图像线宽的属性名称，注意一定要输对，大小写都不要错（尽可能），后面跟上的就是属性值 PropertyValue 了。 当然有一个例外就是图形的样式。 这是不用说 PropertyName的，直接在输完X,Y 之后，直接用单引号括起来想要的款式。</p><p>​        来来，例子上了！</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">plot</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">,</span><span class="token string">'ro'</span><span class="token punctuation">)</span> # 就是对上面那个函数，加点东西就好了grid on #打开网格显示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230407131949917.png" alt="image-20230407131949917"></p><p>​        可是，就是这样拿给别人看，这不好。这是啥啊？？？不知道，含义是啥，不知道。可不可以加点注释呢？可以！</p><pre class="line-numbers language-none"><code class="language-none">title(&#39;I think this is a sample of 1dim image demonstration&#39;);xlabel(&#39;I am X&#39;);ylabel(&#39;I am Y, the function&#39;s val&#39;);legend(&#39;y &#x3D; x + sin(x) + e^x&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230407132306428.png" alt="image-20230407132306428"></p><p>​        很有意思了。 注意到legend 就是图例的意思！</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>​        我们绘制简单的离散数据与连续函数，使用的就是如下的步骤来完成我们的工作！</p><p>（1）准备数据， 就是准备好你的X Y</p><p>（2）确定好在那里画，第一个子图，还是哪里，但一定不是你的草稿纸！</p><p>（3）调用图像绘制函数来画！ plot是我们现在搞到的</p><p>（4）制定好坐标轴的范围</p><p>（5）添加绘制的属性（懒狗可以不管）</p><p>（6）添加一些注释（针对要不要做的话。。。你知道我要说什么）</p><p>（7）图像导出与展示</p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch 1</title>
      <link href="/2023/03/29/pytorch-1/"/>
      <url>/2023/03/29/pytorch-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Pytorch学习"><a href="#Pytorch学习" class="headerlink" title="Pytorch学习"></a>Pytorch学习</h1><h2 id="学习加载数据集"><a href="#学习加载数据集" class="headerlink" title="学习加载数据集"></a>学习加载数据集</h2><p>​        我们首先需要学会导入数据集。在Pytorch里，负责导入数据集的有两个大类：DataSet 和DataLoader.</p><p>​        DataSet 可以认为是提供一种方式来获取数据和对应的标签</p><p>​        DataLoader为后面的网络提供不同的数据形式（需要dataSet来作为源数据集）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Dataset</span><span class="token punctuation">(</span>Generic<span class="token punctuation">[</span>T_co<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">r"""An abstract class representing a :class:`Dataset`.    All datasets that represent a map from keys to data samples should subclass    it. All subclasses should overwrite :meth:`__getitem__`, supporting fetching a    data sample for a given key. Subclasses could also optionally overwrite    :meth:`__len__`, which is expected to return the size of the dataset by many    :class:`~torch.utils.data.Sampler` implementations and the default options    of :class:`~torch.utils.data.DataLoader`.    .. note::      :class:`~torch.utils.data.DataLoader` by default constructs a index      sampler that yields integral indices.  To make it work with a map-style      dataset with non-integral indices/keys, a custom sampler must be provided.    """</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T_co<span class="token punctuation">:</span>        <span class="token keyword">raise</span> NotImplementedError    <span class="token keyword">def</span> <span class="token function">__add__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token string">'Dataset[T_co]'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">'ConcatDataset[T_co]'</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> ConcatDataset<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">,</span> other<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># No `def __len__(self)` default?</span>    <span class="token comment"># See NOTE [ Lack of Default `__len__` in Python Abstract Base Classes ]</span>    <span class="token comment"># in pytorch/torch/utils/data/sampler.py</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到这是抽象类，需要我们重写DataSet 来运行：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> Dataset<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token keyword">import</span> os<span class="token keyword">class</span> <span class="token class-name">Mydata</span><span class="token punctuation">(</span>Dataset<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 准备一下路径</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>rootDir<span class="token punctuation">,</span>label_dir<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        :param rootDir: the root image source        :param label_dir: whether it is ants or bees        """</span>        self<span class="token punctuation">.</span>rootDir <span class="token operator">=</span> rootDir        self<span class="token punctuation">.</span>label_dir <span class="token operator">=</span>label_dir        self<span class="token punctuation">.</span>path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>rootDir<span class="token punctuation">,</span>self<span class="token punctuation">.</span>label_dir<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>imagePath <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>self<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token comment">#获取东西</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">:</span>        img_name <span class="token operator">=</span> self<span class="token punctuation">.</span>imagePath<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>        img_item_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>self<span class="token punctuation">.</span>path<span class="token punctuation">,</span>img_name<span class="token punctuation">)</span>        img <span class="token operator">=</span> Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span>img_item_path<span class="token punctuation">)</span>        label <span class="token operator">=</span> self<span class="token punctuation">.</span>label_dir        <span class="token keyword">return</span> img<span class="token punctuation">,</span>label    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>imagePath<span class="token punctuation">)</span>rootDir <span class="token operator">=</span> <span class="token string">"hymenoptera_data/train"</span>labelDir <span class="token operator">=</span> <span class="token string">"ants"</span>ants_dataset <span class="token operator">=</span> Mydata<span class="token punctuation">(</span>rootDir<span class="token punctuation">,</span>labelDir<span class="token punctuation">)</span>img<span class="token punctuation">,</span>label <span class="token operator">=</span> ants_dataset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>img<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="TensorBoard的基本使用"><a href="#TensorBoard的基本使用" class="headerlink" title="TensorBoard的基本使用"></a>TensorBoard的基本使用</h2><p>​        我们为了使用 tensorBoard可视化，需要在我们自己的源代码文件中引入 SummaryWriter类。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>tensorboard <span class="token keyword">import</span> SummaryWriter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们就是在这里实现可视化的！</p><p>​        来看看简介怎么说</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""Writes entries directly to event files in the log_dir to be   consumed by TensorBoard.   The `SummaryWriter` class provides a high-level API to create an event file   in a given directory and add summaries and events to it. The class updates the   file contents asynchronously. This allows a training program to call methods   to add data to the file directly from the training loop, without slowing down   training.   """</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        简单来讲。就是通过生成event file(事件文件)来预备可视化，在cmd或者是已经被激活的 pytorch环境下来整指令：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">tensorboard --logdir&#x3D;&lt;logFileName&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        SummaryWriter的构造函数（<strong> init </strong>()）是这样说的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>    self<span class="token punctuation">,</span> <span class="token comment"># this 指针一样的东西</span>    log_dir<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>    comment<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span>    purge_step<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span>    max_queue<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>    flush_secs<span class="token operator">=</span><span class="token number">120</span><span class="token punctuation">,</span>    filename_suffix<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Creates a `SummaryWriter` that will write out events and summaries    to the event file.    Args:        log_dir (str): Save directory location. Default is          runs/**CURRENT_DATETIME_HOSTNAME**, which changes after each run.          Use hierarchical folder structure to compare          between runs easily. e.g. pass in 'runs/exp1', 'runs/exp2', etc.          for each new experiment to compare across them.        comment (str): Comment log_dir suffix appended to the default          ``log_dir``. If ``log_dir`` is assigned, this argument has no effect.        purge_step (int):          When logging crashes at step :math:`T+X` and restarts at step :math:`T`,          any events whose global_step larger or equal to :math:`T` will be          purged and hidden from TensorBoard.          Note that crashed and resumed experiments should have the same ``log_dir``.        max_queue (int): Size of the queue for pending events and          summaries before one of the 'add' calls forces a flush to disk.          Default is ten items.        flush_secs (int): How often, in seconds, to flush the          pending events and summaries to disk. Default is every two minutes.        filename_suffix (str): Suffix added to all event filenames in          the log_dir directory. More details on filename construction in          tensorboard.summary.writer.event_file_writer.EventFileWriter.    Examples::        from torch.utils.tensorboard import SummaryWriter        # create a summary writer with automatically generated folder name.        writer = SummaryWriter()        # folder location: runs/May04_22-14-54_s-MacBook-Pro.local/        # create a summary writer using the specified folder name.        writer = SummaryWriter("my_experiment")        # folder location: my_experiment        # create a summary writer with comment appended.        writer = SummaryWriter(comment="LR_0.1_BATCH_16")        # folder location: runs/May04_22-14-54_s-MacBook-Pro.localLR_0.1_BATCH_16/    """</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是，我们实例化一个SummaryWriter,只需要告诉构造函数一个文件夹的名字即可</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">writer <span class="token operator">=</span> SummaryWriter<span class="token punctuation">(</span><span class="token string">"logs"</span><span class="token punctuation">)</span><span class="token comment"># 产生一个logs文件夹，其事件文件就在里面！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        向里头输入样本点，比如说函数”y = x”，就需要加入：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     writer<span class="token punctuation">.</span>add_scalar<span class="token punctuation">(</span><span class="token string">"y = x"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        不要忘记关闭文件流</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">writer<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="经验来了"><a href="#经验来了" class="headerlink" title="经验来了"></a>经验来了</h3><p>​        首先，如果你打开终端，发现是PS控制台，那就麻烦你手动改成cmd控制台，他在Files - settings - tools - terminal里，选择CMD控制台</p><p><img src="image-20230329201937164.png" alt="image-20230329201937164"></p><p>​        回到终端，他就是这样的了。</p><p><img src="image-20230329202008458.png" alt="image-20230329202008458"></p><p>​        但是，这个时候输入 tensorboard —logdir=logs(你自己看看你指定的文件夹的名字是什么，比如说我的是这个，以及如果你发现你甚至没有log文件夹那就检查代码，去文件的上级找找，但大概率是你代码出错了！)</p><p><img src="image-20230329202055328.png" alt="image-20230329202055328"></p><p><img src="image-20230329202202553.png" alt="image-20230329202202553"></p><p>​        出现了上图的 bug，说明cmd没认识，不知道tensorboard.那就这样，输入</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pip install tensorboard -i --trusted-host  http:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是使用pip 来下载tensorboard, 其中，后面信任域名是为了防止下图种类的报错</p><p><img src="image-20230329202344121.png" alt="image-20230329202344121"></p><p>​        但是，即使这样，我还是遇到了另一个奇怪的错误：</p><p><img src="image-20230329202418314.png" alt="image-20230329202418314"></p><p>​        这个时候马上换源即可，是源的问题</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">pip install tensorboard -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple --trusted-host https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230329202505259.png" alt="image-20230329202505259"></p><p>​        我们再试一次，成功了！</p><p>​        对了。如果发现端口冲突了，可以手动指定端口，就是在指令的后面在塞上一个—port=</p><p><img src="image-20230329202803683.png" alt="image-20230329202803683"></p><p>下面来看图片的添加！在Pytorch下，我们使用add_image来添加图片</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add_image</span><span class="token punctuation">(</span>    self<span class="token punctuation">,</span> tag<span class="token punctuation">,</span> img_tensor<span class="token punctuation">,</span> global_step<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> walltime<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> dataformats<span class="token operator">=</span><span class="token string">"CHW"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""Add image data to summary.    Note that this requires the ``pillow`` package.    Args:        tag (str): Data identifier        img_tensor (torch.Tensor, numpy.ndarray, or string/blobname): Image data        global_step (int): Global step value to record        walltime (float): Optional override default walltime (time.time())          seconds after epoch of event        dataformats (str): Image data format specification of the form          CHW, HWC, HW, WH, etc.    Shape:        img_tensor: Default is :math:`(3, H, W)`. You can use ``torchvision.utils.make_grid()`` to        convert a batch of tensor into 3xHxW format or call ``add_images`` and let us do the job.        Tensor with :math:`(1, H, W)`, :math:`(H, W)`, :math:`(H, W, 3)` is also suitable as long as        corresponding ``dataformats`` argument is passed, e.g. ``CHW``, ``HWC``, ``HW``.    Examples::        from torch.utils.tensorboard import SummaryWriter        import numpy as np        img = np.zeros((3, 100, 100))        img[0] = np.arange(0, 10000).reshape(100, 100) / 10000        img[1] = 1 - np.arange(0, 10000).reshape(100, 100) / 10000        img_HWC = np.zeros((100, 100, 3))        img_HWC[:, :, 0] = np.arange(0, 10000).reshape(100, 100) / 10000        img_HWC[:, :, 1] = 1 - np.arange(0, 10000).reshape(100, 100) / 10000        writer = SummaryWriter()        writer.add_image('my_image', img, 0)        # If you have non-default dimension setting, set the dataformats argument.        writer.add_image('my_image_HWC', img_HWC, 0, dataformats='HWC')        writer.close()    Expected result:    .. image:: _static/img/tensorboard/add_image.png       :scale: 50 %    """</span>    torch<span class="token punctuation">.</span>_C<span class="token punctuation">.</span>_log_api_usage_once<span class="token punctuation">(</span><span class="token string">"tensorboard.logging.add_image"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> self<span class="token punctuation">.</span>_check_caffe2_blob<span class="token punctuation">(</span>img_tensor<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">from</span> caffe2<span class="token punctuation">.</span>python <span class="token keyword">import</span> workspace        img_tensor <span class="token operator">=</span> workspace<span class="token punctuation">.</span>FetchBlob<span class="token punctuation">(</span>img_tensor<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>_get_file_writer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>add_summary<span class="token punctuation">(</span>        image<span class="token punctuation">(</span>tag<span class="token punctuation">,</span> img_tensor<span class="token punctuation">,</span> dataformats<span class="token operator">=</span>dataformats<span class="token punctuation">)</span><span class="token punctuation">,</span> global_step<span class="token punctuation">,</span> walltime    <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        是的，当我们加载图片的时候，函数的参数接受Tensor类型的图片和ndarray类型，这就需要我们调用API来进行转化</p><pre class="line-numbers language-Python" data-language="Python"><code class="language-Python">from torch.utils.tensorboard import SummaryWriterfrom PIL import Imageimport numpy as npwriter &#x3D; SummaryWriter(&quot;logs&quot;)imgPath &#x3D; &quot;hymenoptera_data&#x2F;train&#x2F;ants&#x2F;0013035.jpg&quot;imgPIL &#x3D; Image.open(imgPath)imgArray &#x3D; np.array(imgPIL) # 转化writer.add_image(&quot;test&quot;,imgArray,1,dataformats&#x3D;&quot;HWC&quot;) #指明通道是如何的！writer.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pytorch </tag>
            
            <tag> python </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning in English 2</title>
      <link href="/2023/03/29/Deep-Learning-in-English-2/"/>
      <url>/2023/03/29/Deep-Learning-in-English-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-2"><a href="#Deep-Learning-2" class="headerlink" title="Deep Learning 2"></a>Deep Learning 2</h1><h2 id="Supervised-learning-with-Neural-Networks"><a href="#Supervised-learning-with-Neural-Networks" class="headerlink" title="Supervised learning with Neural Networks"></a>Supervised learning with Neural Networks</h2><p>​    Recently, with a rapid dedvelopment of Artificial Intelligence, it has already created a large amount of economic benefit to society. Supervised learning, as a part of machine learning, has a large propotions of the benefit created by AI.</p><p>​    Supervised learning can be considered as a type of machine learning that requires exact features and specific targets which was set by human beings . It can be considered as  a semi - automatic  learning methods as we need to input specific data by humans</p><p>​    To be exact, we need to tell the machine what is input, and what is the output to get a model of predictions. Like nowadays, we need to make predictions of our real estate or differatiating the images like photo tagging. (I recently make classifications of kinds of flowers by making machines gather features of variaty kinds of flowers and make classifications according to the features it get), or make precises and pretty translations among languages. Perhaps the most lucrative applications of it is Online advertising. By collecting your personal informations and detecting whether you click the ads, the machines learn whether you get favor of this kind of ads . As returned, it will offer you the ads you likely like more.</p><p>​    These kinds of applications all use the relatively standard neural networks. There are several kind of NN( NN stands for Nerual networks). The traditional one is SNN(Standard NN). and also, we use  CNN(Convolutional NN)(卷积)  in image processing . RNN(Recurrent NN) is fit for one- dimensional sequence data that has maybe a temporal component.</p><p><img src="image-20230321113600065.png" alt="image-20230321113600065"></p><p>​        Supervised learning can deal with Structured data and Unstructured data. Structured data is a kind of data that has been quantified in database, while unstructured data involves audio ,images , texts and so on. Computers is harder to deal with unstructured data, but with a development of AI , computers are getting a better understanding of unstructured data.</p><p>​        So, NN has a deep effect on machine learning, so how should we make NN work properly? Let’s go to the next page!</p>]]></content>
      
      
      
        <tags>
            
            <tag> Deep-Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Learning in English 1</title>
      <link href="/2023/03/29/Deep-Learning-in-English-1/"/>
      <url>/2023/03/29/Deep-Learning-in-English-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-Learning-Notes"><a href="#Deep-Learning-Notes" class="headerlink" title="Deep Learning Notes"></a>Deep Learning Notes</h1><p>​        Here, I want to write a passage that related to deep learning in English,which  undoubtedly aims to practice my English writing and improve my English expressions.</p><p>​        （Passage in this series has already been basically proofread! You can read it for free!）</p><h2 id="What-is-a-deep-learning"><a href="#What-is-a-deep-learning" class="headerlink" title="What is a deep learning"></a>What is a deep learning</h2><p>​    To start with, we can simply say that deep learning  refers to training neural networks. In this case,to get a deep understanding of neural network, let’s take the prediction of house price as an example:</p><p>​    Often, we point the such Price - size relationship on the tablet,and , I mean , if we are good at linear regressions, we will choose to use linear functions , in other words, the functions that can be described as  $kx+b$ to what we call as “FIT” in machine learning. So we definitely get a line if we draw in the figure.</p><p><img src="image-20230319210045067.png" alt="image-20230319210045067"></p><p>​        We can already finish this simple work when we are in high school. But let’s review this process in another way. I mean , Let’s take the size of house as imput because it affects the price of house. So relatively, we treat price as the output. The functions that make fitting can be called: <strong>neural </strong>, as it is single when we establish the model of predictions</p><p><img src="image-20230319210353903.png" alt="image-20230319210353903"></p><p>But what we should get mentioned is that price can’t be negative as it will create finacial wonder(just kidding), so we do need to rectify the line.</p><p><img src="image-20230319220650497.png" alt="image-20230319220650497"></p><p>​        This kind of new line can be called rectified functions , in short, ReLU. But we should also be recognized that the affect can’t be singled. Instead, it should be mutiplied .</p><p>​        Let’s take the advanced example. We  usually take : size ,zip code ,wealth or even whether the house have lavatory as the target.</p><p><img src="image-20230319223411804.png" alt="image-20230319223411804"></p><p>​        We can build up the network by compounding the single neural. We just input the data and train to get the weight.</p><p>​        Let’s sum it up!</p><p><img src="image-20230319223731215.png" alt="image-20230319223731215"></p><p> The input is treated as input features and the neural network is aimed to predict the price, and on the next sections , we will offer more examples of this kind of neural networks</p>]]></content>
      
      
      
        <tags>
            
            <tag> Deep-Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023展望与开发事宜（试行版）</title>
      <link href="/2023/03/24/2023%E5%B1%95%E6%9C%9B%E4%B8%8E%E5%BC%80%E5%8F%91%E4%BA%8B%E5%AE%9C%EF%BC%88%E8%AF%95%E8%A1%8C%E7%89%88%EF%BC%89/"/>
      <url>/2023/03/24/2023%E5%B1%95%E6%9C%9B%E4%B8%8E%E5%BC%80%E5%8F%91%E4%BA%8B%E5%AE%9C%EF%BC%88%E8%AF%95%E8%A1%8C%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="2023展望与开发事宜（试行版）"><a href="#2023展望与开发事宜（试行版）" class="headerlink" title="2023展望与开发事宜（试行版）"></a>2023展望与开发事宜（试行版）</h1><h2 id="不行，必须开水！"><a href="#不行，必须开水！" class="headerlink" title="不行，必须开水！"></a>不行，必须开水！</h2><p>​        最近忙完了些事情，打算重新把注意力放到学习计算机，电子和人工智能的相关内容。这里打算写一个大纲水一水东西（破真）</p><h2 id="数学基础教程"><a href="#数学基础教程" class="headerlink" title="数学基础教程"></a>数学基础教程</h2><h3 id="微积分简明教程"><a href="#微积分简明教程" class="headerlink" title="微积分简明教程"></a>微积分简明教程</h3><h3 id="线性代数简明教程"><a href="#线性代数简明教程" class="headerlink" title="线性代数简明教程"></a>线性代数简明教程</h3><h3 id="概率论简明教程"><a href="#概率论简明教程" class="headerlink" title="概率论简明教程"></a>概率论简明教程</h3><h3 id="复变函数与积分变换简明教程"><a href="#复变函数与积分变换简明教程" class="headerlink" title="复变函数与积分变换简明教程"></a>复变函数与积分变换简明教程</h3><h3 id="数学物理方程简明教程"><a href="#数学物理方程简明教程" class="headerlink" title="数学物理方程简明教程"></a>数学物理方程简明教程</h3><h3 id="离散数学简明教程"><a href="#离散数学简明教程" class="headerlink" title="离散数学简明教程"></a>离散数学简明教程</h3><h2 id="计算机简明教程"><a href="#计算机简明教程" class="headerlink" title="计算机简明教程"></a>计算机简明教程</h2><h3 id="计算机理论"><a href="#计算机理论" class="headerlink" title="计算机理论"></a>计算机理论</h3><h4 id="一-数据结构与算法"><a href="#一-数据结构与算法" class="headerlink" title="一.数据结构与算法"></a>一.数据结构与算法</h4><ol><li><p>算法导论 总结版（可能含coding，但是看我有没有空）</p></li><li><p>基于Java的算法课程笔记</p></li><li><p>C数据结构代码实现与简单概论</p></li></ol><h4 id="二-操作系统引论"><a href="#二-操作系统引论" class="headerlink" title="二.操作系统引论"></a>二.操作系统引论</h4><ol><li>现代操作系统总结</li><li>Linux操作系统导读</li></ol><h3 id="程序语言设计"><a href="#程序语言设计" class="headerlink" title="程序语言设计"></a>程序语言设计</h3><p>1.C/C++手搓 MyTinyStdC / C++库，具体目录待我自 3.26日起开始规划和着手开发</p><p>2.C/C++学习笔记（水）</p><p>3.Python程序设计引论</p><p>4.项目导读与源码解释</p><h3 id="ROS开发水文"><a href="#ROS开发水文" class="headerlink" title="ROS开发水文"></a>ROS开发水文</h3><h3 id="Opencv4入门与程序实例"><a href="#Opencv4入门与程序实例" class="headerlink" title="Opencv4入门与程序实例"></a>Opencv4入门与程序实例</h3><h3 id="入门人工智能"><a href="#入门人工智能" class="headerlink" title="入门人工智能"></a>入门人工智能</h3><p>1.吴恩达机器学习（But in English）</p><p>2.torch学习</p><p>3.tensorFlow学习</p><p>4.自己读书顺手的笔记随记上传</p>]]></content>
      
      
      
        <tags>
            
            <tag> Planning and pre-arranging </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C数据结构 1</title>
      <link href="/2023/03/19/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/"/>
      <url>/2023/03/19/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</url>
      
        <content type="html"><![CDATA[<h1 id="C-算法与数据结构1"><a href="#C-算法与数据结构1" class="headerlink" title="C 算法与数据结构1"></a>C 算法与数据结构1</h1><p>​        鸽了好几天的博客（），现在准备整点花活，开几个大坑，这是其中一个：</p><h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><p>​        递归是用来解决那些可以分开治理的问题的好办法。我们分开求解，随后合并，这正是递归的主要思路，也就是说，我们可以把大问题化成性质相同的子问题。我想，代表性的应用正是斐波那契数列的应用</p><script type="math/tex; mode=display">\begin{equation}a_n=\left\{\begin{aligned}1  && n = 1,2\\a_{n-1}+a_{n-2}  && n\geq 3 \end{aligned}\right.\end{equation}</script><p>​        那么，根据这样的递推公式：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">long long getNFeb(int pos)&#123;if(pos &#x3D;&#x3D; 1 || pos &#x3D;&#x3D; 2)&#123;        return 1;    &#125;    else&#123;        return getNFeb(pos-1)+getNFeb(pos-2);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        是的，你拿去验证一下，马上就会发现这个没啥大的问题。但是，现在让你求一下 Feb(50).你就会高兴的发现自己的电脑寄了！因为这样的递归是不恰当的。它大量的调用了函数的，导致频繁的压栈，而这些压栈往往确实不必要的。有大量的值我们已经计算过了，可以使用备忘录的方式直接索引！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">long long getFeb(int X)&#123;    &#x2F;&#x2F; memory Tab    int x1 &#x3D; 1;    int x2 &#x3D; 1;    &#x2F;&#x2F; use &#39;res&#39; to record the result     int res ;        &#x2F;&#x2F; in this for loop , we specifically use recursion alike to solve problems     for(int i &#x3D; 2; i &lt; X; i++)&#123;        res &#x3D; x1 + x2;        x1 &#x3D; x2;        x2 &#x3D; res;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样就很快了！</p><p>​        我们再来看一个也是稍微简单但是常见的例子：</p><p>​        我们常常这样书写 pow 函数来求乘方：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">long long pow(int X, int N)&#123;    long long res &#x3D; 1;    for(int i &#x3D; 0 ; i&lt; N ; i++)&#123;        res *&#x3D; X;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        递归如何呢？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">long long newPos(int x , int n)&#123;    if(x &#x3D;&#x3D; 1)&#123;        return X;    &#125;    if(n % 2 &#x3D;&#x3D; 0)&#123;        return newPow(int x,n&#x2F;2)*newPow(int x,n&#x2F;2)    &#125;    else    &#123;        return newPow(int x,n&#x2F;2)*newPow(int x,n&#x2F;2)*x;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不错，本质上就是二分来求。但是好像不对，我们的递归还是变成了两个部分，似乎还是O( N )不太好，那么，本质上是同样的递归，不妨合并起来： </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">long long newPow(int X , int N)&#123;if(N &#x3D;&#x3D; 1)&#123;        return X;    &#125;    if(N % 2 &#x3D;&#x3D; 0)&#123;        &#x2F;&#x2F; 下分为 (X^2)^(N&#x2F;2)的问题处理，处理的终点是发现 N &#x3D; 1了的时候停止         return newPow(X*X, N&#x2F;2);    &#125;    else    &#123;        return newPos(X*X, N&#x2F;2)*X;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        很好，这样就是 O(log n)了！</p><p>​        我们再来看一个：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int binarySearch(const int arr[],int findElem,int low,int high)&#123;if(low &gt; high)&#123;        return -1;&#x2F;&#x2F; or an abstractions called NOTFOUND as -1;    &#125;        int mid &#x3D; low + (high - low)&gt;&gt;1;        if(arr[mid] &#x3D;&#x3D; findElem)&#123;        return mid;    &#125;        if(arr[mid] &gt; findElem)&#123;        return binarySearch(arr,findElem,low,mid-1);    &#125;    &#x2F;&#x2F;这里建议写else!否则产生错误，就是递归结束向上返回的过程中又一次进入到这里来导致错误的结果    else&#123;        return binarySearch(arr,findElem,mid+1 ,high);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这就是二分法的递归写法！</p><p>​        总而言之，这就是递归带给我们程序的小小自信！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C DataStruct Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv in Visual Studio C++</title>
      <link href="/2023/03/05/Opencv-in-Visual-Studio-C/"/>
      <url>/2023/03/05/Opencv-in-Visual-Studio-C/</url>
      
        <content type="html"><![CDATA[<h1 id="Opencv-with-Visual-Studio"><a href="#Opencv-with-Visual-Studio" class="headerlink" title="Opencv with Visual Studio"></a>Opencv with Visual Studio</h1><h2 id="C-Version"><a href="#C-Version" class="headerlink" title="C++ Version"></a>C++ Version</h2><h2 id="1-环境配置问题"><a href="#1-环境配置问题" class="headerlink" title="1.环境配置问题"></a>1.环境配置问题</h2><p>​        我们首先下好 Opencv 4.5.1 的包，安装好 Cmake 之后开始使用！</p><p>​        下面为了配置好 Opencv 的开发环境：我们必须书写一个 CmakeLists来链接库：</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">cmake_minimum_required(VERSION 2.8)project(def) # 工程名称 set(SOURCES    default.cpp # 源文件) set(HEADERS    #main.hpp # 头文件) add_executable(Main #产生可执行区域    $&#123;SOURCES&#125;    $&#123;HEADERS&#125;) set(OpenCV_DIR &quot;D:&#x2F;Opencv4.5.1&#x2F;opencv&#x2F;build&#x2F;x64&#x2F;vc15&#x2F;lib&quot;) # 找到二进制的坤文件find_package(OpenCV REQUIRED)if(OpenCV_FOUND)    target_include_directories(Main PUBLIC $&#123;OpenCV_INCLUDE_DIRS&#125;)    target_link_libraries(Main $&#123;OpenCV_LIBS&#125;)    # 上面两行代码把 Opencv 库所需要的文件和程序链接 endif()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        随后，点击Cmake 把工作区和二进制生成文件的地址传进去</p><p><img src="image-20230305134917646.png" alt="image-20230305134917646"></p><p>​        平台选择 64 位，点击 Configure 随后点击 Generate :留意有没有报错！</p><p>​        如果一切没有问题，那么，回到你的工作文件夹，选择BUILD文件夹，打开，随后找到：def.sIn文件，单击启动项目，当然我们需要更改启动项</p><p><img src="image-20230305135524174.png" alt="image-20230305135524174"></p><p>​        选择Main启动项即可！</p><p>​        当然可以使用以下代码测试你的环境！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;Mat img &#x3D; imread(path);if (img.empty()) &#123;return -1;&#125;imshow(&quot;1&quot;, img);waitKey(0);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="项目入门1："><a href="#项目入门1：" class="headerlink" title="项目入门1："></a>项目入门1：</h2><p>​        我们首先来了解什么是图像：这很简单！我们在计算机中用一个矩阵，向里面填入色块实现图像的显示，我们的图像越高清，就说明我们的矩阵划分的越密集，这样，表现出来的就越是清晰！</p><p>​        在黑白图中，我们使用 8 位图来刻画我们的黑白图！0代表黑色，255 则是白色。</p><p><img src="image-20230305140523343.png" alt="image-20230305140523343"></p><p>​        对于彩色图像，我们使用 BGR 三色图，以不同的比例的亮度来叠加在一起。</p><h3 id="显示一个图像"><a href="#显示一个图像" class="headerlink" title="显示一个图像"></a>显示一个图像</h3><p>​        下面我们来使用一个函数 imread 和 imshow!</p><p>​        先来引入头文件</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         现在看一下，有没有报错，一般而言成功了的环境是不会报错的！正是如此！</p><p>​        如果你有幸浏览到了 opencv  的文档，你会注意到 imread 表示的是从程序外面读取一个图像，并且将对象返回给一个叫做 Mat 的类型！函数需要一个string，表示的是图像的地址</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++"># 这里找到一个图像的地址：string path &#x3D; &quot;path_DIR&quot;;# 然后传进去：Mat img &#x3D; imread(path);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个 Mat 就是一个矩阵，存储着图像的信息。显示图像也是简单的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">imshow(&quot;NameWindows&quot;,img);waitKey(0);&#x2F;&#x2F; 防止图像一闪而过<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Examples:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;Mat img &#x3D; imread(path);if (img.empty()) &#123;return -1;&#125;imshow(&quot;1&quot;, img);waitKey(0);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230305141742942.png" alt="image-20230305141742942"></p><p>​        效果如上！</p><h3 id="显示一个视频"><a href="#显示一个视频" class="headerlink" title="显示一个视频"></a>显示一个视频</h3><p>​        视频的本质是一帧一帧图像的播放，基于此，我们可以导入，以及导出一个视频：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">string path &#x3D; &quot;C:\\Users\\陈冠豪\\Videos\\2023-03-05 14-24-15.mp4&quot;;VideoCapture videocap(path);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        我们的 Opencv 里有一个专门搞视频的类型：</p><pre class="line-numbers language-none"><code class="language-none">VideoCapture <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        类型，支持这样的构造：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">VideoCapture videocap(path)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        随后声明一个矩阵，他将会存储我们的视频中一帧的图片：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat img;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们视频的读取是这样的：读取每一帧，然后显示，直到视频结束或者我们人为的退出：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">while(1)&#123;videocap.read(img);    imshow(&quot;Video&quot;,img);    waitKey(1); &#x2F;&#x2F; 我们在这里决定了延迟是如何的，这里实现倍速或者是慢速播放&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Videos\\2023-03-05 14-31-23.mp4&quot;;VideoCapture videocap(path);Mat img;while (1)&#123;videocap.read(img);imshow(&quot;1&quot;, img);waitKey(20);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        你当然可以选择你的摄像头！电脑的默认头是0，这意味着：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;VideoCapture videocap(0);Mat img;while (1)&#123;videocap.read(img);imshow(&quot;1&quot;, img);waitKey(20);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        就可以看到你自己了！</p><p><img src="image-20230305144156399.png" alt="image-20230305144156399"></p><p>​        很好。</p><h2 id="项目入门2：图像处理"><a href="#项目入门2：图像处理" class="headerlink" title="项目入门2：图像处理"></a>项目入门2：图像处理</h2><p>​        下面，我们来一 一介绍函数的图像处理：</p><p>​        1）转化为灰度图：</p><p>来看这个函数：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cvtColor(imgSrc,imgDst,code);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个函数把源图像转化为目标图像，以及转化方式：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;Mat imgSrc, imgDst;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;imgSrc &#x3D; imread(path);cvtColor(imgSrc, imgDst, COLOR_BGR2GRAY);imshow(&quot;gray&quot;, imgDst);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230305145310719.png" alt="image-20230305145310719"></p><h2 id="图像模糊（高斯模糊）"><a href="#图像模糊（高斯模糊）" class="headerlink" title="图像模糊（高斯模糊）"></a>图像模糊（高斯模糊）</h2><p>​        使用函数 GaussainBlur 来实现！</p><p>​        小技巧，如果你不知道这个函数是干什么的，传什么样的参数：可以Ctrl+单击</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS_W void GaussianBlur( InputArray src, OutputArray dst, Size ksize,                                double sigmaX, double sigmaY &#x3D; 0,                                int borderType &#x3D; BORDER_DEFAULT );&#x2F;** @brief Applies the bilateral filter to an image.The function applies bilateral filtering to the input image, as described inhttp:&#x2F;&#x2F;www.dai.ed.ac.uk&#x2F;CVonline&#x2F;LOCAL_COPIES&#x2F;MANDUCHI1&#x2F;Bilateral_Filtering.htmlbilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it isvery slow compared to most filters._Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (\&lt;10), the filter will not have much effect, whereas if they are large (\&gt; 150), they will have a verystrong effect, making the image look &quot;cartoonish&quot;._Filter size_: Large filters (d \&gt; 5) are very slow, so it is recommended to use d&#x3D;5 for real-timeapplications, and perhaps d&#x3D;9 for offline applications that need heavy noise filtering.This filter does not work inplace.@param src Source 8-bit or floating-point, 1-channel or 3-channel image.@param dst Destination image of the same size and type as src .@param d Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,it is computed from sigmaSpace.@param sigmaColor Filter sigma in the color space. A larger value of the parameter means thatfarther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resultingin larger areas of semi-equal color.@param sigmaSpace Filter sigma in the coordinate space. A larger value of the parameter means thatfarther pixels will influence each other as long as their colors are close enough (see sigmaColor). When d\&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d isproportional to sigmaSpace.@param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到，这个函数需要源图像，目标图像和高斯核的大小，以及两个方差（其中有一个是必须的）</p><p><img src="image-20230305150011615.png" alt="image-20230305150011615"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;Mat imgSrc,imgBlur;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;imgSrc &#x3D; imread(path);GaussianBlur(imgSrc, imgBlur, Size(7, 7), 5, 0);imshow(&quot;1&quot;, imgBlur);imshow(&quot;org&quot;, imgSrc);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图像边缘检测"><a href="#图像边缘检测" class="headerlink" title="图像边缘检测"></a>图像边缘检测</h3><p>​        下面我们要使用函数Canny 来给我们的图像进行检测！</p><p>​        <strong>我们在使用 Canny 检测的时候，往往还会在之前使用模糊来更好的检测！！！</strong></p><p>​        通读一下函数需求：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS_W void Canny( InputArray image, OutputArray edges,                         double threshold1, double threshold2,                         int apertureSize &#x3D; 3, bool L2gradient &#x3D; false );&#x2F;** \overloadFinds edges in an image using the Canny algorithm with custom image gradient.@param dx 16-bit x derivative of input image (CV_16SC1 or CV_16SC3).@param dy 16-bit y derivative of input image (same type as dx).@param edges output edge map; single channels 8-bit image, which has the same size as image .@param threshold1 first threshold for the hysteresis procedure.@param threshold2 second threshold for the hysteresis procedure.@param L2gradient a flag, indicating whether a more accurate \f$L_2\f$ norm\f$&#x3D;\sqrt&#123;(dI&#x2F;dx)^2 + (dI&#x2F;dy)^2&#125;\f$ should be used to calculate the image gradient magnitude (L2gradient&#x3D;true ), or whether the default \f$L_1\f$ norm \f$&#x3D;|dI&#x2F;dx|+|dI&#x2F;dy|\f$ is enough (L2gradient&#x3D;false ). *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        可以看到，我们需要源图像，目标图像，两个阈值</p><p><img src="image-20230305150945109.png" alt="image-20230305150945109"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;Mat imgSrc,imgBlur,imgCanny;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;imgSrc &#x3D; imread(path);GaussianBlur(imgSrc, imgBlur, Size(7, 7), 5, 0);Canny(imgBlur,imgCanny,50,150);imshow(&quot;org&quot;, imgSrc);imshow(&quot;canny&quot;, imgCanny);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们用这个来检测阈值，当然，阈值越低，对边界越敏感：</p><p><img src="image-20230305151111912.png" alt="image-20230305151111912"></p><p>​        下调阈值为 25,75后的结果！</p><h3 id="图像膨胀"><a href="#图像膨胀" class="headerlink" title="图像膨胀"></a>图像膨胀</h3><p>​        当我们的图像特征不明显的时候，我们可以放大特征来便于我们的检测：</p><p>​        使用的是函数 dilate:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">CV_EXPORTS_W void dilate( InputArray src,                          OutputArray dst,                          InputArray kernel,                          Point anchor &#x3D; Point(-1,-1),                          int iterations &#x3D; 1,                          int borderType &#x3D; BORDER_CONSTANT,                          const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue()                         );&#x2F;** @brief Performs advanced morphological transformations.The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation asbasic operations.Any of the operations can be done in-place. In case of multi-channel images, each channel isprocessed independently.@param src Source image. The number of channels can be arbitrary. The depth should be one ofCV_8U, CV_16U, CV_16S, CV_32F or CV_64F.@param dst Destination image of the same size and type as source image.@param op Type of a morphological operation, see #MorphTypes@param kernel Structuring element. It can be created using #getStructuringElement.@param anchor Anchor position with the kernel. Negative values mean that the anchor is at thekernel center.@param iterations Number of times erosion and dilation are applied.@param borderType Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.@param borderValue Border value in case of a constant border. The default value has a specialmeaning.@sa  dilate, erode, getStructuringElement@note The number of iterations is the number of times erosion or dilatation operation will be applied.For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to applysuccessively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate). *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        在我们使用完Canny之后：</p><p>​        我们的核怎么来呢？专门使用函数 getStructuringElement来完成我们的工作</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat kernel &#x3D; getStructuringElement(MORPH_RECT,Size(5,5));# 这个核越大膨胀越厉害<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="image-20230305151930037.png" alt="image-20230305151930037"></p><p>​        特征被明显的放大了！</p><h3 id="图像侵蚀"><a href="#图像侵蚀" class="headerlink" title="图像侵蚀"></a>图像侵蚀</h3><p>​        我们使用的函数是 Erode:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">CV_EXPORTS_W void erode( InputArray src, OutputArray dst, InputArray kernel,                         Point anchor &#x3D; Point(-1,-1), int iterations &#x3D; 1,                         int borderType &#x3D; BORDER_CONSTANT,                         const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue() );&#x2F;** @example samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Morphology_1.cppErosion and Dilation sample code![Sample Screenshot-Erosion](Morphology_1_Tutorial_Erosion_Result.jpg)![Sample Screenshot-Dilation](Morphology_1_Tutorial_Dilation_Result.jpg)Check @ref tutorial_erosion_dilatation &quot;the corresponding tutorial&quot; for more details*&#x2F;&#x2F;** @brief Dilates an image by using a specific structuring element.The function dilates the source image using the specified structuring element that determines theshape of a pixel neighborhood over which the maximum is taken:\f[\texttt&#123;dst&#125; (x,y) &#x3D;  \max _&#123;(x&#39;,y&#39;):  \, \texttt&#123;element&#125; (x&#39;,y&#39;) \ne0 &#125; \texttt&#123;src&#125; (x+x&#39;,y+y&#39;)\f]The function supports the in-place mode. Dilation can be applied several ( iterations ) times. Incase of multi-channel images, each channel is processed independently.@param src input image; the number of channels can be arbitrary, but the depth should be one ofCV_8U, CV_16U, CV_16S, CV_32F or CV_64F.@param dst output image of the same size and type as src.@param kernel structuring element used for dilation; if elemenat&#x3D;Mat(), a 3 x 3 rectangularstructuring element is used. Kernel can be created using #getStructuringElement@param anchor position of the anchor within the element; default value (-1, -1) means that theanchor is at the element center.@param iterations number of times dilation is applied.@param borderType pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported.@param borderValue border value in case of a constant border@sa  erode, morphologyEx, getStructuringElement *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230305152314781.png" alt="image-20230305152314781"></p><p>代码一览：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;opencv2&#x2F;opencv.hpp&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;using namespace cv;int main()&#123;Mat imgSrc,imgBlur,imgCanny,imgDial,imgErode;string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;imgSrc &#x3D; imread(path);GaussianBlur(imgSrc, imgBlur, Size(7, 7), 5, 0);Canny(imgBlur,imgCanny,50,150);Mat kernel &#x3D; getStructuringElement(MORPH_RECT, Size(5, 5));dilate(imgCanny, imgDial, kernel);erode(imgDial, imgErode, kernel);imshow(&quot;org&quot;, imgSrc);imshow(&quot;dilate&quot;, imgDial);imshow(&quot;erode&quot;, imgErode);waitKey(0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="图像大小调整与变换"><a href="#图像大小调整与变换" class="headerlink" title="图像大小调整与变换"></a>图像大小调整与变换</h3><p>​        很容易猜到重新设定大小的函数就是Resize:</p><p>​        我们首先学习一下怎样查看图像的大小：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">cout &lt;&lt; img.size()&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230305153228802.png" alt="image-20230305153228802"></p><p>​        现在我们可以调整大小了：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">resize(img,imgResize,Size(640,480));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230305153352540.png" alt="image-20230305153352540"></p><p>​        如果希望是等比例的放缩，可以采用这样的方式：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">resize(img,imgResize,Size(),xRatio,yRatio);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​         我们也可以裁剪图像：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Rect roi(100,100,200,300); &#x2F;&#x2F; 这里产生一个区域矩形imgCrop &#x3D; img(roi);&#x2F;&#x2F;从图像中生成子图像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    <img src="image-20230305154148790.png" alt="image-20230305154148790"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 基于VScode的节点调试</title>
      <link href="/2023/03/04/ROS-%E5%9F%BA%E4%BA%8EVScode%E7%9A%84%E8%8A%82%E7%82%B9%E8%B0%83%E8%AF%95/"/>
      <url>/2023/03/04/ROS-%E5%9F%BA%E4%BA%8EVScode%E7%9A%84%E8%8A%82%E7%82%B9%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS节点：调试（基于VScode）"><a href="#ROS节点：调试（基于VScode）" class="headerlink" title="ROS节点：调试（基于VScode）"></a>ROS节点：调试（基于VScode）</h1><p>​        我们已经学会创建一个简单的 ROS 节点了，但是，我们应当要学会调试，毕竟，我们的代码可不会那么短！出现了问题调试就是必然的！</p><p>​        下面开始介绍基于Vscode的 ROS 的调试办法：</p><h2 id="创建调试用的节点"><a href="#创建调试用的节点" class="headerlink" title="创建调试用的节点"></a>创建调试用的节点</h2><p>​        首先 cd 到工作文件夹，创建他们</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> workTab2/src<span class="token builtin class-name">cd</span> workTab2catkin_make<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        以准备好基本的文件！</p><h2 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h2><p>​        VScode 有两个很是好用的插件！一个是ROS，另一个是 catkin_tools 他们可以让你很好的进行ROS运行和调试（不用再命令框里看了！）。</p><p>​        那么问题来了，在哪里打开VScode 呢？显然不是随便打开，也不是在src文件，而是在工作文件夹 workTab2 下，</p><p><img src="image-20230304211639014.png" alt="image-20230304211639014"></p><p>​        这个地方，准备 ctrl+alt+T打开终端：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">code <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是结构！就出来了：</p><p><img src="image-20230304211739953.png" alt="image-20230304211739953"></p><p>​        点击最左侧栏目中的第四个：扩展，安装</p><p><img src="image-20230304211827660.png" alt="image-20230304211827660"></p><p><img src="image-20230304211844585.png" alt="image-20230304211844585"></p><p><img src="image-20230304211905431.png" alt="image-20230304211905431"></p><p><img src="image-20230304211913952.png" alt="image-20230304211913952"></p><p>​        好消息是：一般你已经安上了。</p><p>​        但是这两个：</p><p><img src="image-20230304211953729.png" alt="image-20230304211953729"></p><p><img src="image-20230304212010942.png" alt="image-20230304212010942"></p><p>​        是你大概率没有安装的！安上！</p><p>​        好了！让我们见识一下这玩意好用不好用！</p><p>​        一般的，在官方的命令行创建时如下的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/workTab2/srccatkin_create_pkg talker roscpp rospy std_msgs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        命令行快，但是不够可视化。那我们安装的插件是怎么处理的呢？看到VScode 的文件管理器：右键 src</p><p><img src="image-20230304212352420.png" alt="image-20230304212352420"></p><p>​        怎么着？有一个 Create Catkin Package 了，点击它：</p><p><img src="image-20230304212442723.png" alt="image-20230304212442723"></p><p>​        留意这里！你可以输入你想创建的节点名字！</p><p><img src="image-20230304212525846.png" alt="image-20230304212525846"></p><p>​        你一需要的 dependencies （就是命令行后半部分的内容）</p><p>​        一个回车：包创建结束</p><p><img src="image-20230304212701151.png" alt="image-20230304212701151"></p><h2 id="Coding时间"><a href="#Coding时间" class="headerlink" title="Coding时间"></a>Coding时间</h2><p>​        在我们的 src 文件夹下，右键整一个新文件：写完代码</p><p><img src="image-20230304212841542.png" alt="image-20230304212841542"></p><p>​        现在你无论是调试还是运行都不行！缺少配置文件！这是最最最麻烦的地方！！！</p><h2 id="补全配置文件"><a href="#补全配置文件" class="headerlink" title="补全配置文件"></a>补全配置文件</h2><h3 id="CmakeLists-txt-的内容补全"><a href="#CmakeLists-txt-的内容补全" class="headerlink" title="CmakeLists.txt 的内容补全"></a>CmakeLists.txt 的内容补全</h3><p>​        有点捞，这个还是要我们自己在文件中手动补充！</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">aux_source_directory(.&#x2F;src SRCS)add_executable(talker $&#123;SRCS&#125;)target_link_libraries(talker $&#123;catkin_LIBRARIES&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        有趣的是！这次我们不需要再次改动 Cmake的最低要求版本了！</p><h3 id="查看c-cpp-properties-json"><a href="#查看c-cpp-properties-json" class="headerlink" title="查看c_cpp_properties.json"></a>查看c_cpp_properties.json</h3><p>​        一般我们改动添加：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"compileCommands"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;/build/compile_commands.json"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们后面会知道，这是调用产生的调试文件，等效于在命令行输入了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">catkin_make <span class="token operator">-</span>DCMAKE_EXPORT_COMPILE_COMMANDS<span class="token operator">=</span> YES<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        后调用它，他在 devel/lib里面！</p><p>​        不同于我参考的，我选择了直接在命令行里直接编译产生二进制文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">catkin_make catkin_make <span class="token parameter variable">-DCMAKE_EXPORT_COMPILE_COMMANDS</span><span class="token operator">=</span> YES<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        省事！</p><h3 id="不用改动settings-json"><a href="#不用改动settings-json" class="headerlink" title="不用改动settings.json"></a>不用改动settings.json</h3><h3 id="手动产生task-json"><a href="#手动产生task-json" class="headerlink" title="手动产生task.json"></a>手动产生task.json</h3><p>​        我说停！不是让你 vim task.json ，而是在Vscode 里摁下 ctrl + shift + P </p><p><img src="image-20230304214318786.png" alt="image-20230304214318786"></p><p>​        输入 tasks: configure task单击一下，注意，会弹出来很多东西！找到：catkin_make: build 点击（其他的我不清楚，萌新QAQ）。</p><p>​        对文件做出如下的修改：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"2.0.0"</span><span class="token punctuation">,</span>    <span class="token property">"tasks"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"catkin_make"</span><span class="token punctuation">,</span> <span class="token comment">//代表提示的描述性信息</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"shell"</span><span class="token punctuation">,</span>  <span class="token comment">//可以选择shell或者process,如果是shell代码是在shell里面运行一个命令，如果是process代表作为一个进程来运行</span>            <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"catkin_make"</span><span class="token punctuation">,</span><span class="token comment">//这个是我们需要运行的命令</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span> <span class="token string">"-DCMAKE_EXPORT_COMPILE_COMMANDS=ON"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment">//如果需要在命令后面加一些后缀，可以写在这里，比如-DCATKIN_WHITELIST_PACKAGES=“pac1;pac2”</span>            <span class="token property">"group"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"kind"</span><span class="token operator">:</span><span class="token string">"build"</span><span class="token punctuation">,</span><span class="token property">"isDefault"</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token property">"presentation"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token property">"reveal"</span><span class="token operator">:</span> <span class="token string">"always"</span><span class="token comment">//可选always或者silence，代表是否输出信息</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token property">"problemMatcher"</span><span class="token operator">:</span> <span class="token string">"$msCompile"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        ！我参考的 CSDN 的作者说他不清楚为什么需要添加</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token string">"-DCMAKE_EXPORT_COMPILE_COMMANDS=ON"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是因为我们本质上是链接 ROS 官方的调试文件产生方法，从那里来调试，如果我们不在这里下这个指令，以及不在c_cpp_properties.json 做出那样更改的话：我们无法链接那个文件！</p><h3 id="手动创建-launch-json"><a href="#手动创建-launch-json" class="headerlink" title="手动创建 launch.json"></a>手动创建 launch.json</h3><p>​        别！不用 vim. 最聪明的办法是</p><p><img src="image-20230304215129045.png" alt="image-20230304215129045"></p><p>​        点击它，配置如下内容</p><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;(gdb) Launch&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            # 这里要修改，找到编译生成的二进制可执行文件            # 这里！！！！！！！！！！！！！！！！！！！！！！！！                   &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;&#x2F;build&#x2F;talker&#x2F;talker&quot;,             &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &#x2F;&#x2F;&quot;preLaunchTask&quot;: &quot;build&quot;,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: false,            &quot;MIMode&quot;: &quot;gdb&quot;,            &quot;targetArchitecture&quot;: &quot;x64&quot;,            &quot;avoidWindowsConsoleRedirection&quot;: true,            &quot;setupCommands&quot;: [                &#123;                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                &#125;            ]        &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        好的，如果你执行过：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">catkin_make <span class="token parameter variable">-DCMAKE_EXPORT_COMPILE_COMMANDS</span><span class="token operator">=</span> YES<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        那你就去 build下面找！</p><p>​        我的是：</p><pre class="line-numbers language-none"><code class="language-none">~&#x2F;workTab2&#x2F;build&#x2F;talker&#x2F;talker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        而如果你是采用 Ctrl + shift+ B VScode 的 task.json 来帮你编译的：就去devel/lib下找！</p><pre class="line-numbers language-none"><code class="language-none">~&#x2F;workTab2&#x2F;devel&#x2F;lib&#x2F;talker&#x2F;talker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        总而言之，找到你的二进制文件在哪里！！！</p><p>​        现在的现在，再次编译一次！！！Ctrl+shift+B!!!</p><p>​        如果出现了编译成功（粉色的蓝色的绿色的都有，但是红色的就是寄！这个时候会给你报一些警告和错误！可以留意）</p><p>​        随后，尝试调试：</p><p><img src="image-20230304230646212.png" alt="image-20230304230646212"></p><p>​        出现这个，恭喜你！调试成功！可以打断点了！</p><p><img src="image-20230304232246697.png" alt="image-20230304232246697"></p><p>​        OK！下班！！！</p><p>​        如果对文件有所更改，请注意，你需要重新编译：Ctrl + Shift + B，随后再次调试！</p><p>​        如果断点失效，博主这里没有什么更好的办法（整了几个小时也没拿出可行的方案（彩笔落泪）），那只好试试重新生成文件看看！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 节点的创建，编程，编译与运行</title>
      <link href="/2023/03/02/ROS-%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E7%BC%96%E7%A8%8B%EF%BC%8C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
      <url>/2023/03/02/ROS-%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E7%BC%96%E7%A8%8B%EF%BC%8C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS节点-范例"><a href="#ROS节点-范例" class="headerlink" title="ROS节点 范例"></a>ROS节点 范例</h1><h2 id="1-创建一个节点"><a href="#1-创建一个节点" class="headerlink" title="1.创建一个节点"></a>1.创建一个节点</h2><p>​        当我们下好了 ROS 之后，可以尝试创建自己的一个节点了！但是正如同工作要有工作桌，我们创立一个工作区才能干活，于是，我们先 mkdir 一个文件夹！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/RosWork<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        以及建立一个子文件夹 src ，他就是来存我们源代码的地方</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/RosWork/<span class="token function">mkdir</span> src <span class="token builtin class-name">cd</span> ./src<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <strong>不要换 src 名字！！！</strong></p><p>​        下面向电脑宣称这地方归 ROS 管：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">catkin_init_workspace<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        先返回上一级文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        先编译一次环境：</p><pre class="line-numbers language-none"><code class="language-none">catkin_make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        从而产生工作文件！我们多了很多文件夹：</p><p><img src="image-20230302231715222.png" alt="image-20230302231715222"></p><p>​        下一步，就是设置一下环境变量，让电脑和ROS知道你的办公桌子在哪里：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> devel/setup.bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        不放心？想看看地方对没对？用这个指令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$ROS_PACKAGE_PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230302232048106.png" alt="image-20230302232048106"></p><p>​        这下工作桌修好了！</p><h2 id="开始向里面塞东西"><a href="#开始向里面塞东西" class="headerlink" title="开始向里面塞东西"></a>开始向里面塞东西</h2><p>​        下面向节点里面塞东西：</p><p>​        下面创建一个 package 包（节点下属的一个功能包）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ./srccatkin_create_pkg talkerAndListener std_msgs rospy roscpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        后边包含了在编译时需要依赖的其他功能包：ROS 的标准消息结构（int、bool 等）以及 C++ 和 Python 的接口。</p><p>​        进去 src 文件看看</p><p>​        <img src="image-20230302232535223.png" alt="image-20230302232535223"></p><p>​        我们可以开始写文件了：</p><p>​        为了测试，我们选用最经典的 订阅 与 接受 来尝试我们的第一次节点编写：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/你的工作区文件夹/src/talker_and__listener/src<span class="token function">vim</span> listener.cpp <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        偷懒了，用 vim 直接编辑！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; 塞这些东西进去&#x2F;&#x2F; 原博客：https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44420419&#x2F;article&#x2F;details&#x2F;111355655#include &quot;ros&#x2F;ros.h&quot;#include &quot;std_msgs&#x2F;String.h&quot; &#x2F;&#x2F;所要订阅的消息类型，此处是std)msgs包下的String。msg&#x2F;&#x2F;回调函数部分void chatterCallback(const std_msgs::String::ConstPtr&amp; msg)&#123;    ROS_INFO(&quot;I heard: [%s]&quot;, msg-&gt;data.c_str()); &#x2F;&#x2F;将接收到的消息打印出来&#125;&#x2F;*subscriber的回调函数，当接收到 chatter 话题的时候就会被调用。参数是所接收的消息的常数指标（const pkg_name::msg_name::ConstPtr&amp; msg）.消息是以 boost shared_ptr 指针的形式传输，这就意味着你可以存储它而又不需要复制数据。之后使用msg-&gt;field_name即可存取message的资料*&#x2F;int main(int argc, char **argv)&#123;    ros::init(argc, argv, &quot;listener&quot;); &#x2F;&#x2F;初始化ROS节点    ros::NodeHandle n; &#x2F;&#x2F;创建句柄节点    ros::Subscriber sub &#x3D; n.subscribe(&quot;chatter&quot;, 1000, chatterCallback);&#x2F;*告诉 master 要订阅 chatter 话题（第一个参数）上的消息。当有消息发布到这个话题时，ROS 就会调用 chatterCallback() 函数（第三个参数）。第二个参数是队列大小，当缓存达到 1000 条消息后，自动舍弃时间戳最早的消息。NodeHandle::subscribe() 返回 ros::Subscriber 对象,此处为sub。当这个对象销毁时，它将自动退订 chatter 话题的消息。有各种不同的 NodeHandle::subscribe() 函数，可以指定类的成员函数，甚至是 Boost.Function 对象可以调用的任何数据类型。*&#x2F;    ros::spin();&#x2F;*ros::spin() 进入自循环，可以尽可能快的调用消息回调函数，会调用主程序中所有回调函数，此处只有chatterCallback()一旦 ros::ok() 返回 false，ros::spin() 就会立刻跳出自循环。这有可能是 ros::shutdown() 被调用，或者是用户按下了 Ctrl-C，使得 master 告诉节点要终止运行。*&#x2F;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在：摁 esc 输入 :wq 退出编辑和 vim ，随后再整一个 talker.cpp</p><pre class="line-numbers language-none"><code class="language-none">vim talker.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;头文件部分#include &lt;sstream&gt; #include &quot;ros&#x2F;ros.h&quot; &#x2F;*&quot;ros&#x2F;ros.h 是一个实用的头文件，它引用了 ROS 系统中大部分常用的头文件。&quot;地址在 &#x2F;opt&#x2F;ros&#x2F;noetic&#x2F;include&#x2F;ros&#x2F;&quot; *&#x2F;#include &quot;std_msgs&#x2F;String.h&quot; &#x2F;* &quot;std_msgs&quot;是一个消息类型依赖包，此处要传输string类型数据，需要包含该数据类型的头文件String.h，就在这个依赖包里 *&#x2F;&#x2F;&#x2F;初始化部分int main(int argc, char **argv)&#123;    ros::init(argc, argv, &quot;talker&quot;);    &#x2F;* ROS节点初始化。初始化的init函数包含三个参数，    前两个参数是命令行或launch文件输入的参数，可以用来命名重映射等功能；    第三个参数定义了Publisher节点的名称“talker”，不允许重复，是一个base name。 *&#x2F;        ros::NodeHandle n;    &#x2F;* 为这个进程的节点创建一个句柄。    第一个创建的 NodeHandle 会为节点进行初始化，    最后一个销毁的 NodeHandle 则会释放该节点所占用的所有资源。 *&#x2F;        ros::Publisher chatter_pub &#x3D; n.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000);    &#x2F;* 告诉 master 将要在 chatter（话题名）上发布 std_msgs&#x2F;String 消息类型的消息。    这样 master 就会告诉所有订阅了 chatter 话题的节点，将要有数据发布。    NodeHandle::advertise() 会建立一个topic。在ROS Master端注册一个Publisher，    返回一个 ros::Publisher 对象,此处为chatter_pub，,它有两个作用：     1) 它有一个 publish()函数可以在topic上发布(pubish)消息；     2) &lt;std_msgs::String&gt;指定后面要发布的消息类型是std_msgs包中的string类型，如果消息类型不对,它会拒绝发布。         (&quot;chatter&quot;, 1000)中两个参数，第一个参数指定以&quot;chatter&quot;为话题发布消息    第二个参数是发布序列的大小。如果发布的消息的频率太高，缓冲区中的消息在大于 1000 个的时候就会开始丢弃先前发布的消息。*&#x2F;        ros::Rate loop_rate(10);    &#x2F;* ros::Rate 对象可以允许你指定自循环的频率。它会追踪记录自上一次调用 Rate::sleep() 后时间的流逝，并休眠直到一个频率周期的时间。在这个例子中，让它以 10Hz 的频率运行，即节点休眠时间为100ms。 *&#x2F;       &#x2F;&#x2F;循环部分    int count &#x3D; 0;    while (ros::ok())    &#123;    &#x2F;*进入节点的主循环，如果下列条件之一发生，ros::ok() 返回false，跳出循环：·SIGINT 被触发 (Ctrl+C)：roscpp 会默认生成一个 SIGINT 句柄，它负责·处理 Ctrl+C 键盘操作使ros::ok() 返回 false·被另一同名节点踢出 ROS 网络·关闭函数ros::shutdown() 被程序的另一部分调用·节点中的所有 ros::NodeHandles 都已经被销毁一旦 ros::ok() 返回 false, 所有的 ROS 调用都会失效。    *&#x2F;            std_msgs::String msg;&#x2F;&#x2F;建立暂存区，先将消息放入，在进行publish        std::stringstream ss;        ss &lt;&lt; &quot;hello world &quot; &lt;&lt; count;        msg.data &#x3D; ss.str();&#x2F;&#x2F;将要输出的字符串消息存储到string消息类型中唯一成员data中        ROS_INFO(&quot;%s&quot;, msg.data.c_str()); &#x2F;&#x2F;类似C&#x2F;C++的 printf&#x2F;cout 等函数，打印日志信息。        chatter_pub.publish(msg);&#x2F;&#x2F;发布封装完毕的消息msg。Master会查找订阅该话题的节点，并完成两个节点的连接，传输消息                ros::spinOnce();&#x2F;&#x2F;处理订阅话题的所有回调函数callback()，        loop_rate.sleep(); &#x2F;&#x2F;休眠，休眠时间由loop_rate()设定        ++count;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>     打开你的 CMakeLists.txt ，随后找到（这里推介使用VScode 的搜索，嘎嘎快）</code></pre><p>​        留意到这里：</p><pre class="line-numbers language-none"><code class="language-none">add_executable()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是用于设置需要编译的代码和生成的可执行文件。第一个参数为期望生成的可执行文件的名称，后边的参数为参与编译的源码文件（cpp），如果需要多个代码文件，则可<br>在后面依次列出，中间用空格进行分隔。</p><p>​        和：</p><pre class="line-numbers language-none"><code class="language-none">target_link_libraries<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        用于设置链接库。很多功能需要使用系统或者第三方的库函数，通过该选项可以配置<br>执行文件链接的库文件，第一个参数是可执行文件的名称，后面依次列出需要链接的<br>库。此处编译没有使用其他库，添加默认链接库${catkin_LIBRARIES}即可。</p><p>​        以及</p><pre class="line-numbers language-none"><code class="language-none">add_dependencies<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        用于设置依赖。在很多应用中，我们需要定义语言无关的消息类型，消息类型会在编<br>译过程中产生相应语言的代码，如果编译的可执行文件依赖这些动态生成的代码，则<br>需要使用add_dependencies添加${PROJECT_NAME}_generate_messages_cpp<br>配置，即该功能包动态产生的消息代码。该编译规则也可以添加其他需要依赖的功能包。</p><p>​        下面我们设置一下：</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">include_directories(include $&#123;catkin_INCLUDE_DIRS&#125;)add_executable(talker src&#x2F;talker.cpp)target_link_libraries(talker $&#123;catkin_LIBRARIES&#125;)add_dependencies(talker $&#123;PROJECT_NAME&#125;_generate_messages_cpp)add_executable(listener src&#x2F;listener.cpp)target_link_libraries(listener $&#123;catkin_LIBRARIES&#125;)add_dependencies(listener $&#123;PROJECT_NAME&#125;_generate_messages_cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230302234440520.png" alt="image-20230302234440520"></p><p>​        现在注意，现在注意！我们的Cmake 的版本要求的是过高的，需要调整最低版本，否则在之后的文件编译中是会爆出找不到文件的迷惑错误！看到文件的第一行</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">cmake_minimum_required(VERSION 3.0.2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        改成：</p><pre class="line-numbers language-Cmake" data-language="Cmake"><code class="language-Cmake">cmake_minimum_required(VERSION 2.8.3)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        编译一下</p><p><img src="image-20230302234954815.png" alt="image-20230302234954815"></p><p>​        成功了。</p><p>​        为了运行，还是要设置环境变量：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/<span class="token operator">&lt;</span>workspace name<span class="token operator">></span><span class="token builtin class-name">source</span> ./devel/setup.bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​            想偷懒的话</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token string">"source ~/ros/tr3_6/devel/setup.bash"</span> <span class="token operator">>></span> ~/.bashrc$ <span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        启动 ROS:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roscore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        开一个新终端：运行我们的包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun talkerAndlistener talker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        再来一个：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun talkerAndlistener listener<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230303002333631.png" alt="image-20230303002333631"></p><p>​        下班！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机入门 1</title>
      <link href="/2023/03/01/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8-1/"/>
      <url>/2023/03/01/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8-1/</url>
      
        <content type="html"><![CDATA[<h1 id="51单片机入门"><a href="#51单片机入门" class="headerlink" title="51单片机入门"></a>51单片机入门</h1><h2 id="什么是单片机"><a href="#什么是单片机" class="headerlink" title="什么是单片机"></a>什么是单片机</h2><p>​        单片机（Single-Chip Microcomputer）是一种<strong>集成电路芯片</strong>，是采用超大规模集成电路技术把具有数据处理能力的<strong>中央处理器CPU、随机存储器RAM、只读存储器ROM、多种I/O口和中断系统、定时器/计数器</strong>等功能（可能还包括显示驱动电路、脉宽调制电路、模拟多路转换器、A/D转换器等电路）集成到一块硅片上构成的一个小而完善的微型计算机系统，在工业控制领域广泛应用。从上世纪80年代，由当时的4位、8位单片机，发展到现在的300M的高速单片机。</p><p>​        单片机又称单片微控制器，它不是完成某一个逻辑功能的芯片，而是把一个计算机系统集成到一个芯片上。相当于一个微型的计算机，和计算机相比，单片机只缺少了I/O设备。概括的讲：一块芯片就成了一台计算机。它的体积小、质量轻、价格便宜、为学习、应用和开发提供了便利条件。<strong>同时，学习使用单片机是了解计算机原理与结构的最佳选择。</strong></p><h2 id="为什么叫51单片机"><a href="#为什么叫51单片机" class="headerlink" title="为什么叫51单片机"></a>为什么叫51单片机</h2><p>​        51单片机是对兼容英特尔8051指令系统的单片机的统称。51单片机广泛应用于家用电器、汽车、工业测控、通信设备中。因为51单片机的指令系统、内部结构相对简单，所以国内许多高校用其进行单片机入门教学。</p><p><img src="image-20230301184900323.png" alt="image-20230301184900323"></p><p>​        </p><p>​        上图是单片机的一种经典结构，现在可以忽略不看</p><p>​        这是接口</p><p><img src="image-20230301185013274.png" alt="image-20230301185013274"></p><p>​        上图里，VCC表示电源的正极，GND是负极。而XTAL1，和XTAL2的两个接口则是表示单片机的时钟接口</p><p><img src="image-20230301185911921.png" alt="image-20230301185911921"></p><p>​        单片机也是机，要供电吃饭。系统电源给单片机供电，其电容是为了稳定的单片机供电（蓄水池）。</p><p>​        而右下角是晶振电路，是为了使单片机程序一步一步运行（固定发出信号）。</p><p>​        在实际上安装单片机的时候，一定要注意正负极！！！看清楚有凹槽的一段右侧是VCC接口，对面左下的是GND接口！</p><p><img src="image-20230301190636190.png" alt="image-20230301190636190"></p><h2 id="Light-UP-OUR-FIRST-LED"><a href="#Light-UP-OUR-FIRST-LED" class="headerlink" title="Light UP OUR FIRST LED"></a>Light UP OUR FIRST LED</h2><p>​        我们兴建一个工程，选择好文件夹并完成对工程文件夹的命名之后，选择器件，可以看到一个选择器件的对话框，选择AT89C52即可，随后在Target1 -&gt; Source Group里开始编写程序。</p><p>​        我们添加好C文件</p><p><img src="image-20230301193657680.png" alt="image-20230301193657680"></p><h3 id="扩展：电阻表示"><a href="#扩展：电阻表示" class="headerlink" title="扩展：电阻表示"></a>扩展：电阻表示</h3><p><img src="image-20230301194206533.png" alt="image-20230301194206533"></p><p>看到这个102了嘛？这表示的是 1 0 后面跟上两个0 就是 1K的电阻。再比如 473 就是47000 欧姆电阻。</p><h3 id="单片机怎么控制原件的？"><a href="#单片机怎么控制原件的？" class="headerlink" title="单片机怎么控制原件的？"></a>单片机怎么控制原件的？</h3><p>​        单片机是集成 CPU 的，外部的引脚同寄存器，通过驱动器（来增大驱动能力）来相连接，这样我们就可以直接向寄存器里写值！</p><p><img src="image-20230301194710160.png" alt="image-20230301194710160"></p><p>​        这样，我们就理解为什么是8 个口了（8位操作系统）</p><p><img src="image-20230301194824050.png" alt="image-20230301194824050"></p><p>​        回到 LED 电路里，为了使第一个灯亮起来，我们就对D1口（P20）处写入0，余下写1（这样其他电平一致，没有电流通过，反之另一个有），这样只有D1会亮！小端法就是1111 1110，十六进制就是 0xFE</p><p><img src="image-20230301195916687.png" alt="image-20230301195916687"></p><p>​        然后，选择：</p><p><img src="image-20230301195936801.png" alt="image-20230301195936801"></p><p>​        选择output 生成 hex 文件 随后再次编译即可.</p><p>​        当然可以循环闪！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;REGX52.H&gt;unsigned int arr[8] &#x3D; &#123;0xFE,0xFD,0xFB,0xF7,0xEF,0xDF,0xBF,0x7F&#125;;void main()&#123;unsigned int i &#x3D; 0;unsigned int j &#x3D; 0;for(j&#x3D;0;j&lt;8;j++)&#123;  P2 &#x3D; arr[j];for(i &#x3D; 0; i&lt;30000;i++) ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数基本教程（3）</title>
      <link href="/2023/02/28/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B%EF%BC%883%EF%BC%89/"/>
      <url>/2023/02/28/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵的概念"><a href="#矩阵的概念" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h1><p>​        本质上是一个数表，一个矩阵可以表达为：$m\times n$矩阵，元素可以使用$a_{ij}$</p><script type="math/tex; mode=display">\left [\begin{matrix}1&2&3 \\1&1&1\end{matrix}\right ]</script><p>​        这是一个$2\times 3$矩阵，记作$A_{2\times 3}$</p><h2 id="负矩阵"><a href="#负矩阵" class="headerlink" title="负矩阵"></a>负矩阵</h2><script type="math/tex; mode=display">B =-A</script><h2 id="N-阶矩阵"><a href="#N-阶矩阵" class="headerlink" title="N 阶矩阵"></a>N 阶矩阵</h2><p>​        定义<strong>行数等于列数的矩阵</strong>是<strong>一个方阵</strong></p><script type="math/tex; mode=display">\left [\begin{matrix}1&2 \\1&1\end{matrix}\right ]</script><h2 id="单位阵"><a href="#单位阵" class="headerlink" title="单位阵"></a>单位阵</h2><p>​        基于 N 阶方阵，如果只有主对角线元素不为0的方阵是单位阵</p><script type="math/tex; mode=display">\left [\begin{matrix}1&0 \\0&1\end{matrix}\right ]</script><h2 id="矩阵相等的前提是同型矩阵"><a href="#矩阵相等的前提是同型矩阵" class="headerlink" title="矩阵相等的前提是同型矩阵"></a>矩阵相等的前提是同型矩阵</h2><p>​        矩阵相等的前提是同型矩阵，接下来才会一 一对比元素！所以两个 0 矩阵不一定相等！</p><h2 id="运算律"><a href="#运算律" class="headerlink" title="运算律"></a>运算律</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>​        首先矩阵的加法只能发生在同型矩阵之中：加法是对应元素相加：</p><p>EG:</p><script type="math/tex; mode=display">\left [\begin{matrix}1&2&3 \\1&1&1\end{matrix}\right ]+\left [\begin{matrix}1&2&3 \\1&1&1\end{matrix}\right ]=\left [\begin{matrix}2&4&6 \\2&2&2\end{matrix}\right ]</script><h3 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h3><p>​        一致的：</p><script type="math/tex; mode=display">\left [\begin{matrix}1&2&3 \\1&1&1\end{matrix}\right ]-\left [\begin{matrix}1&2&3 \\1&1&1\end{matrix}\right ]=\left [\begin{matrix}0&0&0\\0&0&0\end{matrix}\right ]</script><h3 id="基本的运算律"><a href="#基本的运算律" class="headerlink" title="基本的运算律"></a>基本的运算律</h3><p>1）$A+B = B+A$</p><p>2)$(A+B)+C=A+(B+C)$</p><h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><p>​        定义：数子相乘把每个元素乘以数</p><script type="math/tex; mode=display">k\left [\begin{matrix}1&2&3 \\1&1&1\end{matrix}\right ]+=\left [\begin{matrix}k&2k&3k \\k&k&k\end{matrix}\right ]</script><p>​        这个操作可以反过来：叫提公因子：要求<strong>矩阵所有元素都有公因子，才会往外提一次</strong></p><p>对比的：<strong>一行（列）有公因子就提一次</strong></p><p>1）$k(A+B)=kA+kB$</p><p>2）$(k+l)A=kA+lA$</p><p>3)$k(lA)=(kl)A$</p><h3 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h3><p>​        注意矩阵的乘法要注意的：一个矩阵的行数要等于另一个矩阵的列数！</p><script type="math/tex; mode=display">C(i,j)=A(i,1)×B(1,j)+A(i,2)×B(2,j)+...A(r,1)×B(r,j)</script><p>​        结果就是：</p><p>​        <strong>中间相等，取两边，形状就是A的行B的列的矩阵</strong></p><p>​        注意：</p><p>1）$AB\neq BA$,况且AB有意义，BA不一定有意义！</p><p>2）AB = 0 <strong>无法推理出</strong>：$A = 0$或者$B=0$</p><p>3)$AB=AC,A\neq 0$<strong>推理不出</strong>：$B=C$!</p><p>与单位矩阵相乘等于其本身！</p><p>1）$(AB)C=A(BC)$</p><p>2）$(A+B)C=AC+BC$</p><p>3）$C(A+B)=CA+CB$</p><p>4）$k(AB)=(kA)B=A(kB)$</p><h3 id="矩阵的幂"><a href="#矩阵的幂" class="headerlink" title="矩阵的幂"></a>矩阵的幂</h3><p>​        定义幂的计算是如下的：</p><script type="math/tex; mode=display">A^k = AAA...A</script><p>1)$A^{k_1}A^{k_2}=A^{k_1+k_2}$</p><p>2)$(A^{k_1})^{k_2}=A^{k_1 k_2}$</p><h2 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h2><h3 id="数量矩阵"><a href="#数量矩阵" class="headerlink" title="数量矩阵"></a>数量矩阵</h3><script type="math/tex; mode=display">\left\{\begin{matrix}a&0&0&0&0&0\\0&a&0&0&0&0\\0&0&a&0&0&0\\.&.&.&.&.&.\\0&0&0&0&0&a\end{matrix}\right \}=a\left\{\begin{matrix}1&0&0&0&0&0\\0&1&0&0&0&0\\0&0&1&0&0&0\\.&.&.&.&.&.\\0&0&0&0&0&1\end{matrix}\right \}</script><h3 id="对角型矩阵"><a href="#对角型矩阵" class="headerlink" title="对角型矩阵"></a>对角型矩阵</h3><p>​        如果一个矩阵只有对角线的元素非零，那我们简单的写作</p><script type="math/tex; mode=display">diag(a_1,a_2,a_3,...,a_n)</script><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>定义满足$a_{ij}=a_{ji}$的矩阵是对称矩阵，其性质是：$A^T=A$</p><p>1)$(A+B)^T=A^T+B^T$</p><p>2)$(kA)^T=kA^T$</p><p>3)$(AB)^T=B^TA^T=BA$</p><h3 id="反对称矩阵"><a href="#反对称矩阵" class="headerlink" title="反对称矩阵"></a>反对称矩阵</h3><p>满足：$a_{ij}=-a_{ji}$且，$a_{ii}=0$的矩阵</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT 1</title>
      <link href="/2023/02/28/QT-1/"/>
      <url>/2023/02/28/QT-1/</url>
      
        <content type="html"><![CDATA[<h1 id="QT开发-NEW1"><a href="#QT开发-NEW1" class="headerlink" title="QT开发_NEW1"></a>QT开发_NEW1</h1><p>​        注意创建工程路径的时候不要不要不要整到含有中文的路径！</p><p>​        我们下载了 QT 之后，创建信息之后，会发现有三个类：</p><p>1）QWeidge 作为父类</p><p>2）QMainWindows子类</p><p>3）QDialog子类</p><p>2，3是1的子类</p><p><img src="image-20230228192413374.png" alt="image-20230228192413374"></p><p>​        可以看到，有一个.pro文件，跟VS文件是一样的，他是一个工程文件！</p><p><img src="image-20230228192501749.png" alt="image-20230228192501749"></p><p>​        这是一个工程的目录</p><p>​        先看主要的显示文件：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt; &#x2F;&#x2F; 包含一个应用程序类的文件&#x2F;&#x2F;argc 命令行变量的数量， *argv[] 是命令行变量的数组int main(int argc, char *argv[])&#123;    &#x2F;&#x2F;应用程序对象，再QT中方，应用程序对像只有一个    QApplication a(argc, argv);        &#x2F;&#x2F;窗口对象， widget- 父类 -&gt; QWedget    Widget w;    &#x2F;&#x2F; 显示窗口    w.show();    &#x2F;&#x2F; 让应用程序对象进入消息循环    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个循环可以被类比成如下的C程序：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;conio.h&gt;int main()&#123;while(_get() &#x3D;&#x3D; &#39; &#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这里，是点击窗口’ X ‘来关闭！</p><h2 id="看看工程文件"><a href="#看看工程文件" class="headerlink" title="看看工程文件"></a>看看工程文件</h2><p>​        工程文件自身可以在QT里打开：</p><p><img src="image-20230228193538543.png" alt="image-20230228193538543"></p><p>​        点击 1.pro 文件，可以看到如下的内容</p><p><img src="image-20230228193615493.png" alt="image-20230228193615493"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span># <span class="token comment">//工程创建时间</span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Project created by QtCreator <span class="token number">2023</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">28</span>T19<span class="token operator">:</span><span class="token number">15</span><span class="token operator">:</span><span class="token number">11</span></span></span>##<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>QT       <span class="token operator">+=</span> core gui <span class="token comment">// 包含的模块（1）</span><span class="token function">greaterThan</span><span class="token punctuation">(</span>QT_MAJOR_VERSION<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">:</span> QT <span class="token operator">+=</span> widgets <span class="token comment">// 大于这个版本才添加模块</span>TARGET <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 目标 生成的.exe文件的名字（2）不满意名字可以自行更换</span>TEMPLATE <span class="token operator">=</span> app <span class="token comment">//模板</span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">The following define makes your compiler emit warnings <span class="token keyword">if</span> you use</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">any</span> <span class="token expression">feature of Qt which as been marked as <span class="token function">deprecated</span> <span class="token punctuation">(</span>the exact warnings</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">depend</span> <span class="token expression">on your compiler<span class="token punctuation">)</span><span class="token punctuation">.</span> Please consult the documentation of the</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">deprecated</span> <span class="token expression">API in order to know how to port your code away from it<span class="token punctuation">.</span></span></span>DEFINES <span class="token operator">+=</span> QT_DEPRECATED_WARNINGS<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">You can also make your code fail to compile <span class="token keyword">if</span> you use deprecated APIs<span class="token punctuation">.</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">In order to <span class="token keyword">do</span> so<span class="token punctuation">,</span> uncomment the following line<span class="token punctuation">.</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">You can also select to disable deprecated APIs only up to a certain version of Qt<span class="token punctuation">.</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">DEFINES <span class="token operator">+=</span> QT_DISABLE_DEPRECATED_BEFORE<span class="token operator">=</span><span class="token number">0x060000</span>    # disables all the APIs deprecated before Qt <span class="token number">6.0</span><span class="token number">.0</span></span></span>SOURCES <span class="token operator">+=</span> \        main<span class="token punctuation">.</span>cpp \ <span class="token comment">//源文件</span>        widget<span class="token punctuation">.</span>cppHEADERS <span class="token operator">+=</span> \        widget<span class="token punctuation">.</span>h <span class="token comment">// 头文件</span>FORMS <span class="token operator">+=</span> \        widget<span class="token punctuation">.</span>ui<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（1）：</p><p><img src="image-20230228193822499.png" alt="image-20230228193822499"></p><p>（2）那个exe文件在这里：打开你的工程目录，返回上级会发现：</p><p><img src="image-20230228194240791.png" alt="image-20230228194240791"></p><p>点击下面的文件夹</p><p><img src="image-20230228194256086.png" alt="image-20230228194256086"></p><p>点击 debug</p><p><img src="image-20230228194315627.png" alt="image-20230228194315627"></p><p>就在这里的 1.exe</p><h2 id="看看头文件和widget-cpp"><a href="#看看头文件和widget-cpp" class="headerlink" title="看看头文件和widget.cpp"></a>看看头文件和widget.cpp</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECT &#x2F;&#x2F; 允许类中使用信号和槽的宏，不要轻易改动public:    explicit Widget(QWidget *parent &#x3D; 0);&#x2F;&#x2F; 默认构造函数    ~Widget();private:    Ui::Widget *ui;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);&#125;Widget::~Widget()&#123;    delete ui;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>​        类名：首字母大写，单词与单词之间首字母大写</p><p>​        函数名，变量名称：首字母小写，但单词与单词之间首字母大写</p><p>​        快捷键一览：</p><p>​        注释：ctrl + /</p><p>​        运行：ctrl + r</p><p>​        编译：ctrl + b</p><p>​        查找：ctrl + f</p><p>​        整行移动：ctrl + shift + ↑ 或者 ↓</p><p>​        自动对齐：ctrl + i</p><p>​        同名的.cpp 和 .h: F4</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 工程项目（2）：模拟String</title>
      <link href="/2023/02/26/C-%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%EF%BC%882%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%8B%9FString/"/>
      <url>/2023/02/26/C-%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%EF%BC%882%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%8B%9FString/</url>
      
        <content type="html"><![CDATA[<h1 id="MyCString"><a href="#MyCString" class="headerlink" title="MyCString"></a>MyCString</h1><h2 id="课堂摸鱼制作（"><a href="#课堂摸鱼制作（" class="headerlink" title="课堂摸鱼制作（"></a>课堂摸鱼制作（</h2><p>​        这次的小工程是为了还原一些常见的C 字符串功能，以及这是为了可以模拟 C++ string 左准备！</p><h2 id="MyCString-1"><a href="#MyCString-1" class="headerlink" title="MyCString"></a>MyCString</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token comment">//General Version</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token comment">//Error Defined here</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHOW_NULL_INPUT_WARNING</span> <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"this string seems to be NULL."</span><span class="token expression"><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHOW_ERROR_MALLOCING_SPACE</span> <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"can not find a space to store the data"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHOW_INVALID_INPUT</span> <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"cannot accept an invalid input!"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token comment">//Quick set Str's char number</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">Mystrlen</span><span class="token expression"><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span></span></span><span class="token comment">//Print in a line by using this abstractions</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLASHN</span> <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"\n"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span class="token comment">//ErrorCode_String</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token class-name">_MyStringErrorCode_</span> <span class="token punctuation">&#123;</span>MyString_NULL_INPUT <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>MyString_ERROR_IN_MALLOCING_SPACE <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>MyString_INVALID_INPUT <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>MySting_NORMAL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">&#125;</span>MyStringErrorCode<span class="token punctuation">;</span><span class="token comment">// Main Body and basic structure in str</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">MyString</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> charBuffer<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> current_size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyString<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_ComparatorResult_</span> <span class="token punctuation">&#123;</span><span class="token keyword">void</span><span class="token operator">*</span> equal<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> bigger<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> smaller<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ComparatorResult<span class="token punctuation">;</span><span class="token comment">//----------------------------------------------- init a comparator ----------------</span>ComparatorResult<span class="token operator">*</span> <span class="token function">initComparator</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> equal<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> bigger<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> smaller<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//----------------------------------------My_String------------------------------------</span><span class="token comment">// ---------------------------- Init A string -----------------------------------------</span><span class="token comment">// 1. initAString</span><span class="token comment">// by using this, you can init a string by input a ordinary char array</span><span class="token comment">// </span><span class="token comment">// input: char array</span><span class="token comment">// output: MyString* (a pointer to the myString)</span><span class="token comment">// ------------------------------------------------------------------------------------</span><span class="token comment">// 2.copyAString</span><span class="token comment">// by using this , you can copy a MyString as C++ copy init methods!</span><span class="token comment">// </span><span class="token comment">// input: A pointer to MyString</span><span class="token comment">// output: A pointer to MyString</span><span class="token comment">// ------------------------------------------------------------------------------------</span><span class="token comment">// </span>MyString<span class="token operator">*</span> <span class="token function">initAString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>MyString<span class="token operator">*</span> <span class="token function">copyAString</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">*</span> pCopy<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">printString</span><span class="token punctuation">(</span>MyString<span class="token operator">*</span> mine<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">setElemString</span><span class="token punctuation">(</span>MyString<span class="token operator">*</span> be_set_String<span class="token punctuation">,</span> <span class="token keyword">char</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> place<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">MyStrrev</span><span class="token punctuation">(</span>MyString<span class="token operator">*</span> reverse<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ----------------- Append and Copy -----------------------------</span><span class="token comment">// 1. MyStrCat</span><span class="token comment">// by using this , you can append a str at the end of a string</span><span class="token comment">// </span><span class="token comment">// input : two strings :str1 (as be apeended) &amp;&amp; appenderStr</span><span class="token comment">// output: a str that finishing his work</span><span class="token comment">// </span><span class="token comment">// ---------------------------------------------------------------</span><span class="token comment">// 2. MyStrCpy</span><span class="token comment">// by using this , you can get a copyed one and it will erase the data of the container</span><span class="token comment">// </span><span class="token comment">// input :two strings :str1 (as be apeended) &amp;&amp; copierStr</span><span class="token comment">// output:a str that finishing his work</span><span class="token comment">// </span><span class="token comment">// ----------------------------------------------------------------</span>MyString<span class="token operator">*</span> <span class="token function">MyStrCat</span><span class="token punctuation">(</span>MyString<span class="token operator">*</span> str1<span class="token punctuation">,</span> MyString<span class="token operator">*</span> appenderStr<span class="token punctuation">)</span><span class="token punctuation">;</span>MyString<span class="token operator">*</span> <span class="token function">MyStrCpy</span><span class="token punctuation">(</span>MyString<span class="token operator">*</span> container<span class="token punctuation">,</span> MyString<span class="token operator">*</span> beCopied<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ----------------------------------Compare-----------------------------------</span><span class="token comment">// 1. MyStrCmp</span><span class="token comment">// by using this , you can compare string as strcmp does</span><span class="token comment">// </span><span class="token comment">// input : two strings taht you want to compare</span><span class="token comment">// output: get result</span><span class="token comment">// if str1's ASCII &lt; str2's ASCII then returns 1;</span><span class="token comment">// else if str1's ASCII > str2's ASCII then returns -1;</span><span class="token comment">// else return 0 as equal</span><span class="token comment">// ----------------------------------------------------------------------------</span><span class="token comment">// MyStr_Self_Def_Cmp</span><span class="token comment">// by using this,you can compare string as strcmp does,and return the value you want to return</span><span class="token comment">// </span><span class="token comment">// input : two strings taht you want to compare , as well as the comparator</span><span class="token comment">// output: the things that fits the situation you wants to return</span><span class="token comment">// ----------------------------------------------------------------------------</span><span class="token keyword">int</span> <span class="token function">MyStrCmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">*</span> str1<span class="token punctuation">,</span> <span class="token keyword">const</span> MyString<span class="token operator">*</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">MyStr_Self_Def_Cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">*</span> str1<span class="token punctuation">,</span> <span class="token keyword">const</span> MyString<span class="token operator">*</span> str2<span class="token punctuation">,</span> ComparatorResult<span class="token operator">*</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MyCstring-cpp"><a href="#MyCstring-cpp" class="headerlink" title="MyCstring.cpp"></a>MyCstring.cpp</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token comment">//General Version</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token comment">//Error Defined here</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHOW_NULL_INPUT_WARNING</span> <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"this string seems to be NULL."</span><span class="token expression"><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHOW_ERROR_MALLOCING_SPACE</span> <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"can not find a space to store the data"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SHOW_INVALID_INPUT</span> <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"cannot accept an invalid input!"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token comment">//Quick set Str's char number</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">Mystrlen</span><span class="token expression"><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span></span></span><span class="token comment">//Print in a line by using this abstractions</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLASHN</span> <span class="token expression"><span class="token function">printf</span><span class="token punctuation">(</span></span><span class="token string">"\n"</span><span class="token expression"><span class="token punctuation">)</span></span></span><span class="token comment">//ErrorCode_String</span><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token class-name">_MyStringErrorCode_</span> <span class="token punctuation">&#123;</span>MyString_NULL_INPUT <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>MyString_ERROR_IN_MALLOCING_SPACE <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>MyString_INVALID_INPUT <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>MySting_NORMAL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">&#125;</span>MyStringErrorCode<span class="token punctuation">;</span><span class="token comment">// Main Body and basic structure in str</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">MyString</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> charBuffer<span class="token punctuation">;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> current_size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyString<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_ComparatorResult_</span> <span class="token punctuation">&#123;</span><span class="token keyword">void</span><span class="token operator">*</span> equal<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> bigger<span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> smaller<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ComparatorResult<span class="token punctuation">;</span><span class="token comment">//----------------------------------------------- init a comparator ----------------</span>ComparatorResult<span class="token operator">*</span> <span class="token function">initComparator</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> equal<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> bigger<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> smaller<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>ComparatorResult<span class="token operator">*</span> proUsableSpace <span class="token operator">=</span> <span class="token punctuation">(</span>ComparatorResult<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ComparatorResult<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>proUsableSpace <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_ERROR_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>MyString_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>proUsableSpace<span class="token operator">-></span>bigger <span class="token operator">=</span> bigger<span class="token punctuation">;</span>proUsableSpace<span class="token operator">-></span>smaller <span class="token operator">=</span> smaller<span class="token punctuation">;</span>proUsableSpace<span class="token operator">-></span>equal <span class="token operator">=</span> equal<span class="token punctuation">;</span><span class="token keyword">return</span> proUsableSpace<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//----------------------------------------My_String------------------------------------</span><span class="token comment">// ---------------------------- Init A string -----------------------------------------</span><span class="token comment">// 1. initAString</span><span class="token comment">// by using this, you can init a string by input a ordinary char array</span><span class="token comment">// </span><span class="token comment">// input: char array</span><span class="token comment">// output: MyString* (a pointer to the myString)</span><span class="token comment">// ------------------------------------------------------------------------------------</span><span class="token comment">// 2.copyAString</span><span class="token comment">// by using this , you can copy a MyString as C++ copy init methods!</span><span class="token comment">// </span><span class="token comment">// input: A pointer to MyString</span><span class="token comment">// output: A pointer to MyString</span><span class="token comment">// ------------------------------------------------------------------------------------</span><span class="token comment">// </span>MyString<span class="token operator">*</span> <span class="token function">initAString</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> buffer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>MyString<span class="token operator">*</span> pstring <span class="token operator">=</span> <span class="token punctuation">(</span>MyString<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>MyString<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>buffer <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_NULL_INPUT_WARNING<span class="token punctuation">;</span>pstring<span class="token operator">-></span>charBuffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>pstring<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">return</span> pstring<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">*</span> usableSpace <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>usableSpace <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_ERROR_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>MyString_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>usableSpace<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pstring<span class="token operator">-></span>charBuffer <span class="token operator">=</span> usableSpace<span class="token punctuation">;</span>pstring<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token function">Mystrlen</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span><span class="token keyword">return</span> pstring<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyString<span class="token operator">*</span> <span class="token function">copyAString</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">*</span> pCopy<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pCopy <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_NULL_INPUT_WARNING<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>MyString_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyString<span class="token operator">*</span> pstring <span class="token operator">=</span> <span class="token punctuation">(</span>MyString<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>MyString<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pCopy<span class="token operator">-></span>charBuffer <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_NULL_INPUT_WARNING<span class="token punctuation">;</span>pstring<span class="token operator">-></span>charBuffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>pstring<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">return</span> pstring<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">*</span> proUsableSpace <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>pCopy<span class="token operator">-></span>charBuffer<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>proUsableSpace <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_ERROR_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>MyString_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>proUsableSpace<span class="token punctuation">,</span> pCopy<span class="token operator">-></span>charBuffer<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>pCopy<span class="token operator">-></span>charBuffer<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pstring<span class="token operator">-></span>charBuffer <span class="token operator">=</span> proUsableSpace<span class="token punctuation">;</span>pstring<span class="token operator">-></span>current_size <span class="token operator">=</span> pCopy<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> pstring<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// ---------------------------- Do something -----------------------------------------</span><span class="token comment">// 1. printString</span><span class="token comment">// by using this, you can print a string</span><span class="token comment">// </span><span class="token comment">// input: MyString* that aims to be printed in the control tab</span><span class="token comment">// output: normal statues</span><span class="token comment">// ------------------------------------------------------------------------------------</span><span class="token comment">// 2.setElemString</span><span class="token comment">// by using this , you can set a char into a targeted place</span><span class="token comment">// </span><span class="token comment">// input: A pointer to MyString, your val that want to be inputed, and the place you specify</span><span class="token comment">// output: normal statues</span><span class="token comment">// ------------------------------------------------------------------------------------</span><span class="token comment">// 3. MyStrrev</span><span class="token comment">// by using this, it will help reverse a char array</span><span class="token comment">// </span><span class="token comment">// input :A pointer to MyString</span><span class="token comment">// output: normal statues</span><span class="token comment">// ------------------------------------------------------------------------------------</span><span class="token keyword">void</span> <span class="token function">printString</span><span class="token punctuation">(</span>MyString<span class="token operator">*</span> mine<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mine <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_NULL_INPUT_WARNING<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>MyString_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> mine<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> mine<span class="token operator">-></span>charBuffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> MySting_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">setElemString</span><span class="token punctuation">(</span>MyString<span class="token operator">*</span> be_set_String<span class="token punctuation">,</span> <span class="token keyword">char</span> val<span class="token punctuation">,</span><span class="token keyword">int</span> place<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>be_set_String <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_NULL_INPUT_WARNING<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>MyString_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>place <span class="token operator">>=</span> be_set_String<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_INVALID_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>MyString_INVALID_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>be_set_String<span class="token operator">-></span>charBuffer<span class="token punctuation">[</span>place<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token keyword">return</span> MySting_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">MyStrrev</span><span class="token punctuation">(</span>MyString<span class="token operator">*</span> reverse<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>reverse <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_NULL_INPUT_WARNING<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>MyString_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> reverse<span class="token operator">-></span>current_size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>temp <span class="token operator">=</span> reverse<span class="token operator">-></span>charBuffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>reverse<span class="token operator">-></span>charBuffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> reverse<span class="token operator">-></span>charBuffer<span class="token punctuation">[</span>reverse<span class="token operator">-></span>current_size <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>reverse<span class="token operator">-></span>charBuffer<span class="token punctuation">[</span>reverse<span class="token operator">-></span>current_size <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// ----------------- Append and Copy -----------------------------</span><span class="token comment">// 1. MyStrCat</span><span class="token comment">// by using this , you can append a str at the end of a string</span><span class="token comment">// </span><span class="token comment">// input : two strings :str1 (as be apeended) &amp;&amp; appenderStr</span><span class="token comment">// output: a str that finishing his work</span><span class="token comment">// </span><span class="token comment">// ---------------------------------------------------------------</span><span class="token comment">// 2. MyStrCpy</span><span class="token comment">// by using this , you can get a copyed one and it will erase the data of the container</span><span class="token comment">// </span><span class="token comment">// input :two strings :str1 (as be apeended) &amp;&amp; copierStr</span><span class="token comment">// output:a str that finishing his work</span><span class="token comment">// </span><span class="token comment">// ----------------------------------------------------------------</span>MyString<span class="token operator">*</span> <span class="token function">MyStrCat</span><span class="token punctuation">(</span>MyString<span class="token operator">*</span> str1<span class="token punctuation">,</span> MyString<span class="token operator">*</span> appenderStr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>appenderStr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_NULL_INPUT_WARNING<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No need to append str!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>str1 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>str1<span class="token punctuation">,</span> appenderStr<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>appenderStr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>str1<span class="token operator">-></span>current_size <span class="token operator">=</span> appenderStr<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> str1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>str1 <span class="token operator">==</span> appenderStr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> forCopy <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str1<span class="token operator">-></span>charBuffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>forCopy <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_ERROR_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>MyString_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>forCopy<span class="token punctuation">,</span> str1<span class="token operator">-></span>charBuffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str1<span class="token operator">-></span>charBuffer<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> appenderStr<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>str1<span class="token operator">-></span>charBuffer<span class="token punctuation">[</span>i <span class="token operator">+</span> str1<span class="token operator">-></span>current_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> appenderStr<span class="token operator">-></span>charBuffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>str1<span class="token operator">-></span>current_size <span class="token operator">=</span> str1<span class="token operator">-></span>current_size <span class="token operator">+</span> appenderStr<span class="token operator">-></span>current_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> str1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">*</span> proUsableSpace <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>str1<span class="token operator">-></span>charBuffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>str1<span class="token operator">-></span>charBuffer<span class="token punctuation">)</span><span class="token operator">+</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>appenderStr<span class="token operator">-></span>charBuffer<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> appenderStr<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>str1<span class="token operator">-></span>charBuffer<span class="token punctuation">[</span>i <span class="token operator">+</span> str1<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> appenderStr<span class="token operator">-></span>charBuffer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>str1<span class="token operator">-></span>current_size <span class="token operator">=</span> str1<span class="token operator">-></span>current_size <span class="token operator">+</span> appenderStr<span class="token operator">-></span>current_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> str1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>MyString<span class="token operator">*</span> <span class="token function">MyStrCpy</span><span class="token punctuation">(</span>MyString<span class="token operator">*</span> container<span class="token punctuation">,</span> MyString<span class="token operator">*</span> beCopied<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>beCopied <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_NULL_INPUT_WARNING<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No need to append"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> container<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>container <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_NULL_INPUT_WARNING<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Cannot input data into a NULL space"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> container<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">*</span> proUsableSpace <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>container<span class="token operator">-></span>charBuffer<span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span>beCopied<span class="token operator">-></span>charBuffer<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>proUsableSpace <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_ERROR_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>MyString_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>container<span class="token operator">-></span>charBuffer<span class="token punctuation">,</span> beCopied<span class="token operator">-></span>charBuffer<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>beCopied<span class="token operator">-></span>charBuffer<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>container<span class="token operator">-></span>current_size <span class="token operator">=</span> beCopied<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> container<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// ----------------------------------Compare-----------------------------------</span><span class="token comment">// 1. MyStrCmp</span><span class="token comment">// by using this , you can compare string as strcmp does</span><span class="token comment">// </span><span class="token comment">// input : two strings taht you want to compare</span><span class="token comment">// output: get result</span><span class="token comment">// if str1's ASCII &lt; str2's ASCII then returns 1;</span><span class="token comment">// else if str1's ASCII > str2's ASCII then returns -1;</span><span class="token comment">// else return 0 as equal</span><span class="token comment">// ----------------------------------------------------------------------------</span><span class="token comment">// MyStr_Self_Def_Cmp</span><span class="token comment">// by using this,you can compare string as strcmp does,and return the value you want to return</span><span class="token comment">// </span><span class="token comment">// input : two strings taht you want to compare , as well as the comparator</span><span class="token comment">// output: the things that fits the situation you wants to return</span><span class="token comment">// ----------------------------------------------------------------------------</span><span class="token keyword">int</span> <span class="token function">MyStrCmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">*</span> str1<span class="token punctuation">,</span><span class="token keyword">const</span> MyString<span class="token operator">*</span> str2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>str1 <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> str2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_NULL_INPUT_WARNING<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">*</span> CmpStr1 <span class="token operator">=</span> str1<span class="token operator">-></span>charBuffer<span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> CmpStr2 <span class="token operator">=</span> str2<span class="token operator">-></span>charBuffer<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>CmpStr1 <span class="token operator">!=</span> <span class="token char">'\0'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>CmpStr2 <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>CmpStr1 <span class="token operator">!=</span> <span class="token operator">*</span>CmpStr2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>CmpStr1 <span class="token operator">-</span> <span class="token operator">*</span>CmpStr2<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>CmpStr2 <span class="token operator">-</span> <span class="token operator">*</span>CmpStr1<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>CmpStr1<span class="token operator">++</span><span class="token punctuation">;</span>CmpStr2<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">MyStr_Self_Def_Cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyString<span class="token operator">*</span> str1<span class="token punctuation">,</span> <span class="token keyword">const</span> MyString<span class="token operator">*</span> str2<span class="token punctuation">,</span> ComparatorResult<span class="token operator">*</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>str1 <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> str2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_NULL_INPUT_WARNING<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">*</span> CmpStr1 <span class="token operator">=</span> str1<span class="token operator">-></span>charBuffer<span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> CmpStr2 <span class="token operator">=</span> str2<span class="token operator">-></span>charBuffer<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>CmpStr1 <span class="token operator">!=</span> <span class="token char">'\0'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>CmpStr2 <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>CmpStr1 <span class="token operator">>=</span> <span class="token operator">*</span>CmpStr2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> res<span class="token operator">-></span>bigger<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>CmpStr1 <span class="token operator">==</span> <span class="token operator">*</span>CmpStr2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> res<span class="token operator">-></span>equal<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> res<span class="token operator">-></span>smaller<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>CmpStr1<span class="token operator">++</span><span class="token punctuation">;</span>CmpStr2<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MyTest-c"><a href="#MyTest-c" class="headerlink" title="MyTest.c"></a>MyTest.c</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"MyString.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// to init a String</span>MyString<span class="token operator">*</span> pInit <span class="token operator">=</span> <span class="token function">initAString</span><span class="token punctuation">(</span><span class="token string">"this is a string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printString</span><span class="token punctuation">(</span>pInit<span class="token punctuation">)</span><span class="token punctuation">;</span>SLASHN<span class="token punctuation">;</span><span class="token comment">// to Copy a String</span>MyString<span class="token operator">*</span> pCopy <span class="token operator">=</span> <span class="token function">copyAString</span><span class="token punctuation">(</span>pInit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printString</span><span class="token punctuation">(</span>pInit<span class="token punctuation">)</span><span class="token punctuation">;</span>SLASHN<span class="token punctuation">;</span><span class="token comment">// to append a str</span>MyString<span class="token operator">*</span> pCat <span class="token operator">=</span> <span class="token function">MyStrCat</span><span class="token punctuation">(</span>pCopy<span class="token punctuation">,</span> pInit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printString</span><span class="token punctuation">(</span>pCat<span class="token punctuation">)</span><span class="token punctuation">;</span>SLASHN<span class="token punctuation">;</span><span class="token comment">//to copy a str just by charbuffer</span>MyString<span class="token operator">*</span> pC2 <span class="token operator">=</span> <span class="token function">initAString</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printString</span><span class="token punctuation">(</span>pC2<span class="token punctuation">)</span><span class="token punctuation">;</span>SLASHN<span class="token punctuation">;</span><span class="token function">MyStrCpy</span><span class="token punctuation">(</span>pC2<span class="token punctuation">,</span> pInit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printString</span><span class="token punctuation">(</span>pC2<span class="token punctuation">)</span><span class="token punctuation">;</span>SLASHN<span class="token punctuation">;</span><span class="token comment">// to reverse a string</span>MyString<span class="token operator">*</span> prev <span class="token operator">=</span> <span class="token function">initAString</span><span class="token punctuation">(</span><span class="token string">"hello,world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printString</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">MyStrrev</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printString</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// to compare</span>MyString<span class="token operator">*</span> pI <span class="token operator">=</span> <span class="token function">initAString</span><span class="token punctuation">(</span><span class="token string">"AA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MyString<span class="token operator">*</span> pII <span class="token operator">=</span> <span class="token function">initAString</span><span class="token punctuation">(</span><span class="token string">"AB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MyString<span class="token operator">*</span> pIII <span class="token operator">=</span> <span class="token function">initAString</span><span class="token punctuation">(</span><span class="token string">"AC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> t1 <span class="token operator">=</span> <span class="token function">MyStrCmp</span><span class="token punctuation">(</span>pI<span class="token punctuation">,</span> pII<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> t2 <span class="token operator">=</span> <span class="token function">MyStrCmp</span><span class="token punctuation">(</span>pIII<span class="token punctuation">,</span> pII<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> t3 <span class="token operator">=</span> <span class="token function">MyStrCmp</span><span class="token punctuation">(</span>pI<span class="token punctuation">,</span> pI<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C工程项目1： 贪吃蛇项目 v0_0_1</title>
      <link href="/2023/02/21/C%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE1%EF%BC%9A-%E8%B4%AA%E5%90%83%E8%9B%87%E9%A1%B9%E7%9B%AE-v0-0-1/"/>
      <url>/2023/02/21/C%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE1%EF%BC%9A-%E8%B4%AA%E5%90%83%E8%9B%87%E9%A1%B9%E7%9B%AE-v0-0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="贪吃蛇制作详解1"><a href="#贪吃蛇制作详解1" class="headerlink" title="贪吃蛇制作详解1"></a>贪吃蛇制作详解1</h1><h2 id="文档v0-0-1"><a href="#文档v0-0-1" class="headerlink" title="文档v0.0.1"></a>文档v0.0.1</h2><p>​        很有趣的是，这是我制作的第一个 C 语言的小项目，我清楚的记得这是我在逸夫楼第三阶梯花费了3个小时的时间构思+ coding 的，作为一个入门编程的萌新而言，这有点许些不容易，不管怎么说，我还是完成了它！</p><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><p>​        我们将会使用 EasyX 这个入门的图形库。</p><p>​        描述贪吃蛇这个游戏，那很显然，要有蛇，要有食物，也要有减肥餐（认真）。但是，我们要在一个二维的平面刻画他们的关系，那我们就需要一个二维的平面来刻画这样的关系：</p><p>​        我们当然可以类似 Opencv 里的 Point 类来高仿一个轮子,来刻画一个平面，不如说是一个二维点</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _PointPlat_&#123;int x;    int y; &#125;PointPlat;&#x2F;&#x2F;允许我使用int而不是double,我们只是用它来给我们的对象刻画位置的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        那么下面，就是刻画工程的主角：蛇了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _Snake_&#123;    size_t segmentSize;&#x2F;&#x2F; 蛇的节数    char directions;&#x2F;&#x2F; 蛇的方向    PointPlat segPlace[MAX_SEGMENT];  &#x2F;&#x2F; 蛇的节段坐标数组（懒得动态）&#125;Snake；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我想这样蛇就OK了</p><p>​        以及我们的两类食物：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _Food_&#123;    PointPlat foodXY;&#x2F;&#x2F; 食物在哪里    int score;&#x2F;&#x2F; 吃了多少分    bool whetherFoodExist; &#x2F;&#x2F;它现在在吗？我们有必要在下一次循环中来生成一个食物&#125;Food;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还有一个：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_LoseWeightFood_</span><span class="token punctuation">&#123;</span>    PointPlat loseWeightFoodXY<span class="token punctuation">;</span><span class="token comment">// 食物在哪里</span><span class="token keyword">int</span> score<span class="token punctuation">;</span><span class="token comment">// 吃了多少分</span>bool whetherLWF_Exist<span class="token punctuation">;</span><span class="token comment">//它现在在吗？我们有必要在下一次循环中来生成一个食物</span><span class="token punctuation">&#125;</span>LoseWeightFood<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="开始设计菜单"><a href="#开始设计菜单" class="headerlink" title="开始设计菜单"></a>开始设计菜单</h2><p>​        我们先不搞花里胡哨的，先使用 initgraph 函数（In EaxyX）来生成一个窗口：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">initgraph</span><span class="token punctuation">(</span><span class="token keyword">int</span> Length<span class="token punctuation">,</span> <span class="token keyword">int</span> Height<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        当然，太难看了</p><pre class="line-numbers language-none"><code class="language-none">setbkcolor(RGB(0,0,255));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        生成一个纯蓝背景（先别急，俺也知道不好看哈哈哈）好吧，我们写一个插入图片的版本，</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">IMAGE pic<span class="token punctuation">;</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pic<span class="token punctuation">,</span><span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"PATH"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">int</span> height<span class="token punctuation">,</span><span class="token keyword">int</span> width<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        设计一个菜单,显然他是一个既不需要输入也不需要输出的函数！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void menu();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        不过，似乎现在没什么需要显示的必要，先空在这里！</p><h2 id="开始放点东西！"><a href="#开始放点东西！" class="headerlink" title="开始放点东西！"></a>开始放点东西！</h2><p>​        我们要开始给我们的窗体布置东西了！我们首先先试着放东西：    </p><h3 id="蛇"><a href="#蛇" class="headerlink" title="蛇"></a>蛇</h3><p>​        我们开始给我们的蛇做一点初始化：</p><p>​        我们的蛇最好是有三个字节：那就是说首先我们的结构体成员变量：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">psnake -&gt; segmentSize &#x3D; 3;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        其次，也有准备初始化相关的坐标：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">psnake-&gt;segPlace[2].x &#x3D; 20;psnake-&gt;segPlace[2].y &#x3D; 0;psnake-&gt;segPlace[1].x &#x3D; 30;psnake-&gt;segPlace[1].y &#x3D; 0;psnake-&gt;segPlace[0].x &#x3D; 40;psnake-&gt;segPlace[0].y &#x3D; 0;&#x2F;&#x2F;他们都是右上角的点的坐标，后面的绘图问题我们将单独引入一个 EaxyX库来绘图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        最后，蛇当前的方向应该要被制定：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">psnake-&gt;directions &#x3D; Right;&#x2F;&#x2F; temperately this. we will define them later<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这样我们的初始化就完成了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void initSnack(Snake* psnake)&#123;psnake-&gt;segPlace[2].x &#x3D; 20;psnake-&gt;segPlace[2].y &#x3D; 0;psnake-&gt;segPlace[1].x &#x3D; 30;psnake-&gt;segPlace[1].y &#x3D; 0;psnake-&gt;segPlace[0].x &#x3D; 40;psnake-&gt;segPlace[0].y &#x3D; 0;psnake -&gt; segmentSize &#x3D; 3;psnake-&gt;directions &#x3D; Right;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="食物与减肥餐"><a href="#食物与减肥餐" class="headerlink" title="食物与减肥餐"></a>食物与减肥餐</h3><p>​        我们还是注意到食物应当是任意出现的，这就涉及到随机库的使用，在C语言中，我们需要手动制定一个随机工厂函数：</p><p>​        以随机返回一个 int 类型的作为一个例子</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">getRandNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> minRange<span class="token punctuation">,</span> <span class="token keyword">int</span> maxRange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> maxRange <span class="token operator">+</span> minRange<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        扩展以下，如果希望快速产生不一样的随机数，请使用这个模板，因为前者以秒作为刷新单位，后者则是以CPU时间作为基准计算</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">getQuickContiniousRandNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> minRange<span class="token punctuation">,</span> <span class="token keyword">int</span> maxRange<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> maxRange <span class="token operator">+</span> minRange<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，我们就拿到了随机数，可以确定我们生成食物的位置了！</p><p>​        注意到：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">randInitFoodPos</span><span class="token punctuation">(</span>Food<span class="token operator">*</span> pfood<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">650</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">30</span><span class="token punctuation">;</span>pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">480</span><span class="token punctuation">;</span>pfood<span class="token operator">-></span>whetherFoodExist <span class="token operator">=</span> TRUE<span class="token punctuation">;</span> <span class="token comment">// this row</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">randInitLWFoodPos</span><span class="token punctuation">(</span>LoseWeightFood<span class="token operator">*</span> pLWFood<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pLWFood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">650</span><span class="token punctuation">;</span>pLWFood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">480</span><span class="token punctuation">;</span>pLWFood<span class="token operator">-></span>whetherLWF_Exist <span class="token operator">=</span> TRUE<span class="token punctuation">;</span> <span class="token comment">// this row</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们将在后面阐述为什么设置这个状态栏（剧透：确定是否需要刷新食物）</p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>​        我们的绘制是采用 EasyX 库来完成的！</p><p>​        首先介绍以下窗口幕布：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">initgraph</span><span class="token punctuation">(</span><span class="token keyword">int</span> height<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个函数向我们的屏幕投影一个 height 高 weight 宽的一个窗口，显然，是黑色的</p><p><img src="image-20230221111851289.png" alt="image-20230221111851289"></p><p>​        好像不大好看，但是正如前面所讲，我们可以插入一个图片来解决这个问题：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define PATH &quot;&#x2F;*你的图片地址*&#x2F;&quot;loadimage(&amp;pic,_T(PATH),int picHeight,int picWidth);putimage(0, 0, &amp;pic);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        这样就好了！</p><p><img src="image-20230221113213376.png" alt="image-20230221113213376"></p><p>​        随后，让我们来看看画一下蛇和食物！</p><p>​        针对一个一个节段，我们设置，随后使用一个for循环来完成我们的工作就OK了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">drawSnake</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> psnake<span class="token operator">-></span>segmentSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">setlinecolor</span><span class="token punctuation">(</span>YELLOW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//边框色</span><span class="token function">setfillcolor</span><span class="token punctuation">(</span>RED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fillrectangle</span><span class="token punctuation">(</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> psnake  <span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">,</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">drawFood</span><span class="token punctuation">(</span>Food<span class="token operator">*</span> pfood<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">setlinecolor</span><span class="token punctuation">(</span>RED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//边框色</span><span class="token function">setfillcolor</span><span class="token punctuation">(</span>YELLOW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">solidcircle</span><span class="token punctuation">(</span>pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>x<span class="token punctuation">,</span> pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">drawLWFood</span><span class="token punctuation">(</span>LoseWeightFood<span class="token operator">*</span> LWFood<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">setlinecolor</span><span class="token punctuation">(</span>GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//边框色</span><span class="token function">setfillcolor</span><span class="token punctuation">(</span>GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">solidcircle</span><span class="token punctuation">(</span>LWFood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>x<span class="token punctuation">,</span> LWFood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230221113411612.png" alt="image-20230221113411612"></p><p>​        上图就是把程序放在一起编译运行产生的结果！</p><h2 id="动起来"><a href="#动起来" class="headerlink" title="动起来"></a>动起来</h2><p>​        下面，我们准备开始写游戏的逻辑了</p><h3 id="1-让蛇动起来先"><a href="#1-让蛇动起来先" class="headerlink" title="1.让蛇动起来先"></a>1.让蛇动起来先</h3><p>​        让蛇动起来，这是个难题，因为蛇的运动是要有方向的！我们先不考虑我们如何操纵蛇的移动，因为那需要与键盘直接交互（注意到 scanf 是肯定不可以的！那样的话游戏操作性太差了）</p><p>​        我们使用 For 程式的递归，让一条蛇退化成一节蛇！这样我们就可以把目光放在第一节来处理了！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pSnake<span class="token operator">-></span>segmentSize <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    pSnake <span class="token operator">-></span> segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> pSnake <span class="token operator">-></span> segPlace<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>    pSnake <span class="token operator">-></span> segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> pSnake <span class="token operator">-></span> segPlace<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        目光放在第一节来处理了！注意到，如果我们的方向是向右，那么：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (derections &#x3D;&#x3D; RIGHT)&#123;pSnake -&gt; segPlace[0].x +&#x3D; 10;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        我们的蛇的头就向右走，同样的，我们这里是有四个方向的。于是这里使用 switch-case语句比较好</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">switch</span><span class="token punctuation">(</span>pSnake <span class="token operator">-></span> directions<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> RIGHT<span class="token operator">:</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> LEFT<span class="token operator">:</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> UP<span class="token operator">:</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> DOWN<span class="token operator">:</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于边界的处理，有人判定是到边界直接寄，但是我们这里是直接从另一边出来比较好：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">></span> <span class="token number">640</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">640</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">></span> <span class="token number">480</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">480</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="键盘交互"><a href="#键盘交互" class="headerlink" title="键盘交互"></a>键盘交互</h3><p>​        我们的蛇一旦程序跑起来，你会发现他只能一直往一个方向跑路，没办法掉头，这是件不好的事情！那么我们就：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;conio,h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        来引入我们键盘对控制台的直接交互.使用这个函数:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> getter <span class="token operator">=</span> <span class="token function">_getch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这样我们就可以直接向程序中输入东西了！了解到我们的蛇不可以掉头，那。。。加个if直接处理掉就好了！ </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">keyReact</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> key <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>key <span class="token operator">=</span> <span class="token function">_getch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> right<span class="token operator">:</span><span class="token keyword">if</span> <span class="token punctuation">(</span>psnake<span class="token operator">-></span>direction <span class="token operator">!=</span> left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>direction <span class="token operator">=</span> right<span class="token punctuation">;</span><span class="token comment">//禁止掉头</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> left<span class="token operator">:</span><span class="token keyword">if</span> <span class="token punctuation">(</span>psnake<span class="token operator">-></span>direction <span class="token operator">!=</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>direction <span class="token operator">=</span> left<span class="token punctuation">;</span><span class="token comment">//禁止掉头</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> up<span class="token operator">:</span><span class="token keyword">if</span> <span class="token punctuation">(</span>psnake<span class="token operator">-></span>direction <span class="token operator">!=</span> down<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>direction <span class="token operator">=</span> up<span class="token punctuation">;</span><span class="token comment">//禁止掉头</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> down<span class="token operator">:</span><span class="token keyword">if</span> <span class="token punctuation">(</span>psnake<span class="token operator">-></span>direction <span class="token operator">!=</span> up<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>direction <span class="token operator">=</span> down<span class="token punctuation">;</span><span class="token comment">//禁止掉头</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        当然，我们查一下键盘上：↑↓←→的ACSII值：在枚举以下就好了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">Directions</span> <span class="token punctuation">&#123;</span>RIGHT <span class="token operator">=</span> <span class="token number">77</span><span class="token punctuation">,</span>LEFT <span class="token operator">=</span> <span class="token number">75</span><span class="token punctuation">,</span>DOWN <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">,</span>UP <span class="token operator">=</span> <span class="token number">72</span><span class="token punctuation">,</span><span class="token comment">//对应keypress</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="恰饭处理"><a href="#恰饭处理" class="headerlink" title="恰饭处理"></a>恰饭处理</h3><p>​        恰饭了！这怎么处理呢？</p><p>​        首先，那必然是蛇的节数要++了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">psnake<span class="token operator">-></span>segmentSize<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        食物的状态要准备更新了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">pfood<span class="token operator">-></span>whetherFoodExist <span class="token operator">=</span> false<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        判定的条件是几乎重合：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>   psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>y <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>x <span class="token operator">></span> <span class="token operator">-</span><span class="token number">10</span> <span class="token operator">&amp;&amp;</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>y <span class="token operator">></span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>segmentSize<span class="token operator">++</span><span class="token punctuation">;</span>pfood<span class="token operator">-></span>whetherFoodExist <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        当然想加分的话那就：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>   psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>y <span class="token operator">&lt;</span> <span class="token number">10</span>    <span class="token operator">&amp;&amp;</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>x <span class="token operator">></span> <span class="token operator">-</span><span class="token number">10</span>     <span class="token operator">&amp;&amp;</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>y <span class="token operator">></span> <span class="token operator">-</span><span class="token number">10</span>    <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>segmentSize<span class="token operator">++</span><span class="token punctuation">;</span>pfood<span class="token operator">-></span>score <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span>pfood<span class="token operator">-></span>whetherFoodExist <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于减肥餐那也是一样的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">eatLWFood</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">,</span> LoseWeightFood<span class="token operator">*</span> plossfood<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> plossfood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>x<span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">&amp;&amp;</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> plossfood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>y<span class="token operator">&lt;</span><span class="token number">10</span> <span class="token operator">&amp;&amp;</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> plossfood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>x <span class="token operator">></span> <span class="token operator">-</span><span class="token number">10</span> <span class="token operator">&amp;&amp;</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> plossfood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>y <span class="token operator">></span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>segmentSize<span class="token operator">--</span><span class="token punctuation">;</span>plossfood<span class="token operator">-></span>score <span class="token operator">+=</span> <span class="token number">100</span><span class="token punctuation">;</span>plossfood<span class="token operator">-></span>whetherLWF_Exist <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="嗝屁判断"><a href="#嗝屁判断" class="headerlink" title="嗝屁判断"></a>嗝屁判断</h3><p>​        注意，我们的目光滞留在第一个节段，如果第一个节段同其他位置重复了，那就是嗝屁了！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">deathJudge</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> psnake<span class="token operator">-></span>segmentSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">==</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">&amp;&amp;</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">==</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token punctuation">)</span><span class="token comment">//</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> QUIT<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> MOVE_ON<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主程序架构"><a href="#主程序架构" class="headerlink" title="主程序架构"></a>主程序架构</h2><p>​        积木打好了，准备并结成主程序了！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Structure.h"</span></span><span class="token keyword">int</span> judge <span class="token operator">=</span> MOVE_ON<span class="token punctuation">;</span><span class="token keyword">int</span> total_score <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//我们的分数</span><span class="token keyword">int</span> input_game_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//定义速度</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//这里下面说</span>Snake snake1<span class="token punctuation">;</span>Food food1<span class="token punctuation">;</span>LoseWeightFood lossfood1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们可以构建起选择蛇速度的程序，因为我们的程序本质上使用while循环来执行，使用Windows库里的Sleep函数可以让程序空余若干秒</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Sleep(int milisecondTime)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"请输入你想要的速度：>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>input_game_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> input <span class="token operator">=</span> <span class="token function">chooseSpeed</span><span class="token punctuation">(</span>input_game_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// to prevent the slash n get into the scanner!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        准备对象</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Snake snake1<span class="token punctuation">;</span>Food food1<span class="token punctuation">;</span>LoseWeightFood lossfood1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        为主屏幕的东西设置与初始化</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">randInitFoodPos</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>food1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">randInitLWFoodPos</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lossfood1<span class="token punctuation">)</span><span class="token punctuation">;</span>food1<span class="token punctuation">.</span>whetherFoodExist <span class="token operator">=</span> true<span class="token punctuation">;</span>lossfood1<span class="token punctuation">.</span>whetherLWF_Exist <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token function">initBackGround</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">cleardevice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">initSnake</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">)</span><span class="token punctuation">;</span>IMAGE pic<span class="token punctuation">;</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pic<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span>PATH<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>judge <span class="token operator">==</span> MOVE_ON<span class="token punctuation">)</span>   <span class="token punctuation">&#123;</span>          <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        先刷新屏幕，去除上次的东西：</p><p>​        准备放上图片，判断食物有没有，没有就放上！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">cleardevice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pic<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>food1<span class="token punctuation">.</span>whetherFoodExist<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">randInitFoodPos</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>food1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">drawFood</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>food1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> count <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lossfood1<span class="token punctuation">.</span>whetherLWF_Exist<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">randInitLWFoodPos</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lossfood1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>lossfood1<span class="token punctuation">.</span>whetherLWF_Exist<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">drawLWFood</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lossfood1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个count 就是用来描述我们什么时候生成lossFood的！</p><p>​        判断有没有吃到，有没有跟键盘交互：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">eatLWFood</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lossfood1<span class="token punctuation">)</span><span class="token punctuation">;</span>count <span class="token operator">=</span> <span class="token function">eatFood</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>food1<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">drawSnake</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">_kbhit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">keyReact</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        挪动蛇屁股：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">moveSnake</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">)</span><span class="token punctuation">;</span>judge <span class="token operator">=</span> <span class="token function">deathJudge</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Sleep</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>total_score <span class="token operator">=</span> food1<span class="token punctuation">.</span>score <span class="token operator">+</span> lossfood1<span class="token punctuation">.</span>score<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        后续处理：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">closegraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"你得到了分数！：%d\n"</span><span class="token punctuation">,</span> food1<span class="token punctuation">.</span>score <span class="token operator">+</span> lossfood1<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"敲击q退出游戏！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> quit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>quit <span class="token operator">!=</span> <span class="token char">'q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>quit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="源文件一览："><a href="#源文件一览：" class="headerlink" title="源文件一览："></a>源文件一览：</h1><h2 id="主程序："><a href="#主程序：" class="headerlink" title="主程序："></a>主程序：</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Structure.h"</span></span><span class="token keyword">int</span> judge <span class="token operator">=</span> MOVE_ON<span class="token punctuation">;</span><span class="token keyword">int</span> total_score <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> input_game_start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>Snake snake1<span class="token punctuation">;</span>Food food1<span class="token punctuation">;</span>LoseWeightFood lossfood1<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"请输入你想要的速度：>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>input_game_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> input <span class="token operator">=</span> <span class="token function">chooseSpeed</span><span class="token punctuation">(</span>input_game_start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">randInitFoodPos</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>food1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">randInitLWFoodPos</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lossfood1<span class="token punctuation">)</span><span class="token punctuation">;</span>food1<span class="token punctuation">.</span>whetherFoodExist <span class="token operator">=</span> true<span class="token punctuation">;</span>lossfood1<span class="token punctuation">.</span>whetherLWF_Exist <span class="token operator">=</span> false<span class="token punctuation">;</span><span class="token function">initBackGround</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">cleardevice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">initSnake</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">)</span><span class="token punctuation">;</span>IMAGE pic<span class="token punctuation">;</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pic<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span>PATH<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>judge <span class="token operator">==</span> MOVE_ON<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">cleardevice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pic<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>food1<span class="token punctuation">.</span>whetherFoodExist<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">randInitFoodPos</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>food1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">drawFood</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>food1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> count <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lossfood1<span class="token punctuation">.</span>whetherLWF_Exist<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">randInitLWFoodPos</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lossfood1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>lossfood1<span class="token punctuation">.</span>whetherLWF_Exist<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">drawLWFood</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lossfood1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">eatLWFood</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lossfood1<span class="token punctuation">)</span><span class="token punctuation">;</span>count <span class="token operator">=</span> <span class="token function">eatFood</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>food1<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">drawSnake</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">_kbhit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">keyReact</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">moveSnake</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">)</span><span class="token punctuation">;</span>judge <span class="token operator">=</span> <span class="token function">deathJudge</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>snake1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Sleep</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>total_score <span class="token operator">=</span> food1<span class="token punctuation">.</span>score <span class="token operator">+</span> lossfood1<span class="token punctuation">.</span>score<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">closegraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"你得到了分数！：%d\n"</span><span class="token punctuation">,</span> food1<span class="token punctuation">.</span>score <span class="token operator">+</span> lossfood1<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"敲击q退出游戏！\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> quit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>quit <span class="token operator">!=</span> <span class="token char">'q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>quit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="objbehavior-cpp"><a href="#objbehavior-cpp" class="headerlink" title="objbehavior.cpp"></a>objbehavior.cpp</h2><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1#include&quot;Structure.h&quot;void moveSnake(Snake* psnake)&#123;&#x2F;&#x2F;分批次处理：&#x2F;&#x2F;使用For递归处理2~N节数 的蛇for (int i &#x3D; psnake-&gt;segmentSize - 1; i &gt; 0; i--)&#123;psnake-&gt;segPlace[i].x &#x3D; psnake-&gt;segPlace[i - 1].x;psnake-&gt;segPlace[i].y &#x3D; psnake-&gt;segPlace[i - 1].y;&#125;switch (psnake-&gt;direction)&#123;&#x2F;&#x2F;72上 80下 75左 77右case 77:psnake-&gt;segPlace[0].x +&#x3D; 10; break;case 75:psnake-&gt;segPlace[0].x -&#x3D; 10; break;case 80:psnake-&gt;segPlace[0].y +&#x3D; 10; break;case 72:psnake-&gt;segPlace[0].y -&#x3D; 10; break;default:break;&#125;if (psnake-&gt;segPlace[0].x &gt; 640)&#123;psnake-&gt;segPlace[0].x &#x3D; 0;&#125;if (psnake-&gt;segPlace[0].x &lt; 0)&#123;psnake-&gt;segPlace[0].x &#x3D; 640;&#125;if (psnake-&gt;segPlace[0].y &gt; 480)&#123;psnake-&gt;segPlace[0].y &#x3D; 0;&#125;if (psnake-&gt;segPlace[0].y &lt; 0)&#123;psnake-&gt;segPlace[0].y &#x3D; 480;&#125;&#125;void eatLWFood(Snake* psnake, LoseWeightFood* plossfood)&#123;if (psnake-&gt;segPlace[0].x - plossfood-&gt;loseWeightFoodXY.x&lt;10 &amp;&amp; psnake-&gt;segPlace[0].y - plossfood-&gt;loseWeightFoodXY.y&lt;10 &amp;&amp; psnake-&gt;segPlace[0].x - plossfood-&gt;loseWeightFoodXY.x &gt; -10 &amp;&amp; psnake-&gt;segPlace[0].y - plossfood-&gt;loseWeightFoodXY.y &gt;-10)&#123;psnake-&gt;segmentSize--;plossfood-&gt;score +&#x3D; 100;plossfood-&gt;whetherLWF_Exist &#x3D; false;&#125;&#125;int eatFood(Snake* psnake, Food* pfood, int count)&#123;srand((unsigned)time(NULL));if (psnake-&gt;segPlace[0].x - pfood-&gt;foodXY.x&lt;10 &amp;&amp; psnake-&gt;segPlace[0].y - pfood-&gt;foodXY.y&lt;10 &amp;&amp; psnake-&gt;segPlace[0].x - pfood-&gt;foodXY.x &gt; -10 &amp;&amp; psnake-&gt;segPlace[0].y - pfood-&gt;foodXY.y &gt;-10)&#123;psnake-&gt;segmentSize++;pfood-&gt;score +&#x3D; 10;pfood-&gt;whetherFoodExist &#x3D; false;return count + 1;&#125;&#125;void keyReact(Snake* psnake)&#123;char key &#x3D; 0;key &#x3D; _getch();switch (key)&#123;case RIGHT:if (psnake-&gt;direction !&#x3D; LEFT)&#123;psnake-&gt;direction &#x3D; RIGHT;&#x2F;&#x2F;禁止掉头&#125;break;case LEFT:if (psnake-&gt;direction !&#x3D; RIGHT)&#123;psnake-&gt;direction &#x3D; LEFT;&#x2F;&#x2F;禁止掉头&#125;break;case UP:if (psnake-&gt;direction !&#x3D; DOWN)&#123;psnake-&gt;direction &#x3D; UP;&#x2F;&#x2F;禁止掉头&#125;break;case DOWN:if (psnake-&gt;direction !&#x3D; UP)&#123;psnake-&gt;direction &#x3D; DOWN;&#x2F;&#x2F;禁止掉头&#125;break;default: break;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MENUfunc-cpp"><a href="#MENUfunc-cpp" class="headerlink" title="MENUfunc.cpp"></a>MENUfunc.cpp</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Structure.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DEFAULT</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SLOW</span> <span class="token expression"><span class="token number">50</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FAST</span> <span class="token expression"><span class="token number">20</span>   </span></span><span class="token comment">//MenuFunctions</span><span class="token keyword">void</span> <span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"----------------------------------------------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"请选择你想要的难度！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"0:正常 1.放慢 2.加速 3.自定义"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"----------------------------------------------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">chooseSpeed</span><span class="token punctuation">(</span><span class="token keyword">int</span> input<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">return</span> DEFAULT<span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token keyword">return</span> SLOW<span class="token punctuation">;</span><span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token keyword">return</span> FAST<span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span><span class="token keyword">return</span> input<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="initgameFunc-cpp"><a href="#initgameFunc-cpp" class="headerlink" title="initgameFunc.cpp"></a>initgameFunc.cpp</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Structure.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">initBackGround</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>IMAGE pic<span class="token punctuation">;</span><span class="token function">initgraph</span><span class="token punctuation">(</span><span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">480</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">loadimage</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pic<span class="token punctuation">,</span> <span class="token function">_T</span><span class="token punctuation">(</span><span class="token string">"D:/Clion/default.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">640</span><span class="token punctuation">,</span><span class="token number">480</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putimage</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>pic<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">initSnake</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>psnake<span class="token operator">-></span>segmentSize <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>psnake<span class="token operator">-></span>direction <span class="token operator">=</span> RIGHT<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="InitFoodFunc-cpp"><a href="#InitFoodFunc-cpp" class="headerlink" title="InitFoodFunc.cpp"></a>InitFoodFunc.cpp</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Structure.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">randInitFoodPos</span><span class="token punctuation">(</span>Food<span class="token operator">*</span> pfood<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">650</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">30</span><span class="token punctuation">;</span>pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">480</span><span class="token punctuation">;</span>pfood<span class="token operator">-></span>whetherFoodExist <span class="token operator">=</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">randInitLWFoodPos</span><span class="token punctuation">(</span>LoseWeightFood<span class="token operator">*</span> pLWFood<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pLWFood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">650</span><span class="token punctuation">;</span>pLWFood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">480</span><span class="token punctuation">;</span>pLWFood<span class="token operator">-></span>whetherLWF_Exist <span class="token operator">=</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="draw-cpp"><a href="#draw-cpp" class="headerlink" title="draw.cpp"></a>draw.cpp</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Structure.h"</span></span><span class="token keyword">void</span> <span class="token function">drawSnake</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> psnake<span class="token operator">-></span>segmentSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">setlinecolor</span><span class="token punctuation">(</span>YELLOW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//边框色</span><span class="token function">setfillcolor</span><span class="token punctuation">(</span>RED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fillrectangle</span><span class="token punctuation">(</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">,</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">drawFood</span><span class="token punctuation">(</span>Food<span class="token operator">*</span> pfood<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">setlinecolor</span><span class="token punctuation">(</span>RED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//边框色</span><span class="token function">setfillcolor</span><span class="token punctuation">(</span>YELLOW<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">solidcircle</span><span class="token punctuation">(</span>pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>x<span class="token punctuation">,</span> pfood<span class="token operator">-></span>foodXY<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">drawLWFood</span><span class="token punctuation">(</span>LoseWeightFood<span class="token operator">*</span> LWFood<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">setlinecolor</span><span class="token punctuation">(</span>GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//边框色</span><span class="token function">setfillcolor</span><span class="token punctuation">(</span>GREEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">solidcircle</span><span class="token punctuation">(</span>LWFood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>x<span class="token punctuation">,</span> LWFood<span class="token operator">-></span>loseWeightFoodXY<span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="deathJugde-cpp"><a href="#deathJugde-cpp" class="headerlink" title="deathJugde.cpp"></a>deathJugde.cpp</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Structure.h"</span></span><span class="token keyword">int</span> <span class="token function">deathJudge</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> psnake<span class="token operator">-></span>segmentSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">==</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">&amp;&amp;</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">==</span> psnake<span class="token operator">-></span>segPlace<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token punctuation">)</span><span class="token comment">//</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> QUIT<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> MOVE_ON<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Structure-h"><a href="#Structure-h" class="headerlink" title="Structure.h"></a>Structure.h</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_SEGMENT</span> <span class="token expression"><span class="token number">256</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;graphics.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;conio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h></span></span><span class="token comment">//config</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">QUIT</span> <span class="token expression"><span class="token number">2</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MOVE_ON</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PATH</span> <span class="token string">"D:/Clion/default.png"</span></span><span class="token comment">//定义二维平面</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_PointPlat_</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>PointPlat<span class="token punctuation">;</span><span class="token comment">//定义蛇这个对象</span><span class="token comment">//</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_Snake_</span> <span class="token punctuation">&#123;</span><span class="token class-name">size_t</span> segmentSize<span class="token punctuation">;</span><span class="token comment">// 定义蛇的节数</span><span class="token keyword">char</span> direction<span class="token punctuation">;</span><span class="token comment">// 定义当前蛇的前进方向</span>PointPlat segPlace<span class="token punctuation">[</span>MAX_SEGMENT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 定义蛇的段坐标</span><span class="token punctuation">&#125;</span>Snake<span class="token punctuation">;</span><span class="token comment">//食物</span><span class="token comment">//</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_Food_</span> <span class="token punctuation">&#123;</span>PointPlat foodXY<span class="token punctuation">;</span><span class="token keyword">int</span> score<span class="token punctuation">;</span>bool whetherFoodExist<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Food<span class="token punctuation">;</span><span class="token comment">//来点减肥餐</span><span class="token comment">//</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_LoseWeightFood_</span> <span class="token punctuation">&#123;</span>PointPlat loseWeightFoodXY<span class="token punctuation">;</span><span class="token keyword">int</span> score<span class="token punctuation">;</span>bool whetherLWF_Exist<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>LoseWeightFood<span class="token punctuation">;</span><span class="token comment">//定义一下方向</span><span class="token comment">//</span><span class="token keyword">enum</span> <span class="token class-name">Directions</span> <span class="token punctuation">&#123;</span>RIGHT <span class="token operator">=</span> <span class="token number">77</span><span class="token punctuation">,</span>LEFT <span class="token operator">=</span> <span class="token number">75</span><span class="token punctuation">,</span>DOWN <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">,</span>UP <span class="token operator">=</span> <span class="token number">72</span><span class="token punctuation">,</span><span class="token comment">//对应keypress</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//Menu函数</span><span class="token keyword">void</span> <span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">chooseSpeed</span><span class="token punctuation">(</span><span class="token keyword">int</span> input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成食物函数</span><span class="token keyword">void</span> <span class="token function">randInitFoodPos</span><span class="token punctuation">(</span>Food<span class="token operator">*</span> pfood<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">randInitLWFoodPos</span><span class="token punctuation">(</span>LoseWeightFood<span class="token operator">*</span> pLWFood<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成地图函数</span><span class="token keyword">void</span> <span class="token function">initBackGround</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">initSnake</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//基于EasyX的绘画函数</span><span class="token keyword">void</span> <span class="token function">drawSnake</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">drawFood</span><span class="token punctuation">(</span>Food<span class="token operator">*</span> pfood<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">drawLWFood</span><span class="token punctuation">(</span>LoseWeightFood<span class="token operator">*</span> LWFood<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对象行为</span><span class="token keyword">void</span> <span class="token function">moveSnake</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">eatFood</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">,</span> Food<span class="token operator">*</span> pfood<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">eatLWFood</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">,</span> LoseWeightFood<span class="token operator">*</span> plossfood<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">keyReact</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//游戏判定</span><span class="token keyword">int</span> <span class="token function">deathJudge</span><span class="token punctuation">(</span>Snake<span class="token operator">*</span> psnake<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note : 线性代数 （Day 1）</title>
      <link href="/2023/02/20/Note-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%EF%BC%88Day-1%EF%BC%89/"/>
      <url>/2023/02/20/Note-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%EF%BC%88Day-1%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数教程II-Day-1"><a href="#线性代数教程II-Day-1" class="headerlink" title="线性代数教程II(Day 1)"></a>线性代数教程II(Day 1)</h1><h2 id="矩阵的概念"><a href="#矩阵的概念" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h2><p>​        1. 我们的矩阵是从线性方程组这里开始考虑的：</p><script type="math/tex; mode=display">\left\{\begin{equation}\begin{aligned}x_1-x_2+2x_3 = 1\\2x_1+3x_2+x_3=2\\x_1-2x_2-3x_3=4\end{aligned}\end{equation}\right.</script><p>​        可以料想到：如果我们去除了方程组的未知变量，仍可以表达出这个方程组：</p><script type="math/tex; mode=display">\left(\begin{matrix}1&-1&2&1\\2&3&1&2\\1&-2&-3&4\end{matrix}\right)</script><p>​        显然，横排为行，竖排为列，这样的一个数表我们起一个另外的名字：矩阵</p><p>​        一个矩阵显然有$m$行$n$列的说法，于是我们称作：这是一个$m\times n$的矩阵</p><script type="math/tex; mode=display">A=(a_{ij}) _{m\times n}</script><p>​        其中$a_{ij}$表达的是元素里第$i$行，第$j$列的元素。如果我们的元素里面全部是实数的话，则称之为实矩阵，否则是复矩阵！</p><p>​        2.<strong>同样的，定义形状一致的矩阵为同型矩阵！</strong></p><p>​        3.矩阵相等的条件是：</p><p>1）矩阵同型</p><p>2）对应元素相等</p><p>​        4.特别的定义到，当矩阵元素全为 0 时是零矩阵，简称 $O$。当 $m = 1$下是行矩阵，当 $n = 1$下是列矩阵！$m = n$ 下是N阶方阵。在N阶方阵中，定义$\{a_{ii}|\{i \in N\}\}$为对角线，而$\{a_{(n-i)i}|\{i \in N\}\}$是副对角线！</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>​        定义 N 行 1 列的向量是列向量，1行 N 列的向量是行向量！。</p><p>​        特别的：对于$0\leq i \leq n$下，若第i个分量是1，其余全为 0 的列向量为<strong>N维基本单位向量</strong></p><script type="math/tex; mode=display">\left(\begin{matrix}1\\0\\0\end{matrix}\right)...etc</script><p>​        他们可以并在一起：构成 N 阶单位矩阵</p><script type="math/tex; mode=display">E=\left(\begin{matrix}1&0&0\\0&1&0\\0&0&1\end{matrix}\right)</script><h2 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h2><h3 id="1-定义矩阵的加法是这样的："><a href="#1-定义矩阵的加法是这样的：" class="headerlink" title="1.定义矩阵的加法是这样的："></a>1.定义矩阵的加法是这样的：</h3><p>​        定义两个同型矩阵$(a_{ij})$与$(b_{ij})$        </p><script type="math/tex; mode=display">A+B=(a_{ij}+b_{ij})</script><p>​        这样：</p><script type="math/tex; mode=display">i)A+B=B+A</script><script type="math/tex; mode=display">ii)(A+B)+C=A+(B+C)</script><script type="math/tex; mode=display">iii)A+O=A</script><p>同时负矩阵也可以定义了：</p><script type="math/tex; mode=display">A+(-A)=O</script><h3 id="数乘运算"><a href="#数乘运算" class="headerlink" title="数乘运算"></a>数乘运算</h3><p>​        如果一个属乘上了一个矩阵：</p><script type="math/tex; mode=display">\lambda A = A\lambda=(\lambda a_{ij})</script><p>​        这样，我们就有以下这些规律值得我们的注意了：</p><script type="math/tex; mode=display">1) \lambda(\mu A)=(\lambda\mu)A</script><script type="math/tex; mode=display">2)\lambda (AB) = (\lambda A)B =A (\lambda B)</script><h3 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h3><p>​        下面定义一下矩阵的乘法，注意到，它不是总是成立的：</p><pre class="line-numbers language-none"><code class="language-none">定义A是一个 m 行 n 列的矩阵，而B是一个 n 行 p 列的矩阵，产生的矩阵就是C:yige m 行 p 列的矩阵，并且呢：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script type="math/tex; mode=display">c(ij) = \sum_{k=1}^na_{ik}b_{kj}</script><p>​        显然，这一约束使得我们的乘法交换律不一定成立，换而言之：</p><script type="math/tex; mode=display">AB \neq BA (不一定成立)</script><p>​        但是这些依旧成立，假使他们都有意义的话：</p><script type="math/tex; mode=display">A(BC)=(AB)C</script><h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><p>​        很有趣，我们把矩阵的行元素放到列上，列放到行上，就产生了一个 n $\times$ m 的矩阵</p><script type="math/tex; mode=display">\left(\begin{matrix}1&2&1\\-1&3&-2\\2&1&3\\1&2&4\end{matrix}\right)</script><p>​        就有了如下的性质：</p><script type="math/tex; mode=display">(AB)^T = B^TA^T</script><script type="math/tex; mode=display">(A+B)^T=A^T+B^T\\</script><script type="math/tex; mode=display">(A^T)^T=A</script><h2 id="矩阵的初等变换"><a href="#矩阵的初等变换" class="headerlink" title="矩阵的初等变换"></a>矩阵的初等变换</h2><p>​        矩阵可以进行初等变换，而且有三种合法的方法：</p><pre class="line-numbers language-none"><code class="language-none">1) 用一个非零的数乘以矩阵的某一行（列）2) 矩阵的某一行乘上一个系数加到另一行上去3) 交换矩阵的两行或者是两列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="初等矩阵"><a href="#初等矩阵" class="headerlink" title="初等矩阵"></a>初等矩阵</h2><p>​        我们的矩阵有时候可以使用一系列初等变换矩阵来表达我们对矩阵的操作，比如说：</p><pre class="line-numbers language-none"><code class="language-none">1) 初等倍法矩阵: P(i[k])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">2) 初等消去矩阵：P(i,j[k])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">3) 初等换法矩阵：P(i,j)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们容易验证以下的性质：左乘对矩阵行变换，右乘列变换！</p><p>​        但是注意$P(i,j[k])$中行表达为将 第 j 行的 k 倍加到第 i 行上去，列变换却是：第 i 行的 k 倍加到第 j 行上去。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmake 简单笔记 （1）</title>
      <link href="/2023/02/16/Cmake-%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>/2023/02/16/Cmake-%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简单CMake教程"><a href="#简单CMake教程" class="headerlink" title="简单CMake教程"></a>简单CMake教程</h1><p>​        下面请在 Linux 系统下操作，建议虚拟机！</p><h2 id="干嘛的这个"><a href="#干嘛的这个" class="headerlink" title="干嘛的这个"></a>干嘛的这个</h2><p>​        我们构建程序非常需要这个玩意！使用它来构建比如说VS下的项目！</p><h2 id="怎么下载？"><a href="#怎么下载？" class="headerlink" title="怎么下载？"></a>怎么下载？</h2><p>​        先尝试一个指令：</p><pre class="line-numbers language-none"><code class="language-none">cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果出现了这个，那就说明你的Cmake已经装好了！</p><p><img src="image-20230216193703982.png" alt="image-20230216193703982"></p><p>​        如果不是，仔细阅读提示，大概是自己没有安装这个东西：</p><pre class="line-numbers language-none"><code class="language-none">sudo install cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        等一会儿就好了！</p><p>​        为了测试，也自行安装一下 g++ 编译器！</p><pre class="line-numbers language-none"><code class="language-none">sudo install g++<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        方便我们后续的编译。</p><p>​        以及为了方便我们的书写，自然推介 vim 编辑器来干活：</p><pre class="line-numbers language-none"><code class="language-none">sudo install vim&#x2F;&#x2F; 先别急，一般你的linux已经安装好了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="先熟悉一下！"><a href="#先熟悉一下！" class="headerlink" title="先熟悉一下！"></a>先熟悉一下！</h2><p>​        先 cd 到一个工作文件夹吧！</p><p>​        先创建一个文件夹</p><pre class="line-numbers language-none"><code class="language-none">mkdir work<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        进入：</p><pre class="line-numbers language-none"><code class="language-none">cd work<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        直接整一个 main.cpp</p><pre class="line-numbers language-none"><code class="language-none">vim main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        按 i 来进入编辑模式, copy，请</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;int main()&#123;std::cout&lt;&lt;&quot;Hello Cpp&quot;&lt;&lt;std::endl&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后摁 esc 键，输入:wq退出</p><p>​        然后开始入门！</p><pre class="line-numbers language-none"><code class="language-none">vim CMakeLists.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        严格区分大小写！！！！</p><p>​        然后还是 copy ! 先不论这些都是什么东西</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">SET</span><span class="token punctuation">(</span>SRC_LIST main.cpp<span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"this is binary dir"</span> <span class="token punctuation">$&#123;</span><span class="token variable">HELLO_BINARY_DIR</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"this is SOURCE dir"</span> <span class="token punctuation">$&#123;</span><span class="token variable">HELLO_SOURCE_DIR</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello <span class="token punctuation">$&#123;</span>SRC_LIST<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        保存一下，还是一样的 esc :wq</p><p>​        然后编译一下，.的意思是在当前目录找CMakeList，在哪个目录下cmake产生的文件就在哪个目录下</p><pre class="line-numbers language-none"><code class="language-none">cmake .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        然后可以运行了：</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span> <span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span>   <span class="token comment"># 指定了工程的名字，并且支持所有语言—建议</span><span class="token function">PROJECT</span> <span class="token punctuation">(</span>HELLO CXX<span class="token punctuation">)</span>      <span class="token comment"># 指定了工程的名字，并且支持语言是C++</span><span class="token function">PROJECT</span> <span class="token punctuation">(</span>HELLO C CXX<span class="token punctuation">)</span>    <span class="token comment"># 指定了工程的名字，并且支持语言是C和C++</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        该指定隐式定义了两个CMAKE的变量</p><pre class="line-numbers language-none"><code class="language-none">&lt;projectname&gt;_BINARY_DIR，本例中是 HELLO_BINARY_DIR&lt;projectname&gt;_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录。</p><p>​        问题：如果改了工程名，这两个变量名也会改变</p><p>​        解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h2 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h2><p>​        用来显示的指定变量的</p><p>​        SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>​        也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h2 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h2><p>​        向终端输出用户自定义的信息</p><p>​        主要包含三种信息：    </p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><h2 id="ADD-EXECUTABLE关键字"><a href="#ADD-EXECUTABLE关键字" class="headerlink" title="ADD_EXECUTABLE关键字"></a>ADD_EXECUTABLE关键字</h2><p>​        生成可执行文件</p><p>​        ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>​        也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>​        上述例子可以简化的写成</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello main.cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h2 id="语法的基本原则"><a href="#语法的基本原则" class="headerlink" title="语法的基本原则"></a>语法的基本原则</h2><p>​        1. 变量使用 ${} 方式取值，但是在 IF 控制语句中是直接使用变量名</p><p>​        2.</p><ul><li>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，</li><li>如果存在另外一个 func.cpp 源文件，就要写成：</li><li><code>ADD_EXECUTABLE(hello main.cpp func.cpp)</code>或者<code>ADD_EXECUTABLE(hello main.cpp;func.cpp)</code></li><li>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</li><li>指令是大小写无关的，参数和变量是大小写相关的。</li></ul><h2 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a>语法注意事项</h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h2 id="内部构建和外部构建"><a href="#内部构建和外部构建" class="headerlink" title="内部构建和外部构建"></a>内部构建和外部构建</h2><ul><li><p>我们刚刚讲的例子就是内部构建，他生产的临时文件特别多，不方便清理</p><p><img src="image-20230216202047986.png" alt="image-20230216202047986"></p><p>​        一大堆文件混在一起</p></li><li><p>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</p></li></ul><p>​        首先</p><pre class="line-numbers language-none"><code class="language-none">mkdir buildcd build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        然后</p><pre class="line-numbers language-none"><code class="language-none">cmake .. # 在上两级编译<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        现在干净了：（查看时cd ..）</p><p><img src="image-20230216202644656.png" alt="image-20230216202644656"></p><p>​        (记得再cd回去)</p><pre class="line-numbers language-none"><code class="language-none">make.&#x2F;hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        总结一下：</p><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake ..    当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>​        注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 /root/cmake/bulid</p><h2 id="让Hello-World看起来更像一个工程"><a href="#让Hello-World看起来更像一个工程" class="headerlink" title="让Hello World看起来更像一个工程"></a>让Hello World看起来更像一个工程</h2><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</li></ul><p>每个目录下都要有一个CMakeLists.txt说明</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── src    ├── CMakeLists<span class="token punctuation">.</span>txt    └── main<span class="token punctuation">.</span>cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>外层CMakeLists.txt</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>src bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>src下的CMakeLists.txt</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello main<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        可执行文件在 bin 下面</p><h2 id="ADD-SUBDIRECTORY-指令"><a href="#ADD-SUBDIRECTORY-指令" class="headerlink" title="ADD_SUBDIRECTORY 指令"></a>ADD_SUBDIRECTORY 指令</h2><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><ul><li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p></li></ul><h2 id="更改二进制的保存路径"><a href="#更改二进制的保存路径" class="headerlink" title="更改二进制的保存路径"></a>更改二进制的保存路径</h2><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)<br>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h2 id="如何安装HelloWord"><a href="#如何安装HelloWord" class="headerlink" title="如何安装HelloWord"></a>如何安装HelloWord</h2><p>​        使用CMAKE一个新的指令：INSTALL</p><p>​        INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>​        使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><h2 id="安装文件COPYRIGHT和README"><a href="#安装文件COPYRIGHT和README" class="headerlink" title="安装文件COPYRIGHT和README"></a>安装文件COPYRIGHT和README</h2><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/<DESTINATION 定义的路径></p><p>CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</p><p>cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h2 id="安装脚本runhello-sh"><a href="#安装脚本runhello-sh" class="headerlink" title="安装脚本runhello.sh"></a>安装脚本runhello.sh</h2><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p><p>说明：实际安装到的是 /usr/bin</p><p>使用: make install 安装东西</p><pre class="line-numbers language-none"><code class="language-none">sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="安装-doc-中的-hello-txt"><a href="#安装-doc-中的-hello-txt" class="headerlink" title="安装 doc 中的 hello.txt"></a>安装 doc 中的 hello.txt</h2><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过</p><p>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc/有很大的区别</p><p>目录名不以/结尾：这个目录将被安装为目标路径下的</p><p>目录名以/结尾：将这个目录中的内容安装到目标路径</p><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>cmake ..</p><p>make</p><p>make install</p><h2 id="静态库和动态库的构建"><a href="#静态库和动态库的构建" class="headerlink" title="静态库和动态库的构建"></a>静态库和动态库的构建</h2><p>静态库和动态库的区别</p><ul><li><p>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</p></li><li><p>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</p></li><li><p>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</p><h2 id="构建实例"><a href="#构建实例" class="headerlink" title="构建实例"></a>构建实例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@localhost cmake2<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── lib    ├── CMakeLists<span class="token punctuation">.</span>txt    ├── hello<span class="token punctuation">.</span>cpp    └── hello<span class="token punctuation">.</span>h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello.h中的内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HELLO_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Hello_H</span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hello.cpp中的内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hello.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>项目中的cmake内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>lib bin<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>lib中CMakeLists.txt中的内容</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="ADD-LIBRARY"><a href="#ADD-LIBRARY" class="headerlink" title="ADD_LIBRARY"></a>ADD_LIBRARY</h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h3 id="同时构建静态和动态库"><a href="#同时构建静态和动态库" class="headerlink" title="同时构建静态和动态库"></a>同时构建静态和动态库</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello STATIC $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static STATIC $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SET-TARGET-PROPERTIES"><a href="#SET-TARGET-PROPERTIES" class="headerlink" title="SET_TARGET_PROPERTIES"></a>SET_TARGET_PROPERTIES</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static STATIC $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">//对hello_static的重名为hello</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static PROPERTIES  OUTPUT_NAME <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment">//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">&#123;</span>LIBHELLO_SRC<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello PROPERTIES  OUTPUT_NAME <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="动态库的版本号"><a href="#动态库的版本号" class="headerlink" title="动态库的版本号"></a>动态库的版本号</h2><p>一般动态库都有一个版本号的关联</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span>libhello<span class="token punctuation">.</span>so <span class="token operator">-></span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-></span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h2 id="安装共享库和头文件"><a href="#安装共享库和头文件" class="headerlink" title="安装共享库和头文件"></a>安装共享库和头文件</h2><p>我们将 hello 的共享库安装到<prefix>/lib目录，</p><p>将 hello.h 安装到<prefix>/include/hello 目录</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//文件放到该目录下</span><span class="token function">INSTALL</span><span class="token punctuation">(</span>FILES hello<span class="token punctuation">.</span>h DESTINATION include<span class="token operator">/</span>hello<span class="token punctuation">)</span><span class="token comment">//二进制，静态库，动态库安装都用TARGETS</span><span class="token comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span><span class="token function">INSTALL</span><span class="token punctuation">(</span>TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h2 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h2><p>准备工作，新建一个目录来使用外部共享库和头文件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@MiWiFi<span class="token operator">-</span>R4CM<span class="token operator">-</span>srv cmake3<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── src    ├── CMakeLists<span class="token punctuation">.</span>txt    └── main<span class="token punctuation">.</span>cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>main.cpp</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;hello.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解决：make后头文件找不到的问题"><a href="#解决：make后头文件找不到的问题" class="headerlink" title="解决：make后头文件找不到的问题"></a>解决：make后头文件找不到的问题</h2><p>PS：include <hello/hello.h>  这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(/usr/include/hello)</p><h2 id="解决：找到引用的函数问题"><a href="#解决：找到引用的函数问题" class="headerlink" title="解决：找到引用的函数问题"></a>解决：找到引用的函数问题</h2><p>报错信息：undefined reference to `HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@MiWiFi<span class="token operator">-</span>R4CM<span class="token operator">-</span>srv bin<span class="token punctuation">]</span># ldd main linux<span class="token operator">-</span>vdso<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">=</span><span class="token operator">></span>  <span class="token punctuation">(</span><span class="token number">0x00007ffedfda4000</span><span class="token punctuation">)</span>libhello<span class="token punctuation">.</span>so <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libhello<span class="token punctuation">.</span><span class="token function">so</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0d8f000</span><span class="token punctuation">)</span>libstdc<span class="token operator">++</span><span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libstdc<span class="token operator">++</span><span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0874000</span><span class="token punctuation">)</span>libm<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libm<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0572000</span><span class="token punctuation">)</span>libgcc_s<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libgcc_s<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c035c000</span><span class="token punctuation">)</span>libc<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libc<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41bff8e000</span><span class="token punctuation">)</span><span class="token operator">/</span>lib64<span class="token operator">/</span>ld<span class="token operator">-</span>linux<span class="token operator">-</span>x86<span class="token operator">-</span><span class="token number">64.</span>so<span class="token punctuation">.</span><span class="token number">2</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0b7c000</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h2 id="特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH"><a href="#特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH" class="headerlink" title="特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH"></a>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h2><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p><p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE=debug</p><h2 id="For-Lessons"><a href="#For-Lessons" class="headerlink" title="For Lessons:"></a>For Lessons:</h2><p><a href="https://www.bilibili.com/video/BV1vR4y1u77h?p=4&amp;vd_source=7756b1d353ef340c2ab91e80642a8922">从零开始详细介绍CMake</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据结构 （2） 单链表API详解</title>
      <link href="/2023/02/15/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8API%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/02/15/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8API%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言经典单链表API详解"><a href="#C语言经典单链表API详解" class="headerlink" title="C语言经典单链表API详解"></a>C语言经典单链表API详解</h1><h2 id="数据结构一览"><a href="#数据结构一览" class="headerlink" title="数据结构一览"></a>数据结构一览</h2><p>​        具体的源码位置在这里！：<a href="https://github.com/Charliechen114514/Tiny-C-C-standard-Library/tree/C/classicLinkList">click here</a></p><p>​        这一次，我们开发的是链表这个数据结构，基础的链表分为单链表，双链表和循环链表。作为链表，他不同之处在于，我们的数据存储是离散的！就是说，我们的一串数据不一定是在内存上连续，我们的逻辑结构依靠指针来维护：</p><p><img src="image-20230215132846697.png" alt="image-20230215132846697"></p><p>​        可以看到，我们使用指针来访问数据！为了方便我们的维护，那当然是一个抽象成一个链子串起了若干的节点，这就在直观上需要两个数据结构：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _DataNode_&#123;    void* data;&#x2F;&#x2F; 数据域    struct _DataNode_* pNext;&#x2F;&#x2F; 指针域&#125;DataNode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        而在一般的教程中是如下定义的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _DataNode_&#123;    void* data;&#x2F;&#x2F; 数据域    struct _DataNode_* pNext;&#x2F;&#x2F; 指针域&#125;DataNode,*Datalist;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这里我并不这样做，这是为了可读性与方便维护的优点。为了增添属性，我们以加入该链表存在的元素个数作为附属属性：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _DataList_&#123;DataNode* head;    size_t current_num;&#125;DataList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        于是，现在我们开始维护与开发相关的操作函数！</p><h2 id="链表权威导论"><a href="#链表权威导论" class="headerlink" title="链表权威导论"></a>链表权威导论</h2><p>​        链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。<strong>每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</strong> 相比于线性表顺序结构，操作复杂。<strong>由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。</strong></p><p>​        使用链表结构可以克服数组链表需要预先知道数据大小的缺点，<strong>链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。</strong></p><h2 id="基本导入"><a href="#基本导入" class="headerlink" title="基本导入"></a>基本导入</h2><h3 id="1）预先功能启用与宏定义"><a href="#1）预先功能启用与宏定义" class="headerlink" title="1）预先功能启用与宏定义"></a>1）预先功能启用与宏定义</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1 &#x2F;&#x2F; 取消非安全警报#defineOPENUPPOSARR 1&#x2F;&#x2F; 启用动态位置查询存储数组#define OPENUPDEFAULTSIZE 1 &#x2F;&#x2F; 启用默认快捷大小宏#define OPENQUICKMALLOC 1 &#x2F;&#x2F; 启用快捷开辟堆内存宏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2）头文件使用"><a href="#2）头文件使用" class="headerlink" title="2）头文件使用"></a>2）头文件使用</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3）错误码一览"><a href="#3）错误码一览" class="headerlink" title="3）错误码一览"></a>3）错误码一览</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Error Code Meaning&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0&#x2F;&#x2F;When Error in mallocing Space the program return 1&#x2F;&#x2F;when inputing a NULL we returns -1&#x2F;&#x2F;when inputing a invalid input we returns -2&#x2F;&#x2F;Locations UnFind we returns -3 typedef enum _ClassicLinkListFunctionStatues_ &#123;ClassicLinkList_NORMAL&#x3D;0,ClassicLinkList_ERROR_IN_MALLOCING_SPACE &#x3D; 1,ClassicLinkList_NULL_INPUT &#x3D; -1,ClassicLinkList_Invalid_Input&#x3D;-2,ClassicLinkList_UnFind&#x3D;-3,ClassicLinkList_Invalid_Free&#x3D;-4,&#125;ClassicLinkListFunctionStatues;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4）自定义我们的布尔类型"><a href="#4）自定义我们的布尔类型" class="headerlink" title="4）自定义我们的布尔类型"></a>4）自定义我们的布尔类型</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;MyBool Defined here!&#x2F;&#x2F;typedef enum _bool_ &#123;True &#x3D; 1,False &#x3D; 0&#125;Bool;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5）报错机制与参数调整宏"><a href="#5）报错机制与参数调整宏" class="headerlink" title="5）报错机制与参数调整宏"></a>5）报错机制与参数调整宏</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;This is some abstractions using in reminding you some basic informations and errors!&#x2F;&#x2F;#define SHOW_ERROR_ClassicLinkList_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)#define SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)#define SHOW_ERROR_ClassicLinkList_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)#define SHOW_ERROR_ClassicLinkList_UnFind printf(&quot;\nPositions unfind!\n&quot;)#define SHOW_ERROR_ClassicLinkList_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)#define SHOW_WARNING_ClassicLinkList_SWAPPED_POS printf(&quot;Warning! the front_pos is bigger then the final pos\n Do you agreed swap them?&quot;)#define SHOW_WARNING_ClassicLinkList_OVERLAP_POS printf(&quot;Considered as your insertion_input is overlapped!\n set pos as the cur_size?&quot;)&#x2F;&#x2F;this abstractions is used to define the aquisition of whether the program&#39;s decison is acceptable,&#x2F;&#x2F;X is the message string!&#x2F;&#x2F;#define SHOW_WHETHER_ACCCEPTED(X) printf(X)&#x2F;&#x2F;If wanted flashed a newline you can use it! &#x2F;&#x2F;#define SLASHN printf(&quot;\n&quot;)&#x2F;&#x2F;used in MergeclassicLinkList&#x2F;&#x2F;If accepted copy ！ Do write ClassicLinkList_ACCEPTED_COPY#define ClassicLinkList_ACCEPTED_COPY 1#define ClassicLinkList_NO_COPY0#define Unfind_ClassicLinkList -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6）位置查询结果枚举"><a href="#6）位置查询结果枚举" class="headerlink" title="6）位置查询结果枚举"></a>6）位置查询结果枚举</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Used in whether the targeted elements is found&#x2F;&#x2F;If is considered found, just use Find , otherwise unfind!typedef enum _ClassicLinkList_isFind_ &#123;Find &#x3D; 1,Unfind &#x3D; 0&#125;ClassicLinkList_isFind;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7）更好的打印开启枚举"><a href="#7）更好的打印开启枚举" class="headerlink" title="7）更好的打印开启枚举"></a>7）更好的打印开启枚举</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Used in whether print data in ClassicLinkList better&#x2F;&#x2F;Use ClassicLinkList_OPEN if you want a better printtypedef enum _BetterPrintSwitch_for_ClassicLinkList_ &#123;ClassicLinkList_OPEN &#x3D; 1,ClassicLinkList_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_ClassicLinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8）一些类型的重改写"><a href="#8）一些类型的重改写" class="headerlink" title="8）一些类型的重改写"></a>8）一些类型的重改写</h3><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef unsigned int Is_Used_Compared_Int;typedef void(*MyPrint)(void*);typedef void* (*Do_Specific_Change)(void*);typedef Is_Used_Compared_Int(*CompareFunc)(void*, void*);typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9）默认大小宏"><a href="#9）默认大小宏" class="headerlink" title="9）默认大小宏"></a>9）默认大小宏</h3><p>注意，希望关闭默认大小快捷宏请移除宏</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">OPENUPDEFAULTSIZE</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Dyarr_SIGINT</span> <span class="token expression"><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Dyarr_SIGCHAR</span> <span class="token expression"><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Dyarr_SIGFLOAT</span> <span class="token expression"><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Dyarr_SIGDOUBLE</span> <span class="token expression"><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">Dyarr_SIG</span><span class="token expression"><span class="token punctuation">(</span>dataType<span class="token punctuation">)</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dataType<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">Dyarr_INT_SIZE</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span>X</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">Dyarr_CHAR_SIZE</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">*</span>X</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">Dyarr_FLOAT_SIZE</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token operator">*</span>X</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">Dyarr_DOUBLE_SIZE</span><span class="token expression"><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token operator">*</span>X</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">Dyarr_TYPE_SIZE</span><span class="token expression"><span class="token punctuation">(</span>dataType<span class="token punctuation">,</span>X<span class="token punctuation">)</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>dataType<span class="token punctuation">)</span><span class="token operator">*</span>X</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10）快速开辟"><a href="#10）快速开辟" class="headerlink" title="10）快速开辟"></a>10）快速开辟</h3><p>注意，希望关闭快速开辟宏请移除宏</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">OPENQUICKMALLOC</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MALLOC</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">(</span>type<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">MALLOCN</span><span class="token expression"><span class="token punctuation">(</span>type<span class="token punctuation">,</span>ElemNum<span class="token punctuation">)</span> <span class="token punctuation">(</span>type<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token operator">*</span>ElemNum<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11）动态存储位置"><a href="#11）动态存储位置" class="headerlink" title="11）动态存储位置"></a>11）动态存储位置</h3><p>更加详细的API请参考“C语言结构：动态数组API详解”这篇文章</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;-----------------------Position_Stored_Dynamic_Array_For_Dyarr---------------------------------&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;Used in returning multitude locations#if OPENUPPOSARR&#x2F;&#x2F;Main data structure!&#x2F;&#x2F;Used in returning multitude locationstypedef struct _Dyarrposarr_ &#123;int* posSpace;size_t pos_size;&#125;Position_Stored_Dynamic_ArrayFordyarr;&#x2F;&#x2F;Want a better Print to beutify your control table? try this onetypedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;PSDA_dyarr_OPEN &#x3D; 1,PSDA_dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_pos_dyarr;&#x2F;&#x2F;can use this type when indicating the typetypedef unsigned int BetterPrintfor_PosDyarr;&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr()&#123;Position_Stored_Dynamic_ArrayFordyarr* pro_usable_space &#x3D; (Position_Stored_Dynamic_ArrayFordyarr*)malloc(sizeof(Position_Stored_Dynamic_ArrayFordyarr));if (!pro_usable_space)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;pro_usable_space-&gt;posSpace &#x3D; NULL;pro_usable_space-&gt;pos_size &#x3D; 0;return pro_usable_space;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSEClassicLinkListFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr,BetterPrintfor_PosDyarrWhether_Better_Print)&#123;if (!posarr)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nPositions are shown! :\n&quot;);for (int i &#x3D; 0; i &lt; posarr-&gt;pos_size; i++)printf(&quot;%u &quot;, posarr-&gt;posSpace[i]);if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nFinish Printing!\n&quot;);return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_ArrayClassicLinkListFunctionStatues Push_back_a_locations_in_PSDA_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr, intpos_acquired)&#123;int* pro_usable_space &#x3D; (int*)realloc(posarr-&gt;posSpace, sizeof(int) * (posarr-&gt;pos_size + 1));if (!pro_usable_space)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;posarr-&gt;posSpace &#x3D; pro_usable_space;posarr-&gt;posSpace[posarr-&gt;pos_size] &#x3D; pos_acquired;posarr-&gt;pos_size++;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to return the number of locations&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSEsize_t Get_pos_size_From_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr, BetterPrintfor_PosDyarrWhether_Shown_Print)&#123;if (!posarr)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (Whether_Shown_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nCurrent targeted data&#39;s total num is:%u!\n&quot;, posarr-&gt;pos_size);return posarr-&gt;pos_size;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;return a pos that is targeted!&#x2F;&#x2F;void* getPosbyPosinPSDA(Position_Stored_Dynamic_ArrayFordyarr* getter,size_tpos)&#123;if (!getter) &#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (pos &gt; getter-&gt;pos_size)&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;for (int i &#x3D; 0; i &lt; pos; i++)return (char*)getter-&gt;posSpace + i * sizeof(size_t);&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_ArrayClassicLinkListFunctionStatues DesTroy_A_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*pointer_to_wishedfreeposarr)&#123;if (!pointer_to_wishedfreeposarr)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;free(pointer_to_wishedfreeposarr-&gt;posSpace);free(pointer_to_wishedfreeposarr);pointer_to_wishedfreeposarr &#x3D; NULL;return ClassicLinkList_NORMAL;&#125;#endif &#x2F;&#x2F; OPENUPPOSARR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="核心API-1：工程函数"><a href="#核心API-1：工程函数" class="headerlink" title="核心API 1：工程函数"></a>核心API 1：工程函数</h2><p>​        我们的工厂函数依旧是老三样：默认，拷贝和升级！</p><p>​        这里是源文件文档内的注释：</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;----------------------------Init-functions---------------------------&#x2F;&#x2F; &#x2F;&#x2F; there are three basic type of initialization&#x2F;&#x2F; &#x2F;&#x2F; --------------------------------------------------------------------&#x2F;&#x2F; 1.includeing the default type (init a NULL head and zero cur_size)&#x2F;&#x2F; func1: Classic_DataList* Init_A_ClassicLinkList()&#x2F;&#x2F; &#x2F;&#x2F; No input , or input VOID&#x2F;&#x2F; have output : output a clssicLinklist pointer&#x2F;&#x2F; --------------------------------------------------------------------&#x2F;&#x2F; 2.includeing the copy one (init the same type of the be-copied one)&#x2F;&#x2F; func2: Classic_DataList* Init_A_ClassicLinkList_By_CopyAClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : a required_be_copied list .&#x2F;&#x2F; output: a new list but have is the same as the be_copied list&#x2F;&#x2F; --------------------------------------------------------------------&#x2F;&#x2F; 3.includeing to transform the static array to the linklist one&#x2F;&#x2F; func3: Classic_DataList* UpdateStaticArray2ClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : a waited_transformed static_array , the element size which is in the static array &#x2F;&#x2F; output: a new pointer that points to classicLinkList&#x2F;&#x2F; &#x2F;&#x2F; &#x2F;&#x2F;----------------------------Init-functions---------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="默认工厂函数"><a href="#默认工厂函数" class="headerlink" title="默认工厂函数"></a>默认工厂函数</h3><p>​        由于我们定义了一个全新的结构：链表！我们就希望，先什么都不放！换而言之：<code>head</code>是空的，而<code>current_size</code>也是0！同时，使用 malloc 构造出来这个结构并且传出一个指针来供外界托管与使用：</p><p>​        原型这样就出来了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Classic_DataList<span class="token operator">*</span> <span class="token function">Init_A_ClassicLinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        开辟堆空间：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// create empty space</span>Classic_DataList<span class="token operator">*</span> pro_usable_space <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        我们当然最好是检查一下有没有开辟成功</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Check whether init succeeded</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pro_usable_space<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        开辟成功了那就自然开始默认设置</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Default set </span>pro_usable_space<span class="token operator">-></span>Head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>pro_usable_space<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// return out the Structure</span><span class="token keyword">return</span> pro_usable_space<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        连起来就是如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Classic_DataList<span class="token operator">*</span> <span class="token function">Init_A_ClassicLinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// create empty space</span>Classic_DataList<span class="token operator">*</span> pro_usable_space <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Check whether init succeeded</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pro_usable_space<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Default set </span>pro_usable_space<span class="token operator">-></span>Head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>pro_usable_space<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// return out the Structure</span><span class="token keyword">return</span> pro_usable_space<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="拷贝工厂函数"><a href="#拷贝工厂函数" class="headerlink" title="拷贝工厂函数"></a>拷贝工厂函数</h2><p>​        这个函数顾名思义就可以写出原型：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Classic_DataList<span class="token operator">*</span> <span class="token function">Init_A_ClassicLinkList_By_CopyAClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        这个就有意思了，我们的想法是简答的，我们选择两个指针从链表里走，什么意思呢？</p><p><img src="image-20230215135759176.png" alt="image-20230215135759176"></p><p>​        然后，我们开始拷贝被拷贝链表的结点：</p><p><img src="image-20230215135902169.png" alt="image-20230215135902169"></p><p>​        然后，指针连上：顺便进入新的拷贝节点！周而复始直到被拷贝链表指向 NULL</p><p>​        做一点简单判断：让空的或者是非法的指针先排除</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//check whether the input is legal</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//check whether there is neccessity to copy </span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>current_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No need to copy! it hasn't been initialize yet!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Used to return NULL , but it is dangerous that two pointers points one things </span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后，拷贝头节点，做一点简单的初始化（不调用其他工厂函数，尽可能在一个函数完成事情，减少链接丢失带来的失败的风险）！</p><p>​        我们拷贝数据，是要拷贝节点框架+节点数据：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//New a List and new a head and new the data of the head</span><span class="token comment">// 产生一个链表</span>Classic_DataList<span class="token operator">*</span> p_NewList <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 产生一个头节点准备入列</span>Classic_DataNode<span class="token operator">*</span> newHead <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 头节点数据拷贝一份</span><span class="token keyword">void</span><span class="token operator">*</span> newdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        数据拷贝检查：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//check whether we init the node successfully</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newHead <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newdata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        数据拷贝</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//Do copy the data to the new head and finished initialization</span><span class="token comment">//拷贝节点数据</span><span class="token function">memcpy</span><span class="token punctuation">(</span>newdata<span class="token punctuation">,</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//指针托管</span>newHead<span class="token operator">-></span>data <span class="token operator">=</span> newdata<span class="token punctuation">;</span><span class="token comment">//防止野指针或者多进程解引用带来野指针访问</span>newHead<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p_NewList<span class="token operator">-></span>Head <span class="token operator">=</span> newHead<span class="token punctuation">;</span>p_NewList<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，我们可以开始拷贝其他的节点了，正如上文所说，准备两个节点指针：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//Start copy other nodes</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pCurCopy <span class="token operator">=</span> p_NewList<span class="token operator">-></span>Head<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        类似的重复拷贝头节点的工作：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//注意是cur - 1 !</span><span class="token punctuation">&#123;</span><span class="token comment">//Copy the I-th node</span>Classic_DataNode<span class="token operator">*</span> newDataNode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//check if the initialization is illegal</span><span class="token keyword">if</span><span class="token punctuation">(</span>newDataNode<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// prepare to copy data from the current node</span><span class="token keyword">void</span><span class="token operator">*</span> newdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// check if the initialization is illegal</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newdata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//copy the detailed node</span><span class="token function">memcpy</span><span class="token punctuation">(</span>newdata<span class="token punctuation">,</span> p_Currency<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newDataNode<span class="token operator">-></span>data <span class="token operator">=</span> newdata<span class="token punctuation">;</span>newDataNode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//Moving the pointer and prepared next copy</span>pCurCopy<span class="token operator">-></span>p_next_one <span class="token operator">=</span> newDataNode<span class="token punctuation">;</span>pCurCopy <span class="token operator">=</span> pCurCopy<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        链表的属性完善以下，返回指针以便托管</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//Data copy finished , init the cur_size</span>p_NewList<span class="token operator">-></span>current_size <span class="token operator">=</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> p_NewList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        连起来看一下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to copy an already exited linklist</span><span class="token comment">// Classic_DataList* List = Init_A_ClassicLinkList_By_CopyAClassicLinkList(Classic_DataList* list) </span><span class="token comment">//</span>Classic_DataList<span class="token operator">*</span> <span class="token function">Init_A_ClassicLinkList_By_CopyAClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//check whether the input is legal</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//check whether there is neccessity to copy </span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>current_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No need to copy! it hasn't been initialize yet!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Used to return NULL , but it is dangerous that two pointers points one things </span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//New a List and new a head and new the data of the head</span>Classic_DataList<span class="token operator">*</span> p_NewList <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> newHead <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> newdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//check whether we init the node successfully</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newHead <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newdata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Do copy the data to the new head and finished initialization</span><span class="token function">memcpy</span><span class="token punctuation">(</span>newdata<span class="token punctuation">,</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newHead<span class="token operator">-></span>data <span class="token operator">=</span> newdata<span class="token punctuation">;</span>newHead<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p_NewList<span class="token operator">-></span>Head <span class="token operator">=</span> newHead<span class="token punctuation">;</span>p_NewList<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//Start copy other nodes</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pCurCopy <span class="token operator">=</span> p_NewList<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//Copy the I-th node</span>Classic_DataNode<span class="token operator">*</span> newDataNode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//check if the initialization is illegal</span><span class="token keyword">if</span><span class="token punctuation">(</span>newDataNode<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// prepare to copy data from the current node</span><span class="token keyword">void</span><span class="token operator">*</span> newdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// check if the initialization is illegal</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newdata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//copy the detailed node</span><span class="token function">memcpy</span><span class="token punctuation">(</span>newdata<span class="token punctuation">,</span> p_Currency<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newDataNode<span class="token operator">-></span>data <span class="token operator">=</span> newdata<span class="token punctuation">;</span>newDataNode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//Moving the pointer and prepared next copy</span>pCurCopy<span class="token operator">-></span>p_next_one <span class="token operator">=</span> newDataNode<span class="token punctuation">;</span>pCurCopy <span class="token operator">=</span> pCurCopy<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Data copy finished , init the cur_size</span>p_NewList<span class="token operator">-></span>current_size <span class="token operator">=</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> p_NewList<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="升级工厂函数"><a href="#升级工厂函数" class="headerlink" title="升级工厂函数"></a>升级工厂函数</h3><p>​        现在我们把一个数组的元素拆开，存入链表里，那么，每一个元素都作为一个节点穿进绳子里！于是：</p><p>​        函数首先就需要数组的地址，和元素的大小以及元素个数！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Classic_DataList<span class="token operator">*</span> <span class="token function">UpdateStaticArray2ClassicLinkList</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>inputArray<span class="token punctuation">,</span> <span class="token class-name">size_t</span>dataSize<span class="token punctuation">,</span> <span class="token class-name">size_t</span>dataNum<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        接下来，判断是不是空指针：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>inputArray <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        初始化头节点：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Classic_DataList<span class="token operator">*</span> pro_usable_space <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> FirstHeaddata <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> datapiece <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pro_usable_space <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>FirstHeaddata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>datapiece <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>datapiece<span class="token punctuation">,</span> inputArray<span class="token punctuation">,</span> dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span>FirstHeaddata<span class="token operator">-></span>data <span class="token operator">=</span> datapiece<span class="token punctuation">;</span>FirstHeaddata<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>pro_usable_space<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>pro_usable_space<span class="token operator">-></span>Head <span class="token operator">=</span> FirstHeaddata<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        相似的，但是拷贝节点是通过访问数组的地址来拷贝的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dataNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> pro_usable_space<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> datastored <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datastored<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>datastored<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>inputArray <span class="token operator">+</span> i <span class="token operator">*</span> dataSize<span class="token punctuation">,</span> dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> datanode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datanode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>datanode<span class="token operator">-></span>data <span class="token operator">=</span> datastored<span class="token punctuation">;</span>datanode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p_Currency<span class="token operator">-></span>p_next_one <span class="token operator">=</span> datanode<span class="token punctuation">;</span>pro_usable_space<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> pro_usable_space<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工厂函数一览"><a href="#工厂函数一览" class="headerlink" title="工厂函数一览"></a>工厂函数一览</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//----------------------------Init-functions--------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// there are three basic type of initialization</span><span class="token comment">// </span><span class="token comment">// ------------------------------------------------------------------------------------------------------------</span><span class="token comment">// 1.includeing the default type (init a NULL head and zero cur_size)</span><span class="token comment">// func1: Classic_DataList* Init_A_ClassicLinkList()</span><span class="token comment">// </span><span class="token comment">// No input , or input VOID</span><span class="token comment">// have output : output a clssicLinklist pointer</span><span class="token comment">// -------------------------------------------------------------------------------------------------------------</span><span class="token comment">// 2.includeing the copy one (init the same type of the be-copied one)</span><span class="token comment">// func2: Classic_DataList* Init_A_ClassicLinkList_By_CopyAClassicLinkList</span><span class="token comment">// </span><span class="token comment">// input : a required_be_copied list .</span><span class="token comment">// output: a new list but have is the same as the be_copied list</span><span class="token comment">// -------------------------------------------------------------------------------------------------------------</span><span class="token comment">// 3.includeing to transform the static array to the linklist one</span><span class="token comment">// func3: Classic_DataList* UpdateStaticArray2ClassicLinkList</span><span class="token comment">// </span><span class="token comment">// input : a waited_transformed static_array , the element size which is in the static array </span><span class="token comment">// output: a new pointer that points to classicLinkList</span><span class="token comment">// </span><span class="token comment">// </span><span class="token comment">//----------------------------Init-functions--------------------------------------------------------------------</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// This function is used to init a default type of classicLinkList</span><span class="token comment">// that the head of dataPiece is NULL and the cur_size is zero.</span><span class="token comment">// Use push back to init the dataPiece</span><span class="token comment">// use in this Way: </span><span class="token comment">// Classic_DataList* List = Init_A_ClassicLinkList();</span>Classic_DataList<span class="token operator">*</span> <span class="token function">Init_A_ClassicLinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// create empty space</span>Classic_DataList<span class="token operator">*</span> pro_usable_space <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Check whether init succeeded</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pro_usable_space<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Default set </span>pro_usable_space<span class="token operator">-></span>Head <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>pro_usable_space<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// return out the Structure</span><span class="token keyword">return</span> pro_usable_space<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to copy an already exited linklist</span><span class="token comment">// Classic_DataList* List = Init_A_ClassicLinkList_By_CopyAClassicLinkList(Classic_DataList* list) </span><span class="token comment">//</span>Classic_DataList<span class="token operator">*</span> <span class="token function">Init_A_ClassicLinkList_By_CopyAClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//check whether the input is legal</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//check whether there is neccessity to copy </span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>current_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No need to copy! it hasn't been initialize yet!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Used to return NULL , but it is dangerous that two pointers points one things </span><span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//New a List and new a head and new the data of the head</span>Classic_DataList<span class="token operator">*</span> p_NewList <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> newHead <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> newdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//check whether we init the node successfully</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newHead <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newdata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Do copy the data to the new head and finished initialization</span><span class="token function">memcpy</span><span class="token punctuation">(</span>newdata<span class="token punctuation">,</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newHead<span class="token operator">-></span>data <span class="token operator">=</span> newdata<span class="token punctuation">;</span>newHead<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p_NewList<span class="token operator">-></span>Head <span class="token operator">=</span> newHead<span class="token punctuation">;</span>p_NewList<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//Start copy other nodes</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pCurCopy <span class="token operator">=</span> p_NewList<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//Copy the I-th node</span>Classic_DataNode<span class="token operator">*</span> newDataNode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//check if the initialization is illegal</span><span class="token keyword">if</span><span class="token punctuation">(</span>newDataNode<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// prepare to copy data from the current node</span><span class="token keyword">void</span><span class="token operator">*</span> newdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// check if the initialization is illegal</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newdata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//copy the detailed node</span><span class="token function">memcpy</span><span class="token punctuation">(</span>newdata<span class="token punctuation">,</span> p_Currency<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newDataNode<span class="token operator">-></span>data <span class="token operator">=</span> newdata<span class="token punctuation">;</span>newDataNode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//Moving the pointer and prepared next copy</span>pCurCopy<span class="token operator">-></span>p_next_one <span class="token operator">=</span> newDataNode<span class="token punctuation">;</span>pCurCopy <span class="token operator">=</span> pCurCopy<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Data copy finished , init the cur_size</span>p_NewList<span class="token operator">-></span>current_size <span class="token operator">=</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> p_NewList<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to updata a static array into a ClassicLinkList</span><span class="token comment">// Classic_DataList* List = UpdateStaticArray2ClassicLinkList(</span><span class="token comment">// void* inputArray, </span><span class="token comment">// size_t dataSize, </span><span class="token comment">// size_t dataNum</span><span class="token comment">// )</span><span class="token comment">//</span>Classic_DataList<span class="token operator">*</span> <span class="token function">UpdateStaticArray2ClassicLinkList</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span>inputArray<span class="token punctuation">,</span> <span class="token class-name">size_t</span>dataSize<span class="token punctuation">,</span> <span class="token class-name">size_t</span>dataNum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>inputArray <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataList<span class="token operator">*</span> pro_usable_space <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> FirstHeaddata <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> datapiece <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pro_usable_space <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>FirstHeaddata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>datapiece <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>datapiece<span class="token punctuation">,</span> inputArray<span class="token punctuation">,</span> dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span>FirstHeaddata<span class="token operator">-></span>data <span class="token operator">=</span> datapiece<span class="token punctuation">;</span>FirstHeaddata<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>pro_usable_space<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>pro_usable_space<span class="token operator">-></span>Head <span class="token operator">=</span> FirstHeaddata<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dataNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> pro_usable_space<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> datastored <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datastored<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>datastored<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>inputArray <span class="token operator">+</span> i <span class="token operator">*</span> dataSize<span class="token punctuation">,</span> dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> datanode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datanode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>datanode<span class="token operator">-></span>data <span class="token operator">=</span> datastored<span class="token punctuation">;</span>datanode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p_Currency<span class="token operator">-></span>p_next_one <span class="token operator">=</span> datanode<span class="token punctuation">;</span>pro_usable_space<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> pro_usable_space<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本添加函数"><a href="#基本添加函数" class="headerlink" title="基本添加函数"></a>基本添加函数</h2><p>​        现在，我们执行向里面添加数据的方法，说白了，就是创造一个新的节点，或者是若干的节点向里面推送数据：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//----------------------------------------Basic_Add_Functions----------</span><span class="token comment">// there are four basic input functions:</span><span class="token comment">// </span><span class="token comment">// --------------------------------------------------------------------</span><span class="token comment">// 1. push back an element into the classicLinkList</span><span class="token comment">// func1 : ClassicLinkListFunctionStatues Push_Back_Into_A_ClassicLinkList</span><span class="token comment">//</span><span class="token comment">// input : the inserted list ,the data wanted to be inserted and the inserted datasize</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// --------------------------------------------------------------------</span><span class="token comment">// 2. insert back an element into the classicLinkList by offering a valid pos</span><span class="token comment">// func2 : ClassicLinkListFunctionStatues Insert_into_AClassicLinkList</span><span class="token comment">// </span><span class="token comment">// </span><span class="token comment">// input : the inserted list , the data ,the datasize as well as the position you wanted to insert</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// --------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 3. push back a bunch of data into the classicLinkList like the first function</span><span class="token comment">// func3 :ClassicLinkListFunctionStatues push_Back_BunchDataintoClassicLinkList</span><span class="token comment">// </span><span class="token comment">// input : the inserted list , the data ,the datasize as well as the position you wanted to insert</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// --------------------------------------------------------------------</span><span class="token comment">// 4. insert back a bunch of data into the classicLinkList like the second function</span><span class="token comment">// func4: ClassicLinkListFunctionStatues Insert_A_Bunch_of_data_intoClassicLinkList</span><span class="token comment">//</span><span class="token comment">// input : the inserted list , the static array ,the datasize in the static array as well as the position you wanted to insert</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore! </span><span class="token comment">// </span><span class="token comment">//-------------------------Basic_Add_Functions-------------------------</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="尾插一个节点"><a href="#尾插一个节点" class="headerlink" title="尾插一个节点"></a>尾插一个节点</h3><p>​        我们首先得拿到一个尾节点，由于是单链表，我们就必须遍历链表到最后面。然后再伸出指针拷贝！函数的原型显而易见，就不再重复了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ClassicLinkListFunctionStatues <span class="token function">Push_Back_Into_A_ClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span> list<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span><span class="token class-name">size_t</span>datasize<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这里注意，我们需要区分一个事情，如果我们是创建了一个空链表，那就我们直接推进头节点就好了，于是：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token operator">*</span> datastored <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>datasize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datastored<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>datastored<span class="token punctuation">,</span> data<span class="token punctuation">,</span> datasize<span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> datanode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datanode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>datanode<span class="token operator">-></span>data <span class="token operator">=</span> datastored<span class="token punctuation">;</span>datanode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> datanode<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        如果不是，就要一个一个跑路：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//移动指针到尾部</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//准备拷贝</span><span class="token keyword">void</span><span class="token operator">*</span> datastored <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>datasize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datastored<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>datastored<span class="token punctuation">,</span> data<span class="token punctuation">,</span> datasize<span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> datanode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datanode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>datanode<span class="token operator">-></span>data <span class="token operator">=</span> datastored<span class="token punctuation">;</span>datanode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p_Currency<span class="token operator">-></span>p_next_one <span class="token operator">=</span> datanode<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>连起来看看：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// push back some data ,like dynamic array , into the final position</span><span class="token comment">//Used like this Push_Back_Into_A_ClassicLinkList(appendedClassicLinkList, data ,sizeof(data))</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">Push_Back_Into_A_ClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span><span class="token class-name">size_t</span>datasize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> datastored <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>datasize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datastored<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>datastored<span class="token punctuation">,</span> data<span class="token punctuation">,</span> datasize<span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> datanode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datanode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>datanode<span class="token operator">-></span>data <span class="token operator">=</span> datastored<span class="token punctuation">;</span>datanode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p_Currency<span class="token operator">-></span>p_next_one <span class="token operator">=</span> datanode<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token keyword">void</span><span class="token operator">*</span> datastored <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>datasize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datastored<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>datastored<span class="token punctuation">,</span> data<span class="token punctuation">,</span> datasize<span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> datanode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datanode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>datanode<span class="token operator">-></span>data <span class="token operator">=</span> datastored<span class="token punctuation">;</span>datanode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> datanode<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="尾插多个节点"><a href="#尾插多个节点" class="headerlink" title="尾插多个节点"></a>尾插多个节点</h3><p>​        这个很简单，由于是以数组的形式，那我们就仿照升级函数，不过，还是要注意是不是为空链表的问题，总而言之，不细讲，看代码！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicDataList</span><span class="token comment">// push back a bunch data into the datalist</span><span class="token comment">// used like this : push_Back_BunchDataintoClassicLinkList( inserted_list , the static array ,the elementsize ,the element num)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">push_Back_BunchDataintoClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span>inputArray<span class="token punctuation">,</span> <span class="token class-name">size_t</span>sigElemSize<span class="token punctuation">,</span> <span class="token class-name">size_t</span>arrayNum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//数据检查</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>inputArray<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Equally as to updata a Static Array into a ClassicLinkList</span><span class="token comment">//Once just use  UpdateStaticArray2ClassicLinkList(),but i'm afraid of unable to use this functions</span><span class="token comment">//as it is said: "DO NOT motivate another functions , try to finish all work if neccessary"</span>        <span class="token comment">//这是经典的升级工厂函数</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>Head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//New a List and new a head and new the data of the head</span>Classic_DataList<span class="token operator">*</span> p_NewList <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> newHead <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> newdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//check whether we init the node successfully</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newHead <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newdata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Do copy the data to the new head and finished initialization</span><span class="token function">memcpy</span><span class="token punctuation">(</span>newdata<span class="token punctuation">,</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newHead<span class="token operator">-></span>data <span class="token operator">=</span> newdata<span class="token punctuation">;</span>newHead<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p_NewList<span class="token operator">-></span>Head <span class="token operator">=</span> newHead<span class="token punctuation">;</span>p_NewList<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//Start copy other nodes</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pCurCopy <span class="token operator">=</span> p_NewList<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//Copy the I-th node</span>Classic_DataNode<span class="token operator">*</span> newDataNode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//check if the initialization is illegal</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newDataNode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// prepare to copy data from the current node</span><span class="token keyword">void</span><span class="token operator">*</span> newdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// check if the initialization is illegal</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newdata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//copy the detailed node</span><span class="token function">memcpy</span><span class="token punctuation">(</span>newdata<span class="token punctuation">,</span> p_Currency<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newDataNode<span class="token operator">-></span>data <span class="token operator">=</span> newdata<span class="token punctuation">;</span>newDataNode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//Moving the pointer and prepared next copy</span>pCurCopy<span class="token operator">-></span>p_next_one <span class="token operator">=</span> newDataNode<span class="token punctuation">;</span>pCurCopy <span class="token operator">=</span> pCurCopy<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Data copy finished , init the cur_size</span>p_NewList<span class="token operator">-></span>current_size <span class="token operator">=</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span>list <span class="token operator">=</span> p_NewList<span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//如果不是，那说明可以准备尾插</span><span class="token comment">//for this section , that means the head isn't NULL , just copy as usual:</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrayNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pCopyCur <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> copyData <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>sigElemSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pCopyCur <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> copyData <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>copyData<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>inputArray <span class="token operator">+</span> i <span class="token operator">*</span> sigElemSize<span class="token punctuation">,</span> sigElemSize<span class="token punctuation">)</span><span class="token punctuation">;</span>pCopyCur<span class="token operator">-></span>data <span class="token operator">=</span> copyData<span class="token punctuation">;</span>pCopyCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCopyCur<span class="token punctuation">;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>list<span class="token operator">-></span>current_size <span class="token operator">+=</span> arrayNum<span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入一个节点"><a href="#插入一个节点" class="headerlink" title="插入一个节点"></a>插入一个节点</h3><p>​        欸！这里就到了链表的一个关键了！</p><p><img src="image-20230215144354347.png" alt="image-20230215144354347"></p><p>​        还是要注意到，如果我们断开指针，这样子重连就好了，但是注意，我们必须<strong>先让新节点连上下一个节点，然后旧的链接断开，再连上前一个</strong>，原因很容易猜到的：先断开了怎么找下一个呢？</p><p>1）</p><p><img src="image-20230215144716735.png" alt="image-20230215144716735"></p><p>2）</p><p><img src="image-20230215144741500.png" alt="image-20230215144741500"></p><p>3）</p><p><img src="image-20230215144806121.png" alt="image-20230215144806121"></p><p>​        来看看代码：</p><p>​        我们的函数需要知道元素的大小和地址，和插入的位置：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ClassicLinkListFunctionStatues <span class="token function">Insert_into_AClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span><span class="token class-name">size_t</span>dataSize<span class="token punctuation">,</span><span class="token class-name">size_t</span>pos<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        检查数据：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        依旧区分问题：我们插在哪里呢？如果插在头节点，那就：让节点指向旧的头节点，然后把新节点作为头节点就好了</p><pre class="line-numbers language-none"><code class="language-none">if (pos &#x3D;&#x3D; 0)&#123;Classic_DataNode* stored &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));if (stored &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;void* dataPiece &#x3D; malloc(dataSize);memcpy(dataPiece, data, dataSize);stored-&gt;data &#x3D; dataPiece;stored-&gt;p_next_one &#x3D; list-&gt;Head;list-&gt;Head &#x3D; stored;list-&gt;current_size++;return ClassicLinkList_NORMAL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        中间位置的就把我们的思路抽象出来：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//准备空间</span>Classic_DataNode<span class="token operator">*</span> pCurrency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> stored <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>stored <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> dataPiece <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>dataPiece<span class="token punctuation">,</span> data<span class="token punctuation">,</span> dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span>stored<span class="token operator">-></span>data <span class="token operator">=</span> dataPiece<span class="token punctuation">;</span><span class="token comment">//定位到当前位置</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCurrency <span class="token operator">=</span> pCurrency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//开始入列</span>stored<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCurrency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCurrency<span class="token operator">-></span>p_next_one <span class="token operator">=</span> stored<span class="token punctuation">;</span><span class="token comment">//处理属性</span>list<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        就好了！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicDataList</span><span class="token comment">// insert back a data into the datalist</span><span class="token comment">// used like this: Insert_into_AClassicLinkList(inserted list, input data,dataSize,insertion_pos)</span><span class="token comment">// </span>ClassicLinkListFunctionStatues <span class="token function">Insert_into_AClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span><span class="token class-name">size_t</span>dataSize<span class="token punctuation">,</span><span class="token class-name">size_t</span>pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> stored <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>stored <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> dataPiece <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>dataPiece<span class="token punctuation">,</span> data<span class="token punctuation">,</span> dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span>stored<span class="token operator">-></span>data <span class="token operator">=</span> dataPiece<span class="token punctuation">;</span>stored<span class="token operator">-></span>p_next_one <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> stored<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCurrency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> stored <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>stored <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> dataPiece <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>dataPiece<span class="token punctuation">,</span> data<span class="token punctuation">,</span> dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span>stored<span class="token operator">-></span>data <span class="token operator">=</span> dataPiece<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCurrency <span class="token operator">=</span> pCurrency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>stored<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCurrency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCurrency<span class="token operator">-></span>p_next_one <span class="token operator">=</span> stored<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入一群节点函数"><a href="#插入一群节点函数" class="headerlink" title="插入一群节点函数"></a>插入一群节点函数</h3><p>​        很是类似，我们先把目标数组升级，然后找到保存头尾节点，头节点连在插入节点，尾节点连接在下一节点就好了：</p><p>​        函数原型是不难设想的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicDataList</span><span class="token comment">// insert back a bunch of data into the datalist</span><span class="token comment">// used like this: Insert_into_AClassicLinkList(inserted list, insertion_pos,input array ,Single dataSize, the amount of elements)</span><span class="token comment">// </span>ClassicLinkListFunctionStatues <span class="token function">Insert_A_Bunch_of_data_intoClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span> list<span class="token punctuation">,</span><span class="token class-name">size_t</span>pos<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span>inputArray<span class="token punctuation">,</span><span class="token class-name">size_t</span>sigElemSize<span class="token punctuation">,</span><span class="token class-name">size_t</span>arrayNum<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        接下来是：</p><p>​        数据判断：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>inputArray <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 询问用户要不要更改pos</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">></span> list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_WARNING_ClassicLinkList_OVERLAP_POS<span class="token punctuation">;</span><span class="token function">SHOW_WHETHER_ACCCEPTED</span><span class="token punctuation">(</span><span class="token string">"y/n: y for yes , n for n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> choice<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>choice<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>choice <span class="token operator">==</span> <span class="token char">'y'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pos <span class="token operator">=</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        先升级目标数组</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Classic_DataNode<span class="token operator">*</span> pCurNow <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pStart <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrayNum <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pCopyCur <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> copydata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>sigElemSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pCopyCur <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> copydata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>copydata<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>inputArray <span class="token operator">+</span> i <span class="token operator">*</span> sigElemSize<span class="token punctuation">,</span> sigElemSize<span class="token punctuation">)</span><span class="token punctuation">;</span>pCopyCur<span class="token operator">-></span>data <span class="token operator">=</span> copydata<span class="token punctuation">;</span>pCopyCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCurNow <span class="token operator">=</span> pCopyCur<span class="token punctuation">;</span>pStart <span class="token operator">=</span> pCopyCur<span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>pCurNow<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCopyCur<span class="token punctuation">;</span>pCurNow <span class="token operator">=</span> pCurNow<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后，开始分类讨论</p><p>​        头节点的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     <span class="token comment">// 转移</span>pCurNow<span class="token operator">-></span>p_next_one <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>     <span class="token comment">// 托管新的头节点</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> pStart<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size <span class="token operator">+=</span> arrayNum<span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        也有不是的，那就：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>pCurNow<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pStart<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size <span class="token operator">+=</span> arrayNum<span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="增加函数一览"><a href="#增加函数一览" class="headerlink" title="增加函数一览"></a>增加函数一览</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//----------------------------------------Basic_Add_Functions------------------------</span><span class="token comment">// there are four basic input functions:</span><span class="token comment">// </span><span class="token comment">// ----------------------------------------------------------------------------------</span><span class="token comment">// 1. push back an element into the classicLinkList</span><span class="token comment">// func1 : ClassicLinkListFunctionStatues Push_Back_Into_A_ClassicLinkList</span><span class="token comment">//</span><span class="token comment">// input : the inserted list ,the data wanted to be inserted and the inserted datasize</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// ----------------------------------------------------------------------------------</span><span class="token comment">// 2. insert back an element into the classicLinkList by offering a valid pos</span><span class="token comment">// func2 : ClassicLinkListFunctionStatues Insert_into_AClassicLinkList</span><span class="token comment">// </span><span class="token comment">// </span><span class="token comment">// input : the inserted list , the data ,the datasize as well as the position you wanted to insert</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// ----------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 3. push back a bunch of data into the classicLinkList like the first function</span><span class="token comment">// func3 :ClassicLinkListFunctionStatues push_Back_BunchDataintoClassicLinkList</span><span class="token comment">// </span><span class="token comment">// input : the inserted list , the data ,the datasize as well as the position you wanted to insert</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// ----------------------------------------------------------------------------------</span><span class="token comment">// 4. insert back a bunch of data into the classicLinkList like the second function</span><span class="token comment">// func4: ClassicLinkListFunctionStatues Insert_A_Bunch_of_data_intoClassicLinkList</span><span class="token comment">//</span><span class="token comment">// input : the inserted list , the static array ,the datasize in the static array as well as the position you wanted to insert</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore! </span><span class="token comment">// </span><span class="token comment">//----------------------------------------Basic_Add_Functions-------------------------</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// push back some data ,like dynamic array , into the final position</span><span class="token comment">//Used like this Push_Back_Into_A_ClassicLinkList(appendedClassicLinkList, data ,sizeof(data))</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">Push_Back_Into_A_ClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span><span class="token class-name">size_t</span>datasize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> datastored <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>datasize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datastored<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>datastored<span class="token punctuation">,</span> data<span class="token punctuation">,</span> datasize<span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> datanode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datanode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>datanode<span class="token operator">-></span>data <span class="token operator">=</span> datastored<span class="token punctuation">;</span>datanode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p_Currency<span class="token operator">-></span>p_next_one <span class="token operator">=</span> datanode<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token keyword">void</span><span class="token operator">*</span> datastored <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>datasize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datastored<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>datastored<span class="token punctuation">,</span> data<span class="token punctuation">,</span> datasize<span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> datanode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>datanode<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>datanode<span class="token operator">-></span>data <span class="token operator">=</span> datastored<span class="token punctuation">;</span>datanode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> datanode<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicDataList</span><span class="token comment">// insert back a data into the datalist</span><span class="token comment">// used like this: Insert_into_AClassicLinkList(inserted list, input data,dataSize,insertion_pos)</span><span class="token comment">// </span>ClassicLinkListFunctionStatues <span class="token function">Insert_into_AClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span><span class="token class-name">size_t</span>dataSize<span class="token punctuation">,</span><span class="token class-name">size_t</span>pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> stored <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>stored <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> dataPiece <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>dataPiece<span class="token punctuation">,</span> data<span class="token punctuation">,</span> dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span>stored<span class="token operator">-></span>data <span class="token operator">=</span> dataPiece<span class="token punctuation">;</span>stored<span class="token operator">-></span>p_next_one <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> stored<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCurrency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> stored <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>stored <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span><span class="token operator">*</span> dataPiece <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>dataPiece<span class="token punctuation">,</span> data<span class="token punctuation">,</span> dataSize<span class="token punctuation">)</span><span class="token punctuation">;</span>stored<span class="token operator">-></span>data <span class="token operator">=</span> dataPiece<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCurrency <span class="token operator">=</span> pCurrency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>stored<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCurrency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCurrency<span class="token operator">-></span>p_next_one <span class="token operator">=</span> stored<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicDataList</span><span class="token comment">// push back a bunch data into the datalist</span><span class="token comment">// used like this : push_Back_BunchDataintoClassicLinkList( inserted_list , the static array ,the elementsize ,the element num)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">push_Back_BunchDataintoClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span>inputArray<span class="token punctuation">,</span> <span class="token class-name">size_t</span>sigElemSize<span class="token punctuation">,</span> <span class="token class-name">size_t</span>arrayNum<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>inputArray<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Equally as to updata a Static Array into a ClassicLinkList</span><span class="token comment">//Once just use  UpdateStaticArray2ClassicLinkList(),but i'm afraid of unable to use this functions</span><span class="token comment">//as it is said: "DO NOT motivate another functions , try to finish all work if neccessary"</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>Head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//New a List and new a head and new the data of the head</span>Classic_DataList<span class="token operator">*</span> p_NewList <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> newHead <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> newdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//check whether we init the node successfully</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newHead <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newdata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Do copy the data to the new head and finished initialization</span><span class="token function">memcpy</span><span class="token punctuation">(</span>newdata<span class="token punctuation">,</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>list<span class="token operator">-></span>Head<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newHead<span class="token operator">-></span>data <span class="token operator">=</span> newdata<span class="token punctuation">;</span>newHead<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>p_NewList<span class="token operator">-></span>Head <span class="token operator">=</span> newHead<span class="token punctuation">;</span>p_NewList<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//Start copy other nodes</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pCurCopy <span class="token operator">=</span> p_NewList<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//Copy the I-th node</span>Classic_DataNode<span class="token operator">*</span> newDataNode <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//check if the initialization is illegal</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newDataNode <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// prepare to copy data from the current node</span><span class="token keyword">void</span><span class="token operator">*</span> newdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// check if the initialization is illegal</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newdata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//copy the detailed node</span><span class="token function">memcpy</span><span class="token punctuation">(</span>newdata<span class="token punctuation">,</span> p_Currency<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>newDataNode<span class="token operator">-></span>data <span class="token operator">=</span> newdata<span class="token punctuation">;</span>newDataNode<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//Moving the pointer and prepared next copy</span>pCurCopy<span class="token operator">-></span>p_next_one <span class="token operator">=</span> newDataNode<span class="token punctuation">;</span>pCurCopy <span class="token operator">=</span> pCurCopy<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Data copy finished , init the cur_size</span>p_NewList<span class="token operator">-></span>current_size <span class="token operator">=</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span>list <span class="token operator">=</span> p_NewList<span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//for this section , that means the head isn't NULL , just copy as usual:</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrayNum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pCopyCur <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> copyData <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>sigElemSize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pCopyCur <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> copyData <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>copyData<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>inputArray <span class="token operator">+</span> i <span class="token operator">*</span> sigElemSize<span class="token punctuation">,</span> sigElemSize<span class="token punctuation">)</span><span class="token punctuation">;</span>pCopyCur<span class="token operator">-></span>data <span class="token operator">=</span> copyData<span class="token punctuation">;</span>pCopyCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCopyCur<span class="token punctuation">;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>list<span class="token operator">-></span>current_size <span class="token operator">+=</span> arrayNum<span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicDataList</span><span class="token comment">// insert back a bunch of data into the datalist</span><span class="token comment">// used like this: Insert_into_AClassicLinkList(inserted list, insertion_pos,input array ,Single dataSize, the amount of elements)</span><span class="token comment">// </span>ClassicLinkListFunctionStatues <span class="token function">Insert_A_Bunch_of_data_intoClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span><span class="token class-name">size_t</span>pos<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span>inputArray<span class="token punctuation">,</span><span class="token class-name">size_t</span>sigElemSize<span class="token punctuation">,</span><span class="token class-name">size_t</span>arrayNum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>inputArray <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">></span> list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_WARNING_ClassicLinkList_OVERLAP_POS<span class="token punctuation">;</span><span class="token function">SHOW_WHETHER_ACCCEPTED</span><span class="token punctuation">(</span><span class="token string">"y/n: y for yes , n for n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> choice<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>choice<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>choice <span class="token operator">==</span> <span class="token char">'y'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pos <span class="token operator">=</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCurNow <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pStart <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrayNum <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pCopyCur <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> copydata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>sigElemSize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pCopyCur <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> copydata <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>copydata<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>inputArray <span class="token operator">+</span> i <span class="token operator">*</span> sigElemSize<span class="token punctuation">,</span> sigElemSize<span class="token punctuation">)</span><span class="token punctuation">;</span>pCopyCur<span class="token operator">-></span>data <span class="token operator">=</span> copydata<span class="token punctuation">;</span>pCopyCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCurNow <span class="token operator">=</span> pCopyCur<span class="token punctuation">;</span>pStart <span class="token operator">=</span> pCopyCur<span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>pCurNow<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCopyCur<span class="token punctuation">;</span>pCurNow <span class="token operator">=</span> pCurNow<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCurNow<span class="token operator">-></span>p_next_one <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> pStart<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size <span class="token operator">+=</span> arrayNum<span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>pCurNow<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pStart<span class="token punctuation">;</span>list<span class="token operator">-></span>current_size <span class="token operator">+=</span> arrayNum<span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h3><p>​            我们删除就不整什么尾删法了，直接上任意删除</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//------------------------------------------Deletion_Functions-------------</span><span class="token comment">// there are two basic type of functions in the sections</span><span class="token comment">// 1. Erase a targeted element and erase it from the ClassicDataList</span><span class="token comment">// fun1:eraseAElementfromDataList</span><span class="token comment">// </span><span class="token comment">// input : the list and the erase position</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// --------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 2.Erase some target elements from the ClassicDataList</span><span class="token comment">// fun2:eraseAbunchData</span><span class="token comment">// </span><span class="token comment">// input: the list and the start position as well as the last position, that means offer a paired pos</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">//------------------------------------------Deletion_Functions----------------</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除一个节点"><a href="#删除一个节点" class="headerlink" title="删除一个节点"></a>删除一个节点</h3><p>​        对于删除一个元素，我们就逆向过程一下：</p><p><img src="image-20230215151404255.png" alt="image-20230215151404255"></p><p>​        先指定pDel是查找指针的下一个：然后，记作 pDel 之后呢，再：删除与指针重连。</p><p>​        函数的原型显然是显而易见的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ClassicLinkListFunctionStatues <span class="token function">eraseAElementfromDataList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span><span class="token class-name">size_t</span>pos<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        做好数据检查：</p><pre class="line-numbers language-none"><code class="language-none">if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;list-&gt;current_size)&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        开始区分，如果是删除头节点：</p><pre class="line-numbers language-none"><code class="language-none">if (pos &#x3D;&#x3D; 0)&#123;Classic_DataNode* pNewHead &#x3D; list-&gt;Head-&gt;p_next_one;Classic_DataNode* pDel &#x3D; list-&gt;Head;list-&gt;Head &#x3D; pNewHead;free(pDel-&gt;data);list-&gt;current_size--;return ClassicLinkList_NORMAL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        之后的类似：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pDel <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pDel<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicDataList</span><span class="token comment">// delete a  data in the datalist by offering a position</span><span class="token comment">//used like this: eraseAElementfromDataList(list, erasing_pos)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">eraseAElementfromDataList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span><span class="token class-name">size_t</span>pos<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pNewHead <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pDel <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> pNewHead<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pDel <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pDel<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除多个节点"><a href="#删除多个节点" class="headerlink" title="删除多个节点"></a>删除多个节点</h3><p>函数的原型显而易见了，不多赘述：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">ClassicLinkListFunctionStatues <span class="token function">eraseAbunchData_inDataList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span> list<span class="token punctuation">,</span> <span class="token class-name">size_t</span>front_pos<span class="token punctuation">,</span><span class="token class-name">size_t</span>final_pos<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据检查是少不了的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> front_pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>final_pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> final_pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos <span class="token operator">></span> final_pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_WARNING_ClassicLinkList_SWAPPED_POS<span class="token punctuation">;</span><span class="token function">SHOW_WHETHER_ACCCEPTED</span><span class="token punctuation">(</span><span class="token string">"y/n: y for yes , n for n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> choice<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>choice<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>choice <span class="token operator">==</span> <span class="token char">'y'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> temp <span class="token operator">=</span> final_pos<span class="token punctuation">;</span>final_pos <span class="token operator">=</span> front_pos<span class="token punctuation">;</span>front_pos <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        仍然是区分是不是包含了头节点的问题：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Bool flag <span class="token operator">=</span>False<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>flag <span class="token operator">=</span> True<span class="token punctuation">;</span>front_pos<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//开始移动位置</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> front_pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> cur_place <span class="token operator">=</span> front_pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>cur_place <span class="token operator">&lt;=</span> final_pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pDel <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pDel<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token punctuation">)</span><span class="token punctuation">;</span>cur_place<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>list<span class="token operator">-></span>current_size <span class="token operator">-=</span> final_pos <span class="token operator">-</span> front_pos <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//单独处理头节点的问题：</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> True<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pNewHead <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pDel <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> pNewHead<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除函数API一览"><a href="#删除函数API一览" class="headerlink" title="删除函数API一览"></a>删除函数API一览</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//------------------------------------------Deletion_Functions-------------</span><span class="token comment">// there are two basic type of functions in the sections</span><span class="token comment">// 1. Erase a targeted element and erase it from the ClassicDataList</span><span class="token comment">// fun1:eraseAElementfromDataList</span><span class="token comment">// </span><span class="token comment">// input : the list and the erase position</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// --------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 2.Erase some target elements from the ClassicDataList</span><span class="token comment">// fun2:eraseAbunchData</span><span class="token comment">// </span><span class="token comment">// input: the list and the start position as well as the last position, that means offer a paired pos</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">//------------------------------------------Deletion_Functions----------------</span><span class="token comment">// About ClassicDataList</span><span class="token comment">// delete a  data in the datalist by offering a position</span><span class="token comment">//used like this: eraseAElementfromDataList(list, erasing_pos)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">eraseAElementfromDataList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span><span class="token class-name">size_t</span>pos<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pNewHead <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pDel <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> pNewHead<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pDel <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pDel<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">--</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicDataList</span><span class="token comment">// delete a bunch of data in the datalist</span><span class="token comment">// used like this eraseAbunchData( list,  front_pos,  final_pos)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">eraseAbunchData_inDataList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token class-name">size_t</span>front_pos<span class="token punctuation">,</span><span class="token class-name">size_t</span>final_pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> front_pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>final_pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> final_pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos <span class="token operator">></span> final_pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_WARNING_ClassicLinkList_SWAPPED_POS<span class="token punctuation">;</span><span class="token function">SHOW_WHETHER_ACCCEPTED</span><span class="token punctuation">(</span><span class="token string">"y/n: y for yes , n for n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> choice<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>choice<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>choice <span class="token operator">==</span> <span class="token char">'y'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> temp <span class="token operator">=</span> final_pos<span class="token punctuation">;</span>final_pos <span class="token operator">=</span> front_pos<span class="token punctuation">;</span>front_pos <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Bool flag <span class="token operator">=</span>False<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>flag <span class="token operator">=</span> True<span class="token punctuation">;</span>front_pos<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> front_pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> cur_place <span class="token operator">=</span> front_pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>cur_place <span class="token operator">&lt;=</span> final_pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pDel <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pDel<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token punctuation">)</span><span class="token punctuation">;</span>cur_place<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>list<span class="token operator">-></span>current_size <span class="token operator">-=</span> final_pos <span class="token operator">-</span> front_pos <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> True<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pNewHead <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pDel <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> pNewHead<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>front_pos<span class="token operator">++</span><span class="token punctuation">;</span>list<span class="token operator">-></span>current_size<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查询位置类函数"><a href="#查询位置类函数" class="headerlink" title="查询位置类函数"></a>查询位置类函数</h2><p>​        这个函数模块比较大了，我们首先设计一个是否存在的查询，其次还要设计返回位置的函数，甚至是返回多个位置的函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//----------------------------------------check_if_element_existed_functions-----</span><span class="token comment">// there are four functions in this sections</span><span class="token comment">// </span><span class="token comment">// 1.check if the classiclinklist is empty</span><span class="token comment">// fun1: isEmptyClassicLinkList</span><span class="token comment">// </span><span class="token comment">// input :the checked list</span><span class="token comment">// output: My defined bool(Sadly the org C doesn't define that)</span><span class="token comment">// </span><span class="token comment">// ------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 2. check if the target elements is exsited in the datalist</span><span class="token comment">// fun2: checkIsLocateinLinkList</span><span class="token comment">// </span><span class="token comment">// input : the checked list ,the searched data and the Compared functions</span><span class="token comment">// output: the locations that we first found it</span><span class="token comment">// </span><span class="token comment">// -------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 3. return out the first locations that we found of the target elements</span><span class="token comment">// func3:checkIsLocateinLinkList</span><span class="token comment">// </span><span class="token comment">// input : the checked list ,the searched data and the Compared functions</span><span class="token comment">// output: My defined bool(Sadly the org C doesn't define that)</span><span class="token comment">// </span><span class="token comment">// --------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// Warning : this functions required the PSDA abstractions is opened so you can use Position_Stored_Dynamic_ArrayFordyarr*</span><span class="token comment">// to get the position</span><span class="token comment">// </span><span class="token comment">// 4. return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr</span><span class="token comment">// fun4:returnAbunchLocationsinLinkList</span><span class="token comment">// </span><span class="token comment">// input : the checked list , the Position_Stored_Dynamic_ArrayFordyarr*(required init first)</span><span class="token comment">// output: the Position_Stored_Dynamic_ArrayFordyarr that stored the positions!</span><span class="token comment">//</span><span class="token comment">// -------------------------------------------------------------------</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链表是否为空函数"><a href="#链表是否为空函数" class="headerlink" title="链表是否为空函数"></a>链表是否为空函数</h3><p>​        很简答，直接略</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// check if the LinkList is empty</span><span class="token comment">//</span>Bool <span class="token function">isEmptyClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>current_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> True<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> False<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于元素是否存在，我看，我们的用户要定义什么是存在，就是说，提供一个函数可以描述需求：</p><p>​         使用 LocateFun 函数就好了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">LocateFunc user_func<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// check if the target elements is exsited in the datalist</span><span class="token comment">//</span>Bool <span class="token function">checkIsLocateinLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span>LocateFuncuser_func<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        检查输入的合法性：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>user_func <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        走一遍，比较一遍就好了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">user_func</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> True<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> False<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        返回具体位置？把存在改成返回位置就好了！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// return out the first locations that we found of the target elements</span><span class="token comment">// can use in this way: size_t pos = returnOutDatabyposinLinkList( list, data, user_func)</span><span class="token class-name">size_t</span> <span class="token function">returnOutDatabyposinLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span> LocateFuncuser_func<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">user_func</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> Unfind_ClassicLinkList<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>     下面的多重返回：需要打开动态数组存储</code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr</span><span class="token comment">// can use in this way: Position_Stored_Dynamic_ArrayFordyarr* somePos = </span><span class="token comment">// returnAbunchLocationsinLinkList( list,  posArr,  data,  user_func)</span><span class="token comment">//</span>Position_Stored_Dynamic_ArrayFordyarr<span class="token operator">*</span> <span class="token function">returnAbunchLocationsinLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> Position_Stored_Dynamic_ArrayFordyarr<span class="token operator">*</span>  posArr<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>   data<span class="token punctuation">,</span>LocateFunc    user_func<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>posArr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">int</span> possible_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>user_func<span class="token punctuation">)</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//开始重新开辟下内存</span><span class="token keyword">int</span><span class="token operator">*</span> pro_usable_stored_space <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>posArr<span class="token operator">-></span>posSpace<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>possible_count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pro_usable_stored_space<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>posArr<span class="token operator">-></span>posSpace <span class="token operator">=</span> pro_usable_stored_space<span class="token punctuation">;</span>            <span class="token comment">//向第I个位置存储</span>posArr<span class="token operator">-></span>posSpace<span class="token punctuation">[</span>possible_count<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>possible_count<span class="token operator">++</span><span class="token punctuation">;</span>posArr<span class="token operator">-></span>pos_size <span class="token operator">=</span> possible_count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>posArr<span class="token operator">-></span>pos_size<span class="token punctuation">)</span><span class="token keyword">return</span> posArr<span class="token punctuation">;</span><span class="token keyword">return</span> Unfind_ClassicLinkList<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询函数一览"><a href="#查询函数一览" class="headerlink" title="查询函数一览"></a>查询函数一览</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//----------------------------------------check_if_element_existed_functions-----</span><span class="token comment">// there are four functions in this sections</span><span class="token comment">// </span><span class="token comment">// 1.check if the classiclinklist is empty</span><span class="token comment">// fun1: isEmptyClassicLinkList</span><span class="token comment">// </span><span class="token comment">// input :the checked list</span><span class="token comment">// output: My defined bool(Sadly the org C doesn't define that)</span><span class="token comment">// </span><span class="token comment">// ------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 2. check if the target elements is exsited in the datalist</span><span class="token comment">// fun2: checkIsLocateinLinkList</span><span class="token comment">// </span><span class="token comment">// input : the checked list ,the searched data and the Compared functions</span><span class="token comment">// output: the locations that we first found it</span><span class="token comment">// </span><span class="token comment">// -------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 3. return out the first locations that we found of the target elements</span><span class="token comment">// func3:checkIsLocateinLinkList</span><span class="token comment">// </span><span class="token comment">// input : the checked list ,the searched data and the Compared functions</span><span class="token comment">// output: My defined bool(Sadly the org C doesn't define that)</span><span class="token comment">// </span><span class="token comment">// --------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// Warning : this functions required the PSDA abstractions is opened so you can use Position_Stored_Dynamic_ArrayFordyarr*</span><span class="token comment">// to get the position</span><span class="token comment">// </span><span class="token comment">// 4. return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr</span><span class="token comment">// fun4:returnAbunchLocationsinLinkList</span><span class="token comment">// </span><span class="token comment">// input : the checked list , the Position_Stored_Dynamic_ArrayFordyarr*(required init first)</span><span class="token comment">// output: the Position_Stored_Dynamic_ArrayFordyarr that stored the positions!</span><span class="token comment">//</span><span class="token comment">// ---------------------------------------------------------------------------------</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// check if the LinkList is empty</span><span class="token comment">//</span>Bool <span class="token function">isEmptyClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>current_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">return</span> True<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> False<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// check if the target elements is exsited in the datalist</span><span class="token comment">//</span>Bool <span class="token function">checkIsLocateinLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span>LocateFuncuser_func<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>user_func <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">user_func</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> True<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> False<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// return out the first locations that we found of the target elements</span><span class="token comment">// can use in this way: size_t pos = returnOutDatabyposinLinkList( list, data, user_func)</span><span class="token class-name">size_t</span> <span class="token function">returnOutDatabyposinLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span> LocateFuncuser_func<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">user_func</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> Unfind_ClassicLinkList<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Make sure the OPENUPPOSARR == 1 if wanted to use it</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">OPENUPPOSARR</span></span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr</span><span class="token comment">// can use in this way: Position_Stored_Dynamic_ArrayFordyarr* somePos = </span><span class="token comment">// returnAbunchLocationsinLinkList( list,  posArr,  data,  user_func)</span><span class="token comment">//</span>Position_Stored_Dynamic_ArrayFordyarr<span class="token operator">*</span> <span class="token function">returnAbunchLocationsinLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> Position_Stored_Dynamic_ArrayFordyarr<span class="token operator">*</span>posArr<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span>data<span class="token punctuation">,</span>LocateFuncuser_func<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>posArr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">int</span> possible_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>user_func<span class="token punctuation">)</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span><span class="token operator">*</span> pro_usable_stored_space <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>posArr<span class="token operator">-></span>posSpace<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>possible_count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pro_usable_stored_space<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>posArr<span class="token operator">-></span>posSpace <span class="token operator">=</span> pro_usable_stored_space<span class="token punctuation">;</span>posArr<span class="token operator">-></span>posSpace<span class="token punctuation">[</span>possible_count<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>possible_count<span class="token operator">++</span><span class="token punctuation">;</span>posArr<span class="token operator">-></span>pos_size <span class="token operator">=</span> possible_count<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>posArr<span class="token operator">-></span>pos_size<span class="token punctuation">)</span><span class="token keyword">return</span> posArr<span class="token punctuation">;</span><span class="token keyword">return</span> Unfind_ClassicLinkList<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一些作用函数"><a href="#一些作用函数" class="headerlink" title="一些作用函数"></a>一些作用函数</h2><p>请看一览：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//---------------------------------------Do_Something_to_the_datalist_functions----------</span><span class="token comment">// there are seven functions in this sections</span><span class="token comment">// </span><span class="token comment">// 1. Classic Print functions</span><span class="token comment">// func1: Print_All_Data_LinkList</span><span class="token comment">// to print all the data in the user_defined linklist</span><span class="token comment">// </span><span class="token comment">// input : list and the user print , and the decision whether enjoyed a better print</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// ------------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 2. Do some change to the specific data</span><span class="token comment">// to make some change directly to an element</span><span class="token comment">// </span><span class="token comment">// input : the list ,the targeted positions and the way how you want to operate the data itself</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// ------------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 3. Do some change to all the data in the classiclinklist</span><span class="token comment">// to make some change directly to the whole elements</span><span class="token comment">// </span><span class="token comment">// input : the list ,the way how you want to operate the data itself</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// -----------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 4. Do specific change to an interval pos in the classicLickList</span><span class="token comment">// to make some change directly to the interval elements</span><span class="token comment">// </span><span class="token comment">// input : the list ,the front_pos and the final_pos</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// -----------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 5. reverse ClassicLinkList</span><span class="token comment">// to reverse up the classic LinkList</span><span class="token comment">// </span><span class="token comment">// input : the ready_reversed data</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// -----------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 6. combine two linkList into one</span><span class="token comment">// to combine the two classic linklist into one!</span><span class="token comment">// </span><span class="token comment">// input : the two linklist</span><span class="token comment">// output: the merged linklist Pointer</span><span class="token comment">// </span><span class="token comment">// -----------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 7. sort the elements in the classicLinkList under the user's constructions</span><span class="token comment">// to sort the ClassicLinkList</span><span class="token comment">// </span><span class="token comment">// input : the classicLinklist</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// --------------------------------------------------------------------</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="打印函数"><a href="#打印函数" class="headerlink" title="打印函数"></a>打印函数</h3><p>​        还是遍历链表，由于跟查询类似就不再多费口舌了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to print the data</span><span class="token comment">// use in this way: Print_All_Data_LinkList( list, user_print,  whether_better_print)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>   list<span class="token punctuation">,</span>MyPrint  user_print<span class="token punctuation">,</span> BetterPrintSwitch_for_ClassicLinkList whether_better_print<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>user_print<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>whether_better_print <span class="token operator">==</span> ClassicLinkList_OPEN<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nStart printing:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">user_print</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>whether_better_print <span class="token operator">==</span> ClassicLinkList_OPEN<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nFinish printing:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三大作用函数"><a href="#三大作用函数" class="headerlink" title="三大作用函数"></a>三大作用函数</h3><h4 id="个体作用函数"><a href="#个体作用函数" class="headerlink" title="个体作用函数"></a>个体作用函数</h4><p>​        跟查询单个类似：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to make some change to the specific data</span><span class="token comment">// use in this way:doChangetoSpecificElementinLinkList( list,  pos , user_func)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">doChangetoSpecificElementinLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token class-name">size_t</span>pos <span class="token punctuation">,</span>Do_Specific_Changeuser_func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 数据合法性</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>user_func<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">// 开始寻找对应的</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">user_func</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="区间作用函数"><a href="#区间作用函数" class="headerlink" title="区间作用函数"></a>区间作用函数</h4><p>​        不难想的：提供作用方式 + 区间长度+区间位置</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to make some change to the interval data</span><span class="token comment">// use in this way:doChangetoTargetIntervalDatainLinkList(list , pos1,pos2, user_func)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">doChangetoTargetIntervalDatainLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token class-name">size_t</span>front_pos<span class="token punctuation">,</span><span class="token class-name">size_t</span>final_pos<span class="token punctuation">,</span>Do_Specific_Changeuser_func<span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还是类似的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 数据检查</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> front_pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>final_pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> final_pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos <span class="token operator">></span> final_pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_WARNING_ClassicLinkList_SWAPPED_POS<span class="token punctuation">;</span><span class="token function">SHOW_WHETHER_ACCCEPTED</span><span class="token punctuation">(</span><span class="token string">"y/n: y for yes , n for n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> choice<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>choice<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>choice <span class="token operator">==</span> <span class="token char">'y'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> temp <span class="token operator">=</span> final_pos<span class="token punctuation">;</span>final_pos <span class="token operator">=</span> front_pos<span class="token punctuation">;</span>front_pos <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> front_pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> front_pos<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> final_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">user_func</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="全体作用"><a href="#全体作用" class="headerlink" title="全体作用"></a>全体作用</h4><p>​        不细说，类似的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to make some change to the whole elements in the data</span><span class="token comment">// use in this way:doChangetoAllDatainLinkList( list,  user_func)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">doChangetoAllDatainLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span>Do_Specific_Changeuser_func<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> user_func <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">user_func</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>pCur<span class="token operator">=</span>pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="三大函数API一览"><a href="#三大函数API一览" class="headerlink" title="三大函数API一览"></a>三大函数API一览</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to make some change to the specific data</span><span class="token comment">// use in this way:doChangetoSpecificElementinLinkList( list,  pos , user_func)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">doChangetoSpecificElementinLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token class-name">size_t</span>pos <span class="token punctuation">,</span>Do_Specific_Changeuser_func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>user_func<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">user_func</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to make some change to the interval data</span><span class="token comment">// use in this way:doChangetoTargetIntervalDatainLinkList(list , pos1,pos2, user_func)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">doChangetoTargetIntervalDatainLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token class-name">size_t</span>front_pos<span class="token punctuation">,</span><span class="token class-name">size_t</span>final_pos<span class="token punctuation">,</span>Do_Specific_Changeuser_func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> front_pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>final_pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> final_pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos <span class="token operator">></span> final_pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_WARNING_ClassicLinkList_SWAPPED_POS<span class="token punctuation">;</span><span class="token function">SHOW_WHETHER_ACCCEPTED</span><span class="token punctuation">(</span><span class="token string">"y/n: y for yes , n for n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> choice<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>choice<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>choice <span class="token operator">==</span> <span class="token char">'y'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> temp <span class="token operator">=</span> final_pos<span class="token punctuation">;</span>final_pos <span class="token operator">=</span> front_pos<span class="token punctuation">;</span>front_pos <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> front_pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> front_pos<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> final_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">user_func</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to make some change to the whole elements in the data</span><span class="token comment">// use in this way:doChangetoAllDatainLinkList( list,  user_func)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">doChangetoAllDatainLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span>Do_Specific_Changeuser_func<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> user_func <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">user_func</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>pCur<span class="token operator">=</span>pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="翻转链表函数"><a href="#翻转链表函数" class="headerlink" title="翻转链表函数"></a>翻转链表函数</h3><p>​        看一个反转链表的函数</p><p>​        为了加快效率，我们分类讨论一下：</p><p>​        一个没必要反转，两个直接互换就好，问题在于多个的：</p><pre class="line-numbers language-none"><code class="language-none">if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (list-&gt;current_size &#x3D;&#x3D; 1)&#123;printf(&quot;No need in reversing!,try a longer one lol&quot;);return ClassicLinkList_NORMAL;&#125;if (list-&gt;current_size &#x3D;&#x3D; 2)&#123;Classic_DataNode* headFisrt &#x3D; list-&gt;Head;Classic_DataNode* pFin &#x3D; headFisrt-&gt;p_next_one;pFin-&gt;p_next_one &#x3D; headFisrt;headFisrt-&gt;p_next_one &#x3D; NULL;list-&gt;Head &#x3D; pFin;return ClassicLinkList_NORMAL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于一个中间片段：</p><p><img src="image-20230215155300284.png" alt="image-20230215155300284"></p><p>​        我们需要首先将指针反转，然后，后行指针先被先行指针赋值：</p><p><img src="image-20230215155447947.png" alt="image-20230215155447947"></p><p>​        先行指针后移：成为子问题：</p><p><img src="image-20230215155521784.png" alt="image-20230215155521784"></p><p>​        代码上就是这样的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to reverse up the classiclinklist</span><span class="token comment">// use in this way:ReverseLinkList(list)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">ReverseLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>current_size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No need in reversing!,try a longer one lol"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>current_size <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> headFisrt <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pFin <span class="token operator">=</span> headFisrt<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pFin<span class="token operator">-></span>p_next_one <span class="token operator">=</span> headFisrt<span class="token punctuation">;</span>headFisrt<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> pFin<span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pFinal <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pPrior <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>pFinal<span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> tempFin <span class="token operator">=</span> pFinal<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pFinal<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pPrior<span class="token punctuation">;</span>pPrior <span class="token operator">=</span> pFinal<span class="token punctuation">;</span>pFinal <span class="token operator">=</span> tempFin<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> pPrior<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="链表的合并于衔接函数"><a href="#链表的合并于衔接函数" class="headerlink" title="链表的合并于衔接函数"></a>链表的合并于衔接函数</h3><p>​        对于这样，仍然是先检查合法性+指向末尾：</p><p>​        况且，如果用户不想拷贝数据，直接传参</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>list_be_added <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> list_adder <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur<span class="token operator">=</span>list_be_added<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list_be_added<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Do not copy , instead just merge!</span><span class="token keyword">if</span> <span class="token punctuation">(</span>whether_copied<span class="token operator">==</span>ClassicLinkList_NO_COPY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> list_adder<span class="token operator">-></span>Head<span class="token punctuation">;</span>list_be_added<span class="token operator">-></span>current_size <span class="token operator">+=</span> list_adder<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> list_be_added<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        拷贝的话，就是 copy + 衔接的问题：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Classic_DataNode<span class="token operator">*</span> pAdder <span class="token operator">=</span> list_adder<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list_adder<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//prepare the space</span>Classic_DataNode<span class="token operator">*</span> pCopy <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> dataCopy <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>pAdder<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pCopy <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> dataCopy <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Using to copy data and initialize the copied node</span><span class="token function">memcpy</span><span class="token punctuation">(</span>dataCopy<span class="token punctuation">,</span> pAdder<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pAdder<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pCopy<span class="token operator">-></span>data <span class="token operator">=</span> dataCopy<span class="token punctuation">;</span>pCopy<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//then push back into the linklist</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCopy<span class="token punctuation">;</span><span class="token comment">//Moving the copy pointer</span>pAdder <span class="token operator">=</span> pAdder<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>list_be_added<span class="token operator">-></span>current_size <span class="token operator">+=</span> list_adder<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> list_be_added<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        看看：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to merge two linklist into the one</span><span class="token comment">// use in this way:mergeLinkList(list_be_added, list_adder, whether_copied)</span><span class="token comment">//</span>Classic_DataList<span class="token operator">*</span> <span class="token function">mergeLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list_be_added<span class="token punctuation">,</span> Classic_DataList<span class="token operator">*</span>list_adder<span class="token punctuation">,</span> <span class="token class-name">size_t</span>whether_copied<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list_be_added <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> list_adder <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur<span class="token operator">=</span>list_be_added<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list_be_added<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Do not copy , instead just merge!</span><span class="token keyword">if</span> <span class="token punctuation">(</span>whether_copied<span class="token operator">==</span>ClassicLinkList_NO_COPY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> list_adder<span class="token operator">-></span>Head<span class="token punctuation">;</span>list_be_added<span class="token operator">-></span>current_size <span class="token operator">+=</span> list_adder<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> list_be_added<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pAdder <span class="token operator">=</span> list_adder<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list_adder<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//prepare the space</span>Classic_DataNode<span class="token operator">*</span> pCopy <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> dataCopy <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>pAdder<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pCopy <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> dataCopy <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Using to copy data and initialize the copied node</span><span class="token function">memcpy</span><span class="token punctuation">(</span>dataCopy<span class="token punctuation">,</span> pAdder<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pAdder<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pCopy<span class="token operator">-></span>data <span class="token operator">=</span> dataCopy<span class="token punctuation">;</span>pCopy<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//then push back into the linklist</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCopy<span class="token punctuation">;</span><span class="token comment">//Moving the copy pointer</span>pAdder <span class="token operator">=</span> pAdder<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>list_be_added<span class="token operator">-></span>current_size <span class="token operator">+=</span> list_adder<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> list_be_added<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序整理函数"><a href="#排序整理函数" class="headerlink" title="排序整理函数"></a>排序整理函数</h3><p>​        使用冒泡排序排序我们的链表，两两的比较，本质上就是 pCur 跟 pCur<code>-&gt;</code>next_one 比较。。。那就很简单了：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// About ClassicLinkList</span><span class="token comment">// sort the classicLinklist in the bobblesort</span><span class="token comment">// use in this way:sortClassicLinkListinBubbleSort(Classic_DataList* list, CompareFunc user_func) </span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">sortClassicLinkListinBubbleSort</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> CompareFuncuser_func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//检查数据是否合法</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>user_func <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>list<span class="token operator">-></span>current_size<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//this two for loops are just standard BobbleSort</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">user_func</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">,</span> pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">void</span><span class="token operator">*</span> tempdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>tempdata<span class="token punctuation">,</span> pCur<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> tempdatasize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Before Swap,make sure that the dataContainer is huge enough to contain a new space</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">void</span><span class="token operator">*</span> pTempSwap <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pTempSwap <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>pCur<span class="token operator">-></span>data <span class="token operator">=</span> pTempSwap<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Copy and swap</span><span class="token function">memcpy</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">,</span> pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">,</span> tempdata<span class="token punctuation">,</span> tempdatasize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Moving pointer to the next one</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="作用函数一览："><a href="#作用函数一览：" class="headerlink" title="作用函数一览："></a>作用函数一览：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//---------------------------------------Do_Something_to_the_datalist_functions----------</span><span class="token comment">// there are seven functions in this sections</span><span class="token comment">// </span><span class="token comment">// 1. Classic Print functions</span><span class="token comment">// func1: Print_All_Data_LinkList</span><span class="token comment">// to print all the data in the user_defined linklist</span><span class="token comment">// </span><span class="token comment">// input : list and the user print , and the decision whether enjoyed a better print</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// ------------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 2. Do some change to the specific data</span><span class="token comment">// to make some change directly to an element</span><span class="token comment">// </span><span class="token comment">// input : the list ,the targeted positions and the way how you want to operate the data itself</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// ------------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 3. Do some change to all the data in the classiclinklist</span><span class="token comment">// to make some change directly to the whole elements</span><span class="token comment">// </span><span class="token comment">// input : the list ,the way how you want to operate the data itself</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// -----------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 4. Do specific change to an interval pos in the classicLickList</span><span class="token comment">// to make some change directly to the interval elements</span><span class="token comment">// </span><span class="token comment">// input : the list ,the front_pos and the final_pos</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// -----------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 5. reverse ClassicLinkList</span><span class="token comment">// to reverse up the classic LinkList</span><span class="token comment">// </span><span class="token comment">// input : the ready_reversed data</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// -----------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 6. combine two linkList into one</span><span class="token comment">// to combine the two classic linklist into one!</span><span class="token comment">// </span><span class="token comment">// input : the two linklist</span><span class="token comment">// output: the merged linklist Pointer</span><span class="token comment">// </span><span class="token comment">// -----------------------------------------------------------------------------------</span><span class="token comment">// </span><span class="token comment">// 7. sort the elements in the classicLinkList under the user's constructions</span><span class="token comment">// to sort the ClassicLinkList</span><span class="token comment">// </span><span class="token comment">// input : the classicLinklist</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// ---------------------------------------------------------------------------------</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to print the data</span><span class="token comment">// use in this way: Print_All_Data_LinkList( list, user_print,  whether_better_print)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span>MyPrintuser_print<span class="token punctuation">,</span> BetterPrintSwitch_for_ClassicLinkListwhether_better_print<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>user_print<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>whether_better_print <span class="token operator">==</span> ClassicLinkList_OPEN<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nStart printing:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> p_Currency <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">user_print</span><span class="token punctuation">(</span>p_Currency<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>p_Currency <span class="token operator">=</span> p_Currency<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>whether_better_print <span class="token operator">==</span> ClassicLinkList_OPEN<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nFinish printing:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to make some change to the specific data</span><span class="token comment">// use in this way:doChangetoSpecificElementinLinkList( list,  pos , user_func)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">doChangetoSpecificElementinLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token class-name">size_t</span>pos <span class="token punctuation">,</span>Do_Specific_Changeuser_func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token operator">&amp;&amp;</span>user_func<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">user_func</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to make some change to the interval data</span><span class="token comment">// use in this way:doChangetoTargetIntervalDatainLinkList(list , pos1,pos2, user_func)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">doChangetoTargetIntervalDatainLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> <span class="token class-name">size_t</span>front_pos<span class="token punctuation">,</span><span class="token class-name">size_t</span>final_pos<span class="token punctuation">,</span>Do_Specific_Changeuser_func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> front_pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>final_pos<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> final_pos<span class="token operator">></span>list<span class="token operator">-></span>current_size<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>front_pos <span class="token operator">></span> final_pos<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_WARNING_ClassicLinkList_SWAPPED_POS<span class="token punctuation">;</span><span class="token function">SHOW_WHETHER_ACCCEPTED</span><span class="token punctuation">(</span><span class="token string">"y/n: y for yes , n for n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> choice<span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>choice<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>choice <span class="token operator">==</span> <span class="token char">'y'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> temp <span class="token operator">=</span> final_pos<span class="token punctuation">;</span>final_pos <span class="token operator">=</span> front_pos<span class="token punctuation">;</span>front_pos <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_Invalid_Input<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_Invalid_Input<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> front_pos<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> front_pos<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> final_pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">user_func</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to make some change to the whole elements in the data</span><span class="token comment">// use in this way:doChangetoAllDatainLinkList( list,  user_func)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">doChangetoAllDatainLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span>Do_Specific_Changeuser_func<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> user_func <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">user_func</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>pCur<span class="token operator">=</span>pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to reverse up the classiclinklist</span><span class="token comment">// use in this way:ReverseLinkList(list)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">ReverseLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>current_size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No need in reversing!,try a longer one lol"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>current_size <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> headFisrt <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pFin <span class="token operator">=</span> headFisrt<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pFin<span class="token operator">-></span>p_next_one <span class="token operator">=</span> headFisrt<span class="token punctuation">;</span>headFisrt<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> pFin<span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pFinal <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pPrior <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>pFinal<span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> tempFin <span class="token operator">=</span> pFinal<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pFinal<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pPrior<span class="token punctuation">;</span>pPrior <span class="token operator">=</span> pFinal<span class="token punctuation">;</span>pFinal <span class="token operator">=</span> tempFin<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>list<span class="token operator">-></span>Head <span class="token operator">=</span> pPrior<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// to merge two linklist into the one</span><span class="token comment">// use in this way:mergeLinkList(list_be_added, list_adder, whether_copied)</span><span class="token comment">//</span>Classic_DataList<span class="token operator">*</span> <span class="token function">mergeLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list_be_added<span class="token punctuation">,</span> Classic_DataList<span class="token operator">*</span>list_adder<span class="token punctuation">,</span> <span class="token class-name">size_t</span>whether_copied<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list_be_added <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> list_adder <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur<span class="token operator">=</span>list_be_added<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list_be_added<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Do not copy , instead just merge!</span><span class="token keyword">if</span> <span class="token punctuation">(</span>whether_copied<span class="token operator">==</span>ClassicLinkList_NO_COPY<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> list_adder<span class="token operator">-></span>Head<span class="token punctuation">;</span>list_be_added<span class="token operator">-></span>current_size <span class="token operator">+=</span> list_adder<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> list_be_added<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pAdder <span class="token operator">=</span> list_adder<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list_adder<span class="token operator">-></span>current_size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//prepare the space</span>Classic_DataNode<span class="token operator">*</span> pCopy <span class="token operator">=</span> <span class="token punctuation">(</span>Classic_DataNode<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Classic_DataNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span><span class="token operator">*</span> dataCopy <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>pAdder<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pCopy <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> dataCopy <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Using to copy data and initialize the copied node</span><span class="token function">memcpy</span><span class="token punctuation">(</span>dataCopy<span class="token punctuation">,</span> pAdder<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pAdder<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pCopy<span class="token operator">-></span>data <span class="token operator">=</span> dataCopy<span class="token punctuation">;</span>pCopy<span class="token operator">-></span>p_next_one <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//then push back into the linklist</span>pCur<span class="token operator">-></span>p_next_one <span class="token operator">=</span> pCopy<span class="token punctuation">;</span><span class="token comment">//Moving the copy pointer</span>pAdder <span class="token operator">=</span> pAdder<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>list_be_added<span class="token operator">-></span>current_size <span class="token operator">+=</span> list_adder<span class="token operator">-></span>current_size<span class="token punctuation">;</span><span class="token keyword">return</span> list_be_added<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// About ClassicLinkList</span><span class="token comment">// sort the classicLinklist in the bobblesort</span><span class="token comment">// use in this way:sortClassicLinkListinBubbleSort(Classic_DataList* list, CompareFunc user_func) </span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">sortClassicLinkListinBubbleSort</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span>list<span class="token punctuation">,</span> CompareFuncuser_func<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>user_func <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>list<span class="token operator">-></span>current_size<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//this two for loops are just standard BobbleSort</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">user_func</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">,</span> pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">void</span><span class="token operator">*</span> tempdata <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>tempdata<span class="token punctuation">,</span> pCur<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> tempdatasize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Before Swap,make sure that the dataContainer is huge enough to contain a new space</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">void</span><span class="token operator">*</span> pTempSwap <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pTempSwap <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_ERROR_IN_MALLOCING_SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>pCur<span class="token operator">-></span>data <span class="token operator">=</span> pTempSwap<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Copy and swap</span><span class="token function">memcpy</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>data<span class="token punctuation">,</span> pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memcpy</span><span class="token punctuation">(</span>pCur<span class="token operator">-></span>p_next_one<span class="token operator">-></span>data<span class="token punctuation">,</span> tempdata<span class="token punctuation">,</span> tempdatasize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//Moving pointer to the next one</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="消除链表"><a href="#消除链表" class="headerlink" title="消除链表"></a>消除链表</h2><p>​        可以看作一个区域删除的扩展</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//----------------------------------------------------Basic_Erase------------------------------</span><span class="token comment">// </span><span class="token comment">// 1.Erase A LinkList</span><span class="token comment">// used in just clear a linklist</span><span class="token comment">// func1: clearAClassicLinkList</span><span class="token comment">// </span><span class="token comment">// input : just a classiclinklist</span><span class="token comment">// output: the statues of normal ,can be used in check or just ignore!</span><span class="token comment">// </span><span class="token comment">// --------------------------------------------------------------------------------------------</span><span class="token comment">//About ClassicLinkList</span><span class="token comment">// Erase a classicLinkList</span><span class="token comment">// Use in this way clearAClassicLinkList( list)</span><span class="token comment">//</span>ClassicLinkListFunctionStatues <span class="token function">clearAClassicLinkList</span><span class="token punctuation">(</span>Classic_DataList<span class="token operator">*</span> list<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>SHOW_ERROR_ClassicLinkList_NULL_INPUT<span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span>ClassicLinkList_NULL_INPUT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Classic_DataNode<span class="token operator">*</span> pCur <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span>Classic_DataNode<span class="token operator">*</span> pDel <span class="token operator">=</span> list<span class="token operator">-></span>Head<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token operator">-></span>current_size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token operator">-></span>current_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">free</span><span class="token punctuation">(</span>pDel<span class="token punctuation">)</span><span class="token punctuation">;</span>pDel <span class="token operator">=</span> pCur<span class="token punctuation">;</span>pCur <span class="token operator">=</span> pCur<span class="token operator">-></span>p_next_one<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>list<span class="token operator">-></span>current_size <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span><span class="token keyword">return</span> ClassicLinkList_NORMAL<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试文档"><a href="#测试文档" class="headerlink" title="测试文档"></a>测试文档</h2><p>​        可以把这几个头文件和源文件添加到工程测试：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_CRT_SECURE_NO_WARNINGS</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"ClassicLinkList.h"</span></span>MyPrint <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>Do_Specific_Change <span class="token function">dochange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>e <span class="token operator">=</span> <span class="token operator">*</span>e <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>LocateFunc <span class="token function">loc</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> e1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">*</span>e1 <span class="token operator">==</span> <span class="token operator">*</span>e2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>CompareFunc <span class="token function">comp</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> e1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">*</span> e2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">*</span>e1 <span class="token operator">&lt;</span> <span class="token operator">*</span>e2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//do test initailization</span><span class="token comment">//default init</span>Classic_DataList<span class="token operator">*</span> defaultinit <span class="token operator">=</span> <span class="token function">Init_A_ClassicLinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//updata init</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Classic_DataList<span class="token operator">*</span> update_one <span class="token operator">=</span> <span class="token function">UpdateStaticArray2ClassicLinkList</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> Dyarr_SIGINT<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>update_one<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// copy init</span>Classic_DataList<span class="token operator">*</span> copy_one <span class="token operator">=</span> <span class="token function">Init_A_ClassicLinkList_By_CopyAClassicLinkList</span><span class="token punctuation">(</span>update_one<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nThouth , this is the copy one:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Push back </span><span class="token keyword">int</span> addersig <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nFirst push:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Push_Back_Into_A_ClassicLinkList</span><span class="token punctuation">(</span>defaultinit<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addersig<span class="token punctuation">,</span> Dyarr_SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>defaultinit<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nSecond push:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Push_Back_Into_A_ClassicLinkList</span><span class="token punctuation">(</span>defaultinit<span class="token punctuation">,</span> <span class="token operator">&amp;</span>addersig<span class="token punctuation">,</span> Dyarr_SIGINT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>defaultinit<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Push back a sum</span><span class="token keyword">int</span> adderarr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">101</span><span class="token punctuation">,</span><span class="token number">102</span><span class="token punctuation">,</span><span class="token number">103</span><span class="token punctuation">,</span><span class="token number">104</span><span class="token punctuation">,</span><span class="token number">105</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">push_Back_BunchDataintoClassicLinkList</span><span class="token punctuation">(</span>defaultinit<span class="token punctuation">,</span> adderarr<span class="token punctuation">,</span> Dyarr_SIGINT<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>defaultinit<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Insert start:</span><span class="token keyword">int</span> insertionsig <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">//to the head:</span><span class="token function">Insert_into_AClassicLinkList</span><span class="token punctuation">(</span>defaultinit<span class="token punctuation">,</span> <span class="token operator">&amp;</span>insertionsig<span class="token punctuation">,</span> Dyarr_SIGINT<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>defaultinit<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//to other place</span><span class="token function">Insert_into_AClassicLinkList</span><span class="token punctuation">(</span>defaultinit<span class="token punctuation">,</span> <span class="token operator">&amp;</span>insertionsig<span class="token punctuation">,</span> Dyarr_SIGINT<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>defaultinit<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//for a bunch ...</span><span class="token comment">//head</span><span class="token keyword">int</span> insertarr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">Insert_A_Bunch_of_data_intoClassicLinkList</span><span class="token punctuation">(</span>update_one<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> insertarr<span class="token punctuation">,</span> Dyarr_SIGINT<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>update_one<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//other place</span><span class="token function">Insert_A_Bunch_of_data_intoClassicLinkList</span><span class="token punctuation">(</span>update_one<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> insertarr<span class="token punctuation">,</span> Dyarr_SIGINT<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>update_one<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Erase </span><span class="token function">eraseAElementfromDataList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">eraseAElementfromDataList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Erase bunch</span><span class="token function">eraseAbunchData_inDataList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//make change:</span><span class="token comment">//sig</span><span class="token function">doChangetoSpecificElementinLinkList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> dochange<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//interval</span><span class="token function">doChangetoTargetIntervalDatainLinkList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> dochange<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//all</span><span class="token function">doChangetoAllDatainLinkList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> dochange<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>copy_one<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//check if in</span>Classic_DataList<span class="token operator">*</span> checkerlist <span class="token operator">=</span> <span class="token function">UpdateStaticArray2ClassicLinkList</span><span class="token punctuation">(</span>insertarr<span class="token punctuation">,</span> Dyarr_SIGINT<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> wannafind <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"So is it null?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEmptyClassicLinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nNot null sir!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">checkIsLocateinLinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wannafind<span class="token punctuation">,</span> loc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"yes, there is a num that is -1\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"and it is on the place: %d\n"</span><span class="token punctuation">,</span> <span class="token function">returnOutDatabyposinLinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wannafind<span class="token punctuation">,</span> loc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> wannafind2 <span class="token operator">=</span> wannafind <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"and also there is -2 too, it is in: %d\n"</span><span class="token punctuation">,</span> <span class="token function">returnOutDatabyposinLinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wannafind2<span class="token punctuation">,</span> loc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I can also make a change in this way directly:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">doChangetoSpecificElementinLinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">,</span> <span class="token function">returnOutDatabyposinLinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wannafind2<span class="token punctuation">,</span> loc<span class="token punctuation">)</span><span class="token punctuation">,</span> dochange<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//find bunch </span>Position_Stored_Dynamic_ArrayFordyarr<span class="token operator">*</span> posarr <span class="token operator">=</span> <span class="token function">Init_A_Postion_Stored_Dynamic_ArrayFordyarr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">returnAbunchLocationsinLinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">,</span> posarr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wannafind<span class="token punctuation">,</span> loc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Show_All_Locations_In_PSDAfor_dyarr</span><span class="token punctuation">(</span>posarr<span class="token punctuation">,</span> PSDA_dyarr_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//reverse</span><span class="token function">ReverseLinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Sort</span><span class="token function">sortClassicLinkListinBubbleSort</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Del</span><span class="token function">clearAClassicLinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Print_All_Data_LinkList</span><span class="token punctuation">(</span>checkerlist<span class="token punctuation">,</span> print<span class="token punctuation">,</span> ClassicLinkList_OPEN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> MyTinyLibProject </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程 （8）</title>
      <link href="/2023/02/13/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%888%EF%BC%89/"/>
      <url>/2023/02/13/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%888%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="二重积分"><a href="#二重积分" class="headerlink" title="二重积分"></a>二重积分</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>​        他表示一个曲顶柱体的体积，现在把区间里的小区快切割一下</p><p><img src="image-20230213134721131.png" alt="image-20230213134721131"></p><p>​        现在朝上面做一个柱体，产生了一个微元体积</p><p><img src="image-20230213134825844.png" alt="image-20230213134825844"></p><p>​        现在对小区间求和：</p><script type="math/tex; mode=display">\lim\limits_{\lambda \rightarrow 0}\sum_{i=1}^n \Delta \sigma_i f(x_i,y_i)</script><p>​        这个$\lambda$每个小区域的大小。若这个的极限存在，那就有：</p><script type="math/tex; mode=display">\lim\limits_{\lambda \rightarrow 0}\sum_{i=1}^n \Delta \sigma_i f(x_i,y_i)=\iint_{D}f(x,y)d\sigma</script><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>​    1）</p><script type="math/tex; mode=display">\iint_D[\alpha f(x,y)+\beta g(x,y)]d\sigma=\alpha\iint_Df(x,y)d\sigma+\beta\iint_D g(x,y)d\sigma</script><p>​        2)如果$D = D_1+D_2$,然后就有</p><script type="math/tex; mode=display">\iint_D f(x,y)d\sigma = \iint_{D_1} f(x,y)d\sigma+\iint_{D_2} f(x,y)d\sigma</script><p>​        3)对于$f(x,y) \equiv 1$</p><script type="math/tex; mode=display">\iint_D 1 d\sigma =\sigma</script><p>​        4)$f(x,y)\leq g(x,y)$</p><script type="math/tex; mode=display">\iint_D f(x,y) d\sigma\leq \iint_D g(x,y) d\sigma</script><p>​        5)</p><script type="math/tex; mode=display">|\iint_Df(x,y)d\sigma|\leq \iint_D|f(x,y)|d\sigma</script><p>​        6)假设$m\leq f(x,y)\leq M$,</p><script type="math/tex; mode=display">m\sigma \leq \iint_Df(x,y)d\sigma \leq M\sigma</script><p>​        推广：</p><script type="math/tex; mode=display">f(\xi,y)=\frac{1}{\sigma}\iint_Df(x,y)d\sigma</script><h4 id="计算-直角坐标"><a href="#计算-直角坐标" class="headerlink" title="计算(直角坐标)"></a>计算(直角坐标)</h4><p><img src="image-20230213140515497.png" alt="image-20230213140515497"></p><p>​        </p><p>​        假设截面是这个</p><p><img src="image-20230213140555154.png" alt="image-20230213140555154"></p><p>​        于是，可以看作先对 y 再对 x做积分：</p><script type="math/tex; mode=display">V = \int_a^b[\int_{\varphi_1(x)}^{\varphi_2(x)}f(x,y)dy]dx</script><p>于是：</p><p>例题1：</p><p>​        $\iint_D xyd\sigma,y=1,x=2,y=x$</p><p>​        原式=$\int_1^2\int_{1}^{x}xydydx=\int_1^2x[\frac{y^2}{2}|_1^x]dx=\int_1^2{x(\frac{x^2}{2}-\frac{1}{2})}=\frac{x^4}{8}-\frac{x^2}{4}|_1^2=\frac{9}{8}$</p><p>​        我们也有先对X再对Y做积分：</p><script type="math/tex; mode=display">=\int_1^2dy\int_y^2 f(x,y)dx</script><p>​        注意，对于Y，左边是下限，右边是上限</p><p>例题2：</p><p>$\iint_D y\sqrt{1+x^2-y^2}d\sigma,D:y=x,x=-1,y=1$</p><p>法一：$\int_{-1}^1dx\int_{x}^{1}y\sqrt{1+x^2-y^2}dy=0.5$</p><p>法二：$\int_{-1}^1dy\int_{-1}^{y}y\sqrt{1+x^2-y^2}dx$</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        对于积分区域是长方形的：</p><script type="math/tex; mode=display">\int_a^bdx\int_c^d f(x,y)dy = \int_c^ddy\int_a^b f(x,y)dx</script><p><img src="image-20230213141904801.png" alt="image-20230213141904801"></p><p>​        对于积分区域是长方形的，且<code>f(x,y)</code>=$f_1(x)f_2(x)$</p><script type="math/tex; mode=display">\int_a^bdx\int_c^df_1(x)f_2(y)dy=\int_a^bf_1(x)dx\cdot\int_C^df_2(x)dy</script><h4 id="计算（极坐标）"><a href="#计算（极坐标）" class="headerlink" title="计算（极坐标）"></a>计算（极坐标）</h4><p>​        主要应用在曲线（圆类）比较多</p><p><img src="image-20230213142436470.png" alt="image-20230213142436470"></p><p>​        </p><p><img src="image-20230213142548063.png" alt="image-20230213142548063"></p><p>​        于是：</p><script type="math/tex; mode=display">\iint_D f(x,y)d\sigma = \iint_D \rho f(\rho\cos\theta,\rho\sin\theta) d\rho d\theta</script><p>​        小心不要丢掉$\rho$!</p><p>如：</p><p>例题:$\iint_D e^{-x^2-y^2}dxdy$</p><p>​        做代换，得到：</p><script type="math/tex; mode=display">\int_0^{2\pi}d\theta\int_0^ae^{-\rho^2}\rho d\rho = \pi(1-e^{-a^2})</script><h4 id="一个重要的推论："><a href="#一个重要的推论：" class="headerlink" title="一个重要的推论："></a>一个重要的推论：</h4><p><img src="image-20230213143049432.png" alt="image-20230213143049432"></p><p>​        同时，作为长方形底面积式子：得到：</p><p><img src="image-20230213143210280.png" alt="image-20230213143210280"></p><script type="math/tex; mode=display">\frac{\pi}{4}(1-e^{-R^2})\leq(\int_0^Re^{-x^2}dx)^2\leq\frac{\pi}{4}(1-e^{-2R^2})</script><p>​        于是有一个著名的结论：</p><script type="math/tex; mode=display">\int_0^R e^{-x^2}dx=\frac{\sqrt \pi}{2}</script><p>例子：$\iint_D \arctan\frac{y}{x}dxdy$</p><p><img src="image-20230213143631579.png" alt="image-20230213143631579"></p><p>D见上图：</p><p>解答：=$\int_0^{\frac{\pi}{4}}d\theta \int_1^3 \arctan(\tan\theta)\rho d\rho=\int_0^{\frac{\pi}{4}}\theta\int_1^3\rho d\rho=\frac{\pi^2}{8}$</p><h4 id="二重积分的换元法"><a href="#二重积分的换元法" class="headerlink" title="二重积分的换元法"></a>二重积分的换元法</h4><p>​        首先可以有：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}x & = & \rho\cos(t) \\y & = & \rho\sin(t) \\\end{aligned}\right.\end{equation}</script><p>​        作为一个经典的变换！对于更一般的：</p><p>1)$x=x(u,v),y=y(u,v)$</p><p>2)$J_{(u,v)}=\frac{\partial (x,y)}{\partial (u,v)}$下：</p><script type="math/tex; mode=display">\iint_D f(x,y)dxdy=\iint_{D'}f(x(u,v),y(u,v))|J_{(u,v)}|</script><p>例题：$\iint_D e^{\frac{y-x}{y+x}}dxdy$</p><p><img src="image-20230213144715490.png" alt="image-20230213144715490"></p><p>令：$u=y-x,v=y+x$于是：</p><script type="math/tex; mode=display">x=\frac{v-u}{2},y=\frac{u+v}{2}</script><p><code>-&gt;</code></p><script type="math/tex; mode=display">x=0 \rightarrow v=u\\y=0 \rightarrow v=-u\\x+y=2\rightarrow v=2\\J=-0.5</script><script type="math/tex; mode=display">\iint_D e^{\frac{u}{v}}dudv=\frac{1}{2}\int_0^2dv\int_{-v}^{v}e^{\frac{u}{v}}du=e-e^{-1}</script><h2 id="三重积分"><a href="#三重积分" class="headerlink" title="三重积分"></a>三重积分</h2><p>​        定义：</p><script type="math/tex; mode=display">\lim\limits_{\lambda\rightarrow 0}\sum_{i=0}^{n}f(x_i,y_i,z_i)\Delta v_i =\iiint_\Omega f(x,y,z)dxdydz</script><p>​        可以理解为：将密度考虑成一个关于空间的函数即可，然后在原有空间上增加一个维度！</p><p>​        使用切丝法逐步切：</p><script type="math/tex; mode=display">\iiint_\Omega f(x,y,z)dxdydz= \int_{x_1}^{x_2}dx\int_{y(x_1)}^{y(x_2)}dy\int_{z(x_1,y_1)}^{z(x_2,y_2)}f(x,y,z)dz</script><p>例如：</p><p><img src="image-20230213150010068.png" alt="image-20230213150010068"></p><script type="math/tex; mode=display">=\iint_{D_ {xy} }[\int_0^{1-x-2y}xdz]dxdy=\int_0^1dx\int_0^{\frac{1-x}{2}}dy\int_0^{1-x-2y}xdz</script><p>例如：$\iiint_D z^2dxdydz$,$D:\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1$</p><script type="math/tex; mode=display">=\int_{-c}^{c}z^2dz\iint_{D_{xy} }dxdy</script><p>而长轴短轴的变化是：</p><script type="math/tex; mode=display">a' = a\sqrt{1-\frac{z^2}{c^2} },b' = b\sqrt{1-\frac{z^2}{c^2} }</script><p>故：因为椭圆的面试是$\pi a’b’$</p><script type="math/tex; mode=display">=\pi ab\int_{-c}^{c}z^2(1-\frac{z^2}{c^2})dz=\frac{4}{15}\pi abc^3</script><h3 id="柱面坐标"><a href="#柱面坐标" class="headerlink" title="柱面坐标"></a>柱面坐标</h3><p>​        使用：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}x & = & \rho\cos(t) \\y & = & \rho\sin(t) \\z & = & z\end{aligned}\right.\end{equation}</script><p>​        表达坐标的系统叫柱坐标系统！</p><p>​        </p><script type="math/tex; mode=display">dv=\rho d\rho d\theta dz</script><p>对于一个长方体：$a \leq x \leq b,c \leq x \leq d,e \leq x \leq f$且函数可以完全分离：</p><script type="math/tex; mode=display">\int_a^bf_1(x)dx\int_c^df_2(y)dy\int_e^ff_3(z)dz= \\(\int_a^bf_1(x)dx)\cdot(\int_c^df_2(y)dy)\cdot(\int_e^ff_3(z)dz)</script>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据结构模拟：动态数组的实现思路</title>
      <link href="/2023/02/12/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/"/>
      <url>/2023/02/12/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="动态数组API实现思路"><a href="#动态数组API实现思路" class="headerlink" title="动态数组API实现思路"></a>动态数组API实现思路</h1><h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><p>​        写这样一篇博客是因为大伙说看不大懂（大悲），强烈建议我写一份思路。所以重新整一篇思路篇，关于通用单链表的源码已经整完了，会在这篇文章出现的时候一并传上来</p><h2 id="结构本身"><a href="#结构本身" class="headerlink" title="结构本身"></a>结构本身</h2><p>​        动态数组不同于静态数组正是在动态数组可以实现动态的扩展，换而言之，它是在运行的时候动态的扩展数组而无需在编译阶段准备。这使得我们的程序更加具有灵活性！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;old oneint arr[255] &#x3D; &#123;1,2,3&#125;;&#x2F;&#x2F;这个时候会在栈上开辟1020个字节，注意，可会导致浪费，用户不一定需这么多——也可能需要的远远大于这么多<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">int* data &#x3D; NULL;&#x2F;&#x2F; ... do somethingdata &#x3D; (int*)malloc(MALLOCSIZE);&#x2F;&#x2F; ... do somethingdata &#x3D; (int*)realloc(data , NEWSIZE);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们的数组就是这样动态编译的——有趣的是，他本质上同数组没有区别！只不过一个合格的动态数组会自动判断访问是否合法与自动伸缩而已</p><p>​        为了达成这样的目的：我们维护以下几个信息</p><p>1）内存区域碎片 ： 就是裸数组本身，我们使用片区域存储东西</p><p>2）元素大小 ： 这个元素多大？我们的指针访问的步长是否可以覆盖到单个数据？</p><p>3）可以容纳的数组大小：使用这个来预防频繁的小量的存储与删除</p><p>4）当前元素的个数 ：这个来判断你的访问是不是合法的！</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>1）增加</p><p>​        动态数组一般只可以追加，但是我们可以使用元素后挪的方式来实现插入</p><p>2）查找</p><p>​        还记得静态数组如何查找吗？我们当然可以使用静态数组一样的方式进行查找</p><p>3）删除</p><p>​        对于尾删，我们可以直接让当前元素数据减1就好了，下次的增加读写可以直接实现覆盖！可以使用元素前移删除指定位置的擦除！</p><p>4）改动</p><p>​        还是涉及到根本访问！不再赘述。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>​        1.C语言 上必须传入一个结构体对当前结构体进行改变，于是要检查是否为空！</p><p>​        2.注意涉及到数据时建议拷贝一份而不是指针直接托管，否则容易陷入一个指针Free了这个内存块，而另一个指针仍有权限访问这个内存地址！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> MyTinyLibProject </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据结构模拟（2）：经典单链表头文件-源代码-测试</title>
      <link href="/2023/02/11/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/02/11/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="API一览"><a href="#API一览" class="headerlink" title="API一览"></a>API一览</h1><p>1.头文件：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">define _CRT_SECURE_NO_WARNINGS 1#defineOPENUPPOSARR 1#define OPENUPDEFAULTSIZE 1#define OPENQUICKMALLOC 1&#x2F;&#x2F;(General Version)#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;&#x2F;&#x2F;Error Code Meaning&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0&#x2F;&#x2F;When Error in mallocing Space the program return 1&#x2F;&#x2F;when inputing a NULL we returns -1&#x2F;&#x2F;when inputing a invalid input we returns -2&#x2F;&#x2F;Locations UnFind we returns -3 typedef enum _ClassicLinkListFunctionStatues_ &#123;ClassicLinkList_NORMAL &#x3D; 0,ClassicLinkList_ERROR_IN_MALLOCING_SPACE &#x3D; 1,ClassicLinkList_NULL_INPUT &#x3D; -1,ClassicLinkList_Invalid_Input &#x3D; -2,ClassicLinkList_UnFind &#x3D; -3,ClassicLinkList_Invalid_Free &#x3D; -4,&#125;ClassicLinkListFunctionStatues;&#x2F;&#x2F;MyBool Defined here!&#x2F;&#x2F;typedef enum _bool_ &#123;True &#x3D; 1,False &#x3D; 0&#125;Bool;&#x2F;&#x2F;This is some abstractions using in reminding you some basic informations and errors!&#x2F;&#x2F;#define SHOW_ERROR_ClassicLinkList_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)#define SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)#define SHOW_ERROR_ClassicLinkList_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)#define SHOW_ERROR_ClassicLinkList_UnFind printf(&quot;\nPositions unfind!\n&quot;)#define SHOW_ERROR_ClassicLinkList_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)#define SHOW_WARNING_ClassicLinkList_SWAPPED_POS printf(&quot;Warning! the front_pos is bigger then the final pos\n Do you agreed swap them?&quot;)#define SHOW_WARNING_ClassicLinkList_OVERLAP_POS printf(&quot;Considered as your insertion_input is overlapped!\n set pos as the cur_size?&quot;)&#x2F;&#x2F;this abstractions is used to define the aquisition of whether the program&#39;s decison is acceptable,&#x2F;&#x2F;X is the message string!&#x2F;&#x2F;#define SHOW_WHETHER_ACCCEPTED(X) printf(X)&#x2F;&#x2F;If wanted flashed a newline you can use it! &#x2F;&#x2F;#define SLASHN printf(&quot;\n&quot;)&#x2F;&#x2F;used in MergeclassicLinkList&#x2F;&#x2F;If accepted copy �� Do write ClassicLinkList_ACCEPTED_COPY#define ClassicLinkList_ACCEPTED_COPY 1#define ClassicLinkList_NO_COPY0#define Unfind_ClassicLinkList -1&#x2F;&#x2F;Used in whether the targeted elements is found&#x2F;&#x2F;If is considered found, just use Find , otherwise unfind!typedef enum _ClassicLinkList_isFind_ &#123;Find &#x3D; 1,Unfind &#x3D; 0&#125;ClassicLinkList_isFind;&#x2F;&#x2F;Used in whether print data in ClassicLinkList better&#x2F;&#x2F;Use ClassicLinkList_OPEN if you want a better printtypedef enum _BetterPrintSwitch_for_ClassicLinkList_ &#123;ClassicLinkList_OPEN &#x3D; 1,ClassicLinkList_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_ClassicLinkList;&#x2F;&#x2F;-------------------------------------------Main_Define------------------------------------------&#x2F;&#x2F;Basic definitions of datanode, it can be considered as a node in a loop&#x2F;&#x2F;is consisted of dataPiece and the pointer to the next datanode&#x2F;&#x2F;UNLESS YOU ARE CONCIOUS ABOUT WHAT YOU ARE DOING! DO NOT CHANGE THE DATA DIRECTLY! typedef struct _Classic_DataNode_ &#123;void* data;struct _Classic_DataNode_* p_next_one;&#125;Classic_DataNode;&#x2F;&#x2F;basic definations of datalist , it can be considered as the loop or the main body of the data structure&#x2F;&#x2F;to better operate the data structure , it is consisted of Head pointer that pointed to the first data in the data struct&#x2F;&#x2F;as well as the current_size of the data structure&#x2F;&#x2F;UNLESS YOU ARE CONCIOUS ABOUT WHAT YOU ARE DOING! DO NOT CHANGE THE DATA DIRECTLY! typedef struct _Classic_DataList_ &#123;Classic_DataNode* Head;size_t current_size;&#125;Classic_DataList;&#x2F;&#x2F;this type of int is used to mark the returnType of the compare functionstypedef unsigned int Is_Used_Compared_Int;typedef void(*MyPrint)(void*);typedef void* (*Do_Specific_Change)(void*);typedef Is_Used_Compared_Int(*CompareFunc)(void*, void*);typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);&#x2F;&#x2F;--------------------Default_size_Type---------------------------------------------#if OPENUPDEFAULTSIZE#define Dyarr_SIGINT sizeof(int)#define Dyarr_SIGCHAR sizeof(char)#define Dyarr_SIGFLOAT sizeof(float)#define Dyarr_SIGDOUBLE sizeof(double)#define Dyarr_SIG(dataType) sizeof(dataType)#define Dyarr_INT_SIZE(X) sizeof(int)*X#define Dyarr_CHAR_SIZE(X) sizeof(char)*X#define Dyarr_FLOAT_SIZE(X) sizeof(float)*X#define Dyarr_DOUBLE_SIZE(X) sizeof(double)*X#define Dyarr_TYPE_SIZE(dataType,X) sizeof(dataType)*X#endif&#x2F;&#x2F;-------------------------------QuickMalloc----------------------------------------------------#if OPENQUICKMALLOC#define MALLOC(type) (type*)malloc(sizeof(type))#define MALLOCN(type,ElemNum) (type*)malloc(sizeof(type)*ElemNum)#endif&#x2F;&#x2F;-----------------------Position_Stored_Dynamic_Array_For_Dyarr---------------------------------&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;Used in returning multitude locations#if OPENUPPOSARR&#x2F;&#x2F;Main data structure!&#x2F;&#x2F;Used in returning multitude locationstypedef struct _Dyarrposarr_ &#123;int* posSpace;size_t pos_size;&#125;Position_Stored_Dynamic_ArrayFordyarr;&#x2F;&#x2F;Want a better Print to beutify your control table? try this onetypedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;PSDA_dyarr_OPEN &#x3D; 1,PSDA_dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_pos_dyarr;&#x2F;&#x2F;can use this type when indicating the typetypedef unsigned int BetterPrintfor_PosDyarr;&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;ClassicLinkListFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(Position_Stored_Dynamic_ArrayFordyarr* posarr,BetterPrintfor_PosDyarrWhether_Better_Print);&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F; push back a pos into the dynamic array&#x2F;&#x2F;ClassicLinkListFunctionStatues Push_back_a_locations_in_PSDA_dyarr(Position_Stored_Dynamic_ArrayFordyarr* posarr,intpos_acquired);&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to return the number of locations&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSEsize_t Get_pos_size_From_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr* posarr,BetterPrintfor_PosDyarrWhether_Shown_Print);&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;return a pos that is targeted!&#x2F;&#x2F;void* getPosbyPosinPSDA(Position_Stored_Dynamic_ArrayFordyarr* getter,size_tpos);&#x2F;&#x2F;About Positions_Stored_Dynamic_ArrayClassicLinkListFunctionStatues DesTroy_A_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr* pointer_to_wishedfreeposarr);#endif &#x2F;&#x2F; OPENUPPOSARR&#x2F;&#x2F;-----------------------------About ClassicLinkList-----------------------------------------------------&#x2F;&#x2F;----------------------------Init-functions-------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; there are three basic type of initialization&#x2F;&#x2F; &#x2F;&#x2F; -----------------------------------------------------------------------------------------------------&#x2F;&#x2F; 1.includeing the default type (init a NULL head and zero cur_size)&#x2F;&#x2F; func1: Classic_DataList* Init_A_ClassicLinkList()&#x2F;&#x2F; &#x2F;&#x2F; No input , or input VOID&#x2F;&#x2F; have output : output a clssicLinklist pointer&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; 2.includeing the copy one (init the same type of the be-copied one)&#x2F;&#x2F; func2: Classic_DataList* Init_A_ClassicLinkList_By_CopyAClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : a required_be_copied list .&#x2F;&#x2F; output: a new list but have is the same as the be_copied list&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; 3.includeing to transform the static array to the linklist one&#x2F;&#x2F; func3: Classic_DataList* UpdateStaticArray2ClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : a waited_transformed static_array , the element size which is in the static array &#x2F;&#x2F; output: a new pointer that points to classicLinkList&#x2F;&#x2F; &#x2F;&#x2F; &#x2F;&#x2F;----------------------------Init-functions-------------------------------------------------------------&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; This function is used to init a default type of classicLinkList&#x2F;&#x2F; that the head of dataPiece is NULL and the cur_size is zero.&#x2F;&#x2F; Use push back to init the dataPiece&#x2F;&#x2F; use in this Way: &#x2F;&#x2F; Classic_DataList* List &#x3D; Init_A_ClassicLinkList();&#x2F;&#x2F;Classic_DataList* Init_A_ClassicLinkList();&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to copy an already exited linklist&#x2F;&#x2F; Classic_DataList* List &#x3D; Init_A_ClassicLinkList_By_CopyAClassicLinkList(Classic_DataList* list) &#x2F;&#x2F;Classic_DataList* Init_A_ClassicLinkList_By_CopyAClassicLinkList(Classic_DataList* list);&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to updata a static array into a ClassicLinkList&#x2F;&#x2F; Classic_DataList* List &#x3D; UpdateStaticArray2ClassicLinkList(&#x2F;&#x2F; void* inputArray, &#x2F;&#x2F; size_t dataSize, &#x2F;&#x2F; size_t dataNum&#x2F;&#x2F; )&#x2F;&#x2F;Classic_DataList* UpdateStaticArray2ClassicLinkList(void* inputArray,size_tdataSize,size_tdataNum);&#x2F;&#x2F;----------------------------------------Basic_Add_Functions--------------------------------------------&#x2F;&#x2F; there are four basic input functions:&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; 1. push back an element into the classicLinkList&#x2F;&#x2F; func1 : ClassicLinkListFunctionStatues Push_Back_Into_A_ClassicLinkList&#x2F;&#x2F;&#x2F;&#x2F; input : the inserted list ,the data wanted to be inserted and the inserted datasize&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 2. insert back an element into the classicLinkList by offering a valid pos&#x2F;&#x2F; func2 : ClassicLinkListFunctionStatues Insert_into_AClassicLinkList(Classic_DataList* list, void* data,size_t dataSize,size_t pos)&#x2F;&#x2F; &#x2F;&#x2F; &#x2F;&#x2F; input : the inserted list , the data ,the datasize as well as the position you wanted to insert&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 3. push back a bunch of data into the classicLinkList like the first function&#x2F;&#x2F; func3 :ClassicLinkListFunctionStatues push_Back_BunchDataintoClassicLinkList(Classic_DataList* list,void* inputArray,size_t sigElemSize,size_t arrayNum)&#x2F;&#x2F; &#x2F;&#x2F; input : the inserted list , the data ,the datasize as well as the position you wanted to insert&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; 4. insert back a bunch of data into the classicLinkList like the second function&#x2F;&#x2F; func4: ClassicLinkListFunctionStatues Insert_A_Bunch_of_data_intoClassicLinkList&#x2F;&#x2F;&#x2F;&#x2F; input : the inserted list , the static array ,the datasize in the static array as well as the position you wanted to insert&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore! &#x2F;&#x2F; &#x2F;&#x2F;----------------------------------------Basic_Add_Functions--------------------------------------------&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; push back some data ,like dynamic array , into the final position&#x2F;&#x2F;Used like this Push_Back_Into_A_ClassicLinkList(appendedClassicLinkList, data ,sizeof(data))&#x2F;&#x2F;ClassicLinkListFunctionStatues Push_Back_Into_A_ClassicLinkList(Classic_DataList* list,void* data,size_tdatasize);&#x2F;&#x2F; About ClassicDataList&#x2F;&#x2F; insert back a data into the datalist&#x2F;&#x2F; used like this: Insert_into_AClassicLinkList(inserted list, input data,dataSize,insertion_pos)&#x2F;&#x2F; ClassicLinkListFunctionStatues Insert_into_AClassicLinkList(Classic_DataList* list,void* data,size_tdataSize,size_tpos);&#x2F;&#x2F; About ClassicDataList&#x2F;&#x2F; push back a bunch data into the datalist&#x2F;&#x2F; used like this : push_Back_BunchDataintoClassicLinkList( inserted_list , the static array ,the elementsize ,the element num)&#x2F;&#x2F;ClassicLinkListFunctionStatues push_Back_BunchDataintoClassicLinkList(Classic_DataList* list,void* inputArray,size_tsigElemSize,size_tarrayNum);&#x2F;&#x2F; About ClassicDataList&#x2F;&#x2F; insert back a bunch of data into the datalist&#x2F;&#x2F; used like this: Insert_into_AClassicLinkList(inserted list, insertion_pos,input array ,Single dataSize, the amount of elements)&#x2F;&#x2F; ClassicLinkListFunctionStatues Insert_A_Bunch_of_data_intoClassicLinkList(Classic_DataList* list,size_tpos,void* inputArray,size_tsigElemSize,size_tarrayNum);&#x2F;&#x2F;------------------------------------------Deletion_Functions-------------------------------------------&#x2F;&#x2F; there are two basic type of functions in the sections&#x2F;&#x2F; 1. Erase a targeted element and erase it from the ClassicDataList&#x2F;&#x2F; fun1:eraseAElementfromDataList&#x2F;&#x2F; &#x2F;&#x2F; input : the list and the erase position&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 2.Erase some target elements from the ClassicDataList&#x2F;&#x2F; fun2:eraseAbunchData&#x2F;&#x2F; &#x2F;&#x2F; input: the list and the start position as well as the last position, that means offer a paired pos&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F;------------------------------------------Deletion_Functions-------------------------------------------&#x2F;&#x2F; About ClassicDataList&#x2F;&#x2F; delete a  data in the datalist by offering a position&#x2F;&#x2F;used like this: eraseAElementfromDataList(list, erasing_pos)&#x2F;&#x2F;ClassicLinkListFunctionStatues eraseAElementfromDataList(Classic_DataList* list,size_tpos);&#x2F;&#x2F; About ClassicDataList&#x2F;&#x2F; delete a bunch of data in the datalist&#x2F;&#x2F; used like this eraseAbunchData( list,  front_pos,  final_pos)&#x2F;&#x2F;ClassicLinkListFunctionStatues eraseAbunchData_inDataList(Classic_DataList* list,size_tfront_pos,size_tfinal_pos);&#x2F;&#x2F;----------------------------------------check_if_element_existed_functions-----------------------------&#x2F;&#x2F; there are four functions in this sections&#x2F;&#x2F; &#x2F;&#x2F; 1.check if the classiclinklist is empty&#x2F;&#x2F; fun1: isEmptyClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input :the checked list&#x2F;&#x2F; output: My defined bool(Sadly the org C doesn&#39;t define that)&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 2. check if the target elements is exsited in the datalist&#x2F;&#x2F; fun2: checkIsLocateinLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : the checked list ,the searched data and the Compared functions&#x2F;&#x2F; output: the locations that we first found it&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 3. return out the first locations that we found of the target elements&#x2F;&#x2F; func3:checkIsLocateinLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : the checked list ,the searched data and the Compared functions&#x2F;&#x2F; output: My defined bool(Sadly the org C doesn&#39;t define that)&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; Warning : this functions required the PSDA abstractions is opened so you can use Position_Stored_Dynamic_ArrayFordyarr*&#x2F;&#x2F; to get the position&#x2F;&#x2F; &#x2F;&#x2F; 4. return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr&#x2F;&#x2F; fun4:returnAbunchLocationsinLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : the checked list , the Position_Stored_Dynamic_ArrayFordyarr*(required init first)&#x2F;&#x2F; output: the Position_Stored_Dynamic_ArrayFordyarr that stored the positions!&#x2F;&#x2F;&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; check if the LinkList is empty&#x2F;&#x2F;Bool isEmptyClassicLinkList(Classic_DataList* list);&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; check if the target elements is exsited in the datalist&#x2F;&#x2F;Bool checkIsLocateinLinkList(Classic_DataList* list,void* data,LocateFuncuser_func);&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; return out the first locations that we found of the target elements&#x2F;&#x2F; can use in this way: size_t pos &#x3D; returnOutDatabyposinLinkList( list, data, user_func)size_t returnOutDatabyposinLinkList(Classic_DataList* list,void* data,LocateFuncuser_func);#if OPENUPPOSARR&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr&#x2F;&#x2F; can use in this way: Position_Stored_Dynamic_ArrayFordyarr* somePos &#x3D; &#x2F;&#x2F; returnAbunchLocationsinLinkList( list,  posArr,  data,  user_func)&#x2F;&#x2F;Position_Stored_Dynamic_ArrayFordyarr* returnAbunchLocationsinLinkList(Classic_DataList* list,Position_Stored_Dynamic_ArrayFordyarr* posArr,void* data,LocateFuncuser_func);#endif &#x2F;&#x2F;---------------------------------------Do_Something_to_the_datalist_functions--------------------------&#x2F;&#x2F; there are seven functions in this sections&#x2F;&#x2F; &#x2F;&#x2F; 1. Classic Print functions&#x2F;&#x2F; func1: Print_All_Data_LinkList&#x2F;&#x2F; to print all the data in the user_defined linklist&#x2F;&#x2F; &#x2F;&#x2F; input : list and the user print , and the decision whether enjoyed a better print&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 2. Do some change to the specific data&#x2F;&#x2F; to make some change directly to an element&#x2F;&#x2F; &#x2F;&#x2F; input : the list ,the targeted positions and the way how you want to operate the data itself&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 3. Do some change to all the data in the classiclinklist&#x2F;&#x2F; to make some change directly to the whole elements&#x2F;&#x2F; &#x2F;&#x2F; input : the list ,the way how you want to operate the data itself&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 4. Do specific change to an interval pos in the classicLickList&#x2F;&#x2F; to make some change directly to the interval elements&#x2F;&#x2F; &#x2F;&#x2F; input : the list ,the front_pos and the final_pos&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 5. reverse ClassicLinkList&#x2F;&#x2F; to reverse up the classic LinkList&#x2F;&#x2F; &#x2F;&#x2F; input : the ready_reversed data&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 6. combine two linkList into one&#x2F;&#x2F; to combine the two classic linklist into one!&#x2F;&#x2F; &#x2F;&#x2F; input : the two linklist&#x2F;&#x2F; output: the merged linklist Pointer&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 7. sort the elements in the classicLinkList under the user&#39;s constructions&#x2F;&#x2F; to sort the ClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : the classicLinklist&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F;&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to print the data&#x2F;&#x2F; use in this way: Print_All_Data_LinkList( list, user_print,  whether_better_print)&#x2F;&#x2F;ClassicLinkListFunctionStatues Print_All_Data_LinkList(Classic_DataList* list,MyPrintuser_print,BetterPrintSwitch_for_ClassicLinkListwhether_better_print);&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to make some change to the specific data&#x2F;&#x2F; use in this way:doChangetoSpecificElementinLinkList( list,  pos , user_func)&#x2F;&#x2F;ClassicLinkListFunctionStatues doChangetoSpecificElementinLinkList(Classic_DataList* list,size_tpos,Do_Specific_Changeuser_func);&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to make some change to the interval data&#x2F;&#x2F; use in this way:doChangetoTargetIntervalDatainLinkList(list , pos1,pos2, user_func)&#x2F;&#x2F;ClassicLinkListFunctionStatues doChangetoTargetIntervalDatainLinkList(Classic_DataList* list,size_tfront_pos,size_tfinal_pos,Do_Specific_Changeuser_func);&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to make some change to the whole elements in the data&#x2F;&#x2F; use in this way:doChangetoAllDatainLinkList( list,  user_func)&#x2F;&#x2F;ClassicLinkListFunctionStatues doChangetoAllDatainLinkList(Classic_DataList* list,Do_Specific_Changeuser_func);&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to reverse up the classiclinklist&#x2F;&#x2F; use in this way:ReverseLinkList(list)&#x2F;&#x2F;ClassicLinkListFunctionStatues ReverseLinkList(Classic_DataList* list);&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to merge two linklist into the one&#x2F;&#x2F; use in this way:mergeLinkList(list_be_added, list_adder, whether_copied)&#x2F;&#x2F;Classic_DataList* mergeLinkList(Classic_DataList* list_be_added,Classic_DataList* list_adder,size_twhether_copied);&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; sort the classicLinklist in the bobblesort&#x2F;&#x2F; use in this way:sortClassicLinkListinBubbleSort(Classic_DataList* list, CompareFunc user_func) &#x2F;&#x2F;ClassicLinkListFunctionStatues sortClassicLinkListinBubbleSort(Classic_DataList* list,CompareFuncuser_func);&#x2F;&#x2F;----------------------------------------------------Basic_Erase----------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 1.Erase A LinkList&#x2F;&#x2F; used in just clear a linklist&#x2F;&#x2F; func1: clearAClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : just a classiclinklist&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------&#x2F;&#x2F;About ClassicLinkList&#x2F;&#x2F; Erase a classicLinkList&#x2F;&#x2F; Use in this way clearAClassicLinkList( list)&#x2F;&#x2F;ClassicLinkListFunctionStatues clearAClassicLinkList(Classic_DataList* list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>源文件：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1#defineOPENUPPOSARR 1#define OPENUPDEFAULTSIZE 1#define OPENQUICKMALLOC 1&#x2F;&#x2F;(General Version)#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;&#x2F;&#x2F;Error Code Meaning&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0&#x2F;&#x2F;When Error in mallocing Space the program return 1&#x2F;&#x2F;when inputing a NULL we returns -1&#x2F;&#x2F;when inputing a invalid input we returns -2&#x2F;&#x2F;Locations UnFind we returns -3 typedef enum _ClassicLinkListFunctionStatues_ &#123;ClassicLinkList_NORMAL&#x3D;0,ClassicLinkList_ERROR_IN_MALLOCING_SPACE &#x3D; 1,ClassicLinkList_NULL_INPUT &#x3D; -1,ClassicLinkList_Invalid_Input&#x3D;-2,ClassicLinkList_UnFind&#x3D;-3,ClassicLinkList_Invalid_Free&#x3D;-4,&#125;ClassicLinkListFunctionStatues;&#x2F;&#x2F;MyBool Defined here!&#x2F;&#x2F;typedef enum _bool_ &#123;True &#x3D; 1,False &#x3D; 0&#125;Bool;&#x2F;&#x2F;This is some abstractions using in reminding you some basic informations and errors!&#x2F;&#x2F;#define SHOW_ERROR_ClassicLinkList_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)#define SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)#define SHOW_ERROR_ClassicLinkList_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)#define SHOW_ERROR_ClassicLinkList_UnFind printf(&quot;\nPositions unfind!\n&quot;)#define SHOW_ERROR_ClassicLinkList_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)#define SHOW_WARNING_ClassicLinkList_SWAPPED_POS printf(&quot;Warning! the front_pos is bigger then the final pos\n Do you agreed swap them?&quot;)#define SHOW_WARNING_ClassicLinkList_OVERLAP_POS printf(&quot;Considered as your insertion_input is overlapped!\n set pos as the cur_size?&quot;)&#x2F;&#x2F;this abstractions is used to define the aquisition of whether the program&#39;s decison is acceptable,&#x2F;&#x2F;X is the message string!&#x2F;&#x2F;#define SHOW_WHETHER_ACCCEPTED(X) printf(X)&#x2F;&#x2F;If wanted flashed a newline you can use it! &#x2F;&#x2F;#define SLASHN printf(&quot;\n&quot;)&#x2F;&#x2F;used in MergeclassicLinkList&#x2F;&#x2F;If accepted copy ！ Do write ClassicLinkList_ACCEPTED_COPY#define ClassicLinkList_ACCEPTED_COPY 1#define ClassicLinkList_NO_COPY0#define Unfind_ClassicLinkList -1&#x2F;&#x2F;Used in whether the targeted elements is found&#x2F;&#x2F;If is considered found, just use Find , otherwise unfind!typedef enum _ClassicLinkList_isFind_ &#123;Find &#x3D; 1,Unfind &#x3D; 0&#125;ClassicLinkList_isFind;&#x2F;&#x2F;Used in whether print data in ClassicLinkList better&#x2F;&#x2F;Use ClassicLinkList_OPEN if you want a better printtypedef enum _BetterPrintSwitch_for_ClassicLinkList_ &#123;ClassicLinkList_OPEN &#x3D; 1,ClassicLinkList_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_ClassicLinkList;&#x2F;&#x2F;-------------------------------------------Main_Define------------------------------------------&#x2F;&#x2F;Basic definitions of datanode, it can be considered as a node in a loop&#x2F;&#x2F;is consisted of dataPiece and the pointer to the next datanode&#x2F;&#x2F;UNLESS YOU ARE CONCIOUS ABOUT WHAT YOU ARE DOING! DO NOT CHANGE THE DATA DIRECTLY! typedef struct _Classic_DataNode_ &#123;void* data;struct _Classic_DataNode_* p_next_one;&#125;Classic_DataNode;&#x2F;&#x2F;basic definations of datalist , it can be considered as the loop or the main body of the data structure&#x2F;&#x2F;to better operate the data structure , it is consisted of Head pointer that pointed to the first data in the data struct&#x2F;&#x2F;as well as the current_size of the data structure&#x2F;&#x2F;UNLESS YOU ARE CONCIOUS ABOUT WHAT YOU ARE DOING! DO NOT CHANGE THE DATA DIRECTLY! typedef struct _Classic_DataList_ &#123;Classic_DataNode* Head;size_t current_size;&#125;Classic_DataList;&#x2F;&#x2F;this type of int is used to mark the returnType of the compare functionstypedef unsigned int Is_Used_Compared_Int;typedef void(*MyPrint)(void*);typedef void* (*Do_Specific_Change)(void*);typedef Is_Used_Compared_Int(*CompareFunc)(void*, void*);typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);&#x2F;&#x2F;--------------------Default_size_Type---------------------------------------------#if OPENUPDEFAULTSIZE#define Dyarr_SIGINT sizeof(int)#define Dyarr_SIGCHAR sizeof(char)#define Dyarr_SIGFLOAT sizeof(float)#define Dyarr_SIGDOUBLE sizeof(double)#define Dyarr_SIG(dataType) sizeof(dataType)#define Dyarr_INT_SIZE(X) sizeof(int)*X#define Dyarr_CHAR_SIZE(X) sizeof(char)*X#define Dyarr_FLOAT_SIZE(X) sizeof(float)*X#define Dyarr_DOUBLE_SIZE(X) sizeof(double)*X#define Dyarr_TYPE_SIZE(dataType,X) sizeof(dataType)*X#endif&#x2F;&#x2F;-------------------------------QuickMalloc----------------------------------------------------#if OPENQUICKMALLOC#define MALLOC(type) (type*)malloc(sizeof(type))#define MALLOCN(type,ElemNum) (type*)malloc(sizeof(type)*ElemNum)#endif&#x2F;&#x2F;-----------------------Position_Stored_Dynamic_Array_For_Dyarr---------------------------------&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;Used in returning multitude locations#if OPENUPPOSARR&#x2F;&#x2F;Main data structure!&#x2F;&#x2F;Used in returning multitude locationstypedef struct _Dyarrposarr_ &#123;int* posSpace;size_t pos_size;&#125;Position_Stored_Dynamic_ArrayFordyarr;&#x2F;&#x2F;Want a better Print to beutify your control table? try this onetypedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;PSDA_dyarr_OPEN &#x3D; 1,PSDA_dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_pos_dyarr;&#x2F;&#x2F;can use this type when indicating the typetypedef unsigned int BetterPrintfor_PosDyarr;&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr()&#123;Position_Stored_Dynamic_ArrayFordyarr* pro_usable_space &#x3D; (Position_Stored_Dynamic_ArrayFordyarr*)malloc(sizeof(Position_Stored_Dynamic_ArrayFordyarr));if (!pro_usable_space)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;pro_usable_space-&gt;posSpace &#x3D; NULL;pro_usable_space-&gt;pos_size &#x3D; 0;return pro_usable_space;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSEClassicLinkListFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr,BetterPrintfor_PosDyarrWhether_Better_Print)&#123;if (!posarr)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nPositions are shown! :\n&quot;);for (int i &#x3D; 0; i &lt; posarr-&gt;pos_size; i++)printf(&quot;%u &quot;, posarr-&gt;posSpace[i]);if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nFinish Printing!\n&quot;);return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_ArrayClassicLinkListFunctionStatues Push_back_a_locations_in_PSDA_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr, intpos_acquired)&#123;int* pro_usable_space &#x3D; (int*)realloc(posarr-&gt;posSpace, sizeof(int) * (posarr-&gt;pos_size + 1));if (!pro_usable_space)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;posarr-&gt;posSpace &#x3D; pro_usable_space;posarr-&gt;posSpace[posarr-&gt;pos_size] &#x3D; pos_acquired;posarr-&gt;pos_size++;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to return the number of locations&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSEsize_t Get_pos_size_From_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr, BetterPrintfor_PosDyarrWhether_Shown_Print)&#123;if (!posarr)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (Whether_Shown_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nCurrent targeted data&#39;s total num is:%u!\n&quot;, posarr-&gt;pos_size);return posarr-&gt;pos_size;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;return a pos that is targeted!&#x2F;&#x2F;void* getPosbyPosinPSDA(Position_Stored_Dynamic_ArrayFordyarr* getter,size_tpos)&#123;if (!getter) &#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (pos &gt; getter-&gt;pos_size)&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;for (int i &#x3D; 0; i &lt; pos; i++)return (char*)getter-&gt;posSpace + i * sizeof(size_t);&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_ArrayClassicLinkListFunctionStatues DesTroy_A_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*pointer_to_wishedfreeposarr)&#123;if (!pointer_to_wishedfreeposarr)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;free(pointer_to_wishedfreeposarr-&gt;posSpace);free(pointer_to_wishedfreeposarr);pointer_to_wishedfreeposarr &#x3D; NULL;return ClassicLinkList_NORMAL;&#125;#endif &#x2F;&#x2F; OPENUPPOSARR&#x2F;&#x2F;-----------------------------About ClassicLinkList-----------------------------------------------------------&#x2F;&#x2F;----------------------------Init-functions--------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; there are three basic type of initialization&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------------------------------&#x2F;&#x2F; 1.includeing the default type (init a NULL head and zero cur_size)&#x2F;&#x2F; func1: Classic_DataList* Init_A_ClassicLinkList()&#x2F;&#x2F; &#x2F;&#x2F; No input , or input VOID&#x2F;&#x2F; have output : output a clssicLinklist pointer&#x2F;&#x2F; -------------------------------------------------------------------------------------------------------------&#x2F;&#x2F; 2.includeing the copy one (init the same type of the be-copied one)&#x2F;&#x2F; func2: Classic_DataList* Init_A_ClassicLinkList_By_CopyAClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : a required_be_copied list .&#x2F;&#x2F; output: a new list but have is the same as the be_copied list&#x2F;&#x2F; -------------------------------------------------------------------------------------------------------------&#x2F;&#x2F; 3.includeing to transform the static array to the linklist one&#x2F;&#x2F; func3: Classic_DataList* UpdateStaticArray2ClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : a waited_transformed static_array , the element size which is in the static array &#x2F;&#x2F; output: a new pointer that points to classicLinkList&#x2F;&#x2F; &#x2F;&#x2F; &#x2F;&#x2F;----------------------------Init-functions--------------------------------------------------------------------&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; This function is used to init a default type of classicLinkList&#x2F;&#x2F; that the head of dataPiece is NULL and the cur_size is zero.&#x2F;&#x2F; Use push back to init the dataPiece&#x2F;&#x2F; use in this Way: &#x2F;&#x2F; Classic_DataList* List &#x3D; Init_A_ClassicLinkList();Classic_DataList* Init_A_ClassicLinkList()&#123;&#x2F;&#x2F; create empty spaceClassic_DataList* pro_usable_space &#x3D; (Classic_DataList*)malloc(sizeof(Classic_DataList));&#x2F;&#x2F; Check whether init succeededif (!pro_usable_space)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F; Default set pro_usable_space-&gt;Head &#x3D; NULL;pro_usable_space-&gt;current_size &#x3D; 0;&#x2F;&#x2F; return out the Structurereturn pro_usable_space;&#125;&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to copy an already exited linklist&#x2F;&#x2F; Classic_DataList* List &#x3D; Init_A_ClassicLinkList_By_CopyAClassicLinkList(Classic_DataList* list) &#x2F;&#x2F;Classic_DataList* Init_A_ClassicLinkList_By_CopyAClassicLinkList(Classic_DataList*list) &#123;&#x2F;&#x2F;check whether the input is legalif (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;&#x2F;&#x2F;check whether there is neccessity to copy if (list-&gt;current_size &#x3D;&#x3D; 0)&#123;printf(&quot;No need to copy! it hasn&#39;t been initialize yet!&quot;);&#x2F;&#x2F;Used to return NULL , but it is dangerous that two pointers points one things return NULL;&#125;&#x2F;&#x2F;New a List and new a head and new the data of the headClassic_DataList* p_NewList &#x3D; (Classic_DataList*)malloc(sizeof(Classic_DataList));Classic_DataNode* newHead &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));void* newdata &#x3D; malloc(sizeof(list-&gt;Head-&gt;data));&#x2F;&#x2F;check whether we init the node successfullyif (newHead &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;if (newdata &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F;Do copy the data to the new head and finished initializationmemcpy(newdata, list-&gt;Head-&gt;data, sizeof(list-&gt;Head-&gt;data));newHead-&gt;data &#x3D; newdata;newHead-&gt;p_next_one &#x3D; NULL;p_NewList-&gt;Head &#x3D; newHead;p_NewList-&gt;current_size &#x3D; 1;&#x2F;&#x2F;Start copy other nodesClassic_DataNode* p_Currency &#x3D; list-&gt;Head-&gt;p_next_one;Classic_DataNode* pCurCopy &#x3D; p_NewList-&gt;Head;for (int i &#x3D; 0; i &lt; list-&gt;current_size-1; i++) &#123;&#x2F;&#x2F;Copy the I-th nodeClassic_DataNode* newDataNode &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));&#x2F;&#x2F;check if the initialization is illegalif(newDataNode&#x3D;&#x3D;NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F; prepare to copy data from the current nodevoid* newdata &#x3D; malloc(sizeof(p_Currency-&gt;data));&#x2F;&#x2F; check if the initialization is illegalif (newdata &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F;copy the detailed nodememcpy(newdata, p_Currency-&gt;data, sizeof(p_Currency-&gt;data));newDataNode-&gt;data &#x3D; newdata;newDataNode-&gt;p_next_one &#x3D; NULL;&#x2F;&#x2F;Moving the pointer and prepared next copypCurCopy-&gt;p_next_one &#x3D; newDataNode;pCurCopy &#x3D; pCurCopy-&gt;p_next_one;p_Currency &#x3D; p_Currency-&gt;p_next_one;&#125;&#x2F;&#x2F;Data copy finished , init the cur_sizep_NewList-&gt;current_size &#x3D; list-&gt;current_size;return p_NewList;&#125;&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to updata a static array into a ClassicLinkList&#x2F;&#x2F; Classic_DataList* List &#x3D; UpdateStaticArray2ClassicLinkList(&#x2F;&#x2F; void* inputArray, &#x2F;&#x2F; size_t dataSize, &#x2F;&#x2F; size_t dataNum&#x2F;&#x2F; )&#x2F;&#x2F;Classic_DataList* UpdateStaticArray2ClassicLinkList(void*inputArray, size_tdataSize, size_tdataNum)&#123;if (inputArray &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;Classic_DataList* pro_usable_space &#x3D; (Classic_DataList*)malloc(sizeof(Classic_DataList));Classic_DataNode* FirstHeaddata &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode*));void* datapiece &#x3D; malloc(dataSize);if (pro_usable_space &#x3D;&#x3D; NULL&amp;&amp;FirstHeaddata &#x3D;&#x3D; NULL&amp;&amp;datapiece &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(datapiece, inputArray, dataSize);FirstHeaddata-&gt;data &#x3D; datapiece;FirstHeaddata-&gt;p_next_one &#x3D; NULL;pro_usable_space-&gt;current_size &#x3D; 1;pro_usable_space-&gt;Head &#x3D; FirstHeaddata;for (int i &#x3D; 1; i &lt; dataNum; i++)&#123;Classic_DataNode* p_Currency &#x3D; pro_usable_space-&gt;Head;while (p_Currency-&gt;p_next_one)&#123;p_Currency &#x3D; p_Currency-&gt;p_next_one;&#125;void* datastored &#x3D; malloc(dataSize);if (!datastored)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(datastored, (char*)inputArray + i * dataSize, dataSize);Classic_DataNode* datanode &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));if (!datanode)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;datanode-&gt;data &#x3D; datastored;datanode-&gt;p_next_one &#x3D; NULL;p_Currency-&gt;p_next_one &#x3D; datanode;pro_usable_space-&gt;current_size++;&#125;return pro_usable_space;&#125;&#x2F;&#x2F;----------------------------------------Basic_Add_Functions------------------------&#x2F;&#x2F; there are four basic input functions:&#x2F;&#x2F; &#x2F;&#x2F; ----------------------------------------------------------------------------------&#x2F;&#x2F; 1. push back an element into the classicLinkList&#x2F;&#x2F; func1 : ClassicLinkListFunctionStatues Push_Back_Into_A_ClassicLinkList&#x2F;&#x2F;&#x2F;&#x2F; input : the inserted list ,the data wanted to be inserted and the inserted datasize&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ----------------------------------------------------------------------------------&#x2F;&#x2F; 2. insert back an element into the classicLinkList by offering a valid pos&#x2F;&#x2F; func2 : ClassicLinkListFunctionStatues Insert_into_AClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; &#x2F;&#x2F; input : the inserted list , the data ,the datasize as well as the position you wanted to insert&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ----------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 3. push back a bunch of data into the classicLinkList like the first function&#x2F;&#x2F; func3 :ClassicLinkListFunctionStatues push_Back_BunchDataintoClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : the inserted list , the data ,the datasize as well as the position you wanted to insert&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ----------------------------------------------------------------------------------&#x2F;&#x2F; 4. insert back a bunch of data into the classicLinkList like the second function&#x2F;&#x2F; func4: ClassicLinkListFunctionStatues Insert_A_Bunch_of_data_intoClassicLinkList&#x2F;&#x2F;&#x2F;&#x2F; input : the inserted list , the static array ,the datasize in the static array as well as the position you wanted to insert&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore! &#x2F;&#x2F; &#x2F;&#x2F;----------------------------------------Basic_Add_Functions-------------------------&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; push back some data ,like dynamic array , into the final position&#x2F;&#x2F;Used like this Push_Back_Into_A_ClassicLinkList(appendedClassicLinkList, data ,sizeof(data))&#x2F;&#x2F;ClassicLinkListFunctionStatues Push_Back_Into_A_ClassicLinkList(Classic_DataList*list, void*data,size_tdatasize)&#123;if (!list)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;Classic_DataNode* p_Currency &#x3D; list-&gt;Head;if(list-&gt;Head !&#x3D; NULL)&#123;while (p_Currency-&gt;p_next_one)&#123;p_Currency &#x3D; p_Currency-&gt;p_next_one;&#125;void* datastored &#x3D; malloc(datasize);if (!datastored)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(datastored, data, datasize);Classic_DataNode* datanode &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));if (!datanode)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;datanode-&gt;data &#x3D; datastored;datanode-&gt;p_next_one &#x3D; NULL;p_Currency-&gt;p_next_one &#x3D; datanode;list-&gt;current_size++;&#125;else&#123;void* datastored &#x3D; malloc(datasize);if (!datastored)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(datastored, data, datasize);Classic_DataNode* datanode &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));if (!datanode)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;datanode-&gt;data &#x3D; datastored;datanode-&gt;p_next_one &#x3D; NULL;list-&gt;Head &#x3D; datanode;list-&gt;current_size++;&#125;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F; About ClassicDataList&#x2F;&#x2F; insert back a data into the datalist&#x2F;&#x2F; used like this: Insert_into_AClassicLinkList(inserted list, input data,dataSize,insertion_pos)&#x2F;&#x2F; ClassicLinkListFunctionStatues Insert_into_AClassicLinkList(Classic_DataList*list, void*data,size_tdataSize,size_tpos)&#123;if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (data &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;list-&gt;current_size)&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;if (pos &#x3D;&#x3D; 0)&#123;Classic_DataNode* stored &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));if (stored &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;void* dataPiece &#x3D; malloc(dataSize);memcpy(dataPiece, data, dataSize);stored-&gt;data &#x3D; dataPiece;stored-&gt;p_next_one &#x3D; list-&gt;Head;list-&gt;Head &#x3D; stored;list-&gt;current_size++;return ClassicLinkList_NORMAL;&#125;Classic_DataNode* pCurrency &#x3D; list-&gt;Head;Classic_DataNode* stored &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));if (stored &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;void* dataPiece &#x3D; malloc(dataSize);memcpy(dataPiece, data, dataSize);stored-&gt;data &#x3D; dataPiece;for (int i &#x3D; 0; i &lt; pos; i++)&#123;pCurrency &#x3D; pCurrency-&gt;p_next_one;&#125;stored-&gt;p_next_one &#x3D; pCurrency-&gt;p_next_one;pCurrency-&gt;p_next_one &#x3D; stored;list-&gt;current_size++;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F; About ClassicDataList&#x2F;&#x2F; push back a bunch data into the datalist&#x2F;&#x2F; used like this : push_Back_BunchDataintoClassicLinkList( inserted_list , the static array ,the elementsize ,the element num)&#x2F;&#x2F;ClassicLinkListFunctionStatues push_Back_BunchDataintoClassicLinkList(Classic_DataList*list,void*inputArray, size_tsigElemSize, size_tarrayNum)&#123;if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if(inputArray&#x3D;&#x3D;NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;&#x2F;&#x2F;Equally as to updata a Static Array into a ClassicLinkList&#x2F;&#x2F;Once just use  UpdateStaticArray2ClassicLinkList(),but i&#39;m afraid of unable to use this functions&#x2F;&#x2F;as it is said: &quot;DO NOT motivate another functions , try to finish all work if neccessary&quot;if (list-&gt;Head &#x3D;&#x3D; NULL)&#123;&#x2F;&#x2F;New a List and new a head and new the data of the headClassic_DataList* p_NewList &#x3D; (Classic_DataList*)malloc(sizeof(Classic_DataList));Classic_DataNode* newHead &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));void* newdata &#x3D; malloc(sizeof(list-&gt;Head-&gt;data));&#x2F;&#x2F;check whether we init the node successfullyif (newHead &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;if (newdata &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F;Do copy the data to the new head and finished initializationmemcpy(newdata, list-&gt;Head-&gt;data, sizeof(list-&gt;Head-&gt;data));newHead-&gt;data &#x3D; newdata;newHead-&gt;p_next_one &#x3D; NULL;p_NewList-&gt;Head &#x3D; newHead;p_NewList-&gt;current_size &#x3D; 1;&#x2F;&#x2F;Start copy other nodesClassic_DataNode* p_Currency &#x3D; list-&gt;Head-&gt;p_next_one;Classic_DataNode* pCurCopy &#x3D; p_NewList-&gt;Head;for (int i &#x3D; 0; i &lt; list-&gt;current_size - 1; i++)&#123;&#x2F;&#x2F;Copy the I-th nodeClassic_DataNode* newDataNode &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));&#x2F;&#x2F;check if the initialization is illegalif (newDataNode &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F; prepare to copy data from the current nodevoid* newdata &#x3D; malloc(sizeof(p_Currency-&gt;data));&#x2F;&#x2F; check if the initialization is illegalif (newdata &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F;copy the detailed nodememcpy(newdata, p_Currency-&gt;data, sizeof(p_Currency-&gt;data));newDataNode-&gt;data &#x3D; newdata;newDataNode-&gt;p_next_one &#x3D; NULL;&#x2F;&#x2F;Moving the pointer and prepared next copypCurCopy-&gt;p_next_one &#x3D; newDataNode;pCurCopy &#x3D; pCurCopy-&gt;p_next_one;p_Currency &#x3D; p_Currency-&gt;p_next_one;&#125;&#x2F;&#x2F;Data copy finished , init the cur_sizep_NewList-&gt;current_size &#x3D; list-&gt;current_size;list &#x3D; p_NewList;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F;for this section , that means the head isn&#39;t NULL , just copy as usual:Classic_DataNode* pCur &#x3D; list-&gt;Head;for (int i &#x3D; 0; i &lt; list-&gt;current_size-1; i++) &#123;pCur &#x3D; pCur-&gt;p_next_one;&#125;for (int i &#x3D; 0; i &lt; arrayNum; i++) &#123;Classic_DataNode* pCopyCur &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));void* copyData &#x3D; malloc(sizeof(sigElemSize));if (pCopyCur &#x3D;&#x3D; NULL &amp;&amp; copyData &#x3D;&#x3D; NULL) &#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(copyData, (char*)inputArray + i * sigElemSize, sigElemSize);pCopyCur-&gt;data &#x3D; copyData;pCopyCur-&gt;p_next_one &#x3D; NULL;pCur-&gt;p_next_one &#x3D; pCopyCur;pCur &#x3D; pCur-&gt;p_next_one;&#125;list-&gt;current_size +&#x3D; arrayNum;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F; About ClassicDataList&#x2F;&#x2F; insert back a bunch of data into the datalist&#x2F;&#x2F; used like this: Insert_into_AClassicLinkList(inserted list, insertion_pos,input array ,Single dataSize, the amount of elements)&#x2F;&#x2F; ClassicLinkListFunctionStatues Insert_A_Bunch_of_data_intoClassicLinkList(Classic_DataList*list,size_tpos,void*inputArray,size_tsigElemSize,size_tarrayNum) &#123;if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (inputArray &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (pos &gt; list-&gt;current_size)&#123;SHOW_WARNING_ClassicLinkList_OVERLAP_POS;SHOW_WHETHER_ACCCEPTED(&quot;y&#x2F;n: y for yes , n for n&quot;);int choice;scanf(&quot;%c&quot;, &amp;choice);if (choice &#x3D;&#x3D; &#39;y&#39;)&#123;pos &#x3D; list-&gt;current_size;&#125;else&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;&#125;Classic_DataNode* pCurNow &#x3D; NULL;Classic_DataNode* pStart &#x3D; NULL;for(int i &#x3D; 0 ; i &lt; arrayNum ; i++)&#123;Classic_DataNode* pCopyCur &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));void* copydata &#x3D; malloc(sigElemSize);if (pCopyCur &#x3D;&#x3D; NULL &amp;&amp; copydata &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(copydata, (char*)inputArray + i * sigElemSize, sigElemSize);pCopyCur-&gt;data &#x3D; copydata;pCopyCur-&gt;p_next_one &#x3D; NULL;if (i &#x3D;&#x3D; 0)&#123;pCurNow &#x3D; pCopyCur;pStart &#x3D; pCopyCur;continue;&#125;pCurNow-&gt;p_next_one &#x3D; pCopyCur;pCurNow &#x3D; pCurNow-&gt;p_next_one;&#125;if (pos &#x3D;&#x3D; 0)&#123;pCurNow-&gt;p_next_one &#x3D; list-&gt;Head;list-&gt;Head &#x3D; pStart;list-&gt;current_size +&#x3D; arrayNum;return ClassicLinkList_NORMAL;&#125;Classic_DataNode* pCur &#x3D; list-&gt;Head;for (int i &#x3D; 0; i &lt; pos; i++) &#123;pCur &#x3D; pCur-&gt;p_next_one;&#125;pCurNow-&gt;p_next_one &#x3D; pCur-&gt;p_next_one;pCur-&gt;p_next_one &#x3D; pStart;list-&gt;current_size +&#x3D; arrayNum;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F;------------------------------------------Deletion_Functions-------------&#x2F;&#x2F; there are two basic type of functions in the sections&#x2F;&#x2F; 1. Erase a targeted element and erase it from the ClassicDataList&#x2F;&#x2F; fun1:eraseAElementfromDataList&#x2F;&#x2F; &#x2F;&#x2F; input : the list and the erase position&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; --------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 2.Erase some target elements from the ClassicDataList&#x2F;&#x2F; fun2:eraseAbunchData&#x2F;&#x2F; &#x2F;&#x2F; input: the list and the start position as well as the last position, that means offer a paired pos&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F;------------------------------------------Deletion_Functions----------------&#x2F;&#x2F; About ClassicDataList&#x2F;&#x2F; delete a  data in the datalist by offering a position&#x2F;&#x2F;used like this: eraseAElementfromDataList(list, erasing_pos)&#x2F;&#x2F;ClassicLinkListFunctionStatues eraseAElementfromDataList(Classic_DataList*list,size_tpos) &#123;if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;list-&gt;current_size)&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;if (pos &#x3D;&#x3D; 0)&#123;Classic_DataNode* pNewHead &#x3D; list-&gt;Head-&gt;p_next_one;Classic_DataNode* pDel &#x3D; list-&gt;Head;list-&gt;Head &#x3D; pNewHead;free(pDel-&gt;data);list-&gt;current_size--;return ClassicLinkList_NORMAL;&#125;Classic_DataNode* pCur &#x3D; list-&gt;Head;for (int i &#x3D; 0; i &lt; pos-1; i++)&#123;pCur &#x3D; pCur-&gt;p_next_one;&#125;Classic_DataNode* pDel &#x3D; pCur-&gt;p_next_one;pCur-&gt;p_next_one &#x3D; pDel-&gt;p_next_one;free(pDel-&gt;data);free(pDel);list-&gt;current_size--;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F; About ClassicDataList&#x2F;&#x2F; delete a bunch of data in the datalist&#x2F;&#x2F; used like this eraseAbunchData( list,  front_pos,  final_pos)&#x2F;&#x2F;ClassicLinkListFunctionStatues eraseAbunchData_inDataList(Classic_DataList*list, size_tfront_pos,size_tfinal_pos)&#123;if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (front_pos&lt;0 || front_pos&gt;list-&gt;current_size)&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;if (final_pos&lt;0 || final_pos&gt;list-&gt;current_size)&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;if (front_pos &gt; final_pos)&#123;SHOW_WARNING_ClassicLinkList_SWAPPED_POS;SHOW_WHETHER_ACCCEPTED(&quot;y&#x2F;n: y for yes , n for n&quot;);int choice;scanf(&quot;%c&quot;, &amp;choice);if (choice &#x3D;&#x3D; &#39;y&#39;) &#123;int temp &#x3D; final_pos;final_pos &#x3D; front_pos;front_pos &#x3D; temp;&#125;else&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;&#125;Bool flag &#x3D;False;if (front_pos &#x3D;&#x3D; 0) &#123;flag &#x3D; True;front_pos++;&#125;Classic_DataNode* pCur &#x3D; list-&gt;Head;for (int i &#x3D; 0; i &lt; front_pos-1; i++) &#123;pCur &#x3D; pCur-&gt;p_next_one;&#125;int cur_place &#x3D; front_pos-1;while (cur_place &lt;&#x3D; final_pos-1) &#123;Classic_DataNode* pDel &#x3D; pCur-&gt;p_next_one;pCur-&gt;p_next_one &#x3D; pDel-&gt;p_next_one;free(pDel);cur_place++;&#125;list-&gt;current_size -&#x3D; final_pos - front_pos +1;if (flag &#x3D;&#x3D; True) &#123;Classic_DataNode* pNewHead &#x3D; pCur-&gt;p_next_one;Classic_DataNode* pDel &#x3D; list-&gt;Head;list-&gt;Head &#x3D; pNewHead;free(pDel-&gt;data);front_pos++;list-&gt;current_size--;&#125;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F;----------------------------------------check_if_element_existed_functions-----&#x2F;&#x2F; there are four functions in this sections&#x2F;&#x2F; &#x2F;&#x2F; 1.check if the classiclinklist is empty&#x2F;&#x2F; fun1: isEmptyClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input :the checked list&#x2F;&#x2F; output: My defined bool(Sadly the org C doesn&#39;t define that)&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 2. check if the target elements is exsited in the datalist&#x2F;&#x2F; fun2: checkIsLocateinLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : the checked list ,the searched data and the Compared functions&#x2F;&#x2F; output: the locations that we first found it&#x2F;&#x2F; &#x2F;&#x2F; -------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 3. return out the first locations that we found of the target elements&#x2F;&#x2F; func3:checkIsLocateinLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : the checked list ,the searched data and the Compared functions&#x2F;&#x2F; output: My defined bool(Sadly the org C doesn&#39;t define that)&#x2F;&#x2F; &#x2F;&#x2F; --------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; Warning : this functions required the PSDA abstractions is opened so you can use Position_Stored_Dynamic_ArrayFordyarr*&#x2F;&#x2F; to get the position&#x2F;&#x2F; &#x2F;&#x2F; 4. return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr&#x2F;&#x2F; fun4:returnAbunchLocationsinLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : the checked list , the Position_Stored_Dynamic_ArrayFordyarr*(required init first)&#x2F;&#x2F; output: the Position_Stored_Dynamic_ArrayFordyarr that stored the positions!&#x2F;&#x2F;&#x2F;&#x2F; ---------------------------------------------------------------------------------&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; check if the LinkList is empty&#x2F;&#x2F;Bool isEmptyClassicLinkList(Classic_DataList* list)&#123;if (list-&gt;current_size &#x3D;&#x3D; 0)&#123;return True;&#125;return False;&#125;&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; check if the target elements is exsited in the datalist&#x2F;&#x2F;Bool checkIsLocateinLinkList(Classic_DataList*list, void*data,LocateFuncuser_func)&#123;if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (data &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (user_func &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;Classic_DataNode* pCur &#x3D; list-&gt;Head;for (int i &#x3D; 0; i &lt; list-&gt;current_size; i++)&#123;if (user_func(data, pCur-&gt;data)) &#123;return True;&#125;&#125;return False;&#125;&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; return out the first locations that we found of the target elements&#x2F;&#x2F; can use in this way: size_t pos &#x3D; returnOutDatabyposinLinkList( list, data, user_func)size_t returnOutDatabyposinLinkList(Classic_DataList*list, void*data, LocateFuncuser_func)&#123;Classic_DataNode* pCur &#x3D; list-&gt;Head;for (int i &#x3D; 0; i &lt; list-&gt;current_size; i++)&#123;if (user_func(data, pCur-&gt;data)) &#123;return i;&#125;pCur &#x3D; pCur-&gt;p_next_one;&#125;return Unfind_ClassicLinkList;&#125;&#x2F;&#x2F; Make sure the OPENUPPOSARR &#x3D;&#x3D; 1 if wanted to use it#if OPENUPPOSARR&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr&#x2F;&#x2F; can use in this way: Position_Stored_Dynamic_ArrayFordyarr* somePos &#x3D; &#x2F;&#x2F; returnAbunchLocationsinLinkList( list,  posArr,  data,  user_func)&#x2F;&#x2F;Position_Stored_Dynamic_ArrayFordyarr* returnAbunchLocationsinLinkList(Classic_DataList*list, Position_Stored_Dynamic_ArrayFordyarr*posArr, void*data,LocateFuncuser_func)&#123;if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (data &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (posArr &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;Classic_DataNode* p_Currency &#x3D; list-&gt;Head;int possible_count &#x3D; 0;for (int i &#x3D; 0; i &lt; list-&gt;current_size; i++)&#123;if ((*user_func)(data, p_Currency-&gt;data))&#123;int* pro_usable_stored_space &#x3D; (int*)realloc(posArr-&gt;posSpace, sizeof(int) * (possible_count + 1));if (!pro_usable_stored_space)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;posArr-&gt;posSpace &#x3D; pro_usable_stored_space;posArr-&gt;posSpace[possible_count] &#x3D; i;possible_count++;posArr-&gt;pos_size &#x3D; possible_count;&#125;p_Currency &#x3D; p_Currency-&gt;p_next_one;&#125;if (posArr-&gt;pos_size)return posArr;return Unfind_ClassicLinkList;&#125;#endif &#x2F;&#x2F;---------------------------------------Do_Something_to_the_datalist_functions----------&#x2F;&#x2F; there are seven functions in this sections&#x2F;&#x2F; &#x2F;&#x2F; 1. Classic Print functions&#x2F;&#x2F; func1: Print_All_Data_LinkList&#x2F;&#x2F; to print all the data in the user_defined linklist&#x2F;&#x2F; &#x2F;&#x2F; input : list and the user print , and the decision whether enjoyed a better print&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 2. Do some change to the specific data&#x2F;&#x2F; to make some change directly to an element&#x2F;&#x2F; &#x2F;&#x2F; input : the list ,the targeted positions and the way how you want to operate the data itself&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ------------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 3. Do some change to all the data in the classiclinklist&#x2F;&#x2F; to make some change directly to the whole elements&#x2F;&#x2F; &#x2F;&#x2F; input : the list ,the way how you want to operate the data itself&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; -----------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 4. Do specific change to an interval pos in the classicLickList&#x2F;&#x2F; to make some change directly to the interval elements&#x2F;&#x2F; &#x2F;&#x2F; input : the list ,the front_pos and the final_pos&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; -----------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 5. reverse ClassicLinkList&#x2F;&#x2F; to reverse up the classic LinkList&#x2F;&#x2F; &#x2F;&#x2F; input : the ready_reversed data&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; -----------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 6. combine two linkList into one&#x2F;&#x2F; to combine the two classic linklist into one!&#x2F;&#x2F; &#x2F;&#x2F; input : the two linklist&#x2F;&#x2F; output: the merged linklist Pointer&#x2F;&#x2F; &#x2F;&#x2F; -----------------------------------------------------------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 7. sort the elements in the classicLinkList under the user&#39;s constructions&#x2F;&#x2F; to sort the ClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : the classicLinklist&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; ---------------------------------------------------------------------------------&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to print the data&#x2F;&#x2F; use in this way: Print_All_Data_LinkList( list, user_print,  whether_better_print)&#x2F;&#x2F;ClassicLinkListFunctionStatues Print_All_Data_LinkList(Classic_DataList*list,MyPrintuser_print, BetterPrintSwitch_for_ClassicLinkListwhether_better_print)&#123;if (!list)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (!user_print)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (whether_better_print &#x3D;&#x3D; ClassicLinkList_OPEN) &#123;printf(&quot;\nStart printing:\n&quot;);&#125;Classic_DataNode* p_Currency &#x3D; list-&gt;Head;for (int i &#x3D; 0; i &lt; list-&gt;current_size; i++)&#123;user_print(p_Currency-&gt;data);p_Currency &#x3D; p_Currency-&gt;p_next_one;&#125;if (whether_better_print &#x3D;&#x3D; ClassicLinkList_OPEN) &#123;printf(&quot;\nFinish printing:\n&quot;);&#125;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to make some change to the specific data&#x2F;&#x2F; use in this way:doChangetoSpecificElementinLinkList( list,  pos , user_func)&#x2F;&#x2F;ClassicLinkListFunctionStatues doChangetoSpecificElementinLinkList(Classic_DataList*list, size_tpos ,Do_Specific_Changeuser_func) &#123;if (list &#x3D;&#x3D; NULL&amp;&amp;user_func&#x3D;&#x3D;NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;list-&gt;current_size)&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;Classic_DataNode* pCur &#x3D; list-&gt;Head;for (int i &#x3D; 0; i &lt; pos; i++)&#123;pCur &#x3D; pCur-&gt;p_next_one;&#125;user_func(pCur-&gt;data);return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to make some change to the interval data&#x2F;&#x2F; use in this way:doChangetoTargetIntervalDatainLinkList(list , pos1,pos2, user_func)&#x2F;&#x2F;ClassicLinkListFunctionStatues doChangetoTargetIntervalDatainLinkList(Classic_DataList*list, size_tfront_pos,size_tfinal_pos,Do_Specific_Changeuser_func) &#123;if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (front_pos&lt;0 || front_pos&gt;list-&gt;current_size)&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;if (final_pos&lt;0 || final_pos&gt;list-&gt;current_size)&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;if (front_pos &gt; final_pos)&#123;SHOW_WARNING_ClassicLinkList_SWAPPED_POS;SHOW_WHETHER_ACCCEPTED(&quot;y&#x2F;n: y for yes , n for n&quot;);int choice;scanf(&quot;%c&quot;, &amp;choice);if (choice &#x3D;&#x3D; &#39;y&#39;)&#123;int temp &#x3D; final_pos;final_pos &#x3D; front_pos;front_pos &#x3D; temp;&#125;else&#123;SHOW_ERROR_ClassicLinkList_Invalid_Input;exit(ClassicLinkList_Invalid_Input);&#125;&#125;Classic_DataNode* pCur &#x3D; list-&gt;Head;for (int i &#x3D; 0; i &lt; front_pos; i++) &#123;pCur &#x3D; pCur-&gt;p_next_one;&#125;for (int i &#x3D; front_pos; i &lt; final_pos+1; i++)&#123;user_func(pCur-&gt;data);pCur &#x3D; pCur-&gt;p_next_one;&#125;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to make some change to the whole elements in the data&#x2F;&#x2F; use in this way:doChangetoAllDatainLinkList( list,  user_func)&#x2F;&#x2F;ClassicLinkListFunctionStatues doChangetoAllDatainLinkList(Classic_DataList*list,Do_Specific_Changeuser_func)&#123;if (list &#x3D;&#x3D; NULL &amp;&amp; user_func &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;Classic_DataNode* pCur &#x3D; list-&gt;Head;for (int i &#x3D; 0; i &lt; list-&gt;current_size; i++) &#123;user_func(pCur-&gt;data);pCur&#x3D;pCur-&gt;p_next_one;&#125;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to reverse up the classiclinklist&#x2F;&#x2F; use in this way:ReverseLinkList(list)&#x2F;&#x2F;ClassicLinkListFunctionStatues ReverseLinkList(Classic_DataList* list)&#123;if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (list-&gt;current_size &#x3D;&#x3D; 1)&#123;printf(&quot;No need in reversing!,try a longer one lol&quot;);return ClassicLinkList_NORMAL;&#125;if (list-&gt;current_size &#x3D;&#x3D; 2)&#123;Classic_DataNode* headFisrt &#x3D; list-&gt;Head;Classic_DataNode* pFin &#x3D; headFisrt-&gt;p_next_one;pFin-&gt;p_next_one &#x3D; headFisrt;headFisrt-&gt;p_next_one &#x3D; NULL;list-&gt;Head &#x3D; pFin;return ClassicLinkList_NORMAL;&#125;Classic_DataNode* pFinal &#x3D; list-&gt;Head-&gt;p_next_one;Classic_DataNode* pPrior &#x3D; list-&gt;Head;while (pFinal!&#x3D; NULL) &#123;Classic_DataNode* tempFin &#x3D; pFinal-&gt;p_next_one;pFinal-&gt;p_next_one &#x3D; pPrior;pPrior &#x3D; pFinal;pFinal &#x3D; tempFin;&#125;list-&gt;Head &#x3D; pPrior;&#125;&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; to merge two linklist into the one&#x2F;&#x2F; use in this way:mergeLinkList(list_be_added, list_adder, whether_copied)&#x2F;&#x2F;Classic_DataList* mergeLinkList(Classic_DataList*list_be_added, Classic_DataList*list_adder, size_twhether_copied)&#123;if (list_be_added &#x3D;&#x3D; NULL &amp;&amp; list_adder &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;Classic_DataNode* pCur&#x3D;list_be_added-&gt;Head;for (int i &#x3D; 0; i &lt; list_be_added-&gt;current_size-1; i++)&#123;pCur &#x3D; pCur-&gt;p_next_one;&#125;&#x2F;&#x2F;Do not copy , instead just merge!if (whether_copied&#x3D;&#x3D;ClassicLinkList_NO_COPY) &#123;pCur-&gt;p_next_one &#x3D; list_adder-&gt;Head;list_be_added-&gt;current_size +&#x3D; list_adder-&gt;current_size;return list_be_added;&#125;Classic_DataNode* pAdder &#x3D; list_adder-&gt;Head;for (int i &#x3D; 0; i &lt; list_adder-&gt;current_size; i++)&#123;&#x2F;&#x2F;prepare the spaceClassic_DataNode* pCopy &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));void* dataCopy &#x3D; malloc(sizeof(pAdder-&gt;data));if (pCopy &#x3D;&#x3D; NULL &amp;&amp; dataCopy &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F;Using to copy data and initialize the copied nodememcpy(dataCopy, pAdder-&gt;data, sizeof(pAdder-&gt;data));pCopy-&gt;data &#x3D; dataCopy;pCopy-&gt;p_next_one &#x3D; NULL;&#x2F;&#x2F;then push back into the linklistpCur-&gt;p_next_one &#x3D; pCopy;&#x2F;&#x2F;Moving the copy pointerpAdder &#x3D; pAdder-&gt;p_next_one;pCur &#x3D; pCur-&gt;p_next_one;&#125;list_be_added-&gt;current_size +&#x3D; list_adder-&gt;current_size;return list_be_added;&#125;&#x2F;&#x2F; About ClassicLinkList&#x2F;&#x2F; sort the classicLinklist in the bobblesort&#x2F;&#x2F; use in this way:sortClassicLinkListinBubbleSort(Classic_DataList* list, CompareFunc user_func) &#x2F;&#x2F;ClassicLinkListFunctionStatues sortClassicLinkListinBubbleSort(Classic_DataList*list, CompareFuncuser_func) &#123;if (list &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;if (user_func &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; list-&gt;current_size-1; i++)&#123;Classic_DataNode* pCur &#x3D; list-&gt;Head;for(int j&#x3D;0;j&lt;list-&gt;current_size-i-1;j++)&#123;&#x2F;&#x2F;this two for loops are just standard BobbleSortif (user_func(pCur-&gt;data, pCur-&gt;p_next_one-&gt;data))&#123;void* tempdata &#x3D; malloc(sizeof(pCur-&gt;data));memcpy(tempdata, pCur-&gt;data, sizeof(pCur-&gt;data));int tempdatasize &#x3D; sizeof(pCur-&gt;data);&#x2F;&#x2F;Before Swap,make sure that the dataContainer is huge enough to contain a new spaceif (sizeof(pCur-&gt;p_next_one-&gt;data) &gt; sizeof(pCur-&gt;data))&#123;void* pTempSwap &#x3D; realloc(pCur-&gt;data, sizeof(pCur-&gt;p_next_one-&gt;data));if (pTempSwap &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);&#125;pCur-&gt;data &#x3D; pTempSwap;&#125;&#x2F;&#x2F;Copy and swapmemcpy(pCur-&gt;data, pCur-&gt;p_next_one-&gt;data, sizeof(pCur-&gt;p_next_one-&gt;data));memcpy(pCur-&gt;p_next_one-&gt;data, tempdata, tempdatasize);&#125;&#x2F;&#x2F;Moving pointer to the next onepCur &#x3D; pCur-&gt;p_next_one;&#125;&#125;return ClassicLinkList_NORMAL;&#125;&#x2F;&#x2F;----------------------------------------------------Basic_Erase------------------------------&#x2F;&#x2F; &#x2F;&#x2F; 1.Erase A LinkList&#x2F;&#x2F; used in just clear a linklist&#x2F;&#x2F; func1: clearAClassicLinkList&#x2F;&#x2F; &#x2F;&#x2F; input : just a classiclinklist&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!&#x2F;&#x2F; &#x2F;&#x2F; --------------------------------------------------------------------------------------------&#x2F;&#x2F;About ClassicLinkList&#x2F;&#x2F; Erase a classicLinkList&#x2F;&#x2F; Use in this way clearAClassicLinkList( list)&#x2F;&#x2F;ClassicLinkListFunctionStatues clearAClassicLinkList(Classic_DataList* list)&#123;if (list &#x3D;&#x3D; NULL) &#123;SHOW_ERROR_ClassicLinkList_NULL_INPUT;exit(ClassicLinkList_NULL_INPUT);&#125;Classic_DataNode* pCur &#x3D; list-&gt;Head-&gt;p_next_one;Classic_DataNode* pDel &#x3D; list-&gt;Head;if (list-&gt;current_size &#x3D;&#x3D; 1) &#123;free(pDel);&#125;for (int i &#x3D; 0; i &lt; list-&gt;current_size-1; i++)&#123;free(pDel);pDel &#x3D; pCur;pCur &#x3D; pCur-&gt;p_next_one;&#125;list-&gt;current_size &#x3D; 0 ;return ClassicLinkList_NORMAL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试文档：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1#include&quot;ClassicLinkList.h&quot;MyPrint print(int* e) &#123;printf(&quot;%d &quot;, *e);&#125;Do_Specific_Change dochange(int* e) &#123;*e &#x3D; *e + 1;&#125;LocateFunc loc(int* e1, int* e2) &#123;return *e1 &#x3D;&#x3D; *e2;&#125;CompareFunc comp(int* e1, int* e2) &#123;return *e1 &lt; *e2;&#125;int main()&#123;&#x2F;&#x2F;do test initailization&#x2F;&#x2F;default initClassic_DataList* defaultinit &#x3D; Init_A_ClassicLinkList();&#x2F;&#x2F;updata initint array[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;Classic_DataList* update_one &#x3D; UpdateStaticArray2ClassicLinkList(array, Dyarr_SIGINT, 10);Print_All_Data_LinkList(update_one, print, ClassicLinkList_OPEN);&#x2F;&#x2F; copy initClassic_DataList* copy_one &#x3D; Init_A_ClassicLinkList_By_CopyAClassicLinkList(update_one);printf(&quot;\nThouth , this is the copy one:&quot;);Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);&#x2F;&#x2F; Push back int addersig &#x3D; 100;printf(&quot;\nFirst push:&quot;);Push_Back_Into_A_ClassicLinkList(defaultinit, &amp;addersig, Dyarr_SIGINT);Print_All_Data_LinkList(defaultinit, print, ClassicLinkList_OPEN);printf(&quot;\nSecond push:&quot;);Push_Back_Into_A_ClassicLinkList(defaultinit, &amp;addersig, Dyarr_SIGINT);Print_All_Data_LinkList(defaultinit, print, ClassicLinkList_OPEN);&#x2F;&#x2F; Push back a sumint adderarr[5] &#x3D; &#123; 101,102,103,104,105 &#125;;push_Back_BunchDataintoClassicLinkList(defaultinit, adderarr, Dyarr_SIGINT, 5);Print_All_Data_LinkList(defaultinit, print, ClassicLinkList_OPEN);&#x2F;&#x2F;Insert start:int insertionsig &#x3D; -100;&#x2F;&#x2F;to the head:Insert_into_AClassicLinkList(defaultinit, &amp;insertionsig, Dyarr_SIGINT, 0);Print_All_Data_LinkList(defaultinit, print, ClassicLinkList_OPEN);&#x2F;&#x2F;to other placeInsert_into_AClassicLinkList(defaultinit, &amp;insertionsig, Dyarr_SIGINT, 1);Print_All_Data_LinkList(defaultinit, print, ClassicLinkList_OPEN);&#x2F;&#x2F;for a bunch ...&#x2F;&#x2F;headint insertarr[5] &#x3D; &#123; -1,-2,-3,-4,-5 &#125;;Insert_A_Bunch_of_data_intoClassicLinkList(update_one, 0, insertarr, Dyarr_SIGINT, 5);Print_All_Data_LinkList(update_one, print, ClassicLinkList_OPEN);&#x2F;&#x2F;other placeInsert_A_Bunch_of_data_intoClassicLinkList(update_one, 1, insertarr, Dyarr_SIGINT, 5);Print_All_Data_LinkList(update_one, print, ClassicLinkList_OPEN);&#x2F;&#x2F;Erase eraseAElementfromDataList(copy_one, 0);Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);eraseAElementfromDataList(copy_one, 1);Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);&#x2F;&#x2F;Erase buncheraseAbunchData_inDataList(copy_one, 0, 2);Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);&#x2F;&#x2F;make change:&#x2F;&#x2F;sigdoChangetoSpecificElementinLinkList(copy_one, 0, dochange);Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);&#x2F;&#x2F;intervaldoChangetoTargetIntervalDatainLinkList(copy_one, 0, 2, dochange);Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);&#x2F;&#x2F;alldoChangetoAllDatainLinkList(copy_one, dochange);Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);&#x2F;&#x2F;check if inClassic_DataList* checkerlist &#x3D; UpdateStaticArray2ClassicLinkList(insertarr, Dyarr_SIGINT, 5);int wannafind &#x3D; -1;printf(&quot;So is it null?&quot;);if (!isEmptyClassicLinkList(checkerlist)) &#123;printf(&quot;\nNot null sir!\n&quot;);&#125;if (checkIsLocateinLinkList(checkerlist, &amp;wannafind, loc)) &#123;printf(&quot;yes, there is a num that is -1\n&quot;);&#125;printf(&quot;and it is on the place: %d\n&quot;, returnOutDatabyposinLinkList(checkerlist, &amp;wannafind, loc));int wannafind2 &#x3D; wannafind - 1;printf(&quot;and also there is -2 too, it is in: %d\n&quot;, returnOutDatabyposinLinkList(checkerlist, &amp;wannafind2, loc));printf(&quot;I can also make a change in this way directly:\n&quot;);doChangetoSpecificElementinLinkList(checkerlist, returnOutDatabyposinLinkList(checkerlist, &amp;wannafind2, loc), dochange);Print_All_Data_LinkList(checkerlist, print, ClassicLinkList_OPEN);&#x2F;&#x2F;find bunch Position_Stored_Dynamic_ArrayFordyarr* posarr &#x3D; Init_A_Postion_Stored_Dynamic_ArrayFordyarr();returnAbunchLocationsinLinkList(checkerlist, posarr, &amp;wannafind, loc);Show_All_Locations_In_PSDAfor_dyarr(posarr, PSDA_dyarr_OPEN);&#x2F;&#x2F;reverseReverseLinkList(checkerlist);Print_All_Data_LinkList(checkerlist, print, ClassicLinkList_OPEN);&#x2F;&#x2F;SortsortClassicLinkListinBubbleSort(checkerlist, comp);Print_All_Data_LinkList(checkerlist, print, ClassicLinkList_OPEN);&#x2F;&#x2F;DelclearAClassicLinkList(checkerlist);Print_All_Data_LinkList(checkerlist, print, ClassicLinkList_OPEN);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> MyTinyLibProject </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程 （7）</title>
      <link href="/2023/02/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%887%EF%BC%89/"/>
      <url>/2023/02/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%887%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学教程（14）"><a href="#高等数学教程（14）" class="headerlink" title="高等数学教程（14）"></a>高等数学教程（14）</h1><h2 id="一元向量值函数及其导数"><a href="#一元向量值函数及其导数" class="headerlink" title="一元向量值函数及其导数"></a>一元向量值函数及其导数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}x & = & \varphi(t) \\y & = & \phi(t) \\z & = & \omega (t)\end{aligned}\right.\end{equation}</script><p>​        可以看到，我们对于空间点的坐标可以使用</p><script type="math/tex; mode=display">\vec{r}=\vec{x}i+\vec{y}j+\vec{z}k</script><p>​        这样的方式表达！</p><p>​        于是对于一个点，可以使用一个类似于函数的表达方式：</p><script type="math/tex; mode=display">\vec{f(t)}=f_1(t)\vec{x}+f_2(t)\vec{y}+f_3(t)\vec{z}</script><h3 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h3><p>定义：</p><p>当</p><script type="math/tex; mode=display">t\rightarrow t_0,f(t)\rightarrow r_0,\lim\limits_{t\rightarrow t_0}\vec{f(t)}=r_0</script><p>下，我们可以记作：</p><script type="math/tex; mode=display">\lim\limits_{t\rightarrow t_0}\vec{f(t)}=(\lim\limits_{t\rightarrow t_0}{f_1(t)},\lim\limits_{t\rightarrow t_0}{f_2(t)},\lim\limits_{t\rightarrow t_0}{f_3(t)})</script><h3 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h3><p>现在定义：</p><script type="math/tex; mode=display">\lim\limits_{\Delta t\rightarrow 0}\frac{\Delta r}{\Delta t}=\lim\limits_{\Delta t\rightarrow 0}\frac{f(t_0+\Delta{t})-f(t_0)}{\Delta t}</script><p>于是展开，可以得到：</p><script type="math/tex; mode=display">f'(t_0)=(f'_1(t_0),f'_2(t_0),f'_3(t_0))</script><h3 id="相关求导法则"><a href="#相关求导法则" class="headerlink" title="相关求导法则"></a>相关求导法则</h3><p>​        跟数量函数一致，我们来看：</p><p><img src="image-20230210170814278.png" alt="image-20230210170814278"></p><h3 id="空间曲线的切线与法平面"><a href="#空间曲线的切线与法平面" class="headerlink" title="空间曲线的切线与法平面"></a>空间曲线的切线与法平面</h3><p><img src="image-20230210170906185.png" alt="image-20230210170906185"></p><p>​        回到上面我们讲到的：一个空间曲线的切向量就是：</p><script type="math/tex; mode=display">T=(\varphi'(t_0),\phi'(t_0),\omega'(t_0))</script><p>​        于是切线方程就是：</p><script type="math/tex; mode=display">\frac{x-x_0}{\varphi'(t_0)}=\frac{y-y_0}{\phi'(t_0)}=\frac{z-z_0}{\omega'(t_0)}</script><p>​        法平面：</p><script type="math/tex; mode=display">(x-x_0){\varphi'(t_0)}+(y-y_0){\phi'(t_0)}+(z-z_0){\omega'(t_0)}=0</script><p>​        对于方程式形式的，还是跟上一节的方程组求导一致</p><p><img src="image-20230210171628902.png" alt="image-20230210171628902"></p><h3 id="空间曲面的切平面和法线"><a href="#空间曲面的切平面和法线" class="headerlink" title="空间曲面的切平面和法线"></a>空间曲面的切平面和法线</h3><p>1.$F(x,y,z)=0$</p><p>​        切平面：</p><script type="math/tex; mode=display">F_x'(x-x_0)+F_y'(y-y_0)+F_z'(z-z_0)=0</script><p>​        法线：</p><script type="math/tex; mode=display">\frac{x-x_0}{F'_x}=\frac{y-y_0}{F'_y}=\frac{z-z_0}{F'_z}</script><p>2.$z=f(x,y)$</p><p>​        挪个位置：$F(x,y,z)=f(x,y)-z$</p><p>​        切平面：</p><script type="math/tex; mode=display">F_x'(x-x_0)+F_y'(y-y_0)-(z-z_0)=0</script><p>​        法线：</p><script type="math/tex; mode=display">\frac{x-x_0}{F'_x}=\frac{y-y_0}{F'_y}=\frac{z-z_0}{-1}</script><h3 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h3><p>求方向导数，可以理解为曲面上的点$P(x_0,y_0)$出发的一条射线</p><p><img src="image-20230210172637380.png" alt="image-20230210172637380"></p><p>我们出发产生的射线方程：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}x & = & x_0+t\cos\alpha \\y & = & y_0+t\cos\beta \\\end{aligned}\right.\end{equation}</script><p>这个时候：</p><script type="math/tex; mode=display">\lim\limits_{t\rightarrow 0^+}\frac{f(x_0+t\cos\alpha,y_0+t\cos\beta)-f(x_0,y_0)}{t}=\frac{\partial f}{\partial l}|_{(x_0,y_0)}</script><p>​        可以看作：<strong>F（x,y）在方向L上的偏导数！</strong>，方向导数这一节就是对偏导的推广！</p><p>​        但是，我们的方向导数是射线，是从一个方向逼近的，于是有：</p><pre class="line-numbers language-none"><code class="language-none">方向导数存在，但是偏导未必因此存在！想要成为充要条件，则需要正负两个方向导数相等<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230210173343849.png" alt="image-20230210173343849"></p><p>​        定理：若函数$f(x,y)$在$(x_0,y_0)$可微，方向导数存在且$\frac{\partial f}{\partial l}|_{(x_0,y_0)}=f’_x\cos \alpha+f_y’\cos \beta $</p><h3 id="关系整理"><a href="#关系整理" class="headerlink" title="关系整理"></a>关系整理</h3><p><img src="image-20230210173813570.png" alt="image-20230210173813570"></p><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>​        定义：</p><script type="math/tex; mode=display">\nabla f(x_0,y_0)=gradf(x_0,y_0)=(f'_x(x_0,y_0),f_y'(x_0,y_0))</script><p>​        为梯度，<strong>他是个向量！</strong></p><p>​        回到这里：</p><script type="math/tex; mode=display">\frac{\partial f}{\partial l}|_{(x_0,y_0)}=(f'_x(x_0,y_0),f_y'(x_0,y_0))\cdot(\cos \alpha,\cos \beta)=|gradf(x_0,y_0)|\cos \theta</script><p>​        1)当$\theta=0$,此时方向导数最大，于是</p><pre class="line-numbers language-none"><code class="language-none">梯度是在这一点方向导数取最大值的方向<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        2）当$\theta = \pi$,此时方向导数最小，为$|-gradf(x_0,y_0)|$</p><p>​        3)当$\theta = \frac{\pi}{2}$此时，方向导数为0，可以看作平行于等高线了！也可以理解为：在这个方向增长最快。</p><h3 id="极大值（极小值）"><a href="#极大值（极小值）" class="headerlink" title="极大值（极小值）"></a>极大值（极小值）</h3><p>定理一：极值必要条件：</p><p>$z=f(x,y)偏导，且(x_0,y_0)是极值点，则f’_x(x_0,y_0)=0,f’_y(x_0,y_0)=0$</p><p>驻点：$f’_x(x_0,y_0)=0,f’_y(x_0,y_0)=0$同时成立！</p><p>定理二：充分条件</p><p>$A=f’’_{xx}(x_0,y_0),B=f’’_{xy}(x_0,y_0),C=f’’_{yy}(x_0,y_0)$</p><p>则：</p><p>1）$AC&gt;B^2$:极值，且$A&gt;0是极小值，A&lt;0是极大值$</p><p>2）$AC&lt;B^2$:不是极值</p><p>3）$AC=B^2$:另作判断！</p><h3 id="条件极值"><a href="#条件极值" class="headerlink" title="条件极值"></a>条件极值</h3><p>​        什么叫条件极值，就是在一定约束之下函数的最大值，于是拉格朗日数乘就有：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}f_x'+\lambda\varphi_x'=0 \\f_y'+\lambda\varphi_y'=0  \\\varphi(x_0,y_0)=0\end{aligned}\right.\end{equation}</script><p>​        实际上，我们常常直接构造拉格朗日函数：</p><script type="math/tex; mode=display">L(x,y)=f(x,y)+\lambda \varphi(x,y)</script><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}L_x'=0 \\L_y'=0  \\\end{aligned}\right.\end{equation}</script>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数基本教程（2）</title>
      <link href="/2023/02/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
      <url>/2023/02/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数（2）"><a href="#线性代数（2）" class="headerlink" title="线性代数（2）"></a>线性代数（2）</h1><h2 id="按行展开的行列式"><a href="#按行展开的行列式" class="headerlink" title="按行展开的行列式"></a>按行展开的行列式</h2><p>首先介绍余子式：</p><h3 id="余子式"><a href="#余子式" class="headerlink" title="余子式"></a>余子式</h3><p>什么叫余子式呢？就是针对一个元素去掉他所在的行它所在的列，剩下的行列式叫做余子式：如对下面的行列式去掉第三行第二列：</p><script type="math/tex; mode=display">\left | \begin{matrix} 1&1&0&3\\1&1&1&1\\2&2&3&4\\5&5&6&6\end{matrix} \right|</script><p>产生的余子式$M_{32}$是：</p><script type="math/tex; mode=display">\left | \begin{matrix} 1&0&3\\1&1&1\\5&6&6\end{matrix} \right|</script><p>派生的概念是代数余子式就是：$A_{ij}$是$(-1)^{i+j}M_{ij}$</p><p>于是</p><h3 id="行列式的按行或列展开"><a href="#行列式的按行或列展开" class="headerlink" title="行列式的按行或列展开"></a>行列式的按行或列展开</h3><p>定理：定义任意的行列式可以如下的计算</p><script type="math/tex; mode=display">D=\sum_{k=1}^na_{ik}A_{ik}</script><p>或者：</p><script type="math/tex; mode=display">D=\sum_{k=1}^na_{ki}A_{ki}</script><p>如：</p><script type="math/tex; mode=display">\left |\begin{matrix}1&1&2 \\0&1&0 \\2&3&5\end{matrix}\right |=\\0\times A_{21}\times(-1)^{2+1}+(-1)^{2+2}\times A_{22}\times1+0\times A_{23}\times(-1)^{2+3}</script><h3 id="异乘变零定理"><a href="#异乘变零定理" class="headerlink" title="异乘变零定理"></a>异乘变零定理</h3><p><strong>某行元素与另一行元素的代数余子式为0</strong></p><h3 id="拉普拉斯K阶子式"><a href="#拉普拉斯K阶子式" class="headerlink" title="拉普拉斯K阶子式"></a>拉普拉斯K阶子式</h3><p>对行列式去掉K行K列的式子还是余子式，去掉的部分叫K阶子式。（可以不做了解，应为后面学矩阵了秒懂）</p><h3 id="行列式的乘法"><a href="#行列式的乘法" class="headerlink" title="行列式的乘法"></a>行列式的乘法</h3><p>​        对于行列式的乘法：跟矩阵一致，我们是</p><script type="math/tex; mode=display">a_{ij}=A_{Row(i)}\times B_{Col(j)}</script><p>​        当然是同阶的</p><h3 id="行列式计算技巧"><a href="#行列式计算技巧" class="headerlink" title="行列式计算技巧"></a>行列式计算技巧</h3><h4 id="尽量制造行和便于提取：如对于"><a href="#尽量制造行和便于提取：如对于" class="headerlink" title="尽量制造行和便于提取：如对于"></a>尽量制造行和便于提取：如对于</h4><script type="math/tex; mode=display">\left |\begin{matrix}x&a&a&...&a\\a&x&a&...&a\\a&a&x&...&a\\...&...&...&...&...\\a&a&a&...&x\\\end{matrix}\right |</script><p>讲所有的列依次加到第一列，提取(x+(n-1)a)得到</p><script type="math/tex; mode=display">(x+(n-1)a)\left |\begin{matrix}1&0&0&...&0\\1&x-a&0&...&0\\1&1&x-a&...&0\\...&...&...&...&...\\1&1&1&...&x-a\\\end{matrix}\right |</script><h4 id="可以适当加边，便于计算"><a href="#可以适当加边，便于计算" class="headerlink" title="可以适当加边，便于计算"></a>可以适当加边，便于计算</h4><p>对于：</p><script type="math/tex; mode=display">\left |\begin{matrix}1+a_1&1&1&...&1\\1&1+a_2&1&...&1\\1&1&1+a_3&...&1\\...&...&...&...&...\\1&1&1&...&1+a_n\\\end{matrix}\right |</script><p>可以：</p><script type="math/tex; mode=display">\left |\begin{matrix}1&1&1&1&...&1\\0&1+a_1&1&1&...&1\\0&1&1+a_2&1&...&1\\0&1&1&1+a_3&...&1\\0&...&...&...&...&...\\0&1&1&1&...&1+a_n\\\end{matrix}\right |</script><p>这是因为代数余子式计算中只有第一行有效，展开后还是原来的样子，所以：第一行乘上-1加到其他行得到：</p><script type="math/tex; mode=display">\left |\begin{matrix}1&1&1&1&...&1\\-1&a_1&0&0&...&0\\-1&0&a_2&0&...&0\\-1&0&0&a_3&...&0\\-1&...&...&...&...&...\\-1&0&0&0&...&a_n\\\end{matrix}\right |</script><p>对于这样的行列式，叫三叉形行列式：我们是：依次从列，消掉第一列（第二列乘上$\frac{1}{a_1}$加到第一列…依次类推），得到</p><script type="math/tex; mode=display">\left |\begin{matrix}1+\sum_{i=1}^{n}\frac{1}{a_i}&1&1&1&...&1\\0&a_1&0&0&...&0\\0&0&a_2&0&...&0\\0&0&0&a_3&...&0\\0&...&...&...&...&...\\01&0&0&0&...&a_n\\\end{matrix}\right |</script><h3 id="范德蒙德行列式"><a href="#范德蒙德行列式" class="headerlink" title="范德蒙德行列式"></a>范德蒙德行列式</h3><p>特殊定义这个行列式</p><script type="math/tex; mode=display">\left | \begin{matrix}1&1&1&...&1 \\x_1&x_2&x_3&...&x_n \\x_1^2&x_2^2&x_3^2&...&x_n^2 \\...&...&...&...&...\\x_1^{n-2}&x_2^{n-2}&x_3^{n-2}&...&x_n^{n-2} \\x_1^{n-1}&x_2^{n-1}&x_3^{n-1}&...&x_n^{n-1} \\ \end{matrix} \right |</script><p>这个值是</p><script type="math/tex; mode=display">\Pi_{1\leq j <i \leq n}(x_i-x_j)</script><p>说白了就是，假设这是一个五阶行列式：</p><script type="math/tex; mode=display">D=(x_2-x_1)(x_3-x_1)(x_4-x_1)(x_5-x_1)\\(x_3-x_2)(x_4-x_2)(x_5-x_2)\\(x_4-x_3)(x_5-x_3)\\(x_5-x_4)</script><p>怎么来的？首先第一行乘上$-x_1$在这个基础上接着再做，行列式变成</p><script type="math/tex; mode=display">\left | \begin{matrix}1&1&1&...&1 \\0&x_2-x_1&x_3-x_1&...&x_n-x_1 \\0&x_2^2-x_1^2&x_3^2-x_1^2&...&x_n^2 -x_1^2\\...&...&...&...&...\\0&x_2^{n-2}-x_1^{n-2}&x_3^{n-2}-x_1^{n-2}&...&x_n^{n-2}-x_1^{n-2} \\0&x_2^{n-1}-x_1^{n-1}&x_3^{n-1}-x_1^{n-1}&...&x_n^{n-1}-x_1^{n-1} \\ \end{matrix} \right |</script><p>​        然后第一列第一行就可以消去了</p><script type="math/tex; mode=display">\left | \begin{matrix}x_2-x_1&x_3-x_1&...&x_n-x_1 \\x_2^2-x_1^2&x_3^2-x_1^2&...&x_n^2 -x_1^2\\...&...&...&...\\x_2^{n-2}-x_1^{n-2}&x_3^{n-2}-x_1^{n-2}&...&x_n^{n-2}-x_1^{n-2} \\x_2^{n-1}-x_1^{n-1}&x_3^{n-1}-x_1^{n-1}&...&x_n^{n-1}-x_1^{n-1} \\ \end{matrix} \right |</script><p>​        好好看每一个列，发现都有因子$(x_i-x_1)$提出来：</p><script type="math/tex; mode=display">(x_2-x_1)(x_3-x_1)...(x_n-x_1)\left | \begin{matrix}1&1&1&...&1 \\x_1&x_2&x_3&...&x_{n-1} \\x_1^2&x_2^2&x_3^2&...&x_{n-1}^2 \\...&...&...&...&...\\x_1^{n-2}&x_2^{n-2}&x_3^{n-2}&...&x_{n-1}^{n-2} \\x_1^{n-1}&x_2^{n-1}&x_3^{n-1}&...&x_{n-1}^{n-1} \\ \end{matrix} \right |</script><p>​        又出现了！又可以重复做！</p><h3 id="反对称行列式"><a href="#反对称行列式" class="headerlink" title="反对称行列式"></a>反对称行列式</h3><p>​        对于这样的行列式</p><script type="math/tex; mode=display">\left | \begin{matrix}0&a&b&c&...&h\\-a&0&d&e&...&w\\-b&-d&0&...&...&y\\-c&-e&...&0&...&z\\...&...&...&...&...&...\\-h&-w&-y&-z&...&0\end{matrix}\right |</script><p>​        1)主对角线全是0</p><p>​        2）上下位置对应成相反数</p><p><strong>于是，奇数阶：$D=0$</strong></p><h3 id="对称行列式"><a href="#对称行列式" class="headerlink" title="对称行列式"></a>对称行列式</h3><script type="math/tex; mode=display">\left | \begin{matrix}a&b&c&d&y&x\\b&e&f&h&f&i\\c&f&k&p&m&n\\d&h&p&q&r&s\\y&f&m&r&w&t\\x&i&n&s&t&u\end{matrix}\right |</script><p>​        1）主对角线无所谓2）上下元素对应相等</p><p>​        这样的行列式叫做对称行列式</p><h3 id="Crammer法则"><a href="#Crammer法则" class="headerlink" title="Crammer法则"></a>Crammer法则</h3><p>​        方程组的系数行列式即是行列式的每个元素由系数组成。</p><p>​        对于$x_j$,当$D\neq 0$,</p><script type="math/tex; mode=display">x_j=\frac{D_j}{D}</script><p>​        其中，$D_j$是等号右边的列替换第J列产生的新行列式</p><p><img src="image-20230209223519341.png" alt="image-20230209223519341"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 （2）</title>
      <link href="/2023/02/09/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%EF%BC%882%EF%BC%89/"/>
      <url>/2023/02/09/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概率论与数理统计（2）"><a href="#概率论与数理统计（2）" class="headerlink" title="概率论与数理统计（2）"></a>概率论与数理统计（2）</h1><h3 id="事件的概率"><a href="#事件的概率" class="headerlink" title="事件的概率"></a>事件的概率</h3><p>​        </p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​        概率是衡量可能性大小的量，对于事件A,我们记：概率是$P(A)$</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>1）$P(\Omega)=1$</p><p>2）$P(\phi)=0$</p><p>3）$0\leq P(A)\leq 1$</p><h3 id="古典概率模型"><a href="#古典概率模型" class="headerlink" title="古典概率模型"></a>古典概率模型</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>​        一个概率事件可以被视作古典概率模型的条件如下：</p><p><strong>1）有限个样本点</strong></p><p><strong>2）所有的事件都是等可能性的</strong>！</p><p>​        于是，基于我们的直觉，我们可以构想出集合下样本点发生的概率是：</p><script type="math/tex; mode=display">P(A)=\frac{A事件的样本点}{\Omega中样本点的个数}</script><h4 id="记数："><a href="#记数：" class="headerlink" title="记数："></a>记数：</h4><p>​        首先引入我们高中排列组合的知识：</p><p>加法原理：几种方案（加法算）</p><p>乘法原理：几步走（乘法算）</p><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><p>​        从N个不同的元素选出M个元素的排列</p><script type="math/tex; mode=display">P_N^M=n(n-1)(n-2)...(n-m+1)=\frac{n!}{(n-m)!}</script><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>​        从N个元素中选出M个不同元素</p><script type="math/tex; mode=display">C_N^M=\frac{P_N^M}{m!}=\frac{n!}{(n-m)!m!}</script><h3 id="几何概型"><a href="#几何概型" class="headerlink" title="几何概型"></a>几何概型</h3><p>​        如果我们的样本点连续的密不可分：我们可以用面积，线段占比长度来衡量，我们就说这个是几何概型：</p><script type="math/tex; mode=display">P(A)=\frac{\mu(G)}{\mu(\Omega)}</script><p>​        举个例子：蒲丰投针问题</p><p><img src="image-20230209204850321.png" alt="image-20230209204850321"></p><p>​        求相交的概率:</p><p>​        注意到：</p><script type="math/tex; mode=display">\Omega = \{(\varphi,x)|0\leq\varphi\leq\pi,0\leq x\leq\frac{l}{2}\}</script><script type="math/tex; mode=display">G=\{(\varphi,x)|0\leq\varphi\leq\pi,0\leq x\leq\frac{l}{2}\sin\varphi\}</script><p>故：</p><script type="math/tex; mode=display">P(G)=\frac{\int_0^\pi\frac{l}{2}\sin\varphi d\varphi }{\pi \times \frac{d}{2}}</script><h3 id="频率与概率"><a href="#频率与概率" class="headerlink" title="频率与概率"></a>频率与概率</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>​        定义频率是N次实验里出现了M次事件，则频率为：</p><script type="math/tex; mode=display">\frac{m}{n}</script><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><p>1）非负性：$0\leq\omega_n(A)\leq1$</p><p>2）  规范：$\omega_n(\emptyset)=0,\omega_n(\Omega)=1$</p><p>3）可加性：$A_1,A_2…A_m$不相容，则：$\omega_n(A_1+…A_m)=\omega_n(A_1)+…\omega_n(A_m)$</p><h3 id="公理化"><a href="#公理化" class="headerlink" title="公理化"></a>公理化</h3><p>​        我们有三条公理：</p><p>1.（非负性）$0\leq P(A)\leq 1$</p><p>2.（规范化）$P(\Omega)=1$</p><p>3.（完全可加）$A_1$,$A_2$…不相容：则$P(A_1+A_2+…)=P(A_1)+…$</p><p>​    由此推导性质</p><p>1）$P(\phi)=0$</p><p>推导：$\Omega=\Omega+\phi+\phi+…$</p><p>故：$P(\Omega)=P(\Omega)+P(\phi)+…$推导：$P(\phi)=0$</p><p>2)$P(\bar{A})=1-P(A)$</p><p>推导：$A \cap \bar A = \phi,A \cup \bar A = \Omega$</p><p>故：$P(\Omega)=P(A)+P(\bar A)=1$</p><p>3)对于完备事件组：$A_1,A_2,…A_n$,$\sum_{i=1}^nP_i=1$</p><p>4)$P(A-B)=P(A)-P(AB)$</p><p>5)$P(A+B)=P(A)+P(B)-P(AB)$</p><p> 推论：$P(A+B+C)=P(A)+P(B)+P(C)-P(AB)-P(BC)-P(AC)+P(ABC)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程 （6）</title>
      <link href="/2023/02/09/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%886%EF%BC%89/"/>
      <url>/2023/02/09/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%886%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="多元函数微分法"><a href="#多元函数微分法" class="headerlink" title="多元函数微分法"></a>多元函数微分法</h1><h3 id="平面点集"><a href="#平面点集" class="headerlink" title="平面点集"></a>平面点集</h3><p>​        下面我们要引入多元函数，这就要求我们需要有点集的概念：我们定义一些点，如果满足一些特有的性质，就称之为他们是一个点集：</p><script type="math/tex; mode=display">E=\{(x,y)|(x,y)有特定关系\}</script><p>​        我们举个例子：一些点再一个半径为R的圆上：</p><script type="math/tex; mode=display">E=\{(x,y)|x^2+y^2=R^2\}</script><p>​        由于在平面上更有扩展性，我们就需要引入跟一元函数一样的概念：领域，这一次指的是P周围的地方：记作</p><script type="math/tex; mode=display">\mathring U(P_0,\sigma)=\{P||PP_0|<\sigma\}</script><p>​        点有几种：在一个圈住的特定范围下：有外点（不属于），边界点（处于边界），内点（就属于里面）</p><p>​        对于这些集合：有开集，闭集（就是说白了：取不取等的问题），有有界集无界集的概念，这里不多做阐述。</p><h3 id="N维空间"><a href="#N维空间" class="headerlink" title="N维空间"></a>N维空间</h3><p>​        N维空间表示</p><script type="math/tex; mode=display">R^n=\{(x_1,x_2,...,x_n)|x_i \in R,i=1,2,3,..,n\}</script><p>​        说白了，就像二维空间只用两个分量表达就可以阐述完全一样。</p><h3 id="多元函数的极限"><a href="#多元函数的极限" class="headerlink" title="多元函数的极限"></a>多元函数的极限</h3><p>​        比较一下：我们的一元函数的极限是单一主元趋向一个值：$x\rightarrow x_0$,一元函数也是这样的逼近！（从左边逼近，从右边逼近）。</p><p>​        那么多元函数又如何？（多元函数就像是：z=x+2y这样的玩意），注意到这一次我们的点可以在平面上移动而不是在线上移动！</p><script type="math/tex; mode=display">(x,y)\rightarrow(x_0,y_0)</script><p>​        这样的逼近方式是任意方式逼近的，这就让我们：可以直线逼近，可以曲线逼近！</p><p>​        <img src="image-20230206111243619.png" alt="image-20230206111243619"></p><p>​        如此：如果就算这样我们的极限值还是都不变：那么我们说函数的极限存在</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow(x_0,y_0)}f(x,y)=A</script><p>​        举个例子：$f(x,y)=(x^2+y^2)\sin\frac{1}{x^2+y^2}$求解：</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow(0,0)}(x^2+y^2)\sin\frac{1}{x^2+y^2}</script><p>​        很容易看出：$\sin\frac{1}{x^2+y^2}$有界的，这样，函数极限怎么样都是0！</p><p>​        如果极限不满足任何方式逼近相等，那就不存在！</p><p>​        比如说：求解$\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(x,y)$</p><script type="math/tex; mode=display">\begin{equation}f(x,y)=\left\{    \begin{aligned}    \frac{xy}{x^2+y^2} \quad x^2+y^2\neq 0\\    0 \quad x^2+y^2=0\\    \end{aligned}    \right    .\end{equation}</script><p>​        只需要：$y=kx$逼近:</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(x,y)=\frac{k}{k^2+1}</script><p>​        而若是：$y=-kx$逼近：</p><script type="math/tex; mode=display">\lim\limits_{(x,y)\rightarrow (x_0,y_0)}f(x,y)=-\frac{k}{k^2+1}</script><p>​         这下显然不存在了！</p><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>​        在一元导数中，我们这样定义导数：</p><script type="math/tex; mode=display">1)x\rightarrow x_0 ,\lim\limits_{x\rightarrow x_0}\frac{f(x)-f(x_0)}{x-x_0}</script><script type="math/tex; mode=display">2)\Delta x\rightarrow 0 ,\lim\limits_{\Delta x\rightarrow 0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}</script><p>​        类似的，<strong>我们的多元函数不过就是多个主元一同影响函数值！</strong>这就是为什么我们的导数多了一个“偏”：如果说我们有一个函数$z=f(x,y)$，我们把目光聚焦在$x$上：我们就说$z$对$x$的偏导数就是这样定义的：</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}=\lim\limits_{\Delta x\rightarrow0}\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta x}</script><p>​        当然还有这个简单的写法：</p><p>1）$z_x’$                         2）$f’_x(x,y)$</p><p>​        试试看，对$y$的偏导又是如何？</p><script type="math/tex; mode=display">\frac{\partial z}{\partial y}=\lim\limits_{\Delta y\rightarrow0}\frac{f(x_0,y_0+\Delta y)-f(x_0,y_0)}{\Delta y}</script><p>​        实际上，我们直接其他变量视作常数就好了</p><p>1）$z=x^2+3xy+y^2$在（1,2）处求偏导:</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}=2x+3y,\frac{\partial z}{\partial y}=2y+3x</script><p>​        带入值就好了！</p><h4 id="几何含义"><a href="#几何含义" class="headerlink" title="几何含义"></a>几何含义</h4><p>​        说白了还是切线，不过是什么方向上的切线而已：过对应点切面产生的曲线的切线</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>​        对于一元函数来讲：可导一定连续！</p><p>​        对于二元函数来讲，可导不一定连续（因为此时退化为偏导，只是一个方向才是连续，其他的方式不一定！此时一个函数的连续指的是函数怎么逼近都是连续）</p><h4 id="高阶偏导"><a href="#高阶偏导" class="headerlink" title="高阶偏导"></a>高阶偏导</h4><p>​        因为主元具有多样性：在二阶偏导中，有了：</p><script type="math/tex; mode=display">\frac{\partial^2 z}{\partial x^2}=z'_{xx}=f''_{xx}</script><script type="math/tex; mode=display">\frac{\partial^2 z}{\partial x\partial y}=z'_{xy}=f''_{xy}</script><script type="math/tex; mode=display">\frac{\partial^2 z}{\partial y\partial x}=z'_{yx}=f''_{yx}</script><script type="math/tex; mode=display">\frac{\partial^2 z}{\partial y^2}=z'_{yy}=f''_{yy}</script><p>​        注意到：中间两个我们先后对函数的不同变量求导，故称之为混合偏导：<strong>当函数连续的时候：$z’’_{xy}=z’’_{yx}$</strong></p><h3 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h3><h4 id="可微的定义"><a href="#可微的定义" class="headerlink" title="可微的定义"></a>可微的定义</h4><p>​        还是跟微分很是相似：$\Delta z_x=f(x_0+\Delta x,y_0)-f(x_0,y_0)$是对X的偏增量，$\Delta z_y=f(x_0,y_0+\Delta y)-f(x_0,y_0)$是对Y的偏增量。现在，我们让两个都变：这就是全微分</p><script type="math/tex; mode=display">\Delta z=f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)</script><p>​        定义：如果这个$\Delta z=A\Delta x+B\Delta y+o(\rho)$其中A，B还是跟增量无关的一个函数，随后就会有：</p><script type="math/tex; mode=display">dz=A\Delta x+B\Delta y</script><h4 id="可微的必要条件"><a href="#可微的必要条件" class="headerlink" title="可微的必要条件"></a>可微的必要条件</h4><p>​        <strong>定理：若z=f(x,y)在点( x,y )处可微，则偏导数$f’_x(x,y),f’_y(x,y)$存在且：</strong></p><script type="math/tex; mode=display">dz=f'_x(x,y)\Delta x+f'_y(x,y)\Delta y</script><p>​        还是跟上一个一样：偏导数只是说明了一个方向上可微，其他的不一定。</p><h4 id="可微的充分条件"><a href="#可微的充分条件" class="headerlink" title="可微的充分条件"></a>可微的充分条件</h4><p>​        如果：$f(x,y)$在(x,y)的某一个领域内有连续的偏导数$f’_x(x,y),f’_y(x,y)$那就说明（x,y）是可微的：</p><script type="math/tex; mode=display">dz=d_xz+d_yz</script><h3 id="求导法则"><a href="#求导法则" class="headerlink" title="求导法则"></a>求导法则</h3><p>​        现在事情准备复杂起来！我们利用链式求导法则</p><p>​        情况1：$z=f(u,v),u=\phi(t),v=\varphi(t)$求导！</p><p>​        注意，跟复合类似，结合我们之前的固有经验：</p><script type="math/tex; mode=display">\frac{dz}{dt}=\frac{\partial z}{\partial u}\cdot\frac{du}{dt}+\frac{\partial z}{\partial v}\cdot\frac{dv}{dt}</script><p>​        </p><p><img src="image-20230209185128299.png" alt="image-20230209185128299"></p><p>​        情况2：$z=f(u,v),u=\phi(x,y),v=\varphi(x,y)$求导</p><script type="math/tex; mode=display">\frac{dz}{\partial x}=\frac{\partial z}{\partial u}\cdot\frac{du}{dx}+\frac{\partial z}{\partial v}\cdot\frac{dv}{dx}\\\frac{\partial z}{\partial y}=\frac{\partial z}{\partial u}\cdot\frac{du}{dx}+\frac{\partial z}{\partial v}\cdot\frac{dv}{dy}</script><p><img src="image-20230209185348990.png" alt="image-20230209185348990"></p><p>​        情况3：$z=f(u,v,w),u=\phi(x,y),v=\varphi(x,y),w=\omega(x,y)$</p><script type="math/tex; mode=display">\frac{dz}{\partial x}=\frac{\partial z}{\partial u}\cdot\frac{du}{dx}+\frac{\partial z}{\partial v}\cdot\frac{dv}{dx}+\frac{\partial z}{\partial w}\cdot\frac{dw}{dx}\\\frac{\partial z}{\partial y}=\frac{\partial z}{\partial u}\cdot\frac{du}{dx}+\frac{\partial z}{\partial v}\cdot\frac{dv}{dy}+\frac{\partial z}{\partial w}\cdot\frac{dw}{dy}</script><p><img src="image-20230209185641030.png" alt="image-20230209185641030"></p><p>​        情况4：$z=f(u,x,y),u=\varphi(x,y)$</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}=\frac{\partial z}{\partial u}\cdot\frac{\partial u}{\partial x}+\frac{\partial f}{\partial x}\\\frac{\partial z}{\partial y}=\frac{\partial z}{\partial u}\cdot\frac{\partial u}{\partial y}+\frac{\partial f}{\partial y}</script><p><img src="image-20230209185926111.png" alt="image-20230209185926111"></p><p>​        例子：$z=e^u \sin v , u=xy , v=x+y$</p><p>$解: \frac{\partial z}{\partial x}=e^u\cdot \sin v\cdot y+e^u\cos v=e^{xy}\sin(x+y)y+e^{xy}\cos(x+y)\\<br>\frac{\partial z}{\partial x}=e^u\cdot \sin v\cdot x+e^u\cos v=e^{xy}\sin(x+y)x+e^{xy}\cos(x+y)$</p><h3 id="隐函数的求导公式"><a href="#隐函数的求导公式" class="headerlink" title="隐函数的求导公式"></a>隐函数的求导公式</h3><p>​        对于$F(x,y)=0$这个方程：</p><script type="math/tex; mode=display">当:F(x_0,y_0)=0,F_y'(x_0,y_0)\neq 0 \\\frac{dy}{dx}=-\frac{F_x'}{F_y'}</script><p>​        对于 $F(x,y,z)=0,F’_z(x_0,y_0,z_0)\neq 0$</p><script type="math/tex; mode=display">\frac{\partial z}{\partial x}=-\frac{F_x'}{F'_z}\\\frac{\partial z}{\partial y}=-\frac{F_y'}{F'_z}</script><p>​        对于方程组的情况</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}F(x,y,u,v)& = & 0 \\G(x,y,u,v)& = & 0 \\\end{aligned}\right.\end{equation}</script><p>​            稍微复杂一点：</p><p>​        定义Jacobi行列式：</p><script type="math/tex; mode=display">J=\frac{\partial(F,G)}{\partial(u,v)}=\left | \begin{matrix}\frac{\partial F}{\partial u}  \frac{\partial F}{\partial v} \\ \frac{\partial G}{\partial u}\frac{\partial G}{\partial v}\end{matrix} \right |</script><script type="math/tex; mode=display">\frac{\partial u}{\partial x}=-\frac{1}{J}\frac{\partial(F,G)}{\partial(x,v)}=-\frac{\left | \begin{matrix}\frac{\partial F}{\partial x}  \frac{\partial F}{\partial v} \\ \frac{\partial G}{\partial x}\frac{\partial G}{\partial v}\end{matrix} \right |}{\left | \begin{matrix}\frac{\partial F}{\partial u}  \frac{\partial F}{\partial v} \\ \frac{\partial G}{\partial u}\frac{\partial G}{\partial v}\end{matrix} \right |}</script><p>​        其他类比</p><p>​        由线性代数里的克莱默法则推出。但是太难背了！我们可以直接对方程求导，然后解方程组就好了</p><p><img src="image-20230209195732899.png" alt="image-20230209195732899"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言常用函数（1）string.h系列</title>
      <link href="/2023/02/09/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89string-h%E7%B3%BB%E5%88%97/"/>
      <url>/2023/02/09/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89string-h%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="string-h常用API-一览"><a href="#string-h常用API-一览" class="headerlink" title="string.h常用API 一览"></a>string.h常用API 一览</h1><h2 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h2><p>​    </p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;string.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个东西，我想学习过C语言的都不陌生。这里我们拿出来一些常见的，有用的函数来仔细讲讲，仔细学学！</p><h3 id="strcpy-amp-amp-strcat"><a href="#strcpy-amp-amp-strcat" class="headerlink" title="strcpy&amp;&amp;strcat"></a>strcpy&amp;&amp;strcat</h3><p>​        我们首先来看看strcpy: 他就是 string copy的简写 而strcat可以看作string concatenates的缩写：这里先放一下官方对这两个函数的解释（水字数（划））</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;****strcat.c - contains strcat() and strcpy()**       Copyright (c) Microsoft Corporation. All rights reserved.**Purpose:*       Strcpy() copies one string onto another.&#x2F;&#x2F;拷贝字符串**       Strcat() concatenates (appends) a copy of the source string to the*       end of the destination string, returning the destination string.&#x2F;&#x2F;追加字符串********************************************************************************&#x2F;#include &lt;string.h&gt;&#x2F;&#x2F; 引入定义的头文件&#x2F;&#x2F;无需理睬这里#ifndef _MBSCAT    #pragma function(strcat, strcpy)#endif&#x2F;&#x2F;&#x2F;****char *strcat(dst, src) - concatenate (append) one string to another**Purpose:*       Concatenates src onto the end of dest.  Assumes enough*       space in dest.&#x2F;&#x2F;这个 Assumptions相当有趣，它忽视了字符串可能发生上溢的风险*&#x2F;&#x2F;转而交给专门检查这个并抛出相关错误的函数来干*Entry:*       char *dst - string to which &quot;src&quot; is to be appended*       const char *src - string to be appended to the end of &quot;dst&quot;**Exit:*       The address of &quot;dst&quot; &#x2F;&#x2F;返回被追加字符串的首地址，便于我们访问**Exceptions:********************************************************************************&#x2F;char * __cdecl strcat (        char * dst, &#x2F;&#x2F; 目标要被写入，就必须不加 const，否则会报错        const char * src &#x2F;&#x2F; 源头不能改，加 const        )&#123;    &#x2F;&#x2F; 先取到首地址，防止改动 dst 导致被追加字符串无法访问        char * cp &#x3D; dst;        while( *cp )                cp++;                   &#x2F;* find end of dst *&#x2F;        while((*cp++ &#x3D; *src++) !&#x3D; &#39;\0&#39;) ;       &#x2F;* Copy src to end of dst *&#x2F;        return( dst );                  &#x2F;* return dst *&#x2F;&#125;&#x2F;****char *strcpy(dst, src) - copy one string over another**Purpose:*       Copies the string src into the spot specified by*       dest; assumes enough room.**Entry:*       char * dst - string over which &quot;src&quot; is to be copied*       const char * src - string to be copied over &quot;dst&quot;**Exit:*       The address of &quot;dst&quot;**Exceptions:*******************************************************************************&#x2F;char * __cdecl strcpy(char * dst, const char * src)&#123;        char * cp &#x3D; dst;        while((*cp++ &#x3D; *src++) !&#x3D; &#39;\0&#39;)                ;               &#x2F;* Copy src over dst *&#x2F;        return( dst );&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        水完了，但是仔细看看，却发现信息量很大！我们首先从 直接拷贝 说起：</p><h4 id="strcpy-直接拷贝"><a href="#strcpy-直接拷贝" class="headerlink" title="strcpy 直接拷贝"></a>strcpy 直接拷贝</h4><p>​        strcpy函数是一个直接从资源（拷贝）字符串中拿取信息扔到另一个字符串里，从实现上我们一眼看出了这个函数<strong>会覆盖目的地字符串的信息</strong>! </p><p>​        问题来了，我们怎样理解这段代码？或者说：当我们也要自己实现一个搬运信息的函数的时候，怎样实现一个跟库里一样简洁的函数呢？</p><p>​        首先，我们的思路就是：</p><p>​        1）确定函数的参数列表，返回类型！ <strong>参数根据问题来看：从哪里拷贝？拷贝到哪里？</strong> 返回类型？好像一眨眼看，不需要返回什么（因为我们可以拿起目的地字符串指针），于是：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void myStrCpy(char* dest , char* src)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        接下来，就是拷贝工作了！为了访问数据， 在C语言中 ，除了使用下标访问，我们还可以使用指针 ：定义两个指针出来，开始拷贝！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* p_Dest &#x3D; dest ; &#x2F;&#x2F;我们当然可以这么做！数组名表示首元素地址！char* p_Src &#x3D; src ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        然后呢？我们开始拷贝：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">*p_Dest &#x3D; *p_Src ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        不对啊！拷贝完第一个，咱们还要拷贝下一个啊！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">p_Dest++;p_Src++ ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        然后重复工作！很明了了，我们使用while循环</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while( &#x2F;* Still Unknown *&#x2F;)&#123;    *p_Dest &#x3D; *p_Src ; &#x2F;&#x2F;拷贝    p_Dest++; &#x2F;&#x2F;移动指针p_Src++ ; &#x2F;&#x2F;移动指针&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        怎么停下来？好说！ source拷完了停下来嘛！怎么看 source 拷没拷完？字符串终结的标志，是<code>\0</code> 那就简单了： Src指针走向 \0的时候，我就让 while 循环停下来嘛！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while (p_Src !&#x3D; &#39;\0&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230209163006541.png" alt="image-20230209163006541"></p><p>​        如上图所示，拷贝完，就移动指针到下一个！周而复始直到 lol拷贝完毕 p_Src 指向 ‘\0’结束拷贝！</p><p>​        就这样完事了？看看打印出来了什么东西？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void myStrCpy(char* dest , char* src)&#123;    char* p_Dest &#x3D; dest ; &#x2F;&#x2F;我们当然可以这么做！数组名表示首元素地址！char* p_Src &#x3D; src ;    while( p_Src !&#x3D; &#39;\0&#39;)&#123;    *p_Dest &#x3D; *p_Src ; &#x2F;&#x2F;拷贝    p_Dest++; &#x2F;&#x2F;移动指针p_Src++ ; &#x2F;&#x2F;移动指针&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230209163254267.png" alt="image-20230209163254267"></p><p>​        挺符合逻辑，所以，敢这样就拍马屁走人了，那就很遗憾了：</p><p><img src="image-20230209163516376.png" alt="image-20230209163516376"></p><p>​        我们的函数，只要在这个环境下工作，马上就会出问题！你猜猜为什么呢？当然是没有’\0’啦！，因为我们的函数逻辑是遇到’\0’就停，‘\0’没有被拷贝就走了！自然我们的打印函数就要跑遍满内存去找你那\0!</p><p>​        我们手动放上一个斜杠0不就好了嘛？</p><p><img src="image-20230209163936912.png" alt="image-20230209163936912"></p><p>​        加上句话就好了！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">p_Dest &#x3D; &#39;\0&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        但是好啰嗦啊，可以自己看看：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void myStrCpy(char* dest , char* src)&#123;    char* p_Dest &#x3D; dest ; &#x2F;&#x2F;我们当然可以这么做！数组名表示首元素地址！char* p_Src &#x3D; src ;    while( p_Src !&#x3D; &#39;\0&#39;)&#123;    *p_Dest &#x3D; *p_Src ; &#x2F;&#x2F;拷贝    p_Dest++; &#x2F;&#x2F;移动指针p_Src++ ; &#x2F;&#x2F;移动指针&#125;    p_Dest &#x3D; &#39;\0&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        开始化简，写高质量代码！</p><p>​        首先想一件事情： 我们有没有必要，整出来一个char<em> p_Src = src ？<strong>没有必要</strong>！因为我们在这里只是对他访问信息，<em>*不做改动</em></em>！马上，我们有两个点可以改动！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;1 原则1： 不改动的一律使用 const 修饰符提高程序安全&#x2F;&#x2F;2 原则2： 减少声明过多的累赘的变量！void myStrCpy(char* dest , const char* src) &#x2F;&#x2F; 1. Change 1&#123;     char* p_Dest &#x3D; dest ; &#x2F;&#x2F;我们当然可以这么做！数组名表示首元素地址！    while( *src !&#x3D; &#39;\0&#39;)&#123;    *p_Dest &#x3D; *p_Src ; &#x2F;&#x2F;拷贝    p_Dest++; &#x2F;&#x2F;移动指针&#125;    p_Dest &#x3D; &#39;\0&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        同时，我们希望可以让程序有更好的扩展性，我们可以修改返回类型，使之可以产生链式编程的效果（在C++中重载 + 等运算符尤为常见的思想），就是返回本身：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* myStrCpy(char* dest , const char* src) &#x2F;&#x2F; 1. Change 1&#123;     char* p_Dest &#x3D; dest ; &#x2F;&#x2F;我们当然可以这么做！数组名表示首元素地址！    while( *src !&#x3D; &#39;\0&#39;)&#123;    *p_Dest &#x3D; *p_Src ; &#x2F;&#x2F;拷贝    p_Dest++; &#x2F;&#x2F;移动指针&#125;    p_Dest &#x3D; &#39;\0&#39;;    return dest ; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        到这里，作为一个良好的编程人已经可以高喊下班了，但是再看看 ，可不可以偷懒，让程序再简洁一些呢？当然可以！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">1.    while循环里使之终止的值为 零，包括：(int)0,&#39;\0&#39;,false , NULL((void*)0)2.表达式产出的结果可以直接放进while循环里做判断，基于此，我们可以化简程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* myStrCpy(char* dest , const char* src)&#123;        char* p_Dest &#x3D; dest;        while(        (            *src++ &#x3D; *p_Dest++ &#x2F;&#x2F;各自赋值，然后指针移动        )         !&#x3D; &#39;\0&#39; &#x2F;&#x2F; 产生的值，就是赋予的东西跟 \0 比较，如果是我们就暂停         )        ; &#x2F;&#x2F; just copy    return dest ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在我们的实现就跟库完全一致了！</p><h4 id="strcat-追加字符串"><a href="#strcat-追加字符串" class="headerlink" title="strcat 追加字符串"></a>strcat 追加字符串</h4><p>​        不同于直接拷贝，咱们这个是追加上去的，什么是追加？就是在屁股后面直接跟上字符串：比如说： str 追加一个 str——<code>&gt;</code> strstr 。我们已经讲过了最为基础的拷贝，具体有关拷贝和移动细节，不在过多的讲了。原型一样的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* myStrCat(char* dest ,const char* src)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        思路是简单的，追加分成 1）追 2）加 两个部分！</p><p>​        先追：到目标地点字符串的最后面：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* p_Dest &#x3D; dest ;while( *p_Dest ) &#x2F;&#x2F;while循环里使之终止的值为 零，包括：(int)0,&#39;\0&#39;,false , NULL    p_Dest ++ ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        再拷贝：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while((            *src++ &#x3D; *p_Dest++ &#x2F;&#x2F;各自赋值，然后指针移动        )         !&#x3D; &#39;\0&#39; &#x2F;&#x2F; 产生的值，就是赋予的东西跟 \0 比较，如果是我们就暂停      )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        再返回：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">return dest;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        就是多了一个追加的过程！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char* myStrCat(char* dest ,const char* src)&#123;    char* p_Dest &#x3D; dest ;    while( *p_Dest ) &#x2F;&#x2F;while循环里使之终止的值为 零，包括：(int)0,&#39;\0&#39;,false , NULL   p_Dest ++ ;        while((            *src++ &#x3D; *p_Dest++ &#x2F;&#x2F;各自赋值，然后指针移动         )          !&#x3D; &#39;\0&#39; &#x2F;&#x2F; 产生的值，就是赋予的东西跟 \0 比较，如果是我们就暂停      )      return dest;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="strcmp比较函数"><a href="#strcmp比较函数" class="headerlink" title="strcmp比较函数"></a>strcmp比较函数</h3><p>​        这个有意思，我们拿他来比较两个字符串 ， 在经典Windows ，Linux文件索引排序的时候，都是使用这样的strcmp决定谁先谁后，注意的是，我们比较的，是ASCII码值的大小，这跟char的特性密切相关（ASCII规定使用一字节二进制数表示一个字符）。Anyway , 看看C库开发者怎么说</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;****strcmp.c - routine to compare two strings (for equal, less, or greater)**       Copyright (c) Microsoft Corporation. All rights reserved.**Purpose:*       Compares two string, determining their ordinal order.********************************************************************************&#x2F;#include &lt;string.h&gt;#pragma function(strcmp)&#x2F;****strcmp - compare two strings, returning less than, equal to, or greater than**Purpose:*       STRCMP compares two strings and returns an integer*       to indicate whether the first is less than the second, the two are*       equal, or whether the first is greater than the second.**       Comparison is done byte by byte on an UNSIGNED basis, which is to*       say that Null (0) is less than any other character (1-255).**Entry:*       const char * src - string for left-hand side of comparison*       const char * dst - string for right-hand side of comparison**Exit:*       returns -1 if src &lt;  dst*       returns  0 if src &#x3D;&#x3D; dst*       returns +1 if src &gt;  dst**Exceptions:********************************************************************************&#x2F;int __cdecl strcmp (        const char * src,        const char * dst        )&#123;        int ret &#x3D; 0 ;        while((ret &#x3D; *(unsigned char *)src - *(unsigned char *)dst) &#x3D;&#x3D; 0 &amp;&amp; *dst)                &#123;                ++src, ++dst;                &#125;&#x2F;&#x2F; what is fxxking this ???        return ((-ret) &lt; 0) - (ret &lt; 0); &#x2F;&#x2F; (if positive) - (if negative) generates branchless code&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我打赌你肯定看不懂了哈哈，没关系。我们先来理解原理！</p><p>​        上面我强调，我们比的，是一个字符一个字符的ASCII值。如果两个字符的ASCII值不一样，说明一个问题：这两个字符串不一样！那就好说了！如果两个字符串长度不一样，我们直接就认为两个字符串不相等（触犯了<em>str1 == </em>str2,因为‘\0’一定不等于另一个未完结字符串的内容）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while( *str1 &#x3D;&#x3D; *str2 &amp;&amp; &#x2F;* Must have other conditions...*&#x2F;)&#123;    str1++;    str2++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        当然。。。截至判断必须要有：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">while( *str1 &#x3D;&#x3D; *str2 &amp;&amp; *str1 !&#x3D; &#39;\0&#39; &amp;&amp; *str2 !&#x3D; &#39;\0&#39;)&#123;    str1++;    str2++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        返回什么？其实，标准库有两种返回！我们先来看第一种：</p><pre class="line-numbers language-none"><code class="language-none">ASCII小的返回-1 ， ASCII 完全一致的返回 0 ，大的返回 1！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        那简单！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if( *str1 &lt; *str2) return -1;else if( *str1 &#x3D;&#x3D; *str2 )     return 0;else      return 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不错，还有一种直接返回他们的差</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">return *str1 - *str2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        能不能骚一点？咱们的 <code>if-else if - else</code>写的太捞了！让我们一行代码搞定？可以！</p><p>​        首先来看一件事！这个差是怎样的，可以跟 0 比较！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int ret &#x3D; *str1 - *str2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">ret &lt; 0 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个式子返回1，反之如果不成立，就返回0！</p><p>​        现在，我们这样来看！ ret要不小于0，要不大于0 要不等于0  -ret更是如此：如果我们的表达式产出的布尔值，无非就是这样的：</p><div class="table-container"><table><thead><tr><th>ret</th><th>&gt;0</th><th>=0</th><th>&lt;0</th></tr></thead><tbody><tr><td>-ret&lt;0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>ret&lt;0</td><td>0</td><td>0</td><td>1</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><p>​        很好！现在我们来看，如果把这两行的值相减！不久达到了我们的目的吗！</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">-</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        再把<code>int ret = *str1 - *str2</code>带入</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">return (-(*str1 - *str2) &lt; 0)- ((*str1 - *str2) &lt; 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        完事！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int myStrCmp(const char* str1, const char* str2) &#123;    while (*str1 !&#x3D; &#39;\0&#39; &amp;&amp; *str2 !&#x3D; &#39;\0&#39;&amp;&amp;*str1&#x3D;&#x3D;*str2) &#123;        str1++;        str2++;    &#125;    return (-(*str1 - *str2) &lt; 0)- ((*str1 - *str2) &lt; 0);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="memory-h"><a href="#memory-h" class="headerlink" title="memory.h"></a>memory.h</h3><p>注意，在这里我不打算放出源码，作为C语言里几乎可以说是最底层的头文件，不打算让你去看大量的汇编代码，那没意思！但是，我们可以了解一些常用的API</p><h4 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h4><p>​        memory copy的简写！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void* memcpy(void *dest, const void *src, size_t n) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        参数？作为直接操作内存块的函数，我们的接受类型必须是<code>void*</code>!同时，看const修饰的位置我们也知道，dest是写入内存的地方，另一个是资源区块!</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;this is a example shows that memcpy can copy things whatever it is!int main()&#123;    &#x2F;&#x2F;可以拷贝内置数据类型    int src1 &#x3D; 10;int* dest1 &#x3D; (int*)malloc(4);if (dest1 &#x3D;&#x3D; NULL) &#123;return;&#125;memcpy(dest1, &amp;src1, 4);printf(&quot;%d &quot;, *dest1);        &#x2F;&#x2F;可以拷贝自定义的内容typedef struct student_ &#123;int age;char* name;&#125;student;student s1;s1.age &#x3D; 18;s1.name &#x3D; &quot;charliechen&quot;;student* s_copy &#x3D; (student*)malloc(sizeof(student));memcpy(s_copy, &amp;s1, sizeof(student));printf(&quot;%d %s&quot;, s_copy-&gt;age, s_copy-&gt;name);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230209181211552.png" alt="image-20230209181211552"></p><h4 id="memmove"><a href="#memmove" class="headerlink" title="memmove"></a>memmove</h4><p>​        这个函数解决了资源与拷贝区重叠的问题：</p><p>​        对于memmove，即使内容有重叠，src的内容也可以正确地被拷贝到了dest指向的空间。</p><p><img src="1.png" alt="1"></p><p>​                                                                    内存重叠的拷贝</p><p>​        这种情况下，src的地址小于dest的地址，拷贝前3个字节没问题，但是拷贝第4，5个字节时，原有的内容已经被src拷贝过来的字符覆盖了，所以已经丢失原来src的内容，这很明显就是问题所在。所以，对于正常情况下，优先使用memmove防止出现未定义行为，其他的跟memcpy完全一致！</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C extension Learning （1） 位运算符，逻辑运算符和简单应用</title>
      <link href="/2023/02/09/C-extension-Learning-%EF%BC%881%EF%BC%89-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
      <url>/2023/02/09/C-extension-Learning-%EF%BC%881%EF%BC%89-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言扩展1："><a href="#C语言扩展1：" class="headerlink" title="C语言扩展1："></a>C语言扩展1：</h1><h2 id="位运算符与逻辑运算符"><a href="#位运算符与逻辑运算符" class="headerlink" title="位运算符与逻辑运算符"></a>位运算符与逻辑运算符</h2><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><h4 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h4><p>​        C语言中的位运算符有下面几个：</p><p>1）与 ： &amp;;</p><p>2）或：|；</p><p>3）异或： ^;</p><p>4）取反 ：~;</p><p>5）左移 :&lt;&lt; ;</p><p>6）右移： &gt;&gt; ;</p><p>​        范例：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int main()&#123;    int a &#x3D; 0b1001; &#x2F;&#x2F; 二进制写法：十进制下是：9    int b &#x3D; 0b0011; &#x2F;&#x2F; 二进制写法：十进制下是：3    int and_res &#x3D; a &amp; b; &#x2F;&#x2F;与    int or_res &#x3D; a | b; &#x2F;&#x2F;或    int xor_res &#x3D; a^b; &#x2F;&#x2F;异或    int opp_res_a &#x3D; ~a; &#x2F;&#x2F;取反    int leftMoveRes &#x3D; a &lt;&lt; 1; &#x2F;&#x2F; 左移一位 得到的结果应当是 0b10010 (18)    int rightMovRes &#x3D; a &gt;&gt; 1; &#x2F;&#x2F; 右移一位 得到的结果应当是 0b00100 (4)  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意：这样的一些运算符只能用在整数上：比如说带符号或无符号的char,short,int与long类型上！不可以用在比如说浮点型和其他类型上：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int a &#x3D; 0b0011 &amp; 0b1100; &#x2F;&#x2F; Legaldouble d &#x3D; 10 ;double e &#x3D; d &amp; 0b1100 ; &#x2F;&#x2F; Sadly illegal <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230209120334081.png" alt="Clion下的报错"></p><p>​        再引入具体概念之前，请先让我们来看一个函数：</p><h3 id="Itoa函数"><a href="#Itoa函数" class="headerlink" title="Itoa函数"></a>Itoa函数</h3><p>​        我们知道，在C语言里，在 printf 中，只可打印八进制位( %o )，十进制位（ %d ）,和十六进制位（ %x ）。想要打印 二进制位 ，我们可以自己手搓一个，但是那没必要！我们可以导入库里的函数 itoa 函数 ： 他需要一个 char 的数组来存放结果 ：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123;    char result[100] &#x3D; &#123;0&#125;;    int d &#x3D; 10;    itoa(d , result , 2);&#x2F;&#x2F; itoa 函数参数列表：待转化数 ， 字符数组 ， 进制     printf(&quot;%s&quot;,result);&#x2F;&#x2F; 1010&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>     这样我们就很方便的查看结果了！</code></pre><h3 id="运算符详解"><a href="#运算符详解" class="headerlink" title="运算符详解"></a>运算符详解</h3><p>​        我们回想一下计算机科学里对按位与运算 &amp;，按位或运算 |，按位异或运算 ^，按位非（取反） ~，左移 &lt;&lt;，右移 &gt;&gt;里的概念。他们分别是：</p><h4 id="按位与运算-amp"><a href="#按位与运算-amp" class="headerlink" title="按位与运算 &amp;"></a>按位与运算 &amp;</h4><p>​        如果两个相应的二进制位都为1，则该位的结果值为1，否则为0。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char result[40] &#x3D; &#123;0&#125;;int n1 , n2 ;n1 &#x3D; 0b0000; n2 &#x3D; 0b0001 ; &#x2F;&#x2F; 0000 &amp; 0001 -&gt; 0000itoa(n1 &amp; n2 , result , 2);printf(&quot;%s &quot;, result);n1 &#x3D; 0b0001; &#x2F;&#x2F; 0001 &amp; 0001 -&gt; 0001itoa(n1 &amp; n2 , result , 2);printf(&quot;%s &quot;, result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230209133854965.png" alt="image-20230209133854965"></p><h4 id="按位或运算"><a href="#按位或运算" class="headerlink" title="按位或运算 |"></a>按位或运算 |</h4><p>如果两个相应的二进制位中只要有一个1，则该位的结果值为1，否则为0。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char result[40] &#x3D; &#123;0&#125;;int n1 , n2 ;n1 &#x3D; 0b0000; n2 &#x3D; 0b0001 ; &#x2F;&#x2F; 0000 | 0001 -&gt; 0001itoa(n1 | n2 , result , 2);printf(&quot;%s &quot;, result);n2 &#x3D; 0b0000; &#x2F;&#x2F; 0000 | 0000 -&gt; 0001itoa(n1 | n2 , result , 2);printf(&quot;%s &quot;, result);n1 &#x3D; 0b0001;n2 &#x3D; 0b0001;itoa(n1 | n2 , result , 2);printf(&quot;%s &quot;, result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230209134207600.png" alt="image-20230209134207600"></p><h4 id="按位异或运算"><a href="#按位异或运算" class="headerlink" title="按位异或运算 ^"></a>按位异或运算 ^</h4><p>如果两个相应的二进制位相同，则该位的结果值为0，否则为1。（但是最高位之外的0）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char result[40] &#x3D; &#123;0&#125;;int n1 , n2 ;int n1 &#x3D; 0b001100 , n2 &#x3D; 0b001111; &#x2F;&#x2F; 0b000011itoa(n1 ^ n2 , result , 10);printf(&quot;%s &quot;, result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230209134501422.png" alt="image-20230209134501422"></p><h4 id="按位非（取反）"><a href="#按位非（取反）" class="headerlink" title="按位非（取反） ~"></a>按位非（取反） ~</h4><p><strong>~</strong> 是一元运算符，用来对二进制数按位取反，即将0变1，将1变0。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char result[40] &#x3D; &#123;0&#125; ;int n1 &#x3D; 0b00001;&#x2F;&#x2F; 1111111111111111111...1110 int n2 &#x3D; ~n1;itoa(n2 , result , 2);printf(&quot;%s &quot;, result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230209135537488.png" alt="image-20230209135537488"></p><h4 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h4><p>将一个数的各二进制位全部左移N位，右补0，即将一个数乘2^n;说白了</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char result[40] &#x3D; &#123;0&#125; ;int n1 , n2 ;n1 &#x3D; 0b0001 ;n2 &#x3D; n1 &lt;&lt; 1 ; &#x2F;&#x2F; 左移 1 位itoa(n2,result,2);printf(&quot;%s &quot;,result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230209140613467.png" alt="image-20230209140613467"></p><h4 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h4><p>将一个数的各二进制位全部右移N位，移到右端的低位被舍弃，即将一个整数型除2^n;</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">char result[40] &#x3D; &#123;0&#125; ;int n1 , n2 ;n1 &#x3D; 0b0010 ;n2 &#x3D; n1 &gt;&gt; 1; &#x2F;&#x2F; 右移 1 位itoa(n2,result,2);printf(&quot;%s &quot;,result);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230209140838447.png" alt="image-20230209140838447"></p><p>注意：<strong>位运算符的操作数必须是整数类型，并且遵循寻常算术转换！寻常算术转换</strong>：如果 <strong>某个操作符</strong> 的各个操作数属于 <strong>不同的类型</strong> ，那么除非其中一个操作数 <strong>转换</strong> 为另一个操作数的类型，否则操作就无法进行。下面的层次体系称为 <strong>寻常算术转换</strong>。</p><p><img src="93e0b9f7c5054bfea4d8523fe1e58a22.jpeg" alt="img"></p><p>如果某个操作数的类型在上面这个列表中 <strong>排名较低</strong>，那么首先要转换为 <strong>另外一个操作数</strong> 的类型后 <strong>执行运算</strong>。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>​        三种运算符： 逻辑与:  &amp;&amp; 逻辑或 ： ||  逻辑非： ！</p><p>​        <code>&amp;&amp;</code>表示“与”的意思，需要两端的表达式的值都为true，该式的值才为true。<br>​        <code>||</code>表示“或”的意思，两端的表达式的值只要有一端为true，该式的值就为true。<br>​        <code>!</code>表示“非”的意思，将该式的真值换成相反的真值，即false和true互换。</p><p>​        <strong>使用&amp;&amp;时，如果左边false则右边不会执行，使用||时，如果左边true则右边不会执行</strong></p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    int a &#x3D; 0;    a &amp;&amp; a++; &#x2F;&#x2F; a为0 ，是假，那就 a++不执行    printf(&quot;%d &quot;, a);&#x2F;&#x2F;所以 a 还是 0！&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <img src="image-20230209142259608.png" alt="image-20230209142259608"></p><p>​        例子1 ：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; this is a test code of logical and , or as well as notint main()&#123;    int a &#x3D; -1, b &#x3D; 0 ;    if( a++ &amp;&amp; b++)&#123;        printf(&quot;%d %d&quot;,b , a);    &#125;    if( ++b &amp;&amp; ++a)&#123;         printf(&quot;%d %d&quot;, a , b);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        先定义变量<code>a=-1，b=0</code>，然后进入第一个<code>if()</code>判断，<code>&amp;&amp;</code>左边的值是<code>-1</code>，右边的值为<code>0</code>，所以此<code>if()</code>下的语句不执行。（<code>++</code>在后，先执行后<code>++</code>）</p><p>​        但是由于<code>&amp;&amp;</code>左侧为true，所以<code>&amp;&amp;</code>右侧的b++也会得到执行，此行结束时，a的值为0，b的值为1。第二次if()，左边的值为2，右边的值为1，所以<code>if()</code>下的语句得到执行，输出a的值1，b的值2。</p><p>​        例题2：请在不允许使用 乘除法，if, for ,else while等条件判断与循环语句下计算</p><script type="math/tex; mode=display">1+2+3+4+...+n</script><p>的值（选自 Leetcode）(数据在 1 $\leq$ n $\leq$ 10000下)</p><p>​        显然，我们只可以使用递归来解决我们的问题（递归策略是值将一个大问题逐步转化成同性质但是规模更小的小问题上）。问题来了，递归需要出口，我们有什么办法让递归停止呢？请看C99下逻辑运算符的特性：</p><p>​        我们只需要设计程序：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int returnSum(int n)&#123;int flag &#x3D; n &amp;&amp; (n+returnSum(n-1)); &#x2F;&#x2F;  其实 flag没什么用，这里是为了程序的可读性    return n;&#125;&#x2F;&#x2F;testint main()&#123;    int n &#x3D; 0;    while(~scanf(&quot;%d&quot;,&amp;n))        &#x2F;&#x2F;PS ：因为 scanf读取结束或者遇到错误(读到EOF)可以返回EOF：-1，取反就是0        printf(&quot;%d\n&quot;,returnSum(n));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据结构模拟（1）：动态数组API详解</title>
      <link href="/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84API%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84API%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="动态数组——API思路详解"><a href="#动态数组——API思路详解" class="headerlink" title="动态数组——API思路详解"></a>动态数组——API思路详解</h1><p>​        写在前面：这里是动态数组API简介：版本是v1.0.0!这篇API博客我写了4个小时，匆匆忙忙。但却是我第一个过一万字的博客！</p><p>​        我第一次手搓大型的小项目，也是我第一次单个程序突破1000行！这个前言就算小小的纪念一下这个成就吧！</p><p>​        鄙人编程年龄仅仅就7个月，还是一枚小白，这个项目里面肯定还有许多不足！如果你对它感兴趣！可以到我的GitHub上下载，测试！如果发现了Bug，麻烦及时反馈给我！（如果还有解决方案我会直接磕头叫声Daddy（逃））</p><p>​                                                                                                                                                                                        —-2023/2.7/21：47</p><h3 id="动态数组入门"><a href="#动态数组入门" class="headerlink" title="动态数组入门"></a>动态数组入门</h3><p>​        首先，作为入门级别的数据结构，我们毫无疑问的：这个数据结构必须满足增删查改！其中，增加就必须要有一个一个增加的，还有直接加入一大群的，删除也是如此。此外，这个数组可以查询是否有目标元素存在，这就需要我们也写一些相关的函数来支持我们的操作！就是这些，我们还可以为了使我们的打印更加清晰，（有点难过的是：C语言必须多增加一个参数来存放它，使得看起来相当的拥挤），可以自定义打印方式。事实上，这就是我们C++里面的vector容器（我就是想要复刻API哈哈哈）</p><p>​        我们的数据结构首先已经被框死：他是一个数组，存储的是相同类型的元素：要不全是整形，要不全是字符，要不全是指针，要么就是同一个类型的结构体！于是，我们不妨这样设想：他必须还是数组，那就说明内存的物理结构还是连续的，但是又要不停的扩展或者伸缩！那就把我们的数组（严肃的讲是静态数组）做一些改动，使之可以自由扩展不就好了嘛？这就需要我们使用头文件,来引入malloc函数群就好了</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;&#x2F;&#x2F;IO流交互#include&lt;stdlib.h&gt;&#x2F;&#x2F;标准库：里面有我们想要的函数#include&lt;string.h&gt;&#x2F;&#x2F;memory函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>基于上面的思路，我们很快就搓出来一个这个玩意：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()&#123;void* data &#x3D; NULL;    int current_size&#x3D;0;    &#x2F;&#x2F;...Do something and the size need to increase        data&#x3D;realloc(data,current_size+1);    current_size++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不错，这就是我们动态数组的雏形了！不过，这样散架着太捞了，后续也不好维护与处理。那很简单了：结构体用起来嘛！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _DynamicArray_ &#123;&#x2F;&#x2F;_HHH_是为了后续智能提示不会产生冲突void* DataPiece; &#x2F;&#x2F;连续内存块size_t current_size; &#x2F;&#x2F;当前的大小如何！不过，使用size_t其实更是说明我们的程序变量是非负的而已！&#125;DynamicArray;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        好像也不太好，我们后续要知道，访问起来是void*！这个特殊的指针不能帮我们锁定目标，是一个未确定类型的指针，所以。。。我们不妨加上一个常量，在数据首次入动态数组的时候直接将这样的值初始化！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _DynamicArray_ &#123;&#x2F;&#x2F;_HHH_是为了后续智能提示不会产生冲突void* DataPiece; &#x2F;&#x2F;连续内存块size_t current_size; &#x2F;&#x2F;当前的大小如何！不过，使用size_t其实更是说明我们的程序变量是非负的而已！size_t total_usable_size;&#x2F;&#x2F;用来调整数组的大小，同时又允许我们在一定范围内自由插入size_t Single_Data_size;&#x2F;&#x2F;相当于类型名了，这个数据在我们后面十分的重要&#125;DynamicArray;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，我想我们的动态数组就具有了极强的通用性：可以像一般的数组那样存储任何数据！</p><h3 id="工厂函数与基本调整函数系列"><a href="#工厂函数与基本调整函数系列" class="headerlink" title="工厂函数与基本调整函数系列"></a>工厂函数与基本调整函数系列</h3><p>​        什么是工厂函数？就是产生对象并且返回它供我们程序员使用的函数，比如说，C语言的malloc函数就是一个代表性的工厂函数。他返回一个任意大小的堆空间：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">(void*)malloc(bit_malloc)&#x2F;&#x2F;开辟多少字节自己制定，是一个操作性很强的函数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们的函数就必须使用它来开辟我们的内存：但是，直接让用户制定是麻烦的，极易出错的，所以：</p><h4 id="默认工厂函数"><a href="#默认工厂函数" class="headerlink" title="默认工厂函数"></a>默认工厂函数</h4><p>​        我们首先需要一个可以产生一个这样的结构体并且还要返回它的函数，为了初始化这样的结构体，我们需要知道我们要开辟多少个元素，元素多大，否则我们不会开辟。函数的原型可以轻而易举的给出：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* Init_A_DynamicArray(size_texpected_number, size_tdatasize);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        首先，作为动态数组，灵活性是重要的，用户（也就是咱们），往往压根就不知道我们会有多少个数据入列。于是，我们可能需要自己指定一个默认的大小，一旦我们的数据超过了指标，我们就马上调用一个自己手动写的函数，如你所见，就是这个功能的封装：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;...Do something and the size need to increase        data&#x3D;realloc(data,current_size+1);&#x2F;&#x2F; Adjustment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>来立马调用起来防止指针越界！我们稍后在调整函数里会再次阐述！回到初始化函数Init_A_DynamicArray上来！我们首先初始化一个结构体：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* pro_usable_space &#x3D; (DynamicArray*)malloc(sizeof(DynamicArray))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果屏幕前的你有一定编程经验，马上就会意识到如果仅是止步如此会大错特错！因为我们的malloc函数一旦开辟失败就会返回一个NULL指针，如果我们不对它进行空判断就会闹出程序崩溃的笑话，这里我们看到，一般的教程是直接这么写的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if(!pro_usable_space)&#123;  return;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        如果只是随意教教，这样写可以；工程开发中如此书写很不负责任！首先，我们的程序不可以直接return！后续我们的操作一旦再次拿起甚至时使用返回出去的NULL指针，马上又会闹起报错的笑话！既然如此，我们做一点报错友善处理！·</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if(pro_usable_space &#x3D;&#x3D; NULL)&#123;  printf(&quot;Sorry! Failed to malloc a new space! Program exits!&quot;);    exit(-1);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​         这样好些了！我们后续开发还会反复用到，何不直接使用宏定义直接节省反复车轮子的工作呢？还是相信智能提示的好！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;Sorry! Failed to malloc a new space! Program exits!&quot;) &#x2F;&#x2F;宏定义的重要作用之一：代替代码块#define DynamicArray_ERROR_IN_MALLOCING_SPACE 1 &#x2F;&#x2F;编写异常程序可以这样写，使之错误码和错误信息完全对应起来&#x2F;&#x2F;  Do Something ...     if(pro_usable_space &#x3D;&#x3D; NULL) &#123;  SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         随后顺手初始化，回到刚刚的问题，我们需要给数据结构一个默认的大小，我们不妨设置成5！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define Dyarr_DEFAULT_MALLOC 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">pro_usable_space-&gt;DataPiece &#x3D; NULL;&#x2F;&#x2F;赋予空指针，防止成为野指针修改其他内存块pro_usable_space-&gt;Single_Data_size &#x3D; datasize;&#x2F;&#x2F;初始化单位元素大小if (expected_number &gt;&#x3D; Dyarr_DEFAULT_MALLOC)&#x2F;&#x2F;大于默认的就用户指定的那个大小pro_usable_space-&gt;total_usable_size &#x3D; expected_number;elsepro_usable_space-&gt;total_usable_size &#x3D; Dyarr_DEFAULT_MALLOC;&#x2F;&#x2F;顺手处理异常的数字大小pro_usable_space-&gt;current_size &#x3D; 0;&#x2F;&#x2F;当下就没有元素在，赋0！return pro_usable_space;&#x2F;&#x2F;返回产生的堆区开辟的结构体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        有的时候我们可能需要直接拿起一个静态数组直接转化，很简单，我们可以这样写：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;int arr[10]&#x3D;&#123;1,2,3,4,5,6,7,8,9,10&#125;;    for(int i &#x3D; 0; i &lt; 10; i++)&#123;        &#x2F;&#x2F;插入    &#125;    &#x2F;&#x2F;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        但这样我们需要反复调用函数，导致程序性能很差，我们为什么不直接提供一个接口，一边创造结构体一边入列呢？</p><h4 id="升级工厂函数"><a href="#升级工厂函数" class="headerlink" title="升级工厂函数"></a>升级工厂函数</h4><p>​        很简单明了，我们的函数的原型是很容易想到的：你这个数组：是什么？（Single_Data_size），有多少个元素？（current_size），在哪里（Datapiece）的问题！我们产生的结构体还是要返回给用户使用的！</p><p>​        所以，我们的参数需要：数组地址（在哪里），数组元素大小（是什么），数组元素个数（有几个）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(void*data, size_tdatasize,size_tdatanum)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        注意，这个时候要多想！data会不会是空？我们是要看看的！类似的，我们再次构造一个错误码模块：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        之后的流程相比就很简单了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F;。。。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        Ok，到这里，我们要开始准备初始化了，不同于标准的，默认的工厂函数，我们这里直接就是有数据的！因此，需要直接开始拷贝！</p><p>​        <strong>注意：不建议直接把data的地址交给DataPiece直接托管！！！！！！！！！！！！之后的我们的操作可能会使数据抹除，但是DataPiece还记得，贸然的直接托管会导致非法访问内存！</strong></p><p>​        所以：我们单独为数据准备一块空间：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void* pro_usable_data &#x3D; malloc(datasize * datanum*1.5);&#x2F;&#x2F;预留一些空间if(!pro_usable_data)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        养成随手判断空的好习惯（乐）。</p><p>​        然后，拿出我们的memcpy，这是因为我们的数据可能啥都是，指定一个类型会使得我们的动态数组丧失通用性！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">memcpy(    pro_usable_data,     &#x2F;&#x2F;dst : 我们的预留空间    data,         &#x2F;&#x2F;rsc : 我们的来源：静态数组    datasize * datanum&#x2F;&#x2F;多大？很是显然！个数乘上大小      );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后初始化</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">pro_usable_space-&gt;DataPiece         &#x3D; pro_usable_data; &#x2F;&#x2F;将拷贝的空间交给dataPiece托管pro_usable_space-&gt;current_size      &#x3D; datanum;pro_usable_space-&gt;Single_Data_size  &#x3D; datasize;pro_usable_space-&gt;total_usable_size &#x3D; 1.5 * datanum;&#x2F;&#x2F;开辟多大就给多大return pro_usable_space;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="复制工厂函数"><a href="#复制工厂函数" class="headerlink" title="复制工厂函数"></a>复制工厂函数</h4><p>​            我们可以模仿C++ STL里面的复制构造：协同上面的升级函数一样，这里不过多的废话！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* Init_A_DynamicArray_by_CopyADyarr(DynamicArray*dyarr_copied)&#123;&#x2F;&#x2F;检查来源是否合法    if (!dyarr_copied)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;             &#x2F;&#x2F;准备空间并检查DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;    void* pro_usable_data &#x3D; MALLOCDYARR(        char, &#x2F;&#x2F;一个字节单位        (dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size)&#x2F;&#x2F;多大？还是一样嘛！    );if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;    &#x2F;&#x2F;拷贝数据pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;memcpy(        pro_usable_space-&gt;DataPiece, &#x2F;&#x2F;dst : 我们的预留空间        dyarr_copied-&gt;DataPiece, &#x2F;&#x2F; rsc: 来源：显然是被拷贝的dataPiece        dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size    );    &#x2F;&#x2F;初始化与托管数据pro_usable_space-&gt;current_size &#x3D; dyarr_copied-&gt;current_size;pro_usable_space-&gt;Single_Data_size &#x3D; dyarr_copied-&gt;Single_Data_size;pro_usable_space-&gt;total_usable_size &#x3D; dyarr_copied-&gt;total_usable_size;return pro_usable_space;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，我们的三个基本工厂函数已经做好：可以一览了</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;1 默认的工厂函数DynamicArray* Init_A_DynamicArray(size_texpected_number,size_tdatasize)&#123;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;pro_usable_space-&gt;DataPiece &#x3D; NULL;pro_usable_space-&gt;Single_Data_size &#x3D; datasize;if (expected_number &gt;&#x3D; Dyarr_DEFAULT_MALLOC)pro_usable_space-&gt;total_usable_size &#x3D; expected_number;elsepro_usable_space-&gt;total_usable_size &#x3D; Dyarr_DEFAULT_MALLOC;pro_usable_space-&gt;current_size &#x3D; 0;return pro_usable_space;&#125;&#x2F;&#x2F;2.拷贝工厂函数DynamicArray* Init_A_DynamicArray_by_CopyADyarr(DynamicArray*dyarr_copied)&#123;if (!dyarr_copied)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;void* pro_usable_data &#x3D; MALLOCDYARR(char, (dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size));if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;memcpy(pro_usable_space-&gt;DataPiece, dyarr_copied-&gt;DataPiece, dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size);pro_usable_space-&gt;current_size &#x3D; dyarr_copied-&gt;current_size;pro_usable_space-&gt;Single_Data_size &#x3D; dyarr_copied-&gt;Single_Data_size;pro_usable_space-&gt;total_usable_size &#x3D; dyarr_copied-&gt;total_usable_size;return pro_usable_space;&#125;&#x2F;&#x2F;3.升级工厂函数DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(void*data, size_tdatasize,size_tdatanum)&#123;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;void* pro_usable_data &#x3D; malloc(datasize * datanum*1.5);if(!pro_usable_data)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(pro_usable_data, data, datasize * datanum);pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;pro_usable_space-&gt;current_size &#x3D; datanum;pro_usable_space-&gt;Single_Data_size &#x3D; datasize;pro_usable_space-&gt;total_usable_size &#x3D; 1.5 * datanum;return pro_usable_space;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在我们已经有了基本的工厂函数，已经有了一个可以可以操作的对象了！不过，我们还提到，动态数组必须有必要的调整函数，防止大量的插入导致空间不足或者是删除导致大量的空间浪费！</p><h4 id="基本调整函数"><a href="#基本调整函数" class="headerlink" title="基本调整函数"></a>基本调整函数</h4><p>​        调整大小，我们首先要拿到希望调整的动态数组，以及我们想要调成多大！函数的原型，显然易见：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void Resize_The_Dynamic_Array(DynamicArray*dyarr,size_twished_new_space_size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        为了使程序更加健壮，我们还是返回一个NORMAL的FLAG值表示程序逻辑正常，从而更好的调整程序，这里，我先把enum列举列齐：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Error Code Meaning&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0&#x2F;&#x2F;When Error in mallocing Space the program return 1&#x2F;&#x2F;when inputing a NULL we returns -1&#x2F;&#x2F;when inputing a invalid input we returns -2&#x2F;&#x2F;Locations UnFind we returns -3 &#x2F;&#x2F;typedef enum _DynamicFunctionStatues_ &#123;DynamicArray_Normal &#x3D; 0,&#x2F;&#x2F;正常返回DynamicArray_ERROR_IN_MALLOCING_SPACE&#x3D;1,&#x2F;&#x2F;错误1：开辟空间失败DynamicArray_NULL_INPUT&#x3D;-1,&#x2F;&#x2F;错误-1：传入空值DynamicArray_Invalid_Input&#x3D;-2,&#x2F;&#x2F;错误-2： 传入不合法的值DynamicArray_UnFind&#x3D;-3, &#x2F;&#x2F;错误值-3 没有找到（后面没有使用，这里就算遗留了）DynamicArray_Invalid_Free&#x3D;-4&#x2F;&#x2F;错误值-4 不合法的释放，后面删减的时候会用到&#125;DynamicArrayFunctionStatues;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        以及错误提示宏：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define SHOW_ERROR_DynamicArray_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)#define SHOW_ERROR_DynamicArray_UnFind printf(&quot;\nPositions unfind!\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        其他所有的空返回函数全部就会升级成状态标识函数：只需要我们返回的是：DynamicArrayFunctionStatues枚举下的值（有点伤心，如果是C++11以上，我们可以使用Enum 作用域这个概念了）就好了。函数就改成了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Resize_The_Dynamic_Array(DynamicArray*dyarr,size_twished_new_space_size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这样，我们的框架又可以搭建起来了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Resize_The_Dynamic_Array(DynamicArray*dyarr,size_twished_new_space_size)&#123;    &#x2F;&#x2F;经典检查if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;    ...&#x2F;&#x2F;Do something     return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于调整函数，我们实际上就是在调整数组的堆空间，这下马上就知道函数的核心是什么了！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void* newspace &#x3D; realloc(dataPiece, new_size)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        不错，就是realloc函数！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;调整void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, wished_new_space_size * (dyarr-&gt;Single_Data_size));&#x2F;&#x2F;检查空间是否合法if (newspace &#x3D;&#x3D; NULL)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         然后就是托管，和调整结构体参数：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">dyarr-&gt;DataPiece &#x3D; newspace;&#x2F;&#x2F;空间托管dyarr-&gt;total_usable_size &#x3D; wished_new_space_size;&#x2F;&#x2F;调整usable space<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        别跑，还先别返回正常状态，我们想一个问题，万一，我们的函数当前数据大于了可用空间怎么办？既然是就想要这么多，我们何不妨：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (dyarr-&gt;current_size &gt; dyarr-&gt;total_usable_size)&#123;    dyarr-&gt;current_size &#x3D; dyarr-&gt;total_usable_size;&#x2F;&#x2F;调整至正好满溢的状态，后面的数据直接截断归还给操作系统&#125;&#x2F;&#x2F;Used when still unable to contain data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        活干完了，返回正常状态！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="总体一览工厂函数与基本调整函数："><a href="#总体一览工厂函数与基本调整函数：" class="headerlink" title="总体一览工厂函数与基本调整函数："></a>总体一览工厂函数与基本调整函数：</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Resize_The_Dynamic_Array(DynamicArray*dyarr,size_twished_new_space_size)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, wished_new_space_size * (dyarr-&gt;Single_Data_size));if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;total_usable_size &#x3D; wished_new_space_size;if (dyarr-&gt;current_size &gt; dyarr-&gt;total_usable_size)dyarr-&gt;current_size &#x3D; dyarr-&gt;total_usable_size;&#x2F;&#x2F;Used when still unable to contain datareturn DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="增（加）函数一览"><a href="#增（加）函数一览" class="headerlink" title="增（加）函数一览"></a>增（加）函数一览</h3><p>​        终于，我们可以进行增删查改了！先来看增函数！</p><p>​        增加：一个数据？一堆数据？是往后面加，还是插入式的加？这就引出了四个基本函数：我们先来最简单的追加一个数据！</p><h4 id="追加单个"><a href="#追加单个" class="headerlink" title="追加单个"></a>追加单个</h4><p>​        我们仔细问问自己，追加的数据，有多大？玩意要满溢了，要不要调整？OK！我们一个一个按照程序的进行考虑！首先思考函数的原型：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tdatasize);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        很容易想到吧！我们往哪里插入，插入什么！就是我们的参数列表吧！</p><p>​        好，检查来了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        完事了？肯定没有！我们试想一下，用户可能在不知情的情况下，传入一个完全不是本类型的数据进来：怎么办？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (sizeof(data) !&#x3D; dyarr-&gt;Single_Data_size) &#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        挺好，我们进一步想啊，数据进来了：万一溢出来，怎么办？</p><p>​        别怕，我们不是已经有了调整函数了嘛！调整一下就好了！（不过这里没有用，开销不必要）</p><p>​        现在，数据准备入列！我们准备一块空间：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void* Afteradd_piece &#x3D; realloc(    dyarr-&gt;DataPiece,     (dyarr-&gt;current_size + 1)*dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        入列咯！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;拷贝memcpy(       &#x2F;&#x2F;注意：我们插入到尾部：那就是第I-1的后面，(char*)Afteradd_piece + dyarr-&gt;current_size * dyarr-&gt;Single_Data_size, &#x2F;&#x2F;拷贝Data        data,        &#x2F;&#x2F;拷贝Single_Data_size大小，或者sizeof(data)，这个随意！dyarr-&gt;Single_Data_size);&#x2F;&#x2F;刷新结构体值dyarr-&gt;DataPiece &#x3D; Afteradd_piece;dyarr-&gt;current_size++;&#x2F;&#x2F;任务完成，返回状态Flagreturn DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="尾插多个数据函数1：尾插相同数据"><a href="#尾插多个数据函数1：尾插相同数据" class="headerlink" title="尾插多个数据函数1：尾插相同数据"></a>尾插多个数据函数1：尾插相同数据</h4><p>​        那插入一堆值，也是如此了！我们在尾插的时候，可以开发出来两个函数：一个是尾插一堆一样的值！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        一个是尾插一个数组，有点像Update升级函数了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data_array, size_tarray_num, size_tpos,size_tdata_inarray_size)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        一个个来！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;检查if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)    &#123;        &#x2F;&#x2F;先预备好空间，因为大量数据准备入场        Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面是扩展多大空间的问题：我们扩展是按照比例扩展的，那就需要计算比例：再传入调整函数！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)&#123;    Resize_The_Dynamic_Array(        dyarr,         (datarate + 1) * dyarr-&gt;total_usable_size    );&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        预留，托管和拷贝：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void* newspace &#x3D; realloc(    dyarr-&gt;DataPiece,     (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;for (int i &#x3D; 0; i &lt; n_repeat; i++)&#123;    &#x2F;&#x2F;逐个拷贝    memcpy(        &#x2F;&#x2F;插入到后面的第I+cur_size个位置上，第一个插入结束就要插入到后面一个(char*)newspace + (dyarr-&gt;current_size+i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);&#125;dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="尾插一个数组函数"><a href="#尾插一个数组函数" class="headerlink" title="尾插一个数组函数"></a>尾插一个数组函数</h4><p>​        而同类型的数组拷贝推入逻辑上是一样的：但是我们不得不遍历目标数组，再逐个插入</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data_array, size_tarray_num, size_tpos,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (data_inarray_size !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)&#123;        Resize_The_Dynamic_Array(            dyarr,             (DataRate + 1) * dyarr-&gt;total_usable_size        );    &#125;void* newspace &#x3D; realloc(        dyarr-&gt;DataPiece,         (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size    );if(!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece &#x3D; newspace;for (int i &#x3D; 0; i &lt; array_num; i++)memcpy(        &#x2F;&#x2F;插入到后面的第I+cur_size个位置上，第一个插入结束就要插入到后面一个(char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,        &#x2F;&#x2F;这个是数组的，写成&amp;data_array[i]也是无伤大雅的(char*)data_array + i * (dyarr-&gt;Single_Data_size),        &#x2F;&#x2F;拷贝的大小dyarr-&gt;Single_Data_size);    &#x2F;&#x2F;调整大小dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        下面就是有点难度的插入增函数了：我们这样想，我们需要把一个元素插入到目标动态数组的pos位置上。那：使用memmove把想要插入的位置后面的所有数据挪动一个元素大小的位置，那么，目标位置就空出来了一个位置虚以待坐了！前面的工作不再多说了：</p><h4 id="插入一个元素函数"><a href="#插入一个元素函数" class="headerlink" title="插入一个元素函数"></a>插入一个元素函数</h4><p>​        函数的原型：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data, size_tpos)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        检查：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * (dyarr-&gt;total_usable_size));void* Afteradd_piece&#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F;。。。    return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        OK，我们开始让后面的数据挪动他们的屁股！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">memcpy(    &#x2F;&#x2F;拷贝到pos+1位置处(char*)dyarr-&gt;DataPiece + (pos + 1) * dyarr-&gt;Single_Data_size,    &#x2F;&#x2F;从pos往后的数据(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,    &#x2F;&#x2F;大小计算是个数学问题：不过就是那种从i到j有几个数字的问题：j-i+1个！dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - pos + 1));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后把数据请进来：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">memmove((char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);dyarr-&gt;current_size++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         然后嘞：宣布我们干完活了！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="插入若干数据函数1：插入数组"><a href="#插入若干数据函数1：插入数组" class="headerlink" title="插入若干数据函数1：插入数组"></a>插入若干数据函数1：插入数组</h4><p>​        于是，插入一堆数据，还是一个原理的！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(DynamicArray*dyarr,size_tpos,void*data_array, size_tarray_num,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (!dyarr-&gt;current_size)&#123;Push_Back_Some_data_Into_A_Dynamic_Array(dyarr, data_array, array_num, pos,data_inarray_size);return DynamicArray_Normal;&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove(        &#x2F;&#x2F;预留array_num个位置(char*)dyarr-&gt;DataPiece + (pos + array_num) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*array_num);for (int i &#x3D; 0; i &lt; array_num; i++)memcpy(        &#x2F;&#x2F;从目标位往后拷贝(char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,        &#x2F;&#x2F;这个是数组的，写成&amp;data_array[i]也是无伤大雅的(char*)data_array + i * (dyarr-&gt;Single_Data_size),dyarr-&gt;Single_Data_size);dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="插入若干数据：相同数据"><a href="#插入若干数据：相同数据" class="headerlink" title="插入若干数据：相同数据"></a>插入若干数据：相同数据</h4><p>​        还是一样，直接上代码：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)&#x2F;&#x2F;DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize,size_tpos)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove((char*)dyarr-&gt;DataPiece + (pos + n_repeat) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * n_repeat);for (int i &#x3D; 0; i &lt; n_repeat; i++)memcpy((char*)newspace + (pos + i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拼接动态数组"><a href="#拼接动态数组" class="headerlink" title="拼接动态数组"></a>拼接动态数组</h4><p>​        欸嘿！我们可不可以拼接一下两个动态数组呢？可以啊！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues AppendByMergeDynamicArray(DynamicArray*dyarr_be_appended,DynamicArray*exp_append_array)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        这下很容易了：我们的dataPiece直接延后exp_append_array-&gt;current_size个，再拷贝就完事咯！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues AppendByMergeDynamicArray(DynamicArray*dyarr_be_appended,DynamicArray*exp_append_array)&#123;if (!dyarr_be_appended &amp;&amp; !exp_append_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;&#x2F;&#x2F;跟插入大量数据是一个道理的！int datarate &#x3D; exp_append_array-&gt;current_size &#x2F; dyarr_be_appended-&gt;total_usable_size;if (        dyarr_be_appended-&gt;current_size         &#x3D;&#x3D;         dyarr_be_appended-&gt;total_usable_size    )&#123;        Resize_The_Dynamic_Array(            dyarr_be_appended,             2 * dyarr_be_appended-&gt;total_usable_size        );    &#125;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr_be_appended, (datarate + 1) * dyarr_be_appended-&gt;total_usable_size);void* AfterAppend &#x3D; realloc(dyarr_be_appended-&gt;DataPiece,        &#x2F;&#x2F;这一大长串就是两个动态数组一共的大小！        (dyarr_be_appended-&gt;current_size + exp_append_array-&gt;current_size) * dyarr_be_appended-&gt;Single_Data_size);if (!AfterAppend)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr_be_appended-&gt;DataPiece &#x3D; AfterAppend;memcpy(&#x2F;&#x2F;目标地：被追加的数组的尾部        (char*)dyarr_be_appended-&gt;DataPiece +         dyarr_be_appended-&gt;current_size * dyarr_be_appended-&gt;Single_Data_size,        &#x2F;&#x2F;源头：被拷贝的数组(char*)exp_append_array-&gt;DataPiece,        &#x2F;&#x2F;大小：被拷贝数组的大小exp_append_array-&gt;current_size * exp_append_array-&gt;Single_Data_size);    &#x2F;&#x2F;调整大小dyarr_be_appended-&gt;current_size +&#x3D; exp_append_array-&gt;current_size;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="一览增（加）函数"><a href="#一览增（加）函数" class="headerlink" title="一览增（加）函数"></a>一览增（加）函数</h4><p>OK，我们再一览我们的成果就好了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a data into the Dynamic Array&#x2F;&#x2F;Use like this: Push_Back_Into_A_Dynamic_Array(dyarr,data)&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data,size_tdatasize)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size) &#123;printf(&quot;%d &quot;, sizeof(data));SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 1.3 * (dyarr-&gt;total_usable_size));void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1)*dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy((char*)Afteradd_piece + dyarr-&gt;current_size * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; Afteradd_piece;dyarr-&gt;current_size++;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(dyarr,data,the_time_data_repeated,sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;for (int i &#x3D; 0; i &lt; n_repeat; i++)memcpy((char*)newspace + (dyarr-&gt;current_size+i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has a organiztion with static array&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(&#x2F;&#x2F;dyarr,&#x2F;&#x2F;data,&#x2F;&#x2F;how_many_data_are_there_in_static_array,&#x2F;&#x2F;sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data_array, size_tarray_num, size_tpos,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (data_inarray_size !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);if(!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece &#x3D; newspace;for (int i &#x3D; 0; i &lt; array_num; i++)memcpy((char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,(char*)data_array + i * (dyarr-&gt;Single_Data_size),dyarr-&gt;Single_Data_size);dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Insert back a data &#x2F;&#x2F; use like this: &#x2F;&#x2F; Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; data, &#x2F;&#x2F; where_to_insert,&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data, size_tpos)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * (dyarr-&gt;total_usable_size));void* Afteradd_piece&#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy((char*)dyarr-&gt;DataPiece + (pos + 1) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos+1));memmove((char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);dyarr-&gt;current_size++;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)&#x2F;&#x2F;DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize,size_tpos)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove((char*)dyarr-&gt;DataPiece + (pos + n_repeat) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * n_repeat);for (int i &#x3D; 0; i &lt; n_repeat; i++)memcpy((char*)newspace + (pos + i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back some data that organized in static array&#x2F;&#x2F;use like this: Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; where_to_insert, &#x2F;&#x2F; data, &#x2F;&#x2F; how_many_data_are_there_in_static_array,&#x2F;&#x2F; sizeof(data)&#x2F;&#x2F;)&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(DynamicArray*dyarr,size_tpos,void*data_array, size_tarray_num,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (!dyarr-&gt;current_size)&#123;Push_Back_Some_data_Into_A_Dynamic_Array(dyarr, data_array, array_num, pos,data_inarray_size);return DynamicArray_Normal;&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove((char*)dyarr-&gt;DataPiece + (pos + array_num) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*array_num);for (int i &#x3D; 0; i &lt; array_num; i++)memcpy((char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,(char*)data_array + i * (dyarr-&gt;Single_Data_size),dyarr-&gt;Single_Data_size);dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Append another dynamic Array&#x2F;&#x2F; use like this:&#x2F;&#x2F; AppendByMergeDynamicArray(dyarr_be_appended, exp_append_array)&#x2F;&#x2F;DynamicArrayFunctionStatues AppendByMergeDynamicArray(DynamicArray*dyarr_be_appended,DynamicArray*exp_append_array)&#123;if (!dyarr_be_appended &amp;&amp; !exp_append_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;int datarate &#x3D; exp_append_array-&gt;current_size &#x2F; dyarr_be_appended-&gt;total_usable_size;if (dyarr_be_appended-&gt;current_size &#x3D;&#x3D; dyarr_be_appended-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr_be_appended, 2 * dyarr_be_appended-&gt;total_usable_size);if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr_be_appended, (datarate + 1) * dyarr_be_appended-&gt;total_usable_size);void* AfterAppend &#x3D; realloc(dyarr_be_appended-&gt;DataPiece,(dyarr_be_appended-&gt;current_size + exp_append_array-&gt;current_size) * dyarr_be_appended-&gt;Single_Data_size);if (!AfterAppend)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr_be_appended-&gt;DataPiece &#x3D; AfterAppend;memcpy((char*)dyarr_be_appended-&gt;DataPiece + dyarr_be_appended-&gt;current_size * dyarr_be_appended-&gt;Single_Data_size,(char*)exp_append_array-&gt;DataPiece,exp_append_array-&gt;current_size * exp_append_array-&gt;Single_Data_size);dyarr_be_appended-&gt;current_size +&#x3D; exp_append_array-&gt;current_size;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删减函数"><a href="#删减函数" class="headerlink" title="删减函数"></a>删减函数</h3><p>​        就像人生需要做减法一样，我们也要给我们的数据结构提供删减操作！</p><h4 id="尾删除函数（删减一个）"><a href="#尾删除函数（删减一个）" class="headerlink" title="尾删除函数（删减一个）"></a>尾删除函数（删减一个）</h4><p>​        不删减多个，不水代码！</p><p>​        很简单，我们只需要size—就好了！之后再次增加的时候会直接覆盖，同时，若是删减过多可以在后续直接调用Resize函数！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase the final element!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(DynamicArray*dyarr)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="直接清除函数（直接清空）"><a href="#直接清除函数（直接清空）" class="headerlink" title="直接清除函数（直接清空）"></a>直接清除函数（直接清空）</h4><p>​        一个思路，但是，这次由于是清空，我们直接free掉数据！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Clear_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size &#x3D; 0;if (!dyarr-&gt;DataPiece)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;printf(&quot;VOID DATA SHOULDN&#39;T BE FREE!&quot;);exit(DynamicArray_Invalid_Free);&#125;    &#x2F;&#x2F;预留一个位置，便于后期操作！void* pro_usable_space&#x3D; realloc(dyarr-&gt;DataPiece, dyarr-&gt;Single_Data_size);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece&#x3D;pro_usable_space;dyarr-&gt;total_usable_size &#x3D; 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除一个数据（指定一个位置）"><a href="#删除一个数据（指定一个位置）" class="headerlink" title="删除一个数据（指定一个位置）"></a>删除一个数据（指定一个位置）</h4><p>​        我们怎么删除数组里的一个数据呢？只需要回顾到Insert函数的操作，我们反过来，让pos后面的数据往前移动一个！不久把数据盖上了嘛！随后size—就是我们想要的结果！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tpos)&#123;    &#x2F;&#x2F;检查if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;    &#x2F;&#x2F;直接拷贝覆盖跑路！memcpy((char*)dyarr-&gt;DataPiece+pos*dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece+(pos+1)*dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos-1));    &#x2F;&#x2F;size--，防止访问到奇怪的数据！dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除一些数据"><a href="#删除一些数据" class="headerlink" title="删除一些数据"></a>删除一些数据</h4><p>​        这个难度稍大一点：关键在于，如果我们删除了大量的数据，我们需要调用Resize函数来释放多余的空间，这样可以优化内存占用！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase some specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tBeginpos, size_tEndpos)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Beginpos &lt; 0 || Beginpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (Endpos &lt; 0 || Endpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;memcpy((char*)dyarr-&gt;DataPiece + Beginpos * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (Endpos + 1) * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - Endpos + 1));dyarr-&gt;current_size -&#x3D; Endpos - Beginpos + 1;    &#x2F;&#x2F;开始调整大小！if (dyarr-&gt;current_size &lt;&#x3D; dyarr-&gt;total_usable_size &#x2F; 4 &amp;&amp; dyarr-&gt;total_usable_size &gt; 5)&#123;Resize_The_Dynamic_Array(dyarr, dyarr-&gt;total_usable_size &#x2F; 2);dyarr-&gt;total_usable_size &#x2F;&#x3D; 2;&#125;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="直接删掉整个动态数组的函数："><a href="#直接删掉整个动态数组的函数：" class="headerlink" title="直接删掉整个动态数组的函数："></a>直接删掉整个动态数组的函数：</h4><p>​        注意：我们先释放数据，再释放本身！不然会造成内存泄漏！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;exit(DynamicArray_Invalid_Free);&#125;free(dyarr-&gt;DataPiece);free(dyarr);return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="一览删除函数："><a href="#一览删除函数：" class="headerlink" title="一览删除函数："></a>一览删除函数：</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase the final element!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(DynamicArray*dyarr)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Clear_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Clear_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size &#x3D; 0;if (!dyarr-&gt;DataPiece)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;printf(&quot;VOID DATA SHOULDN&#39;T BE FREE!&quot;);exit(DynamicArray_Invalid_Free);&#125;void* pro_usable_space&#x3D; realloc(dyarr-&gt;DataPiece, dyarr-&gt;Single_Data_size);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece&#x3D;pro_usable_space;dyarr-&gt;total_usable_size &#x3D; 1;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements! and unable to be used again!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Destroy_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;exit(DynamicArray_Invalid_Free);&#125;free(dyarr-&gt;DataPiece);free(dyarr);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tpos)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;memcpy((char*)dyarr-&gt;DataPiece+pos*dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece+(pos+1)*dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos-1));dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase some specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tBeginpos, size_tEndpos)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Beginpos &lt; 0 || Beginpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (Endpos &lt; 0 || Endpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;memcpy((char*)dyarr-&gt;DataPiece + Beginpos * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (Endpos + 1) * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - Endpos + 1));dyarr-&gt;current_size -&#x3D; Endpos - Beginpos + 1;if (dyarr-&gt;current_size &lt;&#x3D; dyarr-&gt;total_usable_size &#x2F; 4 &amp;&amp; dyarr-&gt;total_usable_size &gt; 5)&#123;Resize_The_Dynamic_Array(dyarr, dyarr-&gt;total_usable_size &#x2F; 2);dyarr-&gt;total_usable_size &#x2F;&#x3D; 2;&#125;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="打印内容与处理其内数据函数系列"><a href="#打印内容与处理其内数据函数系列" class="headerlink" title="打印内容与处理其内数据函数系列"></a>打印内容与处理其内数据函数系列</h3><h4 id="打印操作"><a href="#打印操作" class="headerlink" title="打印操作"></a>打印操作</h4><p>​        打印数据是我们常用的与数据交互的操作，我们正是需要这个东西来看看我们的数据如何：注意到，我们打印的可能不是整数，可能不是字符，而是任何东西！那么，我们所作的，只是提供一个函数接口！至于怎么打印，让用户自己看着办！为了方便打字，为了防止用户花式整出来奇形八怪的Print接口，我们统一 一个！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void(* MyPrint )(void*)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个是函数指针别名的经典写法，如果你不熟悉，可以从这里看：比若说，我要指定一个类型，给他起个别名便于我们后续写程序提醒与应用（工程上常常这么做！提醒自己这个是干嘛的的）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef int MyInt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这就是说：MyInt是我自己起的一个类型，但是本质上就是Int！它可以跟int 起到完全一致的效果！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    int a &#x3D; 1;    MyInt b &#x3D; 1;&#x2F;&#x2F; Legal!&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        而这个：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void(* MyPrint )(void*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        就是一个函数指针（说白了，就是一个接受一个任意数据啥都不返回的函数！）的别名，这样写，你可能会更有感觉：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void(*)(void*) MyPrint ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        于是，我们的打印函数就有了点可行的想法了！</p><h4 id="打印一个数据（指定位置）"><a href="#打印一个数据（指定位置）" class="headerlink" title="打印一个数据（指定位置）"></a>打印一个数据（指定位置）</h4><p>​        这个函数可以和后面的返回位置的查找函数搭配使用！我们的这个函数打印动态数组里的一个元素！函数肯定的：需要一个动态数组！需要位置！需要打印方式！原型直接出来了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(DynamicArray*dyarr, MyPrint&#x2F;*就是函数指针，说白了就是打印方式传进来*&#x2F;user_print, size_tpos) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        还是检查：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;    ...        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        为了让打印好看点，我们加入表示语句：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;\nSpecific Data is Shown:\n&quot;);...&#x2F;&#x2F;here we printprintf(&quot;\nSpecific Data Finished Showing!\n&quot;);return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于函数的调用，我们使用（）调用！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">user_print(    (char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        为什么这样写？注意，我们必须转化void* 为具体的指针来对指针进行加减操作！否则不合法！，而操作程度最小的指针就是char指针！于是，我们使用：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">(char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定位到我们想要打印到的位置！之后解引用的方式（决定访问步长，这是指针的一个应用本质）是由用户决定的！</p><p>​        看看成品：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(DynamicArray*dyarr, MyPrintuser_print, size_tpos) &#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;printf(&quot;\nSpecific Data is Shown:\n&quot;);user_print((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));printf(&quot;\nSpecific Data Finished Showing!\n&quot;);return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="打印所有数据"><a href="#打印所有数据" class="headerlink" title="打印所有数据"></a>打印所有数据</h4><p>​        我说停！先别开工！我们引入一个enum，让用户传入一个参数来决定要不要更好的打印我们的数据！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;A switch that used in better Print in Dynamic Array!&#x2F;&#x2F;Often use OPEN to beautify the control table&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_dyarr_ &#123;Dyarr_OPEN &#x3D; 1,Dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_dyarr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        之后？就是遍历咯！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print All data&#x2F;&#x2F; use like this&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(DynamicArray*dyarr,MyPrintuser_print,BetterPrintSwitch_for_dyarrwhether_better_print)&#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;    &#x2F;&#x2F;要不要更好的打印？if(whether_better_print&#x3D;&#x3D;Dyarr_OPEN)&#123;printf(&quot;\nStart Printing\n&quot;);&#125;    &#x2F;&#x2F;遍历！for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;        &#x2F;&#x2F;函数名跟数组名一样！本质上还是指针，所以，无所谓解不解引用(*user_print)(            &#x2F;&#x2F;打印第I个            (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)        );&#125;if (whether_better_print &#x3D;&#x3D; Dyarr_OPEN)&#123;printf(&quot;\nFinish Printing\n&quot;);&#125;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="处理数据（单个多个）"><a href="#处理数据（单个多个）" class="headerlink" title="处理数据（单个多个）"></a>处理数据（单个多个）</h4><p>​        仿照Print思路，这一次，我们使用Do_Specific_Change函数指针！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void*(*Do_Specific_Change)(void*);&#x2F;&#x2F;返回void也行，主要考虑扩展接口的问题，后续可能自己定义函数要继续操作<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这次不在多说！一样的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in all data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change) &#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)user_change(        &#x2F;&#x2F;处理第I个数据        (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)    );return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change, size_tpos)&#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;user_change((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="打印内容与处理其内数据函数系列一览"><a href="#打印内容与处理其内数据函数系列一览" class="headerlink" title="打印内容与处理其内数据函数系列一览"></a>打印内容与处理其内数据函数系列一览</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(DynamicArray*dyarr, MyPrintuser_print, size_tpos) &#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;printf(&quot;\nSpecific Data is Shown:\n&quot;);user_print((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));printf(&quot;\nSpecific Data Finished Showing!\n&quot;);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print All data&#x2F;&#x2F; use like this&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(DynamicArray*dyarr,MyPrintuser_print,BetterPrintSwitch_for_dyarrwhether_better_print)&#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;    &#x2F;&#x2F;要不要更好的打印？if(whether_better_print&#x3D;&#x3D;Dyarr_OPEN)&#123;printf(&quot;\nStart Printing\n&quot;);&#125;    &#x2F;&#x2F;遍历！for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;        &#x2F;&#x2F;函数名跟数组名一样！本质上还是指针，所以，无所谓解不解引用(*user_print)(            &#x2F;&#x2F;打印第I个            (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)        );&#125;if (whether_better_print &#x3D;&#x3D; Dyarr_OPEN)&#123;printf(&quot;\nFinish Printing\n&quot;);&#125;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in all data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change) &#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)user_change(        &#x2F;&#x2F;处理第I个数据        (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)    );return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change, size_tpos)&#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;user_change((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查询状况与数据函数一览"><a href="#查询状况与数据函数一览" class="headerlink" title="查询状况与数据函数一览"></a>查询状况与数据函数一览</h3><h4 id="查询动态数组是否为空函数"><a href="#查询动态数组是否为空函数" class="headerlink" title="查询动态数组是否为空函数"></a>查询动态数组是否为空函数</h4><p>​        呃，最简单了哈哈：不过注意，在C89的时候还没有布尔类型！我们需要自己手搓一个：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Mybool defined&#x2F;&#x2F;typedef enum _bool_ &#123;True &#x3D; 1,False &#x3D; 0&#125;Bool;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        用起来咯！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in judging whether the dynamic array is empty&#x2F;&#x2F; use like this:&#x2F;&#x2F; isEmpty_InDynamicArray(dyarr)&#x2F;&#x2F;Bool isEmpty_InDynamicArray(DynamicArray*dyarr) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (dyarr-&gt;current_size&#x3D;&#x3D;0)return True;return False;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查询特定元素是否存在"><a href="#查询特定元素是否存在" class="headerlink" title="查询特定元素是否存在"></a>查询特定元素是否存在</h4><p>​        咳咳，难度来了：对于任意的数据，我们怎么知道他们符不符合要求：相等呢？嘛！这个简单，用户决定嘛！</p><p>​        还是一样，我们统一一个函数指针：其返回值类型是专门用来标记是否存在的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef unsigned int Is_Used_Compared_Int;&#x2F;&#x2F;返回类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这下函数原型好说了！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues isLocateinDyarr(DynamicArray* dyarr,void*data,LocateFuncuser_func)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        老老老样子，判判判判断！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遍历一下咯！不过为了提高程序可阅读性质：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;this type of int is specifically used in Returning Find Or Unfind.&#x2F;&#x2F;Recommmend to be used as a nickname:)&#x2F;&#x2F;Can use Find or Unfind to return the result&#x2F;&#x2F;typedef enum _DynamicArray_isFind_ &#123;Find&#x3D; 1,Unfind&#x3D; -1&#125;DynamicArray_isFind;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if (user_func(        &#x2F;&#x2F;check the Ith one        (char*)dyarr-&gt;DataPiece +        i * dyarr-&gt;Single_Data_size,         data    )&#x2F;&#x2F;if found return Find)&#123;return Find;&#125;&#125;return Unfind;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="返回第一次遇到的位置"><a href="#返回第一次遇到的位置" class="headerlink" title="返回第一次遇到的位置"></a>返回第一次遇到的位置</h4><p>​        跟上面很类似捏：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues returnAElembyPos_inDyarr(DynamicArray*dyarr, void*data, LocateFuncuser_func) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if ( &#x2F;&#x2F;check the Ith one            user_func            (            (char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size,            data            )        )&#123;&#x2F;&#x2F; if found return i(the position)return i;&#125;&#125;return Unfind;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="存储位置的动态数组及其API"><a href="#存储位置的动态数组及其API" class="headerlink" title="存储位置的动态数组及其API"></a>存储位置的动态数组及其API</h4><p>​        这个是为了下面做铺垫！原理一致，只展现API！</p><h6 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h6><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _Dyarrposarr_ &#123;int* posSpace;size_t pos_size;&#125;Position_Stored_Dynamic_ArrayFordyarr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="更好的打印开关枚举定义："><a href="#更好的打印开关枚举定义：" class="headerlink" title="更好的打印开关枚举定义："></a>更好的打印开关枚举定义：</h6><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Want a better Print to beutify your control table? try this one&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;PSDA_dyarr_OPEN &#x3D; 1,PSDA_dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_pos_dyarr;&#x2F;&#x2F;can use this type when indicating the type&#x2F;&#x2F;typedef unsigned int BetterPrintfor_PosDyarr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API-1：创造一个存储位置的动态数组"><a href="#API-1：创造一个存储位置的动态数组" class="headerlink" title="API 1：创造一个存储位置的动态数组"></a>API 1：创造一个存储位置的动态数组</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr()&#123;Position_Stored_Dynamic_ArrayFordyarr* pro_usable_space         &#x3D;         MALLOCDYARR(Position_Stored_Dynamic_ArrayFordyarr, 1);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;  pro_usable_space-&gt;posSpace &#x3D; NULL;pro_usable_space-&gt;pos_size &#x3D; 0;return pro_usable_space;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API-2：打印所有的位置："><a href="#API-2：打印所有的位置：" class="headerlink" title="API 2：打印所有的位置："></a>API 2：打印所有的位置：</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;DynamicArrayFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr,BetterPrintfor_PosDyarr   Whether_Better_Print)&#123;if (!posarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nPositions are shown! :\n&quot;);for (int i &#x3D; 0; i &lt; posarr-&gt;pos_size; i++)printf(&quot;%u &quot;, posarr-&gt;posSpace[i]);if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nFinish Printing!\n&quot;);return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API-3：推入一个位置"><a href="#API-3：推入一个位置" class="headerlink" title="API 3：推入一个位置"></a>API 3：推入一个位置</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to push back a position into the Position_Stored_Dynamic_ArrayFordyarr&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_a_locations_in_PSDA_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr, intpos_acquired)&#123;int* pro_usable_space &#x3D; (int*)realloc(posarr-&gt;posSpace, sizeof(int) * (posarr-&gt;pos_size + 1));if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;posarr-&gt;posSpace &#x3D; pro_usable_space;posarr-&gt;posSpace[posarr-&gt;pos_size] &#x3D; pos_acquired;posarr-&gt;pos_size++;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API4：统计个数"><a href="#API4：统计个数" class="headerlink" title="API4：统计个数"></a>API4：统计个数</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to return the number of locations&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;size_t Get_pos_size_From_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr,BetterPrintfor_PosDyarrWhether_Shown_Print )&#123;if (!posarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Whether_Shown_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nCurrent targeted data&#39;s total num is:%u!\n&quot;,posarr-&gt;pos_size);return posarr-&gt;pos_size;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API-5：销毁一个存储位置的动态数组"><a href="#API-5：销毁一个存储位置的动态数组" class="headerlink" title="API 5：销毁一个存储位置的动态数组"></a>API 5：销毁一个存储位置的动态数组</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;Erase a dynamic Array when donot using it!&#x2F;&#x2F;DynamicArrayFunctionStatues DesTroy_A_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*pointer_to_wishedfreeposarr)&#123;if (!pointer_to_wishedfreeposarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_Invalid_Free);&#125;free(pointer_to_wishedfreeposarr-&gt;posSpace);free(pointer_to_wishedfreeposarr);pointer_to_wishedfreeposarr &#x3D; NULL;return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="API-6：返回指定位置的标记位置"><a href="#API-6：返回指定位置的标记位置" class="headerlink" title="API 6：返回指定位置的标记位置"></a>API 6：返回指定位置的标记位置</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;return a pos that is targeted!&#x2F;&#x2F;DynamicArrayFunctionStatues getPosbyPosinPSDA(Position_Stored_Dynamic_ArrayFordyarr*getter,size_t pos) &#123;if (!getter) &#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_Invalid_Free);&#125;if (pos &gt; getter-&gt;pos_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;for (int i &#x3D; 0; i &lt; pos; i++)return (char*)getter-&gt;posSpace + i * sizeof(size_t);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这些API很简单，我不阐述原理了！</p><h4 id="返回多个位置函数"><a href="#返回多个位置函数" class="headerlink" title="返回多个位置函数"></a>返回多个位置函数</h4><p>​        返回一个简单，返回多个怎么办？存储位置的动态数组嘛！不过，这个是只记载位置的：那就好说了！</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">Position_Stored_Dynamic_ArrayFordyarr* returnABunchofData_inDyarr(DynamicArray*dyarr, Position_Stored_Dynamic_ArrayFordyarr*posArr, void*data, LocateFuncuser_func)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if (                (*user_func)(                    data,                     (char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size)            )&#123;                &#x2F;&#x2F;类似于return i，这次往PSDA里return！Push_back_a_locations_in_PSDA_dyarr(posArr，i)&#125;&#125;if (posArr-&gt;pos_size!&#x3D;0)return posArr;return Unfind;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="交换于排序函数系列"><a href="#交换于排序函数系列" class="headerlink" title="交换于排序函数系列"></a>交换于排序函数系列</h3><p>​        我们的排序只涉及冒泡排序！</p><h4 id="交换函数"><a href="#交换函数" class="headerlink" title="交换函数"></a>交换函数</h4><p>​        回忆一下基本的交换方法：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void swapInt(int* e1, int*e2)&#123;    int temp &#x3D; *e1 ;    *e1 &#x3D; *e2;    *e2 &#x3D; temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        基于此：我们还是一样的仿照设计出函数原型：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues swapData_in_DynamicArray(DynamicArray*dyarr, size_tpos1, size_tpos2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>检查：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一次，我们的交换使用memcpy（memmove都可以）(为了演示我交叉使用了)</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;准备空间char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);if(!swapbit)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;&#x2F;&#x2F; int temp &#x3D; *e1 ;memcpy(swapbit,(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);&#x2F;&#x2F;*e1 &#x3D; *e2;memmove((char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);&#x2F;&#x2F; *e2 &#x3D; temp;memcpy((char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,swapbit,dyarr-&gt;Single_Data_size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        别忘了释放空间：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">free(swapbit);return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>整合看看：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in swap data&#x2F;&#x2F; use like this:&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)&#x2F;&#x2F;DynamicArrayFunctionStatues swapData_in_DynamicArray(DynamicArray*dyarr, size_tpos1, size_tpos2)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);if(!swapbit)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(swapbit,(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memmove((char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memcpy((char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,swapbit,dyarr-&gt;Single_Data_size);free(swapbit);return DynamicArray_Normal;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="冒泡排序交换函数："><a href="#冒泡排序交换函数：" class="headerlink" title="冒泡排序交换函数："></a>冒泡排序交换函数：</h4><p>​        仿照经典冒泡排序。。。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">void bubbleSort(int* arr, int arr_size)&#123;    if(arr&#x3D;&#x3D;NULL)&#123;        return;    &#125;           if(arr_size&lt;&#x3D;1)&#123;        return;    &#125;        for(int i&#x3D;0; i&lt;arr_size-1; i++)    &#123;        for(int j &#x3D; 0;j&lt;arr_size-i-1; j++)        &#123;            if(arr[j]&gt; arr[j+1])            &#123;                swap(arr[j],arr[j+1]);&#x2F;&#x2F;swap不实现了，上面就有            &#125;        &#125;    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; sadly that is bubblesort :(&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol&#x2F;&#x2F; use like this:&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues sort_In_Dynamic_Array(DynamicArray*dyarr,CompareFunccompfunc) &#123;    &#x2F;&#x2F;检查if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!compfunc)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size-1; i++)&#123;for (int j &#x3D; 0; j &lt; dyarr-&gt;current_size - i-1; j++)&#123;if (&#x2F;&#x2F;if(arr[j]&gt; arr[j+1])compfunc                ((char*)dyarr-&gt;DataPiece + j * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (j + 1) * dyarr-&gt;Single_Data_size))                &#x2F;&#x2F;swap(arr[j],arr[j+1])swapData_in_DynamicArray(dyarr, j, j + 1);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="交换于排序函数系列一览"><a href="#交换于排序函数系列一览" class="headerlink" title="交换于排序函数系列一览"></a>交换于排序函数系列一览</h4><p>OK，集合一下</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in swap data&#x2F;&#x2F; use like this:&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)&#x2F;&#x2F;DynamicArrayFunctionStatues swapData_in_DynamicArray(DynamicArray*dyarr, size_tpos1, size_tpos2)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);if(!swapbit)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(swapbit,(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memmove((char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memcpy((char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,swapbit,dyarr-&gt;Single_Data_size);free(swapbit);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; sadly that is bubblesort :(&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol&#x2F;&#x2F; use like this:&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues sort_In_Dynamic_Array(DynamicArray*dyarr,CompareFunccompfunc) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!compfunc)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size-1; i++)&#123;for (int j &#x3D; 0; j &lt; dyarr-&gt;current_size - i-1; j++)&#123;if (compfunc((char*)dyarr-&gt;DataPiece + j * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (j + 1) * dyarr-&gt;Single_Data_size))swapData_in_DynamicArray(dyarr, j, j + 1);&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试一下子咯！"><a href="#测试一下子咯！" class="headerlink" title="测试一下子咯！"></a>测试一下子咯！</h3><p>测试代码：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1#include&quot;standard_dynamic_array.h&quot;MyPrint print(int* e1) &#123;printf(&quot;%d &quot;, *e1);&#125;Do_Specific_Change dochange(int* e1) &#123;*e1 &#x3D; *e1 + 1;&#125;LocateFunc loc(int* e1, int* e2) &#123;if (*e1 &#x3D;&#x3D; *e2) &#123;return Find;&#125;return Unfind;&#125;int main()&#123;int data1 &#x3D; 10;    &#x2F;&#x2F;test InitingDynamicArray* testDyarr1 &#x3D; Init_A_DynamicArray(10, Dyarr_SIGINT);    &#x2F;&#x2F;test a Sigdata pushed:Push_Back_Into_A_Dynamic_Array(testDyarr1, &amp;data1);Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;test pushing the same dataPush_back_Same_data_Into_A_Dynamic_Array(testDyarr1, &amp;data1, 10, Dyarr_SIGINT);Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;Test ClearingClear_A_Dynamic_Array(testDyarr1);Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;test updateint data2[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;DynamicArray* test2&#x3D;Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);Print_ALL_Data_In_A_Dynamic_Array(test2, print, Dyarr_OPEN);    &#x2F;&#x2F;test copy:DynamicArray* copyone &#x3D; Init_A_DynamicArray_by_CopyADyarr(test2);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test insertprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Insert_Into_A_Dynamic_Array(copyone, &amp;data1, 1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test insert bunchprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Insert_Some_Data_Into_A_Dynamic_Array(copyone, 1, data2, 10, Dyarr_SIGINT);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Erasing sigoneprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Delete_A_Specific_Data_From_the_DynamicArray(copyone, 1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Erasing bunch oneprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Delete_Some_Specific_Data_From_the_DynamicArray(copyone,1,10);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Do changeprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Do_Specific_Change_To_Specific_Data(copyone,dochange,1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);printf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Do_Specific_Change_To_All_Data(copyone, dochange);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test location:DynamicArray* test3 &#x3D; Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);if (isLocateinDyarr(test3, &amp;data2[2], loc)) &#123;printf(&quot;\nI have found it!\n&quot;);&#125;int where &#x3D; returnAElembyPos_inDyarr(test3, &amp;data2[2], loc);printf(&quot;\nIn dyarr the %d place\n&quot;, where);    &#x2F;&#x2F;test Position Stored Dynamic Array and returnBunchClear_A_Dynamic_Array(test3);Push_back_Same_data_Into_A_Dynamic_Array(test3, &amp;data2[2], 10, Dyarr_SIGINT);Position_Stored_Dynamic_ArrayFordyarr* p1 &#x3D; Init_A_Postion_Stored_Dynamic_ArrayFordyarr();returnABunchofData_inDyarr(test3, p1, &amp;data2[2], loc);Print_ALL_Data_In_A_Dynamic_Array(test3, print, Dyarr_OPEN);Show_All_Locations_In_PSDAfor_dyarr(p1, PSDA_dyarr_OPEN);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看效果：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">4Start Printing10Finish PrintingStart Printing10 10 10 10 10 10 10 10 10 10 10Finish PrintingStart PrintingFinish PrintingStart Printing1 2 3 4 5 6 7 8 9 10Finish PrintingStart Printing1 2 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 2 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing1 10 2 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 10 2 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing1 1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing1 2 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 2 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing1 3 3 4 5 6 7 8 9 10Finish Printingbefore:Start Printing1 3 3 4 5 6 7 8 9 10Finish Printingafter:Start Printing2 4 4 5 6 7 8 9 10 11Finish PrintingI have found it!In dyarr the 2 placeStart Printing3 3 3 3 3 3 3 3 3 3Finish PrintingPositions are shown! :0 1 2 3 4 5 6 7 8 9Finish Printing!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230207221151700.png" alt="image-20230207221151700"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> MyTinyLibProject </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据结构模拟：动态数组（1）头文件+源代码+测试</title>
      <link href="/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="动态数组（1）源代码阅读-注释"><a href="#动态数组（1）源代码阅读-注释" class="headerlink" title="动态数组（1）源代码阅读+注释"></a>动态数组（1）源代码阅读+注释</h1><h4 id="开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））"><a href="#开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））" class="headerlink" title="开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））"></a>开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））</h4><p>​        请注意：使用和调用环境为C语言环境，不！要！用！在！CPP文件里！函数指针返回逻辑不一样lol</p><p>​        下载源文件和MD文件（有代码高亮）可以去我的GitHub上下载！</p><h5 id="头文件一览："><a href="#头文件一览：" class="headerlink" title="头文件一览："></a>头文件一览：</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1#defineOPENUPPOSARR 1#define OPENUPDEFAULTSIZE 1#defineQUICKMALLOC 1&#x2F;&#x2F;(General Version)#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;&#x2F;&#x2F;Error Code Meaning&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0&#x2F;&#x2F;When Error in mallocing Space the program return 1&#x2F;&#x2F;when inputing a NULL we returns -1&#x2F;&#x2F;when inputing a invalid input we returns -2&#x2F;&#x2F;Locations UnFind we returns -3 &#x2F;&#x2F;typedef enum _DynamicFunctionStatues_ &#123;DynamicArray_Normal &#x3D; 0,DynamicArray_ERROR_IN_MALLOCING_SPACE &#x3D; 1,DynamicArray_NULL_INPUT &#x3D; -1,DynamicArray_Invalid_Input &#x3D; -2,DynamicArray_UnFind &#x3D; -3,DynamicArray_Invalid_Free &#x3D; -4&#125;DynamicArrayFunctionStatues;&#x2F;&#x2F;Mybool defined&#x2F;&#x2F;typedef enum _bool_ &#123;True &#x3D; 1,False &#x3D; 0&#125;Bool;#define SHOW_ERROR_DynamicArray_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)#define SHOW_ERROR_DynamicArray_UnFind printf(&quot;\nPositions unfind!\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)&#x2F;&#x2F;this type of int is specifically used in Returning Find Or Unfind.&#x2F;&#x2F;Recommmend to be used as a nickname:)&#x2F;&#x2F;Can use Find or Unfind to return the result&#x2F;&#x2F;typedef enum _DynamicArray_isFind_ &#123;Find &#x3D; 1,Unfind &#x3D; 0&#125;DynamicArray_isFind;&#x2F;&#x2F;A switch that used in better Print in Dynamic Array!&#x2F;&#x2F;Often use OPEN to beautify the control table&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_dyarr_ &#123;Dyarr_OPEN &#x3D; 1,Dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_dyarr;&#x2F;&#x2F;Main Definitions about DynamicArray&#x2F;&#x2F;When Programing , not recommend to Change the data directly! &#x2F;&#x2F;typedef struct _DynamicArray_ &#123;void* DataPiece;size_t current_size;size_t total_usable_size;size_t Single_Data_size;&#125;DynamicArray;&#x2F;&#x2F;--------------------------------Default_size_Type--------------------------------------------&#x2F;&#x2F;These abstractions are used to reduce the input&#x2F;&#x2F;used as Dyarr_Default_TYPE(type_number) to replace the code:sizeof(Typename)*type_number#if OPENUPDEFAULTSIZE&#x2F;&#x2F;Single Type size&#x2F;&#x2F;#define Dyarr_SIGINT sizeof(int)#define Dyarr_SIGCHAR sizeof(char)#define Dyarr_SIGFLOAT sizeof(float)#define Dyarr_SIGDOUBLE sizeof(double)#define Dyarr_SIG(dataType) sizeof(dataType)&#x2F;&#x2F;Mutiply type size&#x2F;&#x2F;#define Dyarr_INT_SIZE(X) sizeof(int)*X#define Dyarr_CHAR_SIZE(X) sizeof(char)*X#define Dyarr_FLOAT_SIZE(X) sizeof(float)*X#define Dyarr_DOUBLE_SIZE(X) sizeof(double)*X#define Dyarr_TYPE_SIZE(dataType,X) sizeof(dataType)*X#endif&#x2F;&#x2F;-------------------------------------------QuickMalloc----------------------------------------&#x2F;&#x2F;As the name goes lol&#x2F;&#x2F;#if QUICKMALLOC #define Dyarr_DEFAULT_MALLOC 5#define MALLOCDYARR(datatype,data_num) (datatype*)malloc(sizeof(datatype)*data_num)#endif&#x2F;&#x2F;----------------------------------------STD_FUNC_AND_INT_TYPE----------------------------------&#x2F;&#x2F; Return type of compared functions&#x2F;&#x2F;typedef unsigned int Is_Used_Compared_Int;&#x2F;&#x2F; the pointer type of Print !&#x2F;&#x2F; When Printing , type :&#x2F;&#x2F; MyPrint user_print_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F; &#123;&#x2F;&#x2F;print in your way for your data!&#x2F;&#x2F; &#125;&#x2F;&#x2F;typedef void(*MyPrint)(void*);&#x2F;&#x2F; the pointer type of Making change for the data that has been locates in the Dynamic Array!&#x2F;&#x2F; When want to make some change, type like this:&#x2F;&#x2F; Do_Specific_Change user_dochange_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;do some change here for your data!&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef void* (*Do_Specific_Change)(void*);&#x2F;&#x2F; the pointer type of using when comparing for your data&#x2F;&#x2F; When want to make a comparisons, type like this:&#x2F;&#x2F; CompareFunc user_comp_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;return &#x2F;&#x2F;the wishing compare!&#x2F;&#x2F;&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef Is_Used_Compared_Int(*CompareFunc)(void*, void*);&#x2F;&#x2F; the pointer type of using when checking iflocated for your data&#x2F;&#x2F; When want to make a comparisons, type like this:&#x2F;&#x2F; LocateFunc user_loc_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;return data1&#x3D;&#x3D;data2(define by yourself! if complicated, just return Find or unfind to show whether is found)&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);&#x2F;&#x2F;-----------------------Position_Stored_Dynamic_Array_For_Dyarr---------------------------------#if OPENUPPOSARR&#x2F;&#x2F;Main data structure!&#x2F;&#x2F;Used in returning multitude locations&#x2F;&#x2F;typedef struct _Dyarrposarr_ &#123;int* posSpace;size_t pos_size;&#125;Position_Stored_Dynamic_ArrayFordyarr;&#x2F;&#x2F;Want a better Print to beutify your control table? try this one&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;PSDA_dyarr_OPEN &#x3D; 1,PSDA_dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_pos_dyarr;&#x2F;&#x2F;can use this type when indicating the type&#x2F;&#x2F;typedef unsigned int BetterPrintfor_PosDyarr;&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;DynamicArrayFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(Position_Stored_Dynamic_ArrayFordyarr* posarr,BetterPrintfor_PosDyarrWhether_Better_Print);&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to push back a position into the Position_Stored_Dynamic_ArrayFordyarr&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_a_locations_in_PSDA_dyarr(Position_Stored_Dynamic_ArrayFordyarr* posarr,intpos_acquired);&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to return the number of locations&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;size_t Get_pos_size_From_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr* posarr,BetterPrintfor_PosDyarrWhether_Shown_Print);&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;Erase a dynamic Array when donot using it!&#x2F;&#x2F;DynamicArrayFunctionStatues DesTroy_A_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr* pointer_to_wishedfreeposarr);&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;return a pos that is targeted!&#x2F;&#x2F;void* getPosbyPosinPSDA(Position_Stored_Dynamic_ArrayFordyarr* getter,size_tpos);#endif&#x2F;&#x2F;----------------------------------DynamicArray----------------------------------------------------------------------&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;A Properway to init a default and empty Dynamic Array&#x2F;&#x2F;Use like this: DynamicArray* Dyarr &#x3D; Init_A_DynamicArray(expected_number, datasize)&#x2F;&#x2F;DynamicArray* Init_A_DynamicArray(size_texpected_number,size_tdatasize);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Copied up a Dyarr!&#x2F;&#x2F;Use like this: DynamicArray* copied_one &#x3D; Init_A_DynamicArray_by_CopyADyarr(be_copied)&#x2F;&#x2F;DynamicArray* Init_A_DynamicArray_by_CopyADyarr(DynamicArray* dyarr_copied);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;An update! used to transform a static array to DynamicArray&#x2F;&#x2F;use like this:  &#x2F;&#x2F;DynamicArray* update_arr &#x3D; Updata_A_Static_Array_To_Dynamic_Array(&#x2F;&#x2F;static arr,&#x2F;&#x2F;sizeof(data),&#x2F;&#x2F;how_many_data_are_there_in_the_static_array)&#x2F;&#x2F;DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(void* data,size_tdatasize,size_tdatanum);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a data into the Dynamic Array&#x2F;&#x2F;Use like this: Push_Back_Into_A_Dynamic_Array(dyarr,data)&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tdatasize);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(dyarr,data,the_time_data_repeated,sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(DynamicArray* dyarr,void* data,size_tn_repeat,size_tdatasize);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has a organiztion with static array&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(&#x2F;&#x2F;dyarr,&#x2F;&#x2F;data,&#x2F;&#x2F;how_many_data_are_there_in_static_array,&#x2F;&#x2F;sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(DynamicArray* dyarr,void* data_array,size_tarray_num,size_tpos,size_tdata_inarray_size);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Reshape the dynamic array&#x2F;&#x2F;NOT ROCOMMEND TO USE UNLESS YOU ARE CONCIOUS OF WHAT YOU ARE DOING&#x2F;&#x2F;DynamicArrayFunctionStatues Resize_The_Dynamic_Array(DynamicArray* dyarr,size_twished_new_space_size);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Insert back a data &#x2F;&#x2F; use like this: &#x2F;&#x2F; Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; data, &#x2F;&#x2F; where_to_insert,&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(DynamicArray* dyarr,void* data,size_tpos);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)&#x2F;&#x2F;DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(DynamicArray* dyarr,void* data,size_tn_repeat,size_tdatasize,size_tpos);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back some data that organized in static array&#x2F;&#x2F;use like this: Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; where_to_insert, &#x2F;&#x2F; data, &#x2F;&#x2F; how_many_data_are_there_in_static_array,&#x2F;&#x2F; sizeof(data)&#x2F;&#x2F;)&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(DynamicArray* dyarr,size_tpos,void* data_array,size_tarray_num,size_tdata_inarray_size);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Append another dynamic Array&#x2F;&#x2F; use like this:&#x2F;&#x2F; AppendByMergeDynamicArray(dyarr_be_appended, exp_append_array)&#x2F;&#x2F;DynamicArrayFunctionStatues AppendByMergeDynamicArray(DynamicArray* dyarr_be_appended,DynamicArray* exp_append_array);&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Gain a copy of targeted array from the dynamic array&#x2F;&#x2F;use like this&#x2F;&#x2F; type* datawanna &#x3D; Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(dyarr, datawanna, sizeof(datawanna))&#x2F;&#x2F;void* Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(DynamicArray* dyarr,size_tpos,void* container,size_tcontainer_size);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase the final element!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(DynamicArray* dyarr);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase the final element!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(DynamicArray* dyarr);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Clear_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Clear_A_Dynamic_Array(DynamicArray* dyarr);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements! and unable to be used again!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Destroy_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(DynamicArray* dyarr);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print All data&#x2F;&#x2F; use like this&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(DynamicArray* dyarr,MyPrintuser_print,BetterPrintSwitch_for_dyarr whether_better_print);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(DynamicArray* dyarr,MyPrintuser_print,size_tpos);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in all data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(DynamicArray* dyarr,Do_Specific_Changeuser_change);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(DynamicArray* dyarr,Do_Specific_Changeuser_change,size_tpos);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(DynamicArray* dyarr,size_tpos);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase some specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(DynamicArray* dyarr,size_tBeginpos,size_tEndpos);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues reverse_Data_In_DynamicArray(DynamicArray* dyarr);&#x2F;&#x2F;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in judging whether the dynamic array is empty&#x2F;&#x2F; use like this:&#x2F;&#x2F; isEmpty_InDynamicArray(dyarr)&#x2F;&#x2F;Bool isEmpty_InDynamicArray(DynamicArray* dyarr);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in swap data&#x2F;&#x2F; use like this:&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)&#x2F;&#x2F;DynamicArrayFunctionStatues swapData_in_DynamicArray(DynamicArray* dyarr,size_tpos1,size_tpos2);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; sadly that is bubblesort :(&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol&#x2F;&#x2F; use like this:&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues sort_In_Dynamic_Array(DynamicArray* dyarr,CompareFunccompfunc);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; check if located in the dynamic array&#x2F;&#x2F; use like this:&#x2F;&#x2F; isLocateinDyarr(dyarr, data, comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues isLocateinDyarr(DynamicArray* dyarr,void* data,LocateFuncuser_func);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; return the position of data that is targeted &#x2F;&#x2F; use like this:&#x2F;&#x2F; returnAElembyPos_inDyarr(dyarr, data, comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues returnAElembyPos_inDyarr(DynamicArray* dyarr,void* data,LocateFuncuser_func);&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Using the function when Posarr is enable to use!&#x2F;&#x2F; return a bunch of position of data that is targeted &#x2F;&#x2F; use like this:&#x2F;&#x2F; Position_Stored_Dynamic_ArrayFordyarr* pos &#x3D;r eturnAElembyPos_inDyarr(dyarr, posArr,data, comparision_funcuntional_pointer)&#x2F;&#x2F;#if OPENUPPOSARRPosition_Stored_Dynamic_ArrayFordyarr* returnABunchofData_inDyarr(DynamicArray* dyarr,Position_Stored_Dynamic_ArrayFordyarr* posArr,void* data,LocateFuncuser_func);#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.源文件：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1#defineOPENUPPOSARR 1#define OPENUPDEFAULTSIZE 1#defineQUICKMALLOC 1&#x2F;&#x2F;(General Version)&#x2F;&#x2F;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;&#x2F;&#x2F;Error Code Meaning&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0&#x2F;&#x2F;When Error in mallocing Space the program return 1&#x2F;&#x2F;when inputing a NULL we returns -1&#x2F;&#x2F;when inputing a invalid input we returns -2&#x2F;&#x2F;Locations UnFind we returns -3 &#x2F;&#x2F;typedef enum _DynamicFunctionStatues_ &#123;DynamicArray_Normal &#x3D; 0,DynamicArray_ERROR_IN_MALLOCING_SPACE&#x3D;1,DynamicArray_NULL_INPUT&#x3D;-1,DynamicArray_Invalid_Input&#x3D;-2,DynamicArray_UnFind&#x3D;-3,DynamicArray_Invalid_Free&#x3D;-4&#125;DynamicArrayFunctionStatues;&#x2F;&#x2F;Mybool defined&#x2F;&#x2F;typedef enum _bool_ &#123;True &#x3D; 1,False &#x3D; 0&#125;Bool;#define SHOW_ERROR_DynamicArray_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)#define SHOW_ERROR_DynamicArray_UnFind printf(&quot;\nPositions unfind!\n&quot;)#define SHOW_ERROR_DynamicArray_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)&#x2F;&#x2F;this type of int is specifically used in Returning Find Or Unfind.&#x2F;&#x2F;Recommmend to be used as a nickname:)&#x2F;&#x2F;Can use Find or Unfind to return the result&#x2F;&#x2F;typedef enum _DynamicArray_isFind_ &#123;Find&#x3D;1,Unfind&#x3D;-1&#125;DynamicArray_isFind;&#x2F;&#x2F;A switch that used in better Print in Dynamic Array!&#x2F;&#x2F;Often use OPEN to beautify the control table&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_dyarr_ &#123;Dyarr_OPEN &#x3D; 1,Dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_dyarr;&#x2F;&#x2F;Main Definitions about DynamicArray&#x2F;&#x2F;When Programing , not recommend to Change the data directly! &#x2F;&#x2F;typedef struct _DynamicArray_ &#123;void* DataPiece;size_t current_size;size_t total_usable_size;size_t Single_Data_size;&#125;DynamicArray;&#x2F;&#x2F;--------------------------------Default_size_Type--------------------------------------------&#x2F;&#x2F;These abstractions are used to reduce the input&#x2F;&#x2F;used as Dyarr_Default_TYPE(type_number) to replace the code:sizeof(Typename)*type_number#if OPENUPDEFAULTSIZE&#x2F;&#x2F;Single Type size&#x2F;&#x2F;#define Dyarr_SIGINT sizeof(int)#define Dyarr_SIGCHAR sizeof(char)#define Dyarr_SIGFLOAT sizeof(float)#define Dyarr_SIGDOUBLE sizeof(double)#define Dyarr_SIG(dataType) sizeof(dataType)&#x2F;&#x2F;Mutiply type size&#x2F;&#x2F;#define Dyarr_INT_SIZE(X) sizeof(int)*X#define Dyarr_CHAR_SIZE(X) sizeof(char)*X#define Dyarr_FLOAT_SIZE(X) sizeof(float)*X#define Dyarr_DOUBLE_SIZE(X) sizeof(double)*X#define Dyarr_TYPE_SIZE(dataType,X) sizeof(dataType)*X#endif&#x2F;&#x2F;-------------------------------------------QuickMalloc----------------------------------------&#x2F;&#x2F;As the name goes lol&#x2F;&#x2F;#if QUICKMALLOC #define Dyarr_DEFAULT_MALLOC 5#define MALLOCDYARR(datatype,data_num) (datatype*)malloc(sizeof(datatype)*data_num)#endif&#x2F;&#x2F;----------------------------------------STD_FUNC_AND_INT_TYPE----------------------------------&#x2F;&#x2F; Return type of compared functions&#x2F;&#x2F;typedef unsigned int Is_Used_Compared_Int;&#x2F;&#x2F; the pointer type of Print !&#x2F;&#x2F; When Printing , type :&#x2F;&#x2F; MyPrint user_print_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F; &#123;&#x2F;&#x2F;print in your way for your data!&#x2F;&#x2F; &#125;&#x2F;&#x2F;typedef void(*MyPrint)(void*);&#x2F;&#x2F; the pointer type of Making change for the data that has been locates in the Dynamic Array!&#x2F;&#x2F; When want to make some change, type like this:&#x2F;&#x2F; Do_Specific_Change user_dochange_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;do some change here for your data!&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef void*(*Do_Specific_Change)(void*);&#x2F;&#x2F; the pointer type of using when comparing for your data&#x2F;&#x2F; When want to make a comparisons, type like this:&#x2F;&#x2F; CompareFunc user_comp_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;return &#x2F;&#x2F;the wishing compare!&#x2F;&#x2F;&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef Is_Used_Compared_Int(*CompareFunc)(void*,void*);&#x2F;&#x2F; the pointer type of using when checking iflocated for your data&#x2F;&#x2F; When want to make a comparisons, type like this:&#x2F;&#x2F; LocateFunc user_loc_function_name(datatype* e1, datatype* e2)&#x2F;&#x2F;&#123;&#x2F;&#x2F;return data1&#x3D;&#x3D;data2(define by yourself! if complicated, just return Find or unfind to show whether is found)&#x2F;&#x2F;&#125;&#x2F;&#x2F;typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);&#x2F;&#x2F;-----------------------Position_Stored_Dynamic_Array_For_Dyarr---------------------------------#if OPENUPPOSARR&#x2F;&#x2F;Main data structure!&#x2F;&#x2F;Used in returning multitude locations&#x2F;&#x2F;typedef struct _Dyarrposarr_ &#123;int* posSpace;size_t pos_size;&#125;Position_Stored_Dynamic_ArrayFordyarr;&#x2F;&#x2F;Want a better Print to beutify your control table? try this one&#x2F;&#x2F;typedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;PSDA_dyarr_OPEN &#x3D; 1,PSDA_dyarr_CLOSE &#x3D; 0&#125;BetterPrintSwitch_for_pos_dyarr;&#x2F;&#x2F;can use this type when indicating the type&#x2F;&#x2F;typedef unsigned int BetterPrintfor_PosDyarr;&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();&#x2F;&#x2F;Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr()&#123;Position_Stored_Dynamic_ArrayFordyarr* pro_usable_space &#x3D; MALLOCDYARR(Position_Stored_Dynamic_ArrayFordyarr, 1);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;  pro_usable_space-&gt;posSpace &#x3D; NULL;pro_usable_space-&gt;pos_size &#x3D; 0;return pro_usable_space;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;DynamicArrayFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr,BetterPrintfor_PosDyarrWhether_Better_Print)&#123;if (!posarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nPositions are shown! :\n&quot;);for (int i &#x3D; 0; i &lt; posarr-&gt;pos_size; i++)printf(&quot;%u &quot;, posarr-&gt;posSpace[i]);if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nFinish Printing!\n&quot;);return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to push back a position into the Position_Stored_Dynamic_ArrayFordyarr&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_a_locations_in_PSDA_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr, intpos_acquired)&#123;int* pro_usable_space &#x3D; (int*)realloc(posarr-&gt;posSpace, sizeof(int) * (posarr-&gt;pos_size + 1));if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;posarr-&gt;posSpace &#x3D; pro_usable_space;posarr-&gt;posSpace[posarr-&gt;pos_size] &#x3D; pos_acquired;posarr-&gt;pos_size++;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;this function is aimed to return the number of locations&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE&#x2F;&#x2F;size_t Get_pos_size_From_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*posarr,BetterPrintfor_PosDyarrWhether_Shown_Print )&#123;if (!posarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Whether_Shown_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)printf(&quot;\nCurrent targeted data&#39;s total num is:%u!\n&quot;,posarr-&gt;pos_size);return posarr-&gt;pos_size;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;Erase a dynamic Array when donot using it!&#x2F;&#x2F;DynamicArrayFunctionStatues DesTroy_A_PSDA_for_dyarr(Position_Stored_Dynamic_ArrayFordyarr*pointer_to_wishedfreeposarr)&#123;if (!pointer_to_wishedfreeposarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_Invalid_Free);&#125;free(pointer_to_wishedfreeposarr-&gt;posSpace);free(pointer_to_wishedfreeposarr);pointer_to_wishedfreeposarr &#x3D; NULL;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Positions_Stored_Dynamic_Array&#x2F;&#x2F;return a pos that is targeted!&#x2F;&#x2F;void* getPosbyPosinPSDA(Position_Stored_Dynamic_ArrayFordyarr*getter,size_tpos) &#123;if (!getter) &#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_Invalid_Free);&#125;if (pos &gt; getter-&gt;pos_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;for (int i &#x3D; 0; i &lt; pos; i++)return (char*)getter-&gt;posSpace + i * sizeof(size_t);&#125;#endif&#x2F;&#x2F;----------------------------------DynamicArray----------------------------------------------------------------------&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;A Properway to init a default and empty Dynamic Array&#x2F;&#x2F;Use like this: DynamicArray* Dyarr &#x3D; Init_A_DynamicArray(expected_number, datasize)&#x2F;&#x2F;DynamicArray* Init_A_DynamicArray(size_texpected_number,size_tdatasize)&#123;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;pro_usable_space-&gt;DataPiece &#x3D; NULL;pro_usable_space-&gt;Single_Data_size &#x3D; datasize;if (expected_number &gt;&#x3D; Dyarr_DEFAULT_MALLOC)pro_usable_space-&gt;total_usable_size &#x3D; expected_number;elsepro_usable_space-&gt;total_usable_size &#x3D; Dyarr_DEFAULT_MALLOC;pro_usable_space-&gt;current_size &#x3D; 0;return pro_usable_space;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Copied up a Dyarr!&#x2F;&#x2F;Use like this: DynamicArray* copied_one &#x3D; Init_A_DynamicArray_by_CopyADyarr(be_copied)&#x2F;&#x2F;DynamicArray* Init_A_DynamicArray_by_CopyADyarr(DynamicArray*dyarr_copied)&#123;if (!dyarr_copied)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;void* pro_usable_data &#x3D; MALLOCDYARR(char, (dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size));if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;memcpy(pro_usable_space-&gt;DataPiece, dyarr_copied-&gt;DataPiece, dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size);pro_usable_space-&gt;current_size &#x3D; dyarr_copied-&gt;current_size;pro_usable_space-&gt;Single_Data_size &#x3D; dyarr_copied-&gt;Single_Data_size;pro_usable_space-&gt;total_usable_size &#x3D; dyarr_copied-&gt;total_usable_size;return pro_usable_space;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;An update! used to transform a static array to DynamicArray&#x2F;&#x2F;use like this:  &#x2F;&#x2F;DynamicArray* update_arr &#x3D; Updata_A_Static_Array_To_Dynamic_Array(&#x2F;&#x2F;static arr,&#x2F;&#x2F;sizeof(data),&#x2F;&#x2F;how_many_data_are_there_in_the_static_array)&#x2F;&#x2F;DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(void*data, size_tdatasize,size_tdatanum)&#123;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);if(!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;void* pro_usable_data &#x3D; malloc(datasize * datanum*1.5);if(!pro_usable_data)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(pro_usable_data, data, datasize * datanum);pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;pro_usable_space-&gt;current_size &#x3D; datanum;pro_usable_space-&gt;Single_Data_size &#x3D; datasize;pro_usable_space-&gt;total_usable_size &#x3D; 1.5 * datanum;return pro_usable_space;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a data into the Dynamic Array&#x2F;&#x2F;Use like this: Push_Back_Into_A_Dynamic_Array(dyarr,data)&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data,size_tdatasize)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size) &#123;printf(&quot;%d &quot;, sizeof(data));SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 1.3 * (dyarr-&gt;total_usable_size));void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1)*dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy((char*)Afteradd_piece + dyarr-&gt;current_size * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; Afteradd_piece;dyarr-&gt;current_size++;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(dyarr,data,the_time_data_repeated,sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;for (int i &#x3D; 0; i &lt; n_repeat; i++)memcpy((char*)newspace + (dyarr-&gt;current_size+i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Push back a lot of data that has a organization that has a organiztion with static array&#x2F;&#x2F;Use like this: &#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(&#x2F;&#x2F;dyarr,&#x2F;&#x2F;data,&#x2F;&#x2F;how_many_data_are_there_in_static_array,&#x2F;&#x2F;sizeof(data))&#x2F;&#x2F;DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data_array, size_tarray_num, size_tpos,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (data_inarray_size !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);if(!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece &#x3D; newspace;for (int i &#x3D; 0; i &lt; array_num; i++)memcpy((char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,(char*)data_array + i * (dyarr-&gt;Single_Data_size),dyarr-&gt;Single_Data_size);dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Reshape the dynamic array&#x2F;&#x2F;NOT ROCOMMEND TO USE UNLESS YOU ARE CONCIOUS OF WHAT YOU ARE DOING&#x2F;&#x2F;DynamicArrayFunctionStatues Resize_The_Dynamic_Array(DynamicArray*dyarr,size_twished_new_space_size)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, wished_new_space_size * (dyarr-&gt;Single_Data_size));if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;total_usable_size &#x3D; wished_new_space_size;if (dyarr-&gt;current_size &gt; dyarr-&gt;total_usable_size)dyarr-&gt;current_size &#x3D; dyarr-&gt;total_usable_size;&#x2F;&#x2F;Used when still unable to contain datareturn DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Insert back a data &#x2F;&#x2F; use like this: &#x2F;&#x2F; Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; data, &#x2F;&#x2F; where_to_insert,&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(DynamicArray*dyarr, void*data, size_tpos)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * (dyarr-&gt;total_usable_size));void* Afteradd_piece&#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy((char*)dyarr-&gt;DataPiece + (pos + 1) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos+1));memmove((char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);dyarr-&gt;current_size++;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data&#x2F;&#x2F;Use like this: &#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)&#x2F;&#x2F;DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(DynamicArray*dyarr,void*data,size_tn_repeat,size_tdatasize,size_tpos)&#123;if (!dyarr &amp;&amp; !data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (datasize !&#x3D; dyarr-&gt;Single_Data_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);if (!newspace)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove((char*)dyarr-&gt;DataPiece + (pos + n_repeat) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * n_repeat);for (int i &#x3D; 0; i &lt; n_repeat; i++)memcpy((char*)newspace + (pos + i) * dyarr-&gt;Single_Data_size,data,dyarr-&gt;Single_Data_size);dyarr-&gt;DataPiece &#x3D; newspace;dyarr-&gt;current_size +&#x3D; n_repeat;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Insert back some data that organized in static array&#x2F;&#x2F;use like this: Insert_Into_A_Dynamic_Array(&#x2F;&#x2F; dyarr, &#x2F;&#x2F; where_to_insert, &#x2F;&#x2F; data, &#x2F;&#x2F; how_many_data_are_there_in_static_array,&#x2F;&#x2F; sizeof(data)&#x2F;&#x2F;)&#x2F;&#x2F;DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(DynamicArray*dyarr,size_tpos,void*data_array, size_tarray_num,size_tdata_inarray_size)&#123;if (!dyarr &amp;&amp; !data_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (!dyarr-&gt;current_size)&#123;Push_Back_Some_data_Into_A_Dynamic_Array(dyarr, data_array, array_num, pos,data_inarray_size);return DynamicArray_Normal;&#125;if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;if (DataRate &gt; 0)Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);if (!Afteradd_piece)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memmove((char*)dyarr-&gt;DataPiece + (pos + array_num) * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*array_num);for (int i &#x3D; 0; i &lt; array_num; i++)memcpy((char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,(char*)data_array + i * (dyarr-&gt;Single_Data_size),dyarr-&gt;Single_Data_size);dyarr-&gt;current_size +&#x3D; array_num;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Append another dynamic Array&#x2F;&#x2F; use like this:&#x2F;&#x2F; AppendByMergeDynamicArray(dyarr_be_appended, exp_append_array)&#x2F;&#x2F;DynamicArrayFunctionStatues AppendByMergeDynamicArray(DynamicArray*dyarr_be_appended,DynamicArray*exp_append_array)&#123;if (!dyarr_be_appended &amp;&amp; !exp_append_array)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;int datarate &#x3D; exp_append_array-&gt;current_size &#x2F; dyarr_be_appended-&gt;total_usable_size;if (dyarr_be_appended-&gt;current_size &#x3D;&#x3D; dyarr_be_appended-&gt;total_usable_size)Resize_The_Dynamic_Array(dyarr_be_appended, 2 * dyarr_be_appended-&gt;total_usable_size);if (datarate &gt; 0)Resize_The_Dynamic_Array(dyarr_be_appended, (datarate + 1) * dyarr_be_appended-&gt;total_usable_size);void* AfterAppend &#x3D; realloc(dyarr_be_appended-&gt;DataPiece,(dyarr_be_appended-&gt;current_size + exp_append_array-&gt;current_size) * dyarr_be_appended-&gt;Single_Data_size);if (!AfterAppend)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr_be_appended-&gt;DataPiece &#x3D; AfterAppend;memcpy((char*)dyarr_be_appended-&gt;DataPiece + dyarr_be_appended-&gt;current_size * dyarr_be_appended-&gt;Single_Data_size,(char*)exp_append_array-&gt;DataPiece,exp_append_array-&gt;current_size * exp_append_array-&gt;Single_Data_size);dyarr_be_appended-&gt;current_size +&#x3D; exp_append_array-&gt;current_size;return DynamicArray_Normal;&#125;&#x2F;&#x2F;About Dynamic Array&#x2F;&#x2F;Gain a copy of targeted array from the dynamic array&#x2F;&#x2F;use like this&#x2F;&#x2F; type* datawanna &#x3D; Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(dyarr, datawanna, sizeof(datawanna))&#x2F;&#x2F;void* Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(DynamicArray*dyarr, size_tpos,void*container,size_tcontainer_size)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (dyarr-&gt;Single_Data_size&gt; container_size)&#123;printf(&quot;Specifically unable to contain your data! Try Larger one!\nNull pointer is returned!&quot;);return NULL;&#125;if (dyarr-&gt;Single_Data_size &lt; container_size)&#123;printf(&quot;Warning:Be Cautious the size doesn&#39;t fit!Please change your pointer step from %u to %u\nElse Error will be occurred&quot;, container_size, dyarr-&gt;Single_Data_size);exit(DynamicArray_Invalid_Input);&#125;memcpy(container, (char*)dyarr-&gt;DataPiece + pos * (dyarr-&gt;Single_Data_size), container_size);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase the final element!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(DynamicArray*dyarr)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Clear_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Clear_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;dyarr-&gt;current_size &#x3D; 0;if (!dyarr-&gt;DataPiece)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;printf(&quot;VOID DATA SHOULDN&#39;T BE FREE!&quot;);exit(DynamicArray_Invalid_Free);&#125;void* pro_usable_space&#x3D; realloc(dyarr-&gt;DataPiece, dyarr-&gt;Single_Data_size);if (!pro_usable_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;dyarr-&gt;DataPiece&#x3D;pro_usable_space;dyarr-&gt;total_usable_size &#x3D; 1;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase all elements! and unable to be used again!&#x2F;&#x2F; use like this:&#x2F;&#x2F; Destroy_A_Dynamic_Array(dyarr)&#x2F;&#x2F;DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(DynamicArray*dyarr)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_Invalid_Free;exit(DynamicArray_Invalid_Free);&#125;free(dyarr-&gt;DataPiece);free(dyarr);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print All data&#x2F;&#x2F; use like this&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(DynamicArray*dyarr,MyPrintuser_print,BetterPrintSwitch_for_dyarrwhether_better_print)&#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if(whether_better_print&#x3D;&#x3D;Dyarr_OPEN)&#123;printf(&quot;\nStart Printing\n&quot;);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;(*user_print)((char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size));&#125;if (whether_better_print &#x3D;&#x3D; Dyarr_OPEN)&#123;printf(&quot;\nFinish Printing\n&quot;);&#125;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually Print a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(DynamicArray*dyarr, MyPrintuser_print, size_tpos) &#123;if (!dyarr &amp;&amp; !user_print)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;printf(&quot;\nSpecific Data is Shown:\n&quot;);user_print((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));printf(&quot;\nSpecific Data Finished Showing!\n&quot;);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in all data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change) &#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)user_change((char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size));return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually make some change in a specific data&#x2F;&#x2F; use like this&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(DynamicArray*dyarr, Do_Specific_Changeuser_change, size_tpos)&#123;if (!dyarr &amp;&amp; !user_change)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;user_change((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tpos)&#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;memcpy((char*)dyarr-&gt;DataPiece+pos*dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece+(pos+1)*dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos-1));dyarr-&gt;current_size--;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase some specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)&#x2F;&#x2F;DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(DynamicArray*dyarr, size_tBeginpos, size_tEndpos)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (Beginpos &lt; 0 || Beginpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (Endpos &lt; 0 || Endpos&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;memcpy((char*)dyarr-&gt;DataPiece + Beginpos * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (Endpos + 1) * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - Endpos + 1));dyarr-&gt;current_size -&#x3D; Endpos - Beginpos + 1;if (dyarr-&gt;current_size &lt;&#x3D; dyarr-&gt;total_usable_size &#x2F; 4 &amp;&amp; dyarr-&gt;total_usable_size &gt; 5)&#123;Resize_The_Dynamic_Array(dyarr, dyarr-&gt;total_usable_size &#x2F; 2);dyarr-&gt;total_usable_size &#x2F;&#x3D; 2;&#125;return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Actually erase a specific data by pos&#x2F;&#x2F; use like this&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)&#x2F;&#x2F;DynamicArrayFunctionStatues reverse_Data_In_DynamicArray(DynamicArray*dyarr) &#123;if(!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size &#x2F; 2; i++)&#123;memcpy(swapbit, (char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size, dyarr-&gt;Single_Data_size);&#x2F;&#x2F;原型：int temp&#x3D;*a,*a&#x3D;*b,*b&#x3D;tempmemmove((char*)dyarr-&gt;DataPiece + i*dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (dyarr-&gt;current_size - i-1) * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memcpy((char*)dyarr-&gt;DataPiece + (dyarr-&gt;current_size - i - 1) * dyarr-&gt;Single_Data_size, swapbit, dyarr-&gt;Single_Data_size);&#125;free(swapbit);return DynamicArray_Normal;&#125;&#x2F;&#x2F;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in judging whether the dynamic array is empty&#x2F;&#x2F; use like this:&#x2F;&#x2F; isEmpty_InDynamicArray(dyarr)&#x2F;&#x2F;Bool isEmpty_InDynamicArray(DynamicArray*dyarr) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!dyarr-&gt;current_size)return True;return False;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; this is used in swap data&#x2F;&#x2F; use like this:&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)&#x2F;&#x2F;DynamicArrayFunctionStatues swapData_in_DynamicArray(DynamicArray*dyarr, size_tpos1, size_tpos2)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)&#123;SHOW_ERROR_DynamicArray_Invalid_Input;exit(DynamicArray_Invalid_Input);&#125;char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);if(!swapbit)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;memcpy(swapbit,(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memmove((char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,dyarr-&gt;Single_Data_size);memcpy((char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,swapbit,dyarr-&gt;Single_Data_size);free(swapbit);return DynamicArray_Normal;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; sadly that is bubblesort :(&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol&#x2F;&#x2F; use like this:&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues sort_In_Dynamic_Array(DynamicArray*dyarr,CompareFunccompfunc) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!compfunc)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size-1; i++)&#123;for (int j &#x3D; 0; j &lt; dyarr-&gt;current_size - i-1; j++)&#123;if (compfunc((char*)dyarr-&gt;DataPiece + j * dyarr-&gt;Single_Data_size,(char*)dyarr-&gt;DataPiece + (j + 1) * dyarr-&gt;Single_Data_size))swapData_in_DynamicArray(dyarr, j, j + 1);&#125;&#125;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; check if located in the dynamic array&#x2F;&#x2F; use like this:&#x2F;&#x2F; isLocateinDyarr(dyarr, data, comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues isLocateinDyarr(DynamicArray*dyarr,void*data,LocateFuncuser_func)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if (user_func((char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size, data))&#123;return Find;&#125;&#125;return Unfind;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; return the position of data that is targeted &#x2F;&#x2F; use like this:&#x2F;&#x2F; returnAElembyPos_inDyarr(dyarr, data, comparision_funcuntional_pointer)&#x2F;&#x2F;DynamicArrayFunctionStatues returnAElembyPos_inDyarr(DynamicArray*dyarr, void*data, LocateFuncuser_func) &#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if (user_func((char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size, data))&#123;return i;&#125;&#125;return Unfind;&#125;&#x2F;&#x2F; About Dynamic Array&#x2F;&#x2F; Using the function when Posarr is enable to use!&#x2F;&#x2F; return a bunch of position of data that is targeted &#x2F;&#x2F; use like this:&#x2F;&#x2F; Position_Stored_Dynamic_ArrayFordyarr* pos &#x3D;r eturnAElembyPos_inDyarr(dyarr, posArr,data, comparision_funcuntional_pointer)&#x2F;&#x2F;#if OPENUPPOSARRPosition_Stored_Dynamic_ArrayFordyarr* returnABunchofData_inDyarr(DynamicArray*dyarr, Position_Stored_Dynamic_ArrayFordyarr*posArr, void*data, LocateFuncuser_func)&#123;if (!dyarr)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!user_func)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;if (!data)&#123;SHOW_ERROR_DynamicArray_NULL_INPUT;exit(DynamicArray_NULL_INPUT);&#125;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;int possible_count &#x3D; 0;for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)&#123;if ((*user_func)(data, (char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size))&#123;int* pro_usable_stored_space &#x3D; (int*)realloc(posArr-&gt;posSpace, sizeof(int) * (possible_count + 1));if (!pro_usable_stored_space)&#123;SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);&#125;posArr-&gt;posSpace &#x3D; pro_usable_stored_space;posArr-&gt;posSpace[possible_count] &#x3D; i;possible_count++;posArr-&gt;pos_size &#x3D; possible_count;&#125;&#125;if (posArr-&gt;pos_size)return posArr;return Unfind;&#125;&#125;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试文档：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1#include&quot;standard_dynamic_array.h&quot;MyPrint print(int* e1) &#123;printf(&quot;%d &quot;, *e1);&#125;Do_Specific_Change dochange(int* e1) &#123;*e1 &#x3D; *e1 + 1;&#125;LocateFunc loc(int* e1, int* e2) &#123;if (*e1 &#x3D;&#x3D; *e2) &#123;return Find;&#125;return Unfind;&#125;int main()&#123;int data1 &#x3D; 10;printf(&quot;%d &quot;, sizeof(data1));    &#x2F;&#x2F;test InitingDynamicArray* testDyarr1 &#x3D; Init_A_DynamicArray(10, Dyarr_SIGINT);    &#x2F;&#x2F;test a Sigdata pushed:Push_Back_Into_A_Dynamic_Array(testDyarr1, &amp;data1,sizeof(int));Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;test pushing the same dataPush_back_Same_data_Into_A_Dynamic_Array(testDyarr1, &amp;data1, 10, Dyarr_SIGINT);Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;Test ClearingClear_A_Dynamic_Array(testDyarr1);Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);    &#x2F;&#x2F;test updateint data2[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;DynamicArray* test2&#x3D;Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);Print_ALL_Data_In_A_Dynamic_Array(test2, print, Dyarr_OPEN);    &#x2F;&#x2F;test copy:DynamicArray* copyone &#x3D; Init_A_DynamicArray_by_CopyADyarr(test2);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test insertprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Insert_Into_A_Dynamic_Array(copyone, &amp;data1, 1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test insert bunchprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Insert_Some_Data_Into_A_Dynamic_Array(copyone, 1, data2, 10, Dyarr_SIGINT);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Erasing sigoneprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Delete_A_Specific_Data_From_the_DynamicArray(copyone, 1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Erasing bunch oneprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Delete_Some_Specific_Data_From_the_DynamicArray(copyone,1,10);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test Do changeprintf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Do_Specific_Change_To_Specific_Data(copyone,dochange,1);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);printf(&quot;before:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);Do_Specific_Change_To_All_Data(copyone, dochange);printf(&quot;after:&quot;);Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);    &#x2F;&#x2F;test location:DynamicArray* test3 &#x3D; Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);if (isLocateinDyarr(test3, &amp;data2[2], loc)) &#123;printf(&quot;\nI have found it!\n&quot;);&#125;int where &#x3D; returnAElembyPos_inDyarr(test3, &amp;data2[2], loc);printf(&quot;\nIn dyarr the %d place\n&quot;, where);    &#x2F;&#x2F;test Position Stored Dynamic Array and returnBunchClear_A_Dynamic_Array(test3);Push_back_Same_data_Into_A_Dynamic_Array(test3, &amp;data2[2], 10, Dyarr_SIGINT);Position_Stored_Dynamic_ArrayFordyarr* p1 &#x3D; Init_A_Postion_Stored_Dynamic_ArrayFordyarr();returnABunchofData_inDyarr(test3, p1, &amp;data2[2], loc);Print_ALL_Data_In_A_Dynamic_Array(test3, print, Dyarr_OPEN);Show_All_Locations_In_PSDAfor_dyarr(p1, PSDA_dyarr_OPEN);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> MyTinyLibProject </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv-in-Pycharm （3）</title>
      <link href="/2023/02/06/Opencv-in-Pycharm-%EF%BC%883%EF%BC%89/"/>
      <url>/2023/02/06/Opencv-in-Pycharm-%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="腐蚀操作"><a href="#腐蚀操作" class="headerlink" title="腐蚀操作"></a>腐蚀操作</h3><p>​        对于这样的一些图片：</p><p><img src="1.png" alt="1"></p><p>​        我们可以使用腐蚀操作来钝化特征：删除掉一些边界的像素点（置黑色）。其中：腐蚀的大小，范围是由kernel决定的。在Python中，我们需要这样指定一个核：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kernel<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        还是需要指定一个迭代次数的参数，这行代码完成了这样的工作：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">erosion<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>                  kernel<span class="token punctuation">,</span>                  iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#迭代次数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们首先看看效果怎么样：</p><p><img src="erosion.png" alt="erosion"></p><p>​        可以看到，腐蚀核在检测到边界条件的时候（白转黑and黑转白）自动将这些像素点填充成黑色，除非核内的像素点都是统一的，否则都会腐蚀！</p><p>​        可以来点控制变量！比如说指定不同的腐蚀核来观察效果</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> nppath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion33<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion55<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span>erosion33<span class="token punctuation">,</span>erosion55<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"comp"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Kernel Diff compararison.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Kernel Diff compararison.png" alt="Kernel Diff compararison"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion33<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion55<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>imgs_ero1<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>erosion33<span class="token punctuation">,</span>erosion55<span class="token punctuation">]</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Original'</span><span class="token punctuation">,</span><span class="token string">'3 times 3 '</span><span class="token punctuation">,</span><span class="token string">'5 times t '</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>imgs_ero1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_1-16756699063337.png" alt="Figure_1"></p><p>​        可以看到，核越大，就越会腐蚀图像！</p><p>​        下面看看图像迭代影响：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> nppath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span>erosion1<span class="token punctuation">,</span>erosion2<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"comp"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Iterator Diff comparasion.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Iterator Diff comparasion.png" alt="Iterator Diff comparasion"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>erosion1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>erosion2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>imgs_ero1<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>erosion1<span class="token punctuation">,</span>erosion2<span class="token punctuation">]</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Original'</span><span class="token punctuation">,</span><span class="token string">'1 '</span><span class="token punctuation">,</span><span class="token string">'2 '</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>imgs_ero1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_2.png" alt="Figure_2"></p><p>可以看见：越是迭代，图像腐蚀的越严重！</p><h3 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h3><p>​        这个操作可以视作腐蚀操作的反操作：就是将特征明显化：</p><p><img src="dilate.png" alt="dilate"></p><p>​        老规矩：还是看看改变核大小和迭代次数产生的效果如何：</p><p>​        先看核大小：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> nppath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>dilate1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>dilate2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span>dilate1<span class="token punctuation">,</span>dilate2<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"comp"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"kernel_in_dilate Diff comparasion.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="kernel_in_dilate Diff comparasion.png" alt="kernel_in_dilate Diff comparasion"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>kernel55<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>dilate1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>dilate2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel55<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'org'</span><span class="token punctuation">,</span><span class="token string">'3 times 3'</span><span class="token punctuation">,</span><span class="token string">'5 times 5'</span><span class="token punctuation">]</span>img_group<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>dilate1<span class="token punctuation">,</span>dilate2<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img_group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_3.png" alt="Figure_3"></p><p>​        再来看看迭代器的影响：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath<span class="token operator">=</span><span class="token string">"1.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33<span class="token operator">=</span>np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>dilate1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>dilate2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img<span class="token punctuation">,</span>kernel33<span class="token punctuation">,</span>iterations<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'org'</span><span class="token punctuation">,</span><span class="token string">'3 times 3'</span><span class="token punctuation">,</span><span class="token string">'5 times 5'</span><span class="token punctuation">]</span>img_group<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>dilate1<span class="token punctuation">,</span>dilate2<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>img_group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="Figure_4.png" alt="Figure_4"></p><p>​        还是很容易看出来：核越大，迭代次数越多，图片的特征就被放大的越明显！</p><h4 id="扩展阅读1"><a href="#扩展阅读1" class="headerlink" title="扩展阅读1"></a>扩展阅读1</h4><p>​        版权声明：本文为CSDN博主「我有一個夢想」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>​        原文链接：<a href="https://blog.csdn.net/B08370108/article/details/118028678">https://blog.csdn.net/B08370108/article/details/118028678</a></p><p>​        <strong>图像的腐蚀过程与图像的卷积操作类似，都需要模板矩阵来控制运算的结果</strong>，在图像的腐蚀和膨胀中这个模板矩阵被称为结构元素。与图像卷积相同，结构元素可以任意指定图像的中心点，并且结构元素的尺寸和具体内容都可以根据需求自己定义。定义结构元素之后，将结构元素的中心点依次放到图像中每一个非0元素处，如果此时结构元素内所有的元素所覆盖的图像像素值均不为0，则保留结构元素中心点对应的图像像素，否则将删除结构元素中心点对应的像素。图像的腐蚀过程示意图如图6-12所示，图6-12中左侧为待腐蚀的原图像，中间为结构元素，<strong>首先将结构元素的中心与原图像中的A像素重合，此时结构元素中心点的左侧和上方元素所覆盖的图像像素值均为0，因此需要将原图像中的A像素删除</strong>；<strong>当把结构元素的中心点与B像素重合时，此时结构元素中所有的元素所覆盖的图像像素值均为1</strong>，因此保留原图像中的B像素。将结构元素中心点依次与原图像中的每个像素重合，判断每一个像素点是否保留或者删除，最终原图像腐蚀的结果如图中下侧图像所示。</p><p>​        <img src="2021011613033220.png" alt="img"></p><p>​        图像腐蚀可以用“Θ”表示，其数学表示形式如式(6.4)所示，通过公式可以发现，其实对图像A的腐蚀运算就是寻找图像中能够将结构元素B全部包含的像素点。</p><p>​        生成常用的矩形结构元素、十字结构元素和椭圆结构：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Mat getStructuringElement(int shape, Size ksize, Point anchor &#x3D; Point(-1,-1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;shape：结构元素的种类，可以选择的参数及含义在表6-5中给出。&#x2F;&#x2F;ksize：结构元素的尺寸大小&#x2F;&#x2F;anchor：中心点的位置，默认参数为结构元素的几何中心点。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>     该函数用于生成图像形态学操作中常用的矩形结构元素、十字结构元素和椭圆结构元素。函数第一个参数为生成结构元素的种类，可以选择的参数及含义在表给出，函数第二个参数是结构元素的尺寸大小，能够影响到图像腐蚀的效果，一般情况下，结构元素的种类相同时，结构元素的尺寸越大腐蚀效果越明显。函数的最后一个参数是结构元素的中心点，只有十字结构元素的中心点位置会影响图像腐蚀后的轮廓形状，其他种类的结构元素的中心点位置只影响形态学操作结果的平移量。</code></pre><p><img src="20210116131530359.png" alt="表6-5 getStructuringElement()函数结构元素形状可选择参数"></p><p>腐蚀函数</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void erode( InputArray src,            OutputArray dst,            InputArray kernel,           Point anchor &#x3D; Point(-1,-1), int iterations &#x3D; 1,           int borderType &#x3D; BORDER_CONSTANT,           const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue()           );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;src：输入的待腐蚀图像，图像的通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。&#x2F;&#x2F;dst：腐蚀后的输出图像，与输入图像src具有相同的尺寸和数据类型。&#x2F;&#x2F;kernel：用于腐蚀操作的结构元素，可以自己定义，也可以用getStructuringElement()函数生成。&#x2F;&#x2F;anchor：中心点在结构元素中的位置，默认参数为结构元素的几何中心点&#x2F;&#x2F;iterations：腐蚀的次数，默认值为1。&#x2F;&#x2F;borderType：像素外推法选择标志，取值范围在表3-5中给出。默认参数为BORDER_DEFAULT，表示不包含边界值倒序填充。&#x2F;&#x2F;borderValue：使用边界不变外推法时的边界值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        该函数根据结构元素对输入图像进行腐蚀，在腐蚀多通道图像时每个通道独立进行腐蚀运算。<br>​        函数的第一个参数为待腐蚀的图像，图像通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。<br>​        函数第二个参数为腐蚀后的输出图像，与输入图像具有相同的尺寸和数据类型。<br>​        函数第三个和第四个参数都是与结构元素相关的参数，第三个参数为结构元素，第四个参数为结构元素的中心位置，第四个参数的默认值为Point(-1,-1)，表示结构元素的几何中心处为结构元素的中心点。<br>​        函数第五个参数是使用结构元素腐蚀的次数，腐蚀次数越多效果越明显，参数默认值为1，表示只腐蚀1次。<br>​        函数第六个参数是图像像素外推法的选择标志，<br>​        第七个参数为使用边界不变外推法时的边界值，这两个参数对图像中主要部分的腐蚀操作没有影响，因此在多数情况下使用默认值即可。</p><p>​        需要注意的是该函数的腐蚀过程只针对图像中的非0像素，因此如果图像是以0像素为背景，那么腐蚀操作后会看到图像中的内容变得更瘦更小；如果图像是以255像素为背景，那么腐蚀操作后会看到图像中的内容变得更粗更大。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">   简单示例&#x2F;&#x2F;&#x2F;&#x2F; Created by smallflyfly on 2021&#x2F;6&#x2F;18.&#x2F;&#x2F;#include &quot;opencv2&#x2F;opencv.hpp&quot;#include &lt;iostream&gt;using namespace std;using namespace cv;void drawResult(Mat im, int num, Mat stats, Mat centroids, const string&amp; name) &#123;    for (int i &#x3D; 1; i &lt; num; ++i)     &#123;        int x &#x3D; centroids.at&lt;double&gt;(i, 0);        int y &#x3D; centroids.at&lt;double&gt;(i, 1);        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;        circle(im, Point(x, y), 2, Scalar(0, 0, 255), -1);        int xmin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_LEFT);        int ymin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_TOP);        int w &#x3D; stats.at&lt;int&gt;(i, CC_STAT_WIDTH);        int h &#x3D; stats.at&lt;int&gt;(i, CC_STAT_HEIGHT);Rect rect(xmin, ymin, w, h);    rectangle(im, rect, Scalar(255, 255, 255), 2);    putText(            im,                 to_string(i),                 Point(x+5, y),                 FONT_HERSHEY_SCRIPT_SIMPLEX,                 0.3,                 Scalar(0, 0, 255),                 1);&#125;imshow(name, im);&#125;int main() &#123;Mat src &#x3D; (            Mat_&lt;uchar&gt;(6, 6) &lt;&lt;                    0, 0, 0, 0, 255, 0,                    0, 255, 255, 255, 255, 255,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 0, 0, 0, 255, 0        );resize(src, src, Size(0, 0), 50, 50, INTER_NEAREST);Mat m1, m2;m1 &#x3D; getStructuringElement(0, Size(3, 3));m2 &#x3D; getStructuringElement(1, Size(3, 3)); Mat erodeM1, erodeM2;erode(src, erodeM1, m1, Point(-1, -1), 10);erode(src, erodeM2, m2, Point(-1, -1), 10); imshow(&quot;src&quot;, src);imshow(&quot;erodeM1&quot;, erodeM1);imshow(&quot;erodeM2&quot;, erodeM2); Mat xbim &#x3D; imread(&quot;xiaobai.jpg&quot;);Mat xbM1, xbM2;erode(xbim, xbM1, m1, Point(-1, -1), 2);erode(xbim, xbM2, m2, Point(-1, -1), 2); imshow(&quot;xb&quot;, xbim);imshow(&quot;xbM1&quot;, xbM1);imshow(&quot;xbM2&quot;, xbM2); Mat im &#x3D; imread(&quot;rice.jfif&quot;);Mat im1 &#x3D; im.clone();Mat im2 &#x3D; im.clone();Mat im3 &#x3D; im.clone(); Mat gray;cvtColor(im, gray, CV_BGR2GRAY);Mat riceBin;threshold(gray, riceBin, 125, 255, THRESH_BINARY); Mat out, stats, centroids;int count1 &#x3D; connectedComponentsWithStats(riceBin, out, stats, centroids, 8, CV_16U);drawResult(im1, count1, stats, centroids, &quot;no erode&quot;); Mat erodeIm1, erodeIm2;erode(riceBin, erodeIm1, m1, Point(-1, -1), 5);erode(riceBin, erodeIm2, m2, Point(-1, -1), 5); int count2 &#x3D; connectedComponentsWithStats(erodeIm1, out, stats, centroids, 8, CV_16U);drawResult(erodeIm1, count2, stats, centroids, &quot;erode1&quot;);int count3 &#x3D; connectedComponentsWithStats(erodeIm2, out, stats, centroids, 8, CV_16U);drawResult(erodeIm2, count3, stats, centroids, &quot;erode2&quot;); waitKey(0);destroyAllWindows();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0IwODM3MDEwOA==,size_16,color_FFFFFF,t_70.png" alt="img"></p><h4 id="扩展阅读2"><a href="#扩展阅读2" class="headerlink" title="扩展阅读2"></a>扩展阅读2</h4><p>​        版权声明：本文为CSDN博主「我有一個夢想」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>​        原文链接：<a href="https://blog.csdn.net/B08370108/article/details/118029682">https://blog.csdn.net/B08370108/article/details/118029682</a></p><p>​        图像的膨胀与图像腐蚀是一对相反的过程，与图像腐蚀相似，图像膨胀同样需要结构元素用于控制图像膨胀的效果。结构元素可以任意指定结构的中心点，并且结构元素的尺寸和具体内容都可以根据需求自己定义。<strong>定义结构元素之后，将结构元素的中心点依次放到图像中每一个非0元素处，如果原图像中某个元素被结构元素覆盖，但是该像素的像素值不与结构元素中心点对应的像素点的像素值相同，那么将原图像中的该像素的像素值修改为结构元素中心点对应点的像素值。</strong>图像的膨胀过程示意图如图所示，图中左侧为待膨胀的原图像，中间为结构元素，首先将结构元素的中心与原图像中的A像素重合，将结构元素覆盖的所有像素的像素值都修改为1，将结构元素中心点依次与原图像中的每个像素重合，判断是否有需要填充的像素。原图像膨胀的结果如图中右侧图像所示。</p><p><img src="20210117230235852.png" alt="在这里插入图片描述"></p><pre><code>     图像膨胀数学表示形式如式(6.5)所示，通过公式可以发现，其实图像A的膨胀运算就是生成能够将结构元素B全部包含的图像。</code></pre><p><img src="20210117230534606.png" alt="在这里插入图片描述"></p><p>膨胀函数</p><pre class="line-numbers language-none"><code class="language-none">void dilate( InputArray src, OutputArray dst, InputArray kernel,Point anchor &#x3D; Point(-1,-1), int iterations &#x3D; 1,int borderType &#x3D; BORDER_CONSTANT,const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue() );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;src：输入的待膨胀图像，图像的通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。&#x2F;&#x2F;dst：膨胀后的输出图像，与输入图像src具有相同的尺寸和数据类型。&#x2F;&#x2F;kernel：用于膨胀操作的结构元素，可以自己定义，也可以用getStructuringElement()函数生成。&#x2F;&#x2F;anchor：中心点在结构元素中的位置，默认参数为结构元素的几何中心点&#x2F;&#x2F;iterations：膨胀的次数，默认值为1。&#x2F;&#x2F;borderType：像素外推法选择标志，取值范围在表3-5中给出。默认参数为BORDER_DEFAULT，表示不包含边界值倒序填充。&#x2F;&#x2F;borderValue：使用边界不变外推法时的边界值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>     该函数根据结构元素对输入图像进行膨胀，在膨胀多通道图像时每个通道独立进行膨胀运算。函数的第一个参数为待膨胀的图像，图像通道数可以是任意的，但是图像的数据类型必须是CV_8U，CV_16U，CV_16S，CV_32F或CV_64F之一。</code></pre><p>​        函数第二个参数为膨胀后的输出图像，与输入图像具有相同的尺寸和数据类型。函数第三个和第四个参数都是与结构元素相关的参数，</p><p>​        第三个参数为结构元素，膨胀时使用的结构元素尺寸越大效果越明显，第四个参数为结构元素的中心位置，</p><p>​        第四个参数的默认值为Point(-1,-1)，表示结构元素的几何中心处为结构元素的中心点。</p><p>​        函数第五个参数是使用结构元素膨胀的次数，膨胀次数越多效果越明显，默认参数为1，表示只膨胀1次。</p><p>​        函数第六个参数是图像像素外推法的选择标志，</p><p>​        第七个参数为使用边界不变外推法时的边界值，这两个参数对图像中主要部分的膨胀操作没有影响，因此在多数情况下使用默认值即可。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">    简单示例&#x2F;&#x2F;&#x2F;&#x2F; Created by smallflyfly on 2021&#x2F;6&#x2F;18.&#x2F;&#x2F;#include &quot;opencv2&#x2F;opencv.hpp&quot;#include &lt;iostream&gt;using namespace cv;using namespace std;void drawResult(Mat im, int num, Mat stats, Mat centroids, const string&amp; name) &#123;    for (int i &#x3D; 1; i &lt; num; ++i) &#123;        int x &#x3D; centroids.at&lt;double&gt;(i, 0);        int y &#x3D; centroids.at&lt;double&gt;(i, 1);        cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;        circle(im, Point(x, y), 2, Scalar(0, 0, 255), -1);        int xmin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_LEFT);        int ymin &#x3D; stats.at&lt;int&gt;(i, CC_STAT_TOP);        int w &#x3D; stats.at&lt;int&gt;(i, CC_STAT_WIDTH);        int h &#x3D; stats.at&lt;int&gt;(i, CC_STAT_HEIGHT);    Rect rect(xmin, ymin, w, h);   rectangle(im, rect, Scalar(255, 255, 255), 2);    putText(    im,     to_string(i),     Point(x+5, y),     FONT_HERSHEY_SCRIPT_SIMPLEX,     0.3,        Scalar(0, 0, 255),         1);&#125;imshow(name, im);&#125;int main() &#123;    Mat src &#x3D; (            Mat_&lt;uchar&gt;(6, 6) &lt;&lt;                              0, 0, 0, 0, 255, 0,                    0, 255, 255, 255, 255, 255,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 255, 255, 255, 255, 0,                    0, 0, 0, 0, 255, 0    );    resize(src, src, Size(0, 0), 50, 50, INTER_NEAREST);    Mat m1, m2;    m1 &#x3D; getStructuringElement(0, Size(3, 3));    m2 &#x3D; getStructuringElement(1, Size(3, 3));Mat dilateM1, dilateM2;dilate(src, dilateM1, m1, Point(-1, -1), 5);dilate(src, dilateM2, m2, Point(-1, -1), 5); imshow(&quot;src&quot;, src);imshow(&quot;dilateM1&quot;, dilateM1);imshow(&quot;dilateM2&quot;, dilateM2); Mat xbim &#x3D; imread(&quot;xiaobai.jpg&quot;);Mat xbM1, xbM2;dilate(xbim, xbM1, m1, Point(-1, -1), 2);dilate(xbim, xbM2, m2, Point(-1, -1), 2); imshow(&quot;xbim&quot;, xbim);imshow(&quot;xbM1&quot;, xbM1);imshow(&quot;xbM2&quot;, xbM2); Mat im &#x3D; imread(&quot;rice.jfif&quot;);resize(im, im, Size(0, 0), 0.6, 0.6);Mat im1 &#x3D; im.clone(); Mat gray;cvtColor(im, gray, CV_BGR2GRAY);Mat riceBin;threshold(gray, riceBin, 125, 255, THRESH_BINARY); Mat out, stats, centroids;int count1 &#x3D; connectedComponentsWithStats(riceBin, out, stats, centroids, 8, CV_16U);drawResult(im, count1, stats, centroids, &quot;no dilate&quot;); Mat dilateIm1, dilateIm2;dilate(riceBin, dilateIm1, m1, Point(-1, -1), 5);dilate(riceBin, dilateIm2, m2, Point(-1, -1), 5); int count2 &#x3D; connectedComponentsWithStats(dilateIm1, out, stats, centroids, 8, CV_16U);drawResult(dilateIm1, count2, stats, centroids, &quot;dilateIm1&quot;);int count3 &#x3D; connectedComponentsWithStats(dilateIm2, out, stats, centroids, 8, CV_16U);drawResult(dilateIm2, count3, stats, centroids, &quot;dilateIm2&quot;); waitKey(0);destroyAllWindows();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="xiaobaixueshijue.png" alt="img"></p><h3 id="开运算与闭运算"><a href="#开运算与闭运算" class="headerlink" title="开运算与闭运算"></a>开运算与闭运算</h3><p>​        刚刚我们整完了腐蚀和膨胀,现在我们一起用：</p><p>​        开运算指的是：<strong>先腐蚀后膨胀</strong></p><p>​        闭运算指的是：<strong>先膨胀后腐蚀</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath <span class="token operator">=</span> <span class="token string">"1.png"</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33 <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>opening <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_OPEN<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"opening"</span><span class="token punctuation">,</span>opening<span class="token punctuation">)</span>closing <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_CLOSE<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"closing"</span><span class="token punctuation">,</span>closing<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"open.png"</span><span class="token punctuation">,</span>opening<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"close.png"</span><span class="token punctuation">,</span>closing<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        开运算：</p><p><img src="open.png" alt="open"></p><p>​        闭运算：</p><p><img src="close.png" alt="close"></p><h3 id="梯度运算"><a href="#梯度运算" class="headerlink" title="梯度运算"></a>梯度运算</h3><p>​        放大边界信息！很简单：膨胀的减去腐蚀的：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">import cv2import numpy as npfrom matplotlib import pyplot as pltpath &#x3D; &quot;1.png&quot;img &#x3D; cv2.imread(path)kernel33 &#x3D; np.ones((3,3),np.uint8)gradient&#x3D;cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel33)cv2.imshow(&quot;gra&quot;,gradient)cv2.imwrite(&quot;gradient.png&quot;,gradient)cv2.waitKey(0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="gradient.png" alt="gradient"></p><h3 id="礼貌与黑帽"><a href="#礼貌与黑帽" class="headerlink" title="礼貌与黑帽"></a>礼貌与黑帽</h3><p>​        <strong>礼貌就是原始输入-开运算结果！</strong></p><p>​        <strong>黑猫就是闭运算-原始输入！</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> pltpath <span class="token operator">=</span> <span class="token string">"1.png"</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span>kernel33 <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>tophat<span class="token operator">=</span>cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_TOPHAT<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>blackhat<span class="token operator">=</span>cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_BLACKHAT<span class="token punctuation">,</span>kernel33<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"to"</span><span class="token punctuation">,</span>tophat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"bl"</span><span class="token punctuation">,</span>blackhat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"tophat.png"</span><span class="token punctuation">,</span>tophat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"blackhat.png"</span><span class="token punctuation">,</span>blackhat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>tophat：</p><p><img src="tophat.png" alt="tophat"></p><p>blackhat:</p><p><img src="blackhat.png" alt="blackhat"></p><h3 id="扩展阅读1-1"><a href="#扩展阅读1-1" class="headerlink" title="扩展阅读1"></a>扩展阅读1</h3><p>阅读链接：<a href="https://zhuanlan.zhihu.com/p/541851526">数字图像处理(c++ opencv)：形态学图像处理-开运算与闭运算 - 知乎 (zhihu.com)</a></p><h4 id="开运算与闭运算-1"><a href="#开运算与闭运算-1" class="headerlink" title="开运算与闭运算"></a>开运算与闭运算</h4><p>（1）开运算</p><p>原理方法：先腐蚀后膨胀；</p><p>功能作用：平滑物体轮廓、断开狭窄的狭颈、消除细长的突出和物体。</p><p>（2）闭运算</p><p>原理方法：先膨胀后腐蚀；</p><p>功能作用：弥合狭窄的狭颈或断裂处、消除小孔、填补轮廓缝隙。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;int main()&#123;Mat image, image_gray, image_bw;   &#x2F;&#x2F;定义输入图像，灰度图像，二值图像image &#x3D; imread(&quot;开运算闭运算.png&quot;);  &#x2F;&#x2F;读取图像；if (image.empty())&#123;cout &lt;&lt; &quot;读取错误&quot; &lt;&lt; endl;return -1;&#125;imshow(&quot;image&quot;, image);&#x2F;&#x2F;转换为灰度图像cvtColor(image, image_gray, COLOR_BGR2GRAY);&#x2F;&#x2F;转换为二值图threshold(image_gray, image_bw, 120, 255, 1); &#x2F;&#x2F;通过0，1调节二值图像背景颜色imshow(&quot;image_bw&quot;, image_bw);&#x2F;&#x2F;闭运算Mat se &#x3D; getStructuringElement(0, Size(3, 3)); &#x2F;&#x2F;构造矩形结构元素dilate(image_bw, image_bw, se, Point(-1, -1), 5); &#x2F;&#x2F;执行膨胀操作erode(image_bw, image_bw, se, Point(-1, -1), 5); &#x2F;&#x2F;执行腐蚀操作&#x2F;&#x2F;开运算&#x2F;&#x2F;Mat se &#x3D; getStructuringElement(0, Size(3, 3)); &#x2F;&#x2F;构造矩形结构元素&#x2F;&#x2F;erode(image_bw, image_bw, se, Point(-1, -1), 2); &#x2F;&#x2F;执行腐蚀操作&#x2F;&#x2F;dilate(image_bw, image_bw, se, Point(-1, -1), 2); &#x2F;&#x2F;执行膨胀操作imshow(&quot;image_bw&quot;, image_bw);waitKey(0);  &#x2F;&#x2F;暂停，保持图像显示，等待按键结束return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="v2-996d420c6bd384ca11957a8745f672b4_1440w.png" alt="img"></p><hr><p><strong>除了使用腐蚀膨胀的函数组合来进行开运算闭运算，还可以通过opencv函数进行处理（morphologyex函数）</strong></p><h3 id="扩展阅读2-1"><a href="#扩展阅读2-1" class="headerlink" title="扩展阅读2"></a>扩展阅读2</h3><p>版权声明：本文为CSDN博主「念980」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_62343847/article/details/122604497">https://blog.csdn.net/weixin_62343847/article/details/122604497</a></p><p>腐蚀与膨胀</p><p>​        图像的腐蚀与膨胀互为逆向操作，通常用于处理二值图像（黑白图，以黑色为底面背景），因此需要先进行二值化处理，腐蚀和膨胀通俗的理解就是，在指定大小的卷积核内，如果该卷积核内全为黑色或全为白色，则该卷积核内像素值不变，但若是既有黑色又有白色，即在图像边缘处，那么膨胀操作则会将该卷积核内所有白色像素点都赋值变为黑色，以此将图像向内腐蚀掉一圈，而膨胀操作则相反，会将卷积核内的黑色像素点赋值成2白色，以此让图像膨胀一圈。</p><p>​        膨胀与腐蚀的函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>uint8<span class="token punctuation">)</span> <span class="token comment">#定义要处理的卷积核大小和卷积核的类型。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">erosion <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">#对图像进行膨胀操作，img_test是要进行处理的图像，kernel是通过上一个函数定义好的卷积核，而iterations则是腐蚀操作的循环次数（可以将卷积核设置为（1，1），然后不断调整循环次数来实现精细化的腐蚀，以达到更好的腐蚀效果）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">dilate_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>img_test<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#对图像进行膨胀操作，这里的参数跟上面的参数作用一样，只是改了函数名而已。（同样可以将卷积核设置为（1，1），不断改变循环次数，以达到更好的膨胀效果）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        应用：腐蚀操作一般用于消去图像中不需要的粘连部分，而膨胀操作则用于填充图像内的空白部分，同时也可以恢复图像由于进行腐蚀操作后缩小的面积，在下面的代码实例中会有体现。</p><p>代码实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment">#导入包</span><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span><span class="token comment">#读入图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定处理的内核</span>erosion <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#腐蚀操作</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"erosion"</span><span class="token punctuation">,</span>erosion<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>pie <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"pie.png"</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"pie"</span><span class="token punctuation">,</span>pie<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>erosion_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#循环腐蚀1次</span>erosion_2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#循环腐蚀2次</span>erosion_3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">#循环腐蚀3次</span>All <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>erosion_1<span class="token punctuation">,</span>erosion_2<span class="token punctuation">,</span>erosion_3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#拼接图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"All"</span><span class="token punctuation">,</span>All<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>img_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>erosion_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>erode<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#腐蚀图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"erosion_test3"</span><span class="token punctuation">,</span>erosion_test3<span class="token punctuation">)</span><span class="token comment">#展示腐蚀后的图像</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>dilate_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>erosion_test3<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#对腐蚀过的图像进行膨胀处理</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"dilate"</span><span class="token punctuation">,</span>dilate_test3<span class="token punctuation">)</span><span class="token comment">#展示膨胀后的图像</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>dilate_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">#循环膨胀一次后的图像</span>dilate_2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#循环膨胀两次后的图像</span>dilate_3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>dilate<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>kernel<span class="token punctuation">,</span>iterations <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">#循环膨胀三次后的图像</span>All <span class="token operator">=</span> np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>dilate_1<span class="token punctuation">,</span>dilate_2<span class="token punctuation">,</span>dilate_3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#拼接以上三幅图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"All"</span><span class="token punctuation">,</span>All<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        运行结果</p><p>​        这是原图，可以看到上面有一些多出来的粘连部分</p><p><img src="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-1OTgw,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>​        进行腐蚀操作后的图像，可以看到，我们用腐蚀操作成功去除了边缘的粘连部分，但同时字体笔画也由于受到了腐蚀而变细了</p><p><img src="qdwd.png" alt="img"></p><p>​        对上图进行膨胀操作，可以看到，我们恢复了被腐蚀前笔画的粗细，同时也去除掉了原图的粘连部分，这种操作称为开运算，能够在尽量不改变原图的情况下去除图像的粘连。（在下面会有详细的介绍）</p><p><img src="ss.png" alt="img"></p><pre><code>     以下是循环腐蚀1~3次之后的图像对比</code></pre><p><img src="wq.png" alt="img"></p><pre><code>     以下是循环膨胀1~3次之后的图像对比</code></pre><p><img src="das.png" alt="img"></p><p>​        通过上面两幅图可以看出，不管是腐蚀还是膨胀，都不是等比例的进行，它们最终都会趋近于矩形（因为卷积核就是矩形的），并且进行腐蚀再膨胀后的图像跟原图是存在细微差别的，比如中间的部分空洞可能已经消失了等等。</p><p>​        开运算和闭运算 </p><p>​        所谓开运算在上面的代码其实已经使用过了，只是opencv本身便带有可以进行腐蚀后再膨胀的函数，不需要我们自己写那么多代码。开运算在原图的基础上就是用于消除图像的一些粘连部分的一种方式。</p><p>​        而闭运算则相反，是先进行膨胀，再进行腐蚀的一种操作。它主要用于填充图像中的空洞部分，在opencv中同样有一个专门的函数进行闭运算。</p><p>​        函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">opening <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_OPEN<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#开运算，img_test3是要进行处理的图片，cv2.MORPH_OPEN表示要进行的是开运算（先腐蚀后膨胀），kernel则跟上面的函数一样，是定义好的卷积核。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"> closing <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_CLOSE<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#闭运算，这里的函数参数跟上一个函数作用一样，cv2.MORPH_OPEN表示要进行的是闭运算（先膨胀后腐蚀）。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>代码实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span><span class="token comment">#读入图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的内核大小</span>opening <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_OPEN<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#开运算，先腐蚀后膨胀，能够去除图像中粘连的部分</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"open"</span><span class="token punctuation">,</span>opening<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定要处理的卷积核大小</span>closing <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_CLOSE<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#闭运算，先膨胀后腐蚀，能够填补图像中间的空隙</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"close"</span><span class="token punctuation">,</span>closing<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果</p><p>​        开运算:</p><p><img src="dqwdqew.png" alt="img"></p><p>​        闭运算：效果不明显，但是如果该图像中间有空洞存在，那么我们可以明显的看到空洞被填上了。</p><p> <img src="ceacergaefr.png" alt="img"></p><pre><code>     梯度运算</code></pre><p>​        原理：将图像分别进行膨胀和腐蚀，然后两者相减，则可以得到该图像的轮廓，而opencv中同样提供了进行梯度运算的函数。</p><p>​        函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">gradient <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_GRADIENT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#这里的pie是将要进行处理的二值图像，cv2.MORPH_GRADIENT表示进行梯度运算，kernel则是定义好的卷积核。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        代码示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltpie <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"pie.png"</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"pie"</span><span class="token punctuation">,</span>pie<span class="token punctuation">)</span><span class="token comment">#展示原图</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span class="token comment">#梯度运算，通过膨胀减去腐蚀得到轮廓</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定卷积核大小</span>gradient <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>pie<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_GRADIENT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#梯度运算</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"gradient"</span><span class="token punctuation">,</span>gradient<span class="token punctuation">)</span><span class="token comment">#展示处理后的图像</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        运行结果</p><p>​        原图</p><p><img src="ewaVQERWEFWRVA.png" alt="img"></p><p>​        处理后得到的图像轮廓</p><p><img src="ce.PNG" alt="img"></p><pre><code>     礼帽与黑帽</code></pre><p>​        礼帽：将图像先进行开运算，再以原始图像减去开运算的结果，我们就可以得到图像被腐蚀掉的粘连部分，或者说原图中灰度较亮的区域，所以也称白顶帽变换。</p><p>​        黑帽：将图像先进行闭运算，再将闭运算的结果减去原始图像，作用我们就可以得到原图像中被填充的空洞部分，也就是图像中件较暗的空洞区域，所以又称黑底帽变换。</p><p>​        函数介绍</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">tophat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_TOPHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#礼帽运算，cv2.MORPH_TOPHAT表示进行的是礼帽运算，即原图像-开运算。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">blackhat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_BLACKHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#黑帽运算，cv2.MORPH_BLACKHAT表示进行的是黑帽运算，即闭运算-原图像。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        代码示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg_test3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"test3.png"</span><span class="token punctuation">)</span><span class="token comment">#读入图像</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"test3"</span><span class="token punctuation">,</span>img_test3<span class="token punctuation">)</span><span class="token comment">#展示图片</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#关闭窗口</span><span class="token comment">#礼帽，原始图像-开运算，得到的就是被腐蚀掉的粘连部分</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定卷积核大小</span>tophat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_TOPHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#礼帽运算</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"tophat"</span><span class="token punctuation">,</span>tophat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#黑帽运算，闭运算-原始图像，得到的是膨胀之前原始图像中比较暗的部分，即中间的空洞</span>kernel <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span><span class="token comment">#设定卷积核大小</span>blackhat <span class="token operator">=</span> cv2<span class="token punctuation">.</span>morphologyEx<span class="token punctuation">(</span>img_test3<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>MORPH_BLACKHAT<span class="token punctuation">,</span>kernel<span class="token punctuation">)</span><span class="token comment">#黑帽运算</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"blackhat"</span><span class="token punctuation">,</span>blackhat<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        运行结果</p><p>​        原图</p><p><img src="QWDQWD.png" alt="img"></p><p>​        礼帽，可以看到图像粘连部分被剔除出来了</p><p><img src="wdqqwdqw.png" alt="img"></p><p>​        黑帽，我们得到了迪哥中间微小的空洞部分</p><p><img src="sqwdw.png" alt="img"></p><p>​        </p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计 （1）</title>
      <link href="/2023/02/06/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%EF%BC%881%EF%BC%89/"/>
      <url>/2023/02/06/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="概率论与数理统计"><a href="#概率论与数理统计" class="headerlink" title="概率论与数理统计"></a>概率论与数理统计</h1><h3 id="确定性现象-必然现象"><a href="#确定性现象-必然现象" class="headerlink" title="确定性现象/必然现象"></a>确定性现象/必然现象</h3><p>​        确定性：一定发生/一定不发生</p><p>​        随机/偶然：可能发生，可能不发生</p><p>​        统计规律：事件发生的规律</p><p>​        实验：观测，测量，实验</p><p>​        随机试验：1）在相同的条件下可以重复</p><p>​                            2）结果不止一个</p><p>​                            3）无法预测</p><p>​        结果用E来表示</p><p>​        事件：每一种结果就叫一个事件</p><p>​        随机事件：随机发生的事件</p><p>​        基本事件：一个事件不能再分或者没有必要再分（相对于实验目的来说）</p><p>​        复合事件：基本事件组成复合事件</p><p>​        必然事件：一定发生（$\Omega$）</p><p>​        不可能事件：一定不发生（$\phi$）</p><p>​        样本空间：所有的基本事件的集合</p><p>​        样本点：样本空间的元素</p><h3 id="事件之间的关系"><a href="#事件之间的关系" class="headerlink" title="事件之间的关系"></a>事件之间的关系</h3><h4 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h4><p>​        定义A发生必然导致B发生就是A包含于B，或者B包含A</p><script type="math/tex; mode=display">A \subset B或写作B\supset A</script><p><img src="image-20230206134525647.png" alt="image-20230206134525647"></p><p>​        <strong>注意这两个符号：$\subset$和$\in$的区别：前者地位平等，阐述的是集合与集合的关系；后者地位不平等，阐述的是集合于元素之间的关系！</strong></p><h4 id="相等"><a href="#相等" class="headerlink" title="相等"></a>相等</h4><p>​        如果</p><script type="math/tex; mode=display">A\subset B,B\supset A \rightarrow A=B</script><h4 id="并（和）"><a href="#并（和）" class="headerlink" title="并（和）"></a>并（和）</h4><p>​        定义他们是A或者B发生：</p><script type="math/tex; mode=display">A \cup B或记作A+B</script><p><img src="image-20230206134547279.png" alt="image-20230206134547279"></p><p>注意这样的一些性质值得我们的注意：</p><script type="math/tex; mode=display">A+B \supset A,A+A=A,A+\emptyset=A,A+\Omega=\Omega</script><h4 id="交（积）"><a href="#交（积）" class="headerlink" title="交（积）"></a>交（积）</h4><p>​        定义A，B同时发生为他们的交：</p><script type="math/tex; mode=display">A\cap B或记作AB</script><p><img src="image-20230206135414625.png" alt="image-20230206135414625"></p><script type="math/tex; mode=display">AB \subset A,AA=A,A\emptyset=\emptyset,A\Omega=A</script><h4 id="差"><a href="#差" class="headerlink" title="差"></a>差</h4><p>​        定义一个发生另一个不发生的区域叫两个事件的差：</p><p><img src="image-20230206135456654.png" alt="image-20230206135456654"></p><script type="math/tex; mode=display">A-B</script><script type="math/tex; mode=display">A-B=A-AB</script><h4 id="多个事件"><a href="#多个事件" class="headerlink" title="多个事件"></a>多个事件</h4><p>多个事件的和：</p><script type="math/tex; mode=display">A_1 \cup A_2\cup A_3\cup ...\cup A_n=\cup_{i=1}^nA_i</script><p>多个事件的并：</p><script type="math/tex; mode=display">A_1 \cap A_2\cap A_3\cap ...\cap A_n=\cap_{i=1}^nA_i</script><p><strong>无限可列：能按一个规律拍成一个序列就叫无限可列</strong></p><h3 id="互不相容与对立事件"><a href="#互不相容与对立事件" class="headerlink" title="互不相容与对立事件"></a>互不相容与对立事件</h3><p>​        如果A，B不同时发生，就有以下简记：</p><script type="math/tex; mode=display">AB=\emptyset</script><p>​        如果一个集合下，不是A就是B，那就称呼A,B是对立事件</p><script type="math/tex; mode=display">A \cap B=\emptyset,A \cup B = \Omega \rightarrow A=\bar{B}</script><p>​        于是又有新的性质</p><p>1)</p><script type="math/tex; mode=display">A-B=A-AB=A\bar{B}</script><p>2)互相对立的事件一定互不相容</p><p>3）互不相容适用于多个事件，对立却只用于描述两个事件的关系</p><h3 id="完备事件组"><a href="#完备事件组" class="headerlink" title="完备事件组"></a>完备事件组</h3><p>​        如果我们列举出来的一些互不相容的事件把所有情况说全了：</p><script type="math/tex; mode=display">\cup_{i=1}^n A_i=\Omega</script><h3 id="运算律"><a href="#运算律" class="headerlink" title="运算律"></a>运算律</h3><p>1）交换律：</p><script type="math/tex; mode=display">A\cup B=B\cup A \\ A\cap B=B\cap A</script><p>2）结合律：</p><script type="math/tex; mode=display">(A\cup B)\cup C=A\cup(B\cup C)\\(A\cap B)\cap C=A\cap(B\cap C)</script><p>3)分配律</p><script type="math/tex; mode=display">(A \cup B)\cap C=(A\cap C)\cup(B\cap C)</script><p><img src="image-20230206140705953.png" alt="image-20230206140705953"></p><script type="math/tex; mode=display">(A \cap B)\cup C=(A\cup C)\cap(B\cup C)</script><p><img src="image-20230206140849230.png" alt="image-20230206140849230"></p><p>4)德摩根律</p><script type="math/tex; mode=display">\overline{A\cup B}=\bar A \cap\bar B</script><p><img src="image-20230206141037146.png" alt="image-20230206141037146"></p><script type="math/tex; mode=display">\overline{A\cap B}=\bar A \cup\bar B</script><p>例子：ABC都是试验随机事件：</p><p>1）A发生：A</p><p>2）只有A发生：$A \bar B\bar C$</p><p>3)有A，B，C卡有一个发生：$A \bar B\bar C+\bar A B\bar C+\bar A \bar B C$</p><p>4)ABC同时发生：ABC</p><p>5）ABC至少一个发生：A+B+C</p><p>6)至多一个发生：$\bar A \bar B\bar C+A \bar B\bar C+\bar A B\bar C+\bar A \bar B C$</p><p>7)恰有两个：$A  B\bar C+A B\bar C+A \bar B C$</p><p>8)至少两个：$A  B\bar C+A B\bar C+A \bar B C+ABC$或者$AB+BC+AC$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性代数基本教程 （1）</title>
      <link href="/2023/02/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B-%EF%BC%881%EF%BC%89/"/>
      <url>/2023/02/06/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B-%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>这个科目，我们将要讨论矩阵，矩阵有很多不同于基础代数的东西。</p><p>​        比如说，将矩阵不满足交换率，不可以作分母$\frac{1}{A}$</p><h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>​        现在我们注意，这门学科起步于线性方程组</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}5x+6y & = & 7 \\9x+4y & = & 3\end{aligned}\right.\end{equation}</script><p>​        我们只解不化简：</p><p><img src="image-20230116173337212.png" alt="image-20230116173337212"></p><p>​        </p><p>我们引入这样的符号：</p><script type="math/tex; mode=display">\left |\begin{array}{cccc}a &b   \\c &d  \\\end{array}\right|</script><p>我们使之这个表示为$ad-bc$，这就是行列式</p><script type="math/tex; mode=display">\left| \begin{array}{} a_{11}& a_{12}\\a_{21}& a_{22}\\\end{array} \right|</script><p>​        其$a_{ij}$中i , j表示行标，列标。那么：</p><script type="math/tex; mode=display">\left| \begin{array}{} a_{11}& a_{12}\\a_{21}& a_{22}\\\end{array} \right|=a_{11}a_{22}-a_{12}a_{21}</script><p><img src="image-20230116174009469.png" alt="image-20230116174009469"></p><h3 id="三阶行列式"><a href="#三阶行列式" class="headerlink" title="三阶行列式"></a>三阶行列式</h3><p>​        </p><script type="math/tex; mode=display">\left | \begin{array}{}a_{11}&a_{12}&a_{13}\\a_{21}&a_{22}&a_{23}\\a_{31}&a_{32}&a_{33}\\\end{array}\right |</script><p> 这是一个三阶行列式，他的求法是这样的：</p><p><img src="image-20230116174744466.png" alt="image-20230116174744466"></p><p><img src="image-20230116174752643.png" alt="image-20230116174752643"></p><p><img src="image-20230116174917249.png" alt="image-20230116174917249"></p><p><img src="image-20230116174924145.png" alt="image-20230116174924145"></p><p>​        不过，还有别的方法，不推荐这种方法计算</p><h3 id="排列与逆序"><a href="#排列与逆序" class="headerlink" title="排列与逆序"></a>排列与逆序</h3><p>​        排列：由1，2，3，4，…n组成的一个有序数组叫N级排列</p><p>​                                                        123,132,213,231,312,321</p><p>​        这是一个三级排列</p><p>​        而3145不是一个五级排列。因为少了2.</p><p>​        N级排列有n!种</p><p>​        </p><p>​        逆序：</p><p>​        大数排在了小数前面，构成了一个逆序：</p><p>​        4213：4排在了2的前面，故这是一个逆序</p><p>​        逆序数：逆序的总数</p><p>​        4213：4后面3个，2：一个，之后没有了，故是4个</p><p>​        可以记作：N(4213)=4</p><p>​        偶排列和奇排列：排列数奇偶</p><p>​        若N(1234…n)=0则称之为标准排列（自然排列）</p><p>​        对于完全逆序的排列：N(n(n-1)(n-2)…321)=$\frac{n(n-1)}{2}$</p><p>​        </p><p>​        对换：交换两个数</p><p>​        我们对一个排序进行对换：可以发现奇偶性改变一次（后面行列式会用到）</p><p>​        N排列中，奇偶排列个数相等，各占一半</p><h3 id="基本求解"><a href="#基本求解" class="headerlink" title="基本求解"></a>基本求解</h3><p>​        我们是这样求解N阶的行列式：</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}a_{11} &a_{12}&...&a_{1n-1}&a_{1n} \\a_{21} &a_{22}&...&a_{2n-1}&a_{2n}\\a_{31} &a_{32}&...&a_{3n-1}&a_{3n}\\...&...&...&...&...\\a_{n1}&a_{n2}&...&a_{nn-1}&a_{nn}\end{array} \right|\end{array}=\sum_{j_1j_2j_3...j_n}(-1)^{N(j_1j_2j_3...j_n)}a_{1j_1}a_{2j_2}a_{3j_3}...a_n{j_n}</script><p>这是按行展开的。</p><p>太抽象了，我们后面使用别的办法求解：是这样的—-我们的j_n求所有可能排列</p><p>我们有这样的一些特殊的矩阵值得注意：</p><p>1）下三角行列式</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}a_{11} &0&...&0&0 \\a_{21} &a_{22}&...&0&0\\a_{31} &a_{32}&...&0 &0\\...&...&...&...&...\\a_{n1}&a_{n2}&...&a_{nn-1}&a_{nn}\end{array} \right|\end{array}</script><p>这是有趣的：因为我们这个行列式的值就是$a_{11}a_{22}a_{33}…a_{nn}$</p><p>2)上三角行列式</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}a_{11} &a_{12}&...&a_{1n-1}&a_{1n} \\0 &a_{22}&...&a_{2n-1}&a_{2n}\\0 &0&...&a_{3n-1}&a_{3n}\\...&...&...&...&...\\0&0&...&0&a_{nn}\end{array} \right|\end{array}</script><p>这是有趣的：因为我们这个行列式的值就是$a_{11}a_{22}a_{33}…a_{nn}$，跟上面的一样</p><p>3）对角行列式</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}a_{11} &0&...&0&0 \\0 &a_{22}&...&0&0\\0 &0&...&0&0\\...&...&...&...&...\\0&0&...&0&a_{nn}\end{array} \right|\end{array}</script><p>这个行列式的值还是上面我提到的那个</p><p>但是下面的有些不同。</p><p>反下三角行列式</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}0 &0&...&0&a_{1n} \\0 &0&...&a_{2n-1}&a_{2n}\\0 &0&...&a_{3n-1}&a_{3n}\\...&...&...&...&...\\a_{n1}&a_{n2}&...&a_{nn-1}&a_{nn}\end{array} \right|\end{array}=(-1)^{\frac{n(n-1)}{2}}a_{1n}a_{2n-1}...a_{n1}</script><p>还有这种：</p><script type="math/tex; mode=display">\begin{array}=\left|\begin{array}{cl}a_{11} &a_{12}&...&a&a_{1n} \\a_{21} &a_{22}&...&a_{2n-1}&0\\a_{31} &a_{32}&...&0&0\\...&...&...&...&...\\a_{n1}&0&...&0&0\end{array} \right|\end{array}=(-1)^{\frac{n(n-1)}{2}}a_{1n}a_{2n-1}...a_{n1}</script><p>总结看来就是这样的：</p><p><img src="image-20230124183544432.png" alt="image-20230124183544432"></p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​        现在来看一个行列式：</p><script type="math/tex; mode=display">D=\left |\begin{matrix}1&2&3\\1&1&1\\8&8&8\\\end{matrix}\right |</script><p>​        现在，我们把行写出列，列写成行，那就是：</p><script type="math/tex; mode=display">D^T=\left | \begin{matrix}1&1&8\\2&1&8\\3&1&8\\\end{matrix}\right |</script><p>那显然：</p><script type="math/tex; mode=display">(D^T)^T=D</script><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>1）$D^T=D$</p><p>2)两行交换，行列式只<strong>变号</strong></p><p>3）两行（列）相等，D=0\</p><p>4)某一行都有公因子k,那就提N次：</p><script type="math/tex; mode=display">\left| \begin{matrix} ...&...&...&...\\ka &kb&kc&...\\...&...&...&...\\\end{matrix} \right |=k^n\left| \begin{matrix} ...&...&...&...\\a &b&c&...\\...&...&...&...\\\end{matrix} \right |</script><p>5)两行对应成比例：那还是行列式的值是0！</p><p>6）对于这样的行列式：</p><script type="math/tex; mode=display">\left| \begin{matrix} ...&...&...&...\\a+d &b+e&c+f&...\\...&...&...&...\\\end{matrix} \right |=\left| \begin{matrix} ...&...&...&...\\a &b&c&...\\...&...&...&...\\\end{matrix} \right |+\left| \begin{matrix} ...&...&...&...\\d &e&f&...\\...&...&...&...\\\end{matrix} \right |</script><p>其余行都不动</p><p>7）某一行乘上一个数加到另一行上，行列式的值还是不变！</p><p>我们可以使用这些性质来求解行列式的值：</p><p>1）<strong>先处理第一行，在处理第二行。。。依次处理即可！不要随意处理！</strong></p><p>或者：</p><p>2）<strong>先处理第一列，在处理第二列。。。依次处理即可！不要随意处理！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab 入门 （1）</title>
      <link href="/2023/02/02/Matlab-%E5%85%A5%E9%97%A8-%EF%BC%881%EF%BC%89/"/>
      <url>/2023/02/02/Matlab-%E5%85%A5%E9%97%A8-%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Matlab入门（1）"><a href="#Matlab入门（1）" class="headerlink" title="Matlab入门（1）"></a>Matlab入门（1）</h1><h3 id="1-matlab（2014a）的界面介绍"><a href="#1-matlab（2014a）的界面介绍" class="headerlink" title="1.matlab（2014a）的界面介绍"></a>1.matlab（2014a）的界面介绍</h3><p><img src="image-20221224193149319.png" alt="image-20221224193149319"></p><p>​        左边是Current Folders:也就是文件区，正中心是命令窗口：输入命令的地方。右上角的WorkSpace（工作区）是储存变量的地方，而右下角的Command History则是命令的历史记录。</p><p><img src="image-20221224193538040.png" alt="image-20221224193538040"></p><p>​        这是2021A版的界面，不过，默认是没有命令历史窗口，需要从布局&gt;&gt;命令历史记录&gt;&gt;勾选停靠，才可以调出历史记录。</p><h3 id="2-matlab的运算符"><a href="#2-matlab的运算符" class="headerlink" title="2.matlab的运算符"></a>2.matlab的运算符</h3><p>​        运算符有以下几种：+，-，*，/，^(这是次方)</p><p><img src="image-20221224193919840.png" alt="image-20221224193919840"></p><p>​                                                                                             （实例）</p><p>​        Precedence Rules（运算优先级规则）</p><p>​        1.在同一级上从左到右</p><p>​        2.从高到底：</p><p>​            1.括号（）</p><p>​            2.次方（^）</p><p>​            3.乘除（*，/）</p><p>​            4.加减（+，-）</p><p>下面可以做一些练习：</p><ol><li><script type="math/tex; mode=display"></script><script type="math/tex; mode=display">cos(\sqrt{\frac{(1+2+3+4)^3}5})2.</script></li></ol><p>2.</p><script type="math/tex; mode=display">sin(\sqrt{\pi})+ln(tan(1))</script><p>3.</p><script type="math/tex; mode=display">2^{3.5\times1.7}</script><p>4.</p><script type="math/tex; mode=display">e^{sin(10)}</script><p>答案：<img src="ans.png" alt="ans"></p><p>​        函数可以嵌条调用，由此，我们可以分布，减少错误</p><p>​        如：</p><p><img src="1.png" alt="1"></p><p>​        对于非常复杂的运算，下面的那个是推介的</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>​        在Matlab里面，我们不需要声明变量的类型，就可以创造一个变量（LHS=RHS）</p><p><img src="image-20221224201954977.png" alt="image-20221224201954977"></p><p>​        此时，我们的WorkSpace：</p><p><img src="image-20221224202037986.png" alt="image-20221224202037986"></p><p>​        注意：</p><p>​        （1）大小写是敏感的，A与a是不一样的</p><p>​        （2）不要以数字开头，但是可以变量里有数字</p><p>​            变量的种类：</p><p><img src="image-20221224202401689.png" alt="image-20221224202401689"></p><p>​        我们默认创造的数字类型是double(不是int!)</p><p>​        查看变量的种类的方法：</p><p>​        双击workspace变量跳出表格：其名字为1 * 1 double,或者,在命令窗口打whos:</p><p><img src="image-20221224202650334.png" alt="image-20221224202650334"></p><p>​        注意：下面是一些特殊的关键字（Keyword）：</p><p><img src="image-20221224202919711.png" alt="image-20221224202919711"></p><p>​    （iskeyword查看已有关键字）</p><p>​        这是Matlab调用的优先级：</p><p><img src="image-20221224203437595.png" alt="image-20221224203437595"></p><h3 id="标准输出调整"><a href="#标准输出调整" class="headerlink" title="标准输出调整"></a>标准输出调整</h3><p>​        Format格式有以下几种</p><p><img src="image-20221224203627494.png" alt="image-20221224203627494"></p><p><img src="image-20221224203819131.png" alt="image-20221224203819131"></p><p><img src="image-20221224203840545.png" alt="image-20221224203840545"></p><p>​        （rat让一个小数以分数形式表示）</p><p>​        a=10;打上分号让matlab不会显示这句话的运算结果。</p><p>​        回溯历史指令：按上回到之前的指令</p><p><img src="image-20221224204349793.png" alt="image-20221224204349793"></p><p>​         vector and matrix</p><p>​        向量（vector）</p><p>​        行向量（row vector）</p><p>​        格式：var=[(num num2 …) ]或者是var=[num,num2,num3,…]</p><p>​        a=[1 2 3 4] or a=[1,2,3,4]</p><p><img src="image-20221224204934420.png" alt="image-20221224204934420"></p><p>​        列向量（column vector）</p><p>​        var=[num1;num2;num3;…]</p><p>​        a=[1;2;3;4]</p><p><img src="image-20221224205359229.png" alt="image-20221224205359229"></p><p>​        当然：a<em>b与b</em>a显然是不太一样的</p><p><img src="image-20221224205457245.png" alt="image-20221224205457245"></p><p>​        输入一个矩阵是这样的：</p><p>​        matrix=[num11,num12,num13…(Row1);num21,num22,…]</p><p>​        m=[1,2,3;4,5,6;7,8,9]</p><p><img src="image-20221224205752715.png" alt="image-20221224205752715"></p><p>​        索引方法</p><p>​        vector（index）(直接取第index个数)</p><p>​        matrix:</p><p>​        法一：matrix（rownum,colnum）</p><p>​        如m(1,2)</p><p><img src="image-20221224210140942.png" alt="image-20221224210140942"></p><p>​        法二：matrix([num1 num2],[num3 num4])</p><p>​        (取其排列组合的组合下表的数组成新的矩阵)</p><p>​        m([1 3],[1 3])</p><p><img src="image-20221224210443939.png" alt="image-20221224210443939"></p><p>​        方法三：matrix(a)</p><p>​        矩阵按列存储，故：m(1)=1,m(2)=4,m(4)=2…</p><p><img src="image-20221224210642070.png" alt="image-20221224210642070"></p><p>​        方法四：matrix([num1 num2 num3…（row1）；num4 num5,num6,…(row n)])</p><p>​        以方法三的排列为基础，取出m(num i)构成一个矩阵</p><p><img src="image-20221224211142755.png" alt="image-20221224211142755"></p><p>​        于是，我们也可以用如此的索引更改矩阵的数</p><h3 id="矩阵里有规律的快速输入"><a href="#矩阵里有规律的快速输入" class="headerlink" title="矩阵里有规律的快速输入"></a>矩阵里有规律的快速输入</h3><p>​    colon operator(:)</p><p>​    用于声明等差的vector</p><p>​    （1）a=num1:num2;(差为1的等差数列)</p><p><img src="image-20221224211635032.png" alt="image-20221224211635032"></p><p>​        (2)a=num1:num2:num3(差为num2的等差数列)</p><p><img src="image-20221224211754286.png" alt="image-20221224211754286"></p><p>​        (3)a=[num1:num2;num3:num4:num5;…]生成矩阵</p><p>​        (4)a=((num1,):)(表示全部)</p><p><img src="image-20221224212148933.png" alt="image-20221224212148933"></p><p>​        空[]去掉一行or一列</p><p><img src="image-20221224212232261.png" alt="image-20221224212232261"></p><p>​        对于可以合并为[A|B]的矩阵，matlab支持[A B]或者[A;B]的操作</p><p><img src="image-20221224212455824.png" alt="image-20221224212455824"></p><p>​        matlab的矩阵运算</p><p><img src="image-20221224212731039.png" alt="image-20221224212731039"></p><p>​        点乘点除是对应位置的数直接乘or除</p><p>​        特殊矩阵：</p><p><img src="image-20221224212922825.png" alt="image-20221224212922825"></p><p>​        matlab的特殊函数：</p><p><img src="image-20221224213011614.png" alt="image-20221224213011614"></p><h2 id="Matlab程序书写"><a href="#Matlab程序书写" class="headerlink" title="Matlab程序书写"></a>Matlab程序书写</h2><p>1.新建一个脚本程序</p><p>单击新建脚本后开始编写</p><p><img src="image-20221225192111703.png" alt="image-20221225192111703"></p><p>之后按F5或者是单击运行。</p><p>在一句最前面加上%表明这是注解</p><p>%%之间划分“节”，让脚本可以分块执行（其中变黄区块表面选中节）</p><p><img src="image-20221225193608481.png" alt="image-20221225193608481"></p><p>（Run：全部执行与Run Section：选中节执行）</p><p>Breaking point：对想检查的语句的下一句和行数处单击产生断点，从而在这一句停下来，随后可以再按continue或者是F5继续。</p><p>在Debug模式下可以将光标停在变量上查看具体属性</p><h3 id="基本的程序结构"><a href="#基本的程序结构" class="headerlink" title="基本的程序结构"></a>基本的程序结构</h3><p><img src="image-20221225194455880.png" alt="image-20221225194455880"></p><h3 id="基本的逻辑符号"><a href="#基本的逻辑符号" class="headerlink" title="基本的逻辑符号"></a>基本的逻辑符号</h3><p><img src="image-20221225194615602.png" alt="image-20221225194615602"></p><p>1.if/elseif/else结构</p><p>if condition1</p><p>​        statement1</p><p>elseif condition2</p><p>​        statement2</p><p>else</p><p>​        statement3</p><p>end</p><p>2.switch结构</p><p><img src="image-20221225195627982.png" alt="image-20221225195627982"></p><p>注意这里不同于C/C++:这里不需要break.</p><p>3.while</p><p><img src="image-20221225195751347.png" alt="image-20221225195751347"></p><p>(prod(1:n)表示阶乘)</p><p>4.for循环</p><p><img src="image-20221225200500864.png" alt="image-20221225200500864"></p><p>注意：</p><p>对于大矩阵要先初始化：</p><p>如A=zeros(2000,2000)</p><p>5.break</p><p>在while里break以中断while循环</p><p><img src="image-20221225201538350.png" alt="image-20221225201538350"></p><p>一些小提示：</p><p><img src="image-20221225201616354.png" alt="image-20221225201616354"></p><p>补充：clc：清空历史</p><h2 id="Matlab的自定义函数"><a href="#Matlab的自定义函数" class="headerlink" title="Matlab的自定义函数"></a>Matlab的自定义函数</h2><p>对于一个function文件：分为三个部分</p><p>function y=func()</p><p>comment：表明这个func的功能</p><p>功能代码</p><p><img src="image-20221225202351453.png" alt="image-20221225202351453"></p><p>为了可以使用自定义代码：请跳转到工作文件夹</p><p>Matlab可以定义多输入与多输出的函数：</p><p><img src="image-20221225203129714.png" alt="image-20221225203129714"></p><p>Matlab也支持定义匿名函数：</p><p><img src="image-20221225203836565.png" alt="image-20221225203836565"></p><h3 id="基本的变量结构"><a href="#基本的变量结构" class="headerlink" title="基本的变量结构"></a>基本的变量结构</h3><p><img src="image-20221226155045231.png" alt="image-20221226155045231"></p><p>这是常见的种类</p><h5 id="char-character"><a href="#char-character" class="headerlink" title="char:character"></a>char:character</h5><p>这是字符变量</p><h5 id="string：字符串"><a href="#string：字符串" class="headerlink" title="string：字符串"></a>string：字符串</h5><p>可以理解 为用数组储存的若干的char</p><p>于是可以这样加长：</p><p>s3=[s1 s2];</p><p>s4=[s1;s2];</p><h5 id="struct-结构"><a href="#struct-结构" class="headerlink" title="struct:结构"></a>struct:结构</h5><p><img src="image-20221226160704872.png" alt="image-20221226160704872"></p><h5 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h5><p><img src="image-20221226161005675.png" alt="image-20221226161005675"></p><p>Cell可以是一个大杂烩：里面可以储存不一样的数据</p><p><img src="image-20221226161237213.png" alt="image-20221226161237213"></p><p>一些函数：</p><p><img src="image-20221226161752014.png" alt="image-20221226161752014"></p><h1 id="matlab使用教程"><a href="#matlab使用教程" class="headerlink" title="matlab使用教程"></a>matlab使用教程</h1><p>如何把我们的数据存成文件：</p><p>save 文件名.mat（把文件以二进制的形式存储）</p><p>save 文件名.mat -ascii（把文件以ASCII的形式存储）</p><p>从excel中读取信息：</p><p>xlsread(‘filename.xlsx’,’列与行’)</p><p>xlswrite向Excel写入数据</p><p>（‘filename.xlsx’,数据,sheet,location）</p><p><img src="image-20221226163047228.png" alt="image-20221226163047228"></p><h3 id="Basic绘图"><a href="#Basic绘图" class="headerlink" title="Basic绘图"></a>Basic绘图</h3><p>​        我们怎么绘制一个函数呢？首先啊，我们知道函数是由足够密集的点连成的。也就是说，我们只需要把一个区间段的函数的X—Y点连起来就好了</p><p>​        我们使用plot函数来绘制图像：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>#<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>是一对点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        也可以这样使用</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">plot</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>#where xx<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">,</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span>n<span class="token operator">=</span><span class="token function">length</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        如：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">0</span>：<span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230122201210020.png" alt="image-20230122201210020"></p><p>​        运行上面的这句话，这就是结果</p><p>​        可不可以两个图像叠在一起嘞？可以</p><p><img src="image-20230122202456650.png" alt="image-20230122202456650"></p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold on<span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以绘制多个图像了：hold on表明重复画不刷新画布</p><p>我们当然可以设置函数曲线的格式：</p><p><img src="image-20230122203054085.png" alt="image-20230122203054085"></p><p>​        这样：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold on<span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'or'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">:</span><span class="token keyword">pi</span><span class="token operator">/</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">'xg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230122203329996.png" alt="image-20230122203329996"></p><p>字符串里的格式顺序没有要求，有什么需求就塞。</p><p>有的时候，我们的函数很多很乱，</p><p>比如说在脚本里运行如下的代码：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">hold onx<span class="token operator">=</span><span class="token number">0</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">4</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">;</span>y<span class="token operator">=</span><span class="token function">sin</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>h<span class="token operator">=</span><span class="token function">cos</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token operator">=</span><span class="token number">1.</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>g<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">^</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token operator">.*</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.</span><span class="token operator">*</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">)</span><span class="token operator">.^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">./</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span><span class="token string">'bd-'</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>h<span class="token punctuation">,</span><span class="token string">'gp:'</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>w<span class="token punctuation">,</span><span class="token string">'ro-'</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>g<span class="token punctuation">,</span><span class="token string">'c^-'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230122204242509.png" alt="image-20230122204242509"></p><p>我们可不可以做一点注记嘞？可以，使用legend函数就好了</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'L1'</span><span class="token punctuation">,</span><span class="token punctuation">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，这需要和你依次绘制函数的图像的顺序是一致的：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">#<span class="token punctuation">...</span><span class="token function">legend</span><span class="token punctuation">(</span><span class="token string">'sin(x)'</span><span class="token punctuation">,</span><span class="token string">'cos(x)'</span><span class="token punctuation">,</span><span class="token string">'Sigmoid'</span><span class="token punctuation">,</span><span class="token string">'Gauss Functions'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hold off<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230122204721499.png" alt="image-20230122204721499"></p><p>那。。。可不可以多上一个坐标轴的标记</p><p>使用函数xlabel(‘showstr’),ylabel(“showstr”)和图像标题title(‘showstr’)</p><p><img src="image-20230122205415466.png" alt="image-20230122205415466"></p><p>text()和annotation()</p><p>我们有的时候需要在图片上来打一些字符：这需要我们来使用$LaTex$实现！比如说：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x<span class="token operator">=</span><span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token operator">=</span>x<span class="token operator">.^</span><span class="token number">2.</span><span class="token operator">*</span><span class="token function">sin</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token number">i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">:</span><span class="token number">0.01</span><span class="token operator">:</span><span class="token number">2</span>    <span class="token function">line</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">i</span><span class="token operator">^</span><span class="token number">i</span><span class="token operator">*</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">i</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">end</span>str<span class="token operator">=</span><span class="token string">'$$\int_&#123;0&#125;^&#123;2&#125;x^2\sin(x) dx$$'</span><span class="token punctuation">;</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token number">0.25</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">,</span>str<span class="token punctuation">,</span><span class="token string">'Interpreter'</span><span class="token punctuation">,</span><span class="token string">'latex'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>#固定用法<span class="token function">annotation</span><span class="token punctuation">(</span><span class="token string">'arrow'</span><span class="token punctuation">,</span><span class="token string">'X'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.32</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'Y'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230202185243199.png" alt="image-20230202185243199"></p><h4 id="图像字体的调整："><a href="#图像字体的调整：" class="headerlink" title="图像字体的调整："></a>图像字体的调整：</h4><p>​        我们的绘图本身就是由很多个元素构成：图像本身，线条，文字等等。我们现在想办法使用代码去更改他们！</p><p><img src="image-20230202190117981.png" alt="image-20230202190117981"></p><p>​        类似于C指针的，我们的操作也可以返回这些对象的句柄（指针），比如说：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">h<span class="token operator">=</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        返回了函数画布的句柄！</p><p><img src="image-20230202190810805.png" alt="image-20230202190810805"></p><p>​        相关的可以了解对象树的概念！</p><p>​        我们使用get()方法来取回对象！set()来设定对象属性。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x<span class="token operator">=</span><span class="token function">linspace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>y<span class="token operator">=</span><span class="token function">sin</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>h<span class="token operator">=</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">get</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们的控制台返回了这样一串东西：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">AlignVertexCenters<span class="token operator">:</span> off           Annotation<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> matlab<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>eventdata<span class="token punctuation">.</span>Annotation<span class="token punctuation">]</span>         BeingDeleted<span class="token operator">:</span> off           BusyAction<span class="token operator">:</span> <span class="token string">'queue'</span>        ButtonDownFcn<span class="token operator">:</span> <span class="token string">''</span>             Children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>             Clipping<span class="token operator">:</span> on                Color<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">0.4470</span> <span class="token number">0.7410</span><span class="token punctuation">]</span>            ColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>          ContextMenu<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>            CreateFcn<span class="token operator">:</span> <span class="token string">''</span>      DataTipTemplate<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> matlab<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>datatip<span class="token punctuation">.</span>DataTipTemplate<span class="token punctuation">]</span>            DeleteFcn<span class="token operator">:</span> <span class="token string">''</span>          DisplayName<span class="token operator">:</span> <span class="token string">''</span>     HandleVisibility<span class="token operator">:</span> <span class="token string">'on'</span>              HitTest<span class="token operator">:</span> on        Interruptible<span class="token operator">:</span> on             LineJoin<span class="token operator">:</span> <span class="token string">'round'</span>            LineStyle<span class="token operator">:</span> <span class="token string">'-'</span>        LineStyleMode<span class="token operator">:</span> <span class="token string">'auto'</span>            LineWidth<span class="token operator">:</span> <span class="token number">0.5000</span>               Marker<span class="token operator">:</span> <span class="token string">'none'</span>      MarkerEdgeColor<span class="token operator">:</span> <span class="token string">'auto'</span>      MarkerFaceColor<span class="token operator">:</span> <span class="token string">'none'</span>        MarkerIndices<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1000</span> uint64<span class="token punctuation">]</span>           MarkerMode<span class="token operator">:</span> <span class="token string">'auto'</span>           MarkerSize<span class="token operator">:</span> <span class="token number">6</span>               Parent<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Axes<span class="token punctuation">]</span>        PickableParts<span class="token operator">:</span> <span class="token string">'visible'</span>             Selected<span class="token operator">:</span> off   SelectionHighlight<span class="token operator">:</span> on          SeriesIndex<span class="token operator">:</span> <span class="token number">1</span>                  Tag<span class="token operator">:</span> <span class="token string">''</span>                 Type<span class="token operator">:</span> <span class="token string">'line'</span>             UserData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>              Visible<span class="token operator">:</span> on                XData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1000</span> double<span class="token punctuation">]</span>            XDataMode<span class="token operator">:</span> <span class="token string">'manual'</span>          XDataSource<span class="token operator">:</span> <span class="token string">''</span>                YData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1000</span> double<span class="token punctuation">]</span>          YDataSource<span class="token operator">:</span> <span class="token string">''</span>                ZData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">0</span> double<span class="token punctuation">]</span>          ZDataSource<span class="token operator">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        然后运行:get(gca)</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">ALim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>                    ALimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                  AlphaScale<span class="token operator">:</span> <span class="token string">'linear'</span>                    Alphamap<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">64</span> double<span class="token punctuation">]</span>           AmbientLightColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                BeingDeleted<span class="token operator">:</span> off                         Box<span class="token operator">:</span> on                    BoxStyle<span class="token operator">:</span> <span class="token string">'back'</span>                  BusyAction<span class="token operator">:</span> <span class="token string">'queue'</span>               ButtonDownFcn<span class="token operator">:</span> <span class="token string">''</span>                        CLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>                    CLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>              CameraPosition<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3.5000</span> <span class="token number">0</span> <span class="token number">17.3205</span><span class="token punctuation">]</span>          CameraPositionMode<span class="token operator">:</span> <span class="token string">'auto'</span>                CameraTarget<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3.5000</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">]</span>            CameraTargetMode<span class="token operator">:</span> <span class="token string">'auto'</span>              CameraUpVector<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">]</span>          CameraUpVectorMode<span class="token operator">:</span> <span class="token string">'auto'</span>             CameraViewAngle<span class="token operator">:</span> <span class="token number">6.6086</span>         CameraViewAngleMode<span class="token operator">:</span> <span class="token string">'auto'</span>                    Children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Line<span class="token punctuation">]</span>                    Clipping<span class="token operator">:</span> on               ClippingStyle<span class="token operator">:</span> <span class="token string">'3dbox'</span>                       Color<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                  ColorOrder<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">7</span>×<span class="token number">3</span> double<span class="token punctuation">]</span>             ColorOrderIndex<span class="token operator">:</span> <span class="token number">2</span>                  ColorScale<span class="token operator">:</span> <span class="token string">'linear'</span>                    Colormap<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">256</span>×<span class="token number">3</span> double<span class="token punctuation">]</span>                 ContextMenu<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>                   CreateFcn<span class="token operator">:</span> <span class="token string">''</span>                CurrentPoint<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">2</span>×<span class="token number">3</span> double<span class="token punctuation">]</span>             DataAspectRatio<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3.5000</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>         DataAspectRatioMode<span class="token operator">:</span> <span class="token string">'auto'</span>                   DeleteFcn<span class="token operator">:</span> <span class="token string">''</span>                   FontAngle<span class="token operator">:</span> <span class="token string">'normal'</span>                    FontName<span class="token operator">:</span> <span class="token string">'Helvetica'</span>                    FontSize<span class="token operator">:</span> <span class="token number">10</span>                FontSizeMode<span class="token operator">:</span> <span class="token string">'auto'</span>               FontSmoothing<span class="token operator">:</span> on                   FontUnits<span class="token operator">:</span> <span class="token string">'points'</span>                  FontWeight<span class="token operator">:</span> <span class="token string">'normal'</span>                   GridAlpha<span class="token operator">:</span> <span class="token number">0.1500</span>               GridAlphaMode<span class="token operator">:</span> <span class="token string">'auto'</span>                   GridColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>               GridColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>               GridLineStyle<span class="token operator">:</span> <span class="token string">'-'</span>            HandleVisibility<span class="token operator">:</span> <span class="token string">'on'</span>                     HitTest<span class="token operator">:</span> on               InnerPosition<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1300</span> <span class="token number">0.1100</span> <span class="token number">0.7750</span> <span class="token number">0.8150</span><span class="token punctuation">]</span>                Interactions<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> matlab<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>interaction<span class="token punctuation">.</span>interface<span class="token punctuation">.</span>DefaultAxesInteractionSet<span class="token punctuation">]</span>               Interruptible<span class="token operator">:</span> on     LabelFontSizeMultiplier<span class="token operator">:</span> <span class="token number">1.1000</span>                       Layer<span class="token operator">:</span> <span class="token string">'bottom'</span>                      Layout<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> matlab<span class="token punctuation">.</span>ui<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>LayoutOptions<span class="token punctuation">]</span>                      Legend<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span>×<span class="token number">0</span> GraphicsPlaceholder<span class="token punctuation">]</span>              LineStyleOrder<span class="token operator">:</span> <span class="token string">'-'</span>         LineStyleOrderIndex<span class="token operator">:</span> <span class="token number">1</span>                   LineWidth<span class="token operator">:</span> <span class="token number">0.5000</span>              MinorGridAlpha<span class="token operator">:</span> <span class="token number">0.2500</span>          MinorGridAlphaMode<span class="token operator">:</span> <span class="token string">'auto'</span>              MinorGridColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1000</span> <span class="token number">0.1000</span> <span class="token number">0.1000</span><span class="token punctuation">]</span>          MinorGridColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>          MinorGridLineStyle<span class="token operator">:</span> <span class="token string">':'</span>                    NextPlot<span class="token operator">:</span> <span class="token string">'replace'</span>             NextSeriesIndex<span class="token operator">:</span> <span class="token number">2</span>               OuterPosition<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                      Parent<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Figure<span class="token punctuation">]</span>               PickableParts<span class="token operator">:</span> <span class="token string">'visible'</span>          PlotBoxAspectRatio<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">0.7896</span> <span class="token number">0.7896</span><span class="token punctuation">]</span>      PlotBoxAspectRatioMode<span class="token operator">:</span> <span class="token string">'auto'</span>                    Position<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1300</span> <span class="token number">0.1100</span> <span class="token number">0.7750</span> <span class="token number">0.8150</span><span class="token punctuation">]</span>          PositionConstraint<span class="token operator">:</span> <span class="token string">'outerposition'</span>                  Projection<span class="token operator">:</span> <span class="token string">'orthographic'</span>                    Selected<span class="token operator">:</span> off          SelectionHighlight<span class="token operator">:</span> on                  SortMethod<span class="token operator">:</span> <span class="token string">'childorder'</span>                    Subtitle<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>          SubtitleFontWeight<span class="token operator">:</span> <span class="token string">'normal'</span>                         Tag<span class="token operator">:</span> <span class="token string">''</span>                     TickDir<span class="token operator">:</span> <span class="token string">'in'</span>                 TickDirMode<span class="token operator">:</span> <span class="token string">'auto'</span>        TickLabelInterpreter<span class="token operator">:</span> <span class="token string">'tex'</span>                  TickLength<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.0100</span> <span class="token number">0.0250</span><span class="token punctuation">]</span>                  TightInset<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.0512</span> <span class="token number">0.0540</span> <span class="token number">0.0071</span> <span class="token number">0.0206</span><span class="token punctuation">]</span>                       Title<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>     TitleFontSizeMultiplier<span class="token operator">:</span> <span class="token number">1.1000</span>             TitleFontWeight<span class="token operator">:</span> <span class="token string">'normal'</span>    TitleHorizontalAlignment<span class="token operator">:</span> <span class="token string">'center'</span>                     Toolbar<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> AxesToolbar<span class="token punctuation">]</span>                        Type<span class="token operator">:</span> <span class="token string">'axes'</span>                       Units<span class="token operator">:</span> <span class="token string">'normalized'</span>                    UserData<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                        View<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">90</span><span class="token punctuation">]</span>                     Visible<span class="token operator">:</span> on                       XAxis<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> NumericRuler<span class="token punctuation">]</span>               XAxisLocation<span class="token operator">:</span> <span class="token string">'bottom'</span>                      XColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>                  XColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>                        XDir<span class="token operator">:</span> <span class="token string">'normal'</span>                       XGrid<span class="token operator">:</span> off                      XLabel<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>                        XLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">7</span><span class="token punctuation">]</span>                    XLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                XLimitMethod<span class="token operator">:</span> <span class="token string">'tickaligned'</span>                  XMinorGrid<span class="token operator">:</span> off                  XMinorTick<span class="token operator">:</span> off                      XScale<span class="token operator">:</span> <span class="token string">'linear'</span>                       XTick<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span><span class="token punctuation">]</span>                  XTickLabel<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token number">8</span>×<span class="token number">1</span> cell<span class="token punctuation">&#125;</span>              XTickLabelMode<span class="token operator">:</span> <span class="token string">'auto'</span>          XTickLabelRotation<span class="token operator">:</span> <span class="token number">0</span>                   XTickMode<span class="token operator">:</span> <span class="token string">'auto'</span>                       YAxis<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> NumericRuler<span class="token punctuation">]</span>               YAxisLocation<span class="token operator">:</span> <span class="token string">'left'</span>                      YColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>                  YColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>                        YDir<span class="token operator">:</span> <span class="token string">'normal'</span>                       YGrid<span class="token operator">:</span> off                      YLabel<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>                        YLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                    YLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                YLimitMethod<span class="token operator">:</span> <span class="token string">'tickaligned'</span>                  YMinorGrid<span class="token operator">:</span> off                  YMinorTick<span class="token operator">:</span> off                      YScale<span class="token operator">:</span> <span class="token string">'linear'</span>                       YTick<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">11</span> double<span class="token punctuation">]</span>                  YTickLabel<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token number">11</span>×<span class="token number">1</span> cell<span class="token punctuation">&#125;</span>              YTickLabelMode<span class="token operator">:</span> <span class="token string">'auto'</span>          YTickLabelRotation<span class="token operator">:</span> <span class="token number">0</span>                   YTickMode<span class="token operator">:</span> <span class="token string">'auto'</span>                       ZAxis<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> NumericRuler<span class="token punctuation">]</span>                      ZColor<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0.1500</span> <span class="token number">0.1500</span> <span class="token number">0.1500</span><span class="token punctuation">]</span>                  ZColorMode<span class="token operator">:</span> <span class="token string">'auto'</span>                        ZDir<span class="token operator">:</span> <span class="token string">'normal'</span>                       ZGrid<span class="token operator">:</span> off                      ZLabel<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span>×<span class="token number">1</span> Text<span class="token punctuation">]</span>                        ZLim<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">]</span>                    ZLimMode<span class="token operator">:</span> <span class="token string">'auto'</span>                ZLimitMethod<span class="token operator">:</span> <span class="token string">'tickaligned'</span>                  ZMinorGrid<span class="token operator">:</span> off                  ZMinorTick<span class="token operator">:</span> off                      ZScale<span class="token operator">:</span> <span class="token string">'linear'</span>                       ZTick<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>                  ZTickLabel<span class="token operator">:</span> <span class="token string">''</span>              ZTickLabelMode<span class="token operator">:</span> <span class="token string">'auto'</span>          ZTickLabelRotation<span class="token operator">:</span> <span class="token number">0</span>                   ZTickMode<span class="token operator">:</span> <span class="token string">'auto'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        现在，我们很想设定GCA属性，就是使用set指令：我们找到了这个的指针（句柄）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">set</span><span class="token punctuation">(</span>gca<span class="token punctuation">,</span><span class="token string">'XLim'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">*</span><span class="token keyword">pi</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">set</span><span class="token punctuation">(</span>gca<span class="token punctuation">,</span><span class="token string">'YLim'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1.2</span><span class="token punctuation">,</span><span class="token number">1.2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        当然。。。其实还有更简单的：</p><pre class="line-numbers language-none"><code class="language-none">xlim([0,2*pi]);ylim([-1.2,1.2]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="多重图像展示"><a href="#多重图像展示" class="headerlink" title="多重图像展示"></a>多重图像展示</h3><p>​        我们可以使用figure来分开画图：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">x<span class="token operator">=</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">:</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">10</span><span class="token punctuation">;</span>y1<span class="token operator">=</span>x<span class="token operator">.^</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">;</span>y2<span class="token operator">=</span><span class="token function">exp</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>figure<span class="token punctuation">,</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y1<span class="token punctuation">)</span><span class="token punctuation">;</span>figure<span class="token punctuation">,</span><span class="token function">plot</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230202195804959-167534035717165.png" alt="image-20230202195804959"></p><p>也可以在一个窗口上显示多个图像</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab"><span class="token function">subplot</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span>n<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230202200620906.png" alt="image-20230202200620906"></p><p><img src="image-20230202200718788.png" alt="image-20230202200718788"></p><p><img src="image-20230202200912381.png" alt="image-20230202200912381"></p><p><img src="image-20230202200933449.png" alt="image-20230202200933449"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（5）</title>
      <link href="/2023/02/02/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%885%EF%BC%89/"/>
      <url>/2023/02/02/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%885%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="向量与线性计算"><a href="#向量与线性计算" class="headerlink" title="向量与线性计算"></a>向量与线性计算</h3><h4 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h4><p>​        一个<strong>有大小，又有方向的量</strong> 我们有概念：模长（长度），假使 向量被记作:$\vec\alpha$，则它的长度就是它的模长：$|\vec\alpha|$,</p><p>​        我们又让长度就是1的向量成为单位向量。长度是0的向量是零向量。</p><p>​        位置关系上：有共线，垂直和相等的关系。</p><p>​        平行指的是夹角是0或者是180度。垂直就是90度等。</p><h4 id="线性运算"><a href="#线性运算" class="headerlink" title="线性运算"></a>线性运算</h4><p><img src="image-20230202144129473.png" alt="image-20230202144129473"></p><p><img src="image-20230202144231912.png" alt="image-20230202144231912"></p><p><img src="image-20230202144315494.png" alt="image-20230202144315494"></p><p><img src="image-20230202144356921.png" alt="image-20230202144356921"></p><h4 id="方向余弦"><a href="#方向余弦" class="headerlink" title="方向余弦"></a>方向余弦</h4><p>​        我们有时只考虑方向，我们可以把它归一化：这需要：</p><script type="math/tex; mode=display">\vec{e}=(\frac{x}{r},\frac{y}{r},\frac{z}{r})</script><p>其中：$r=\sqrt{x^2+y^2+z^2}$</p><p>​        有时也这样记：</p><script type="math/tex; mode=display">\vec{e}=(\cos\alpha,\cos\beta,\cos\gamma)</script><p>​        由于这样，我们可以把任意向量拆解为方向向量和长度的数量积</p><script type="math/tex; mode=display">\vec{\alpha}=L\vec{e}</script><h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>​        我们实际上可以使用如下的公式来计算一个向量在另一个向量的投影</p><script type="math/tex; mode=display">Prj_u\vec{a}=|\vec{a}|\cos\varphi</script><p>$\varphi$ 是两个向量的夹角</p><h5 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h5><script type="math/tex; mode=display">1)Prj_u(\vec{a}+\vec{b})=Prj_u\vec{a}+Prj_u\vec{b}</script><script type="math/tex; mode=display">2)Prj_u\lambda\vec{a}=\lambda Prj_u\vec{a}</script><h3 id="数量积"><a href="#数量积" class="headerlink" title="数量积"></a>数量积</h3><p><img src="image-20230202145138671.png" alt="image-20230202145138671"></p><p><img src="image-20230202145200044.png" alt="image-20230202145200044"></p><p><img src="image-20230202145233436.png" alt="image-20230202145233436"></p><h3 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h3><p>​        这是我们不熟悉的：</p><script type="math/tex; mode=display">\vec{c}=\vec{a}\times \vec{b}</script><p>​        首先模长是：</p><script type="math/tex; mode=display">|\vec{c}|=|\vec{a}||\vec{b}|\sin\theta</script><pre><code>     方向：右手从a到b。</code></pre><p>​        注意结果是一个向量！</p><p><img src="image-20230202145456287.png" alt="image-20230202145456287"></p><p><img src="image-20230202145504892.png" alt="image-20230202145504892"></p><h3 id="平面"><a href="#平面" class="headerlink" title="平面"></a>平面</h3><h4 id="曲面"><a href="#曲面" class="headerlink" title="曲面"></a>曲面</h4><p>​        曲面可以看成运动曲线的结果，我们常常使用方程：</p><script type="math/tex; mode=display">F(x,y,z)=0</script><p>来描述！</p><p>​        由此，曲线可以视作两个曲面的交：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}F(x,y,z) & = 0 \\G(x,y,z) & =  0\end{aligned}\right.\end{equation}</script><p>其法线垂直于平面。</p><h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><h5 id="点法式"><a href="#点法式" class="headerlink" title="点法式"></a>点法式</h5><p>​        如果我们已知一个点和一个法线：我们可以求出方程：</p><p>​        已知：$n(A,B,C)，M(x_0,y_0,z_0)$</p><script type="math/tex; mode=display">L:A(x-x_0)+B(y-y_0)+C(z-z_0)=0</script><p>一般式</p><p>​        拆开上面的式子，将常数化作一个指标D</p><script type="math/tex; mode=display">L:Ax+By+Cz+D=0</script><p><img src="image-20230202150419737.png" alt="image-20230202150419737"></p><h3 id="平面的夹角"><a href="#平面的夹角" class="headerlink" title="平面的夹角"></a>平面的夹角</h3><p>我们回忆高中两直线的夹角：</p><script type="math/tex; mode=display">\cos \theta=|\cos(\vec{n_1},\vec{n_2})|</script><p>平面是一样的：</p><script type="math/tex; mode=display">\cos \theta=|\cos(\vec{n_1},\vec{n_2})|</script><p>只不过：</p><script type="math/tex; mode=display">\cos \theta=\frac{A_1A_2+B_1B_2+C_1C_2}{\sqrt{(A_1^2+B_1^2+C_1^2)(A_2^2+B_2^2+C_2^2)}}</script><p>推广了一个维度！</p><h3 id="空间直线与方程"><a href="#空间直线与方程" class="headerlink" title="空间直线与方程"></a>空间直线与方程</h3><p>回到这个概念：</p><p>曲线可以视作两个曲面的交：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}F(x,y,z) & = 0 \\G(x,y,z) & =  0\end{aligned}\right.\end{equation}</script><p>直线就是：</p><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}A_1x+B_1y+C_1z+D_1 & = 0 \\A_2x+B_2y+C_2z+D_2 & =  0\end{aligned}\right.\end{equation}</script><h4 id="对称式"><a href="#对称式" class="headerlink" title="对称式"></a>对称式</h4><p>​        如果已知：$M(x_0,y_0,z_0),S(m,n,p)$则：</p><script type="math/tex; mode=display">\frac{x-x_0}{m}=\frac{y-y_0}{n}=\frac{z-z_0}{p}</script><h4 id="参数式"><a href="#参数式" class="headerlink" title="参数式"></a>参数式</h4><script type="math/tex; mode=display">\begin{equation}\left\{\begin{aligned}x & = mt+x_0 \\y & =  nt+y_0\\y & =  pt+z_0\end{aligned}\right.\end{equation}</script><p>​        就是在对称式的基础上加上了等于T的条件！</p><h4 id="平面与直线的夹角"><a href="#平面与直线的夹角" class="headerlink" title="平面与直线的夹角"></a>平面与直线的夹角</h4><p>​        类似的，我们可以得到：</p><script type="math/tex; mode=display">\sin\varphi=|\cos(\vec{s},\vec{n})|=\frac{|Am+Bn+Cp|}{\sqrt{(A^2+B^2+C^2)(m^2+n^2+p^2)}}</script><p>​        于是：</p><script type="math/tex; mode=display">垂直: \frac{A}{m}=\frac{B}{n}=\frac{C}{p}</script><script type="math/tex; mode=display">平行:Am+Bn+Cp=0</script><h3 id="曲面-1"><a href="#曲面-1" class="headerlink" title="曲面"></a>曲面</h3><h4 id="旋转曲面"><a href="#旋转曲面" class="headerlink" title="旋转曲面"></a>旋转曲面</h4><p>​        由曲线旋转产生</p><p>​        假设我们原先的曲线的方程是：$f(y,z)=0$，他显然位于$yOz$平面上，其上有一点:$M_1(0,y_1,z_1)$</p><p>​        旋转之后：$M(x,y,z)$一定有：</p><script type="math/tex; mode=display">z=z_1且y_1=\pm\sqrt{x^2+y^2}</script><p>​        于是：</p><script type="math/tex; mode=display">f(\pm\sqrt{x^2+y^2},z)=0</script><p>​        相同的办法推理：对于$f(y,z)=0$绕Y轴旋转：</p><script type="math/tex; mode=display">f(y,\pm\sqrt{x^2+z^2})=0</script><p><img src="image-20230202152227760.png" alt="image-20230202152227760"></p><p>绕谁转，谁不变：剩下两个在旁边。</p><h4 id="曲面类型"><a href="#曲面类型" class="headerlink" title="曲面类型"></a>曲面类型</h4><h5 id="柱面："><a href="#柱面：" class="headerlink" title="柱面："></a>柱面：</h5><p>​        把一个平面作为准线，沿一条线（母线）移动：</p><script type="math/tex; mode=display">x^2+y^2=R^2</script><p>​        是一个代表</p><p><img src="image-20230202152508816.png" alt="image-20230202152508816"></p><p>​        如果是抛物线：就产生抛物面：</p><p><img src="image-20230202152605842.png" alt="image-20230202152605842"></p><p>​        缺什么以什么为准线移动！</p><h5 id="二次曲面"><a href="#二次曲面" class="headerlink" title="二次曲面"></a>二次曲面</h5><p>1）椭圆锥面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}=z^2</script><p>​        只要令$z=t$，我们马上发现这就是个椭圆</p><p><img src="image-20230202152818674.png" alt="image-20230202152818674"></p><p>​        这里引入伸缩的概念：我们对变量可以伸缩：拉长或缩短，直接是令$y’=\lambda y$带入方程来看</p><p>2）椭球面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}+\frac{z^2}{c^2}=1</script><p>3)单叶双曲面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1</script><p>本质上是$\frac{x^2}{a^2}-\frac{z^2}{c^2}=1$先绕Y轴旋转，随后伸缩$\frac{b}{a}$倍数</p><p>4）双叶双曲面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=-1</script><p>5）椭圆抛物面：</p><script type="math/tex; mode=display">\frac{x^2}{a^2}+\frac{y^2}{b^2}=z</script><p>​        可以看作一个$P^2=C$的类抛物线看待</p><p>6）双曲抛物面</p><script type="math/tex; mode=display">\frac{x^2}{a^2}-\frac{y^2}{b^2}=z</script>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（4）</title>
      <link href="/2023/02/02/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%884%EF%BC%89/"/>
      <url>/2023/02/02/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​    定积分是从求解曲边梯形的面积产生的：就是说求解类似于如下的图像的面积</p><p><img src="image-20230124151114672.png" alt="image-20230124151114672"></p><p>​        怎么搞？我们试想一下，使用如下的方式：通过把面积切成很小的小块：</p><p>由于这些面积可以近似成矩形甚至是梯形，我们可以用面积和近似代替曲边梯形的面积。</p><p><img src="image-20230124151244623.png" alt="image-20230124151244623"></p><p>数学上是这么</p><script type="math/tex; mode=display">假设分点:a=x_0<x_1<x_2...<x_{n-1}<x_n=b</script><p>产生了</p><script type="math/tex; mode=display">\Delta x_1,\Delta x_2,...,\Delta x_n,随后令\lambda=max\{\Delta x_1,\Delta x_2,...,\Delta x_n\}</script><p>​        只要切的够小，我们就可以:$S\approx \sum_{k=1}^n \Delta x_kf(\sigma_k)$</p><p>​        其中$\sigma_k$是小区间上的一个任意点。怎么逼近真实值呢？让点取的密集一些：就是令$\lambda \rightarrow 0$就好了：产生的极限就是面积。</p><p>​        我们可以引入定积分了：</p><p>​        定义：$f(x)$在[a,b]有界，在[a,b]上任意插入若干个分点（随便插入），产生N个小区间，其长度为:$x_k(0&lt;k\leq n)$,又在区间上任意取一点$\sigma_i$，现在取出这些区间内最大长度的长度值记成$\lambda$,也就是$\lambda=max\{\Delta x_1,\Delta x_2,…\Delta x_n\}$。这下有了假设和的极限：$\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)$ 假设他存在：就引入这样的记号：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        其中a,b叫积分下限和积分上限，被积函数是f(x),积分区间是[a,b],积分变量是x</p><p>​        注意，这个值（或者说这个定积分）与积分变量无关，也就是说：</p><script type="math/tex; mode=display">\int_a^b f(t)dt=\int_a^b f(x)dx</script><p>​        定理1：函数只要连续就一定可积。</p><p>​        定理2：函数<strong>有界</strong>且<strong>有有限个间断点</strong>也可积。</p><h3 id="定积分的几何意义"><a href="#定积分的几何意义" class="headerlink" title="定积分的几何意义"></a>定积分的几何意义</h3><p>​        1.$f(x)\geq0$</p><p>​        <img src="image-20230124153747909.png" alt="image-20230124153747909"></p><p>​        就是阴影部分面积</p><p>​        2.$f(x)\leq0$</p><p><img src="image-20230124153828323.png" alt="image-20230124153828323"></p><p>​        注意是阴影部分面积的相反数，这是因为：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        中：$f(\sigma_k)&lt;0$</p><h6 id="矩阵法"><a href="#矩阵法" class="headerlink" title="矩阵法"></a>矩阵法</h6><p>​        我们使用切分成矩阵的方式来计算定积分</p><p><img src="image-20230124154130711.png" alt="image-20230124154130711"></p><h6 id="梯形法"><a href="#梯形法" class="headerlink" title="梯形法"></a>梯形法</h6><p><img src="image-20230124154214737.png" alt="image-20230124154214737"></p><p>看看就好，不用他来计算</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1）a=b下：$\int_a^b f(x)dx=0$</p><p>2)$\int_a^b f(x)dx=-\int_b^a f(x)dx$</p><p>3)$\int_a^b (\alpha f(x)+\beta g(x))dx=\alpha \int_a^b f(x)dx+\beta\int_a^b g(x)dx$</p><p>4)$\int_a^b f(x)dx=\int_a^c f(x)dx+\int_c^b f(x)dx$(切成两块加)</p><p>5)$f(x)\equiv 1,\int_a^b 1dx=b-a,\int_a^b kdx=k(b-a)$</p><p>6)$f(x)\geq 0,\int_a^b f(x)dx\geq0$</p><p>7)$f(x)\leq 0,\int_a^b f(x)dx\leq0$</p><p>8)$f(x)\leq g(x),\int_a^b f(x)dx\leq\int_a^b g(x)dx$</p><p>来点推论：</p><p>1.</p><script type="math/tex; mode=display">|\int_a^b f(x)dx|\leq\int_a^b |f(x)|dx</script><p>2.函数的极大值和极小值为$M,m$</p><script type="math/tex; mode=display">m(b-a)\leq\int_a^b f(x)dx\leq M(b-a)</script><p>9)定积分中值定理：$f(x)$连续,$\exists \xi\in[a,b]$</p><script type="math/tex; mode=display">\int_a^b f(x)dx=f(\xi)(b-a)</script><p>这个定理可以用来化简带有积分的极限</p><p><img src="image-20230124155256516.png" alt="image-20230124155256516"></p><h3 id="微积分的基本公式"><a href="#微积分的基本公式" class="headerlink" title="微积分的基本公式"></a>微积分的基本公式</h3><h4 id="积分上限函数"><a href="#积分上限函数" class="headerlink" title="积分上限函数"></a>积分上限函数</h4><p>我们把一个限变成一个变量，有点像把一边可以自由滑动，这样就有一个变限积分函数，我们把目光集中在x上：</p><script type="math/tex; mode=display">\int_a^x f(t)dt</script><p>这样定积分就从一个值变成一个函数</p><script type="math/tex; mode=display">\phi(x)=\int_a^x f(t)dt</script><p>定理1：</p><script type="math/tex; mode=display">\phi'(x)=\frac{d}{dx}\int_a^x f(t)dt=f(x)</script><p>这样来看，$\phi(x)$就是$f(x)$的一个原函数。值得一提的是：</p><script type="math/tex; mode=display">(\int_x^a f(t)dt)'=-f(x)</script><script type="math/tex; mode=display">(\int_a^{\varphi(x)} f(t)dt)'=f(\varphi(x))\varphi'(x)</script><script type="math/tex; mode=display">[\int_{\varphi(x)}^{\phi(x)}f(t)dt]'=f(\phi(x))\varphi'(x)-f(\varphi(x))\phi'(x)</script><p>上面那个可能太抽象，可以使用性质2）插入一个常数点a</p><h4 id="牛顿莱布尼兹公式"><a href="#牛顿莱布尼兹公式" class="headerlink" title="牛顿莱布尼兹公式"></a>牛顿莱布尼兹公式</h4><script type="math/tex; mode=display">\int_a^bf(x)dx=F(x)|_a^b=F(b)-F(a)</script><p>​        其中$F(x)$是$f(x)$的原函数。</p><p>例如：$\int_0^1 x^2dx$</p><p>解：=$\frac{1}{3}x^3|_0^1=\frac{1}{3}$</p><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><h4 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法</h4><p>​        定理：我们令$x=\varphi(t)$使之$\varphi(\alpha)=a,\varphi(\beta)=b$</p><script type="math/tex; mode=display">\int_a^bf(x)dx=\int_\alpha^\beta(\varphi(t))\varphi'(t)dt</script><p>例题：</p><p>1）$\int_0^a\sqrt{a^2-x^2}dx$</p><p>解：$令x=a\sin t$,$dx=a\cos tdt$</p><p>$=\int_0^{\frac{\pi}{2}}a^2\cos^2tdt=\frac{\pi}{4}a^2$</p><p>一些技巧：</p><p>1）$[-a,a]$下：$f(x)$偶：$\int_{-a}^{a}f(x)dx=2\int_{0}^{a}f(x)dx$,$f(x)$奇则为0。</p><p>2）$\int_{0}^{\frac{\pi}{2}}f(\sin x)dx=\int_{0}^{\frac{\pi}{2}}f(\cos x)dx$</p><p>3)$\int_{0}^{\pi}xf(\sin x)dx=\frac{\pi}{2}\int_0^{\pi}f(\sin x)dx$</p><p>（2）（3）怎么说？</p><p>2）令：$x=\frac{\pi}{2}-t,dx=-dt$就可以了</p><p>3）令：$x=\pi-t,dx=-dt$带入之后化简一下得到：</p><script type="math/tex; mode=display">\int_{0}^{\pi}xf(\sin x)dx=\int_{0}^{\pi}(\pi-t)f(\sin t)dt=\pi\int_{0}^{\pi}f(\sin x)dx-\int_{0}^{\pi}xf(\sin x)dx</script><p>(上面中因为与积分变量无关由此可以直接替换)</p><p>例题：$\int_0^{\pi}\frac{x\sin x}{1+\cos^2x}dx=\frac{\pi}{2}\int_0^{\pi}\frac{\sin x}{1+\cos^2x}dx=-\frac{\pi}{2}\arctan(\cos x)|_0^\pi=\frac{\pi^2}{4}$</p><p>4)$\int_a^{a+T}f(x)dx=\int_0^Tf(x)dx$(f(x)是一个周期函数，周期是T)</p><p>5）$\int_a^{a+nT}f(x)dx=n\int_0^af(x)dx$</p><h4 id="分部积分"><a href="#分部积分" class="headerlink" title="分部积分"></a>分部积分</h4><p>​        首先回顾$\int udv=uv-\int vdu$这个公式，于是，在定积分的也自然就是：</p><script type="math/tex; mode=display">\int_a^b udv=uv|_a^b - \int_a^b vdu</script><p>​        例如：$\int _0^\frac{1}{2} \arcsin xdx$</p><p>​        注意到$x$也是一个函数：于是$\int _0^\frac{1}{2} \arcsin xdx=x\arcsin x|_0^\frac{1}{2} - \int_0^\frac{1}{2} \frac{x}{\sqrt {1-x^2} }dx=\frac{\pi}{12}+\frac{\sqrt 3}{2}-1$</p><p>​        也有上面提到的方法一块用的积分：</p><p>​        $\int_0^1 e^\sqrt{x}dx$</p><p>​        令:$t=\sqrt x$, 则:$2\int_0^1 te^tdt$=$2te^t|_0^1-2\int_0^1 e^tdt=2$</p><h3 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h3><h4 id="无穷限的反常积分"><a href="#无穷限的反常积分" class="headerlink" title="无穷限的反常积分"></a>无穷限的反常积分</h4><p>​        什么叫反常积分呢？就是说积分区域下函数在这一点反常。比如说，因为积分区域含有无穷的积分：</p><script type="math/tex; mode=display">\int_a^{+\infty} f(x)dx</script><p>​        或者是这样的：</p><script type="math/tex; mode=display">\int_{-\infty}^b  f(x)dx</script><p>​        这样的积分是无穷限的反常积分。我们不妨采用动态的方法：</p><script type="math/tex; mode=display">\int_a^{+\infty} f(x)dx=\lim_\limits{t\rightarrow +\infty}\int_a^t f(x)dx</script><p>​        这下也有类似的：</p><script type="math/tex; mode=display">\int_{-\infty}^b  f(x)dx=\lim_\limits{t\rightarrow -\infty}\int_t^b f(x)dx</script><p>​        牵扯到了极限，因此：如果上面的极限是存在的，那就：之人格积分是收敛的，反之发散。</p><p>​        还有上下限均是无穷的积分，仍采用上面的处理方式。在实际求值的时候，也是直接</p><script type="math/tex; mode=display">\int_a^{+\infty}f(x)dx=F(x)|_a^{+\infty}</script><p>​        一个结论：对于</p><script type="math/tex; mode=display">\int_a^{+\infty}\frac{dx}{x^p}(a>0)</script><p>​        <strong>p&gt;1收敛，p$\leq 1$手来你</strong></p><h4 id="反常积分：无界函数的反常积分"><a href="#反常积分：无界函数的反常积分" class="headerlink" title="反常积分：无界函数的反常积分"></a>反常积分：无界函数的反常积分</h4><p>​        什么意思？就是说函数在某一点没有定义，我们的积分区域却包含了它。比如说</p><script type="math/tex; mode=display">\int_0^1 \frac{1}{x}dx</script><p>​        结合上一小节的类似方法，我们得到</p><script type="math/tex; mode=display">\int_0^1 \frac{1}{x}dx=\lim\limits_{t\rightarrow 0^+}\int_t^1\frac{1}{t}dx</script><p>​        类似的： </p><script type="math/tex; mode=display">\int_{-1}^0 \frac{1}{x}dx=\lim\limits_{t\rightarrow 0^-}\int_{-1}^t\frac{1}{t}dx</script><p>​        如果这样的点在中间，我们就拆开积分区域就好了。</p><h4 id="补充：-Gamma-s-函数"><a href="#补充：-Gamma-s-函数" class="headerlink" title="补充：$\Gamma(s)$函数"></a>补充：$\Gamma(s)$函数</h4><p>​        $\Gamma(s)$函数是这样定义的：</p><script type="math/tex; mode=display">\Gamma(s)=\int_0^{+\infty}e^{-x}x^{s-1}dx(s>0)</script><p>​        具有以下非常好推导的性质：</p><script type="math/tex; mode=display">1)\Gamma(s+1)=s\Gamma(s)</script><script type="math/tex; mode=display">2)\Gamma(1)=1</script><p>基于2)，我们发现了这个函数的一个奇妙公式：</p><script type="math/tex; mode=display">\Gamma(s+1)=s!</script><h4 id="补充：比较审敛原理"><a href="#补充：比较审敛原理" class="headerlink" title="补充：比较审敛原理"></a>补充：比较审敛原理</h4><p>​        我们假设:$f(x)$和$g(x)$在[a,$\infty$ ]上连续，$60 \leq f(x)\leq g(x)$如果：</p><script type="math/tex; mode=display">1)\int_a^{+\infty}g(x)dx收敛\rightarrow\int_a^{+\infty}f(x)dx收敛</script><script type="math/tex; mode=display">1)\int_a^{+\infty}f(x)dx发散\rightarrow\int_a^{+\infty}g(x)dx发散</script><p>​        很好理解：大哥收敛小弟也收敛，小弟嚣张大哥肯定也嚣张。</p><h4 id="补充：比较审敛法"><a href="#补充：比较审敛法" class="headerlink" title="补充：比较审敛法"></a>补充：比较审敛法</h4><p>​    设$f(x)$在[a,$\infty$]连续(a&gt;0)，且$f(x)\geq 0,\exists M&gt;0,p&gt;1$</p><p>​        如果使得:$f(x)\leq \frac{M}{x^p}$那就$\int_a^{+\infty}f(x)dx$收敛</p><p>​        反之：$f(x)\geq \frac{M}{x},$那就$\int_a^{+\infty}f(x)dx$发散</p><h4 id="补充：绝对审敛法"><a href="#补充：绝对审敛法" class="headerlink" title="补充：绝对审敛法"></a>补充：绝对审敛法</h4><p>​        如果$f(x)$在设$f(x)$在[a,$\infty$]连续（a&gt;0), $\int_a^{+\infty}|f(x)|dx$收敛，那么$\int_a^{+\infty}f(x)dx$收敛。</p><p>​        最后不难得到这个定理</p><h4 id="补充：无界函数反常积分的审敛法"><a href="#补充：无界函数反常积分的审敛法" class="headerlink" title="补充：无界函数反常积分的审敛法"></a>补充：无界函数反常积分的审敛法</h4><p>​        回到这个积分</p><script type="math/tex; mode=display">\int_a^b \frac{dx}{(x-a)^q}</script><p>​        $x=a$显然是一个瑕点$q&lt;1$收敛，q$\geq$1发散。</p><p>​        基于这个积分，我们再次应用比较原理：</p><p>​        如果$f(x)$在(a,b]连续,f(x)$\geq$0,如果$\exists M&gt;0$及其$q&lt;1$使得</p><script type="math/tex; mode=display">1)f(x)\leq \frac{M}{(x-a)^q}收敛</script><script type="math/tex; mode=display">2)f(x)\geq \frac{M}{x-a}发散</script><h4 id="补充：极限审敛法"><a href="#补充：极限审敛法" class="headerlink" title="补充：极限审敛法"></a>补充：极限审敛法</h4><p>​        如果$f(x)$在(a,b]连续,f(x)$\geq$0，$x=a$为$f(x)$的瑕点</p><p>​        1）$\exists 0&lt;q&lt;1$使得$\lim\limits_{x\rightarrow a^+}(x-a)^qf(x)=A$直接说明一件事：$\int_a^b f(x)dx$收敛。</p><p>​        2）类比的$\lim\limits_{x\rightarrow a^+}(x-a)f(x)=A$或者是$\infty$，我们直接认为$\int_a^b f(x)dx$发散。</p><h3 id="定积分的元素法"><a href="#定积分的元素法" class="headerlink" title="定积分的元素法"></a>定积分的元素法</h3><p>​        回到定积分的这个定义式：</p><script type="math/tex; mode=display">\int_a^b f(x)dx=\lim\limits_{\lambda \rightarrow 0} \sum_{k=1}^n \Delta x_kf(\sigma_k)</script><p>​        <strong>本质上，这样的一个定积分就是描述瞬时元素在某一个维度的积累效应的量化程度</strong>，这就是说：它既可以用来描述面积，又可以描述体积，只需要我们掌握了相应的边界函数，只要对应积分即可。</p><p><img src="image-20230130163127477.png" alt="image-20230130163127477"></p><p>​        比如说，这个的体积就是面积函数A(x)对于高度x的积分</p><script type="math/tex; mode=display">V=\int_{x_1}^{x_2}A(x)dx</script><h3 id="补充一下极坐标"><a href="#补充一下极坐标" class="headerlink" title="补充一下极坐标"></a>补充一下极坐标</h3><p>​        我们重新用一种全新的角度来看待坐标系：我们改用距离原点的距离+偏离X轴正方向的描述方法描述点的坐标。</p><p><img src="image-20230130163636247.png" alt="image-20230130163636247"></p><p>这样，一个点就总是可以表示为$A=(\rho, \theta)$，比如说极坐标下(1,1)变成了$(\sqrt 2,\frac{\pi}{4})$,现在，我们试着求：</p><p><img src="image-20230130174155076.png" alt="image-20230130174155076"></p><p>这个阴影面积：怎么办？延续老方法：假设点沿着曲线挪动一丁点，那么我们的产生的微小的面积则是：</p><script type="math/tex; mode=display">dS=\frac{\rho^2d\theta}{2}</script><p>然后从哪到哪？$\alpha$到$\beta$。</p><script type="math/tex; mode=display">S=\int_\alpha^\beta \frac{\rho^2d\theta}{2}</script><p>结束。</p><h3 id="平面图形的面积"><a href="#平面图形的面积" class="headerlink" title="平面图形的面积"></a>平面图形的面积</h3><h4 id="直角坐标系"><a href="#直角坐标系" class="headerlink" title="直角坐标系"></a>直角坐标系</h4><p>​        我们说函数相交也可以产生一些面积</p><p><img src="image-20230130174758444.png" alt="image-20230130174758444"></p><p>​        这个怎么求呢？</p><p><img src="image-20230130174916021.png" alt="image-20230130174916021"></p><p>​        我们的差面积就是：</p><script type="math/tex; mode=display">S=\int_a^bf(x)dx-\int_a^b g(x)dx=\int_a^bf(x)-g(x)dx</script><p>​        这样的差是X型的面积积分，因为我们拿X作为梯形的高</p><p>​        那就还有Y型面积：</p><p><img src="image-20230130175121419.png" alt="image-20230130175121419"></p><p>​        类比的：</p><script type="math/tex; mode=display">S=\int_c^d \varphi(y)-\phi(y)dy</script><p>​        也即是：</p><p>​            X:$S=\int 上-下dx$</p><p>​            Y:$S=\int 右-左dy$</p><p>​        </p><p>​        总结一下：我们对面积先大致画出来图长什么样：如果是这样的</p><p>​        <img src="image-20230130175729566.png" alt="image-20230130175729566"></p><p>​        就这样使用X，Y对应当打，如果不好判断，就都先试试，哪个更加容易用哪个。</p><p>​        举例：求$y=\frac{1}{2}x^2$,$y=\frac{1}{1+x^2}$在$x \in [-\sqrt 3,\sqrt 3]$下的定积分。</p><p>​        我们可以做出图像：</p><p><img src="image-20230202133001296.png" alt="image-20230202133001296"></p><p>​        砍开来看：</p><script type="math/tex; mode=display">S=\int_{-\sqrt{3}}^{-1}(\frac{1}{2}x^2-\frac{1}{1+x^2})+\int_{-1}^1(\frac{1}{1+x^2}-\frac{1}{2}x^2)+\int_{1}^{\sqrt{3}}(\frac{1}{2}x^2-\frac{1}{1+x^2})</script><p>​        随后使用偶函数的对称性结束计算。</p><p>​        求椭圆的面积：$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$</p><p>​        可以拆开四分之一的部分$S_1=\int_0^aydx$</p><p>​        现在，我们引入椭圆参数方程来消去参数：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=a\cos t \\y=a\sin t \end{aligned} \right . \end{equation}</script><p>来看看变成什么了：</p><script type="math/tex; mode=display">S_1=-\int_0^{\frac{\pi}{2}}a\sin t \times a(-\sin t)dt=\frac{\pi ab}{4}</script><p>这就是为什么：</p><script type="math/tex; mode=display">S=\pi ab</script><h4 id="极坐标下"><a href="#极坐标下" class="headerlink" title="极坐标下"></a>极坐标下</h4><p>​        回忆前面所叙述的：对于方程$R=\rho (\theta)$</p><script type="math/tex; mode=display">S=\frac{1}{2}\int_{\alpha}^{\beta}(\rho (\theta))^2d\theta</script><p>​        比如说：$\rho=a\theta$</p><script type="math/tex; mode=display">S=\frac{1}{2}\int_0^{2\pi}(a\theta)^2d\theta=\frac{4}{3}a^2\pi^3</script><h3 id="旋转体体积求法"><a href="#旋转体体积求法" class="headerlink" title="旋转体体积求法"></a>旋转体体积求法</h3><p>说白了可以切成以$f(x)$为半径的圆，在叠起来（求积分）</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2}\pi f^2(x)dx</script><p> 是通过</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2} A(x)dx</script><p>​        派生来的，只是因为面积恰好是圆。</p><p>​        但是，这样的体积求解的是绕X轴的。绕Y轴的怎么办哪？</p><p>​        简单：那就改写方程为$x=x(y)$就好了：</p><script type="math/tex; mode=display">V=\int_{h_1}^{h_2}x^2(y)dy</script><h3 id="弧长的求解"><a href="#弧长的求解" class="headerlink" title="弧长的求解"></a>弧长的求解</h3><h4 id="通用："><a href="#通用：" class="headerlink" title="通用："></a>通用：</h4><p>回来看看这个参数方程：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=\varphi(t) \\y=\phi(t)\end{aligned} \right . \end{equation}</script><p>​        弧微分很容易说：</p><script type="math/tex; mode=display">ds=\sqrt{(dx)^2+(dy)^2}dt=\sqrt{(\varphi'(t))^2+(\phi'(t))^2}dt</script><p>​        于是：</p><script type="math/tex; mode=display">L=\int_\alpha^\beta \sqrt{(\varphi'(t))^2+(\phi'(t))^2}dt</script><p>​        作为积分结果，就是弧长。</p><p>​        以此为源头，开始推广其他的公式：</p><h4 id="直角坐标系下"><a href="#直角坐标系下" class="headerlink" title="直角坐标系下"></a>直角坐标系下</h4><p>​        假如参数方程很容易被表达为$y=y(x)$，那我们就：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=x \\ y=y(x)\\\end{aligned} \right . \end{equation}</script><p>​        那带入：</p><script type="math/tex; mode=display">ds=\sqrt{1+y'^2(x)}dx</script><p>​        再积分：</p><script type="math/tex; mode=display">L=\int_a^b\sqrt{1+y'^2(x)}dx</script><h4 id="极坐标系下"><a href="#极坐标系下" class="headerlink" title="极坐标系下"></a>极坐标系下</h4><p>​        如果不知道的话：科普一下</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x=\rho(\theta)\cos \theta \\ y=\rho(\theta)\sin \theta\\\end{aligned} \right . \end{equation}</script><p>​        所有呢，求个导：</p><script type="math/tex; mode=display">\begin{equation}\left\{ \begin{aligned} x'=\rho'(\theta)\cos \theta- \rho(\theta)\sin \theta\\ y'=\rho(\theta)\cos \theta+\rho'(\theta)\sin \theta\\\end{aligned} \right . \end{equation}</script><p>​        老样子：</p><script type="math/tex; mode=display">ds=\sqrt{(x'^2+y'^2)} d\theta=\sqrt{\rho^2(\theta)+\rho'^2(\theta)d\theta}</script><p>​         嘛，不就完事了！</p><script type="math/tex; mode=display">L=\int_\alpha^\beta\sqrt{\rho^2(\theta)+\rho'^2(\theta)d\theta}</script>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv in Pycharm（2）</title>
      <link href="/2023/01/31/Opencv-in-Pycharm%EF%BC%882%EF%BC%89/"/>
      <url>/2023/01/31/Opencv-in-Pycharm%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><h3 id="平滑操作"><a href="#平滑操作" class="headerlink" title="平滑操作"></a>平滑操作</h3><p>​        平滑平滑，取平均。我们使用卷积核来处理图像像素点。</p><p><img src="lenaNoise.png" alt="lenaNoise"></p><p>​        针对上面这个噪点图形，我们应用平均卷积操作。我们对噪点抹除，就是通过对周围像素点取平均。我们首先构造一个3$\times$3的矩阵对目标像素点为中心的内核求取内积。（不同于经典矩阵相乘，我们是一一对应的，平凡算法复杂度为$O(N^k)(k \in N^+)$的相乘）随后把结果填充到像素点的中心。</p><p>​        下面我们对这个图操作一下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_path <span class="token operator">=</span> <span class="token string">"img/lenaNoise.png"</span>img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Noise Version"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>blur33<span class="token operator">=</span>cv2<span class="token punctuation">.</span>blur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"3 times 3"</span><span class="token punctuation">,</span>blur33<span class="token punctuation">)</span>blur55<span class="token operator">=</span>cv2<span class="token punctuation">.</span>blur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"3 times 3"</span><span class="token punctuation">,</span>blur55<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        产生的效果是令人满意的：</p><p>3$\times$3：</p><p><img src="3 times 3.png" alt="3 times 3"></p><p>5$\times$5：</p><p><img src="5 times 5.png" alt="5 times 5"></p><p>​        可以看到核越大，越是噪点不明显，但是图像也就越模糊。</p><p>​        还有一个类似的：是BoxFilter函数：（方框滤波）</p><p>​        在OpenCV中，实现方框滤波的函数是cv2.boxFilter（），其语法格式为：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">   dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>boxFilter（src<span class="token punctuation">,</span>ddepth<span class="token punctuation">,</span>ksize<span class="token punctuation">,</span>anchor<span class="token punctuation">,</span>normalize<span class="token punctuation">,</span>borderType）   <span class="token comment"># 但是一般的。。。。。。</span>dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>boxFilter（src<span class="token punctuation">,</span>ddepth<span class="token punctuation">,</span>ksize）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>● dst是返回值，表示进行方框滤波后得到的处理结果。● src 是需要处理的图像，即原始图像。它能够有任意数量的通道，并能对各个通道独立处理。图像深度应该是CV_8U、CV_16U、CV_16S、CV_32F 或者 CV_64F中的一种。 ● ddepth是处理结果图像的图像深度，一般使用-1表示与原始图像使用相同的图像深度。 ● ksize 是滤波核的大小。滤波核大小是指在滤波处理过程中所选择的邻域图像的高 度和宽度。● anchor 是锚点，其默认值是（-1,-1），表示当前计算均值的点位于核的中心点位 置。该值使用默认值即可，在特殊情况下可以指定不同的点作为锚点。● normalize 表示在滤波时是否进行归一化（这里指将计算结果规范化为当前像素值范围内的值）处理，该参数是一个逻辑值，可能为真（值为1）或假（值为0）：1.当参数normalize=1时，表示要进行归一化处理，要用邻域像素值的和除以面积。此时方框滤波与均值滤波效果相同。2.当参数normalize=0时，表示不需要进行归一化处理，直接使用邻域像素值的和。当 normalize=0时，因为不进行归一化处理，因此滤波得到的值很可能超过当前像素值范围的最大值，从而被截断为最大值。这样，就会得到一幅纯白色的图像。● borderType是边界样式，该值决定了以何种方式处理边界。通常情况下，在使用方框滤波函数时，对于参数anchor、normalize和borderType，直接采用其默认值即可。因此，函数cv2.boxFilter（）的常用形式为：</code></pre><p>​        可以等效成blur，就是选择更多了而已。如果不进行归一化，就是停在255，所以图像会很白。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Filt1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>boxFilter<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>normalize<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>Filt2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>boxFilter<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>normalize<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Filt1"</span><span class="token punctuation">,</span>Filt1<span class="token punctuation">)</span><span class="token punctuation">;</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Filt2"</span><span class="token punctuation">,</span>Filt2<span class="token punctuation">)</span><span class="token punctuation">;</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Filt1.png"</span><span class="token punctuation">,</span>Filt1<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Filt2.png"</span><span class="token punctuation">,</span>Filt2<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Filt1： 归一化</p><p><img src="Filt1.png" alt="Filt1"></p><p>Filt2: 摆烂</p><p><img src="Filt2.png" alt="Filt2"></p><h4 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h4><p>​        这个改进了平均算法，就是利用空间距离远近来作为计算权重：近的权重大，反之权重小。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Gaussain<span class="token operator">=</span>cv2<span class="token punctuation">.</span>GaussianBlur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Gaussain"</span><span class="token punctuation">,</span>Gaussain<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Gaussain.png"</span><span class="token punctuation">,</span>Gaussain<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="Gaussain.png" alt="Gaussain"></p><h5 id="关于高斯滤波及其算法的扩展"><a href="#关于高斯滤波及其算法的扩展" class="headerlink" title="关于高斯滤波及其算法的扩展"></a>关于高斯滤波及其算法的扩展</h5><p>材料来源：<a href="https://blog.csdn.net/LYSSLQ2015/article/details/125110610">(46条消息) opencv———-高斯滤波_opencv高斯滤波_LYSSLQ2015的博客-CSDN博客</a>！</p><p>​        高斯滤波(Gauss Filter)是<strong>线性滤波</strong>中的一种。在OpenCV图像滤波处理中，高斯滤波用于<strong>平滑图像</strong>，或者说是图像模糊处理，因此高斯滤波是低通的。其广泛的应用在图像处理的减噪过程中，尤其是被高斯噪声所污染的图像上。高斯滤波的基本思想是: 图像上的每一个像素点的值，都由其本身和邻域内其他像素点的值经过加权平均后得到。其具体操作是，用一个核(又称为卷积核、掩模、矩阵)扫描图像中每一个像素点，将邻域内各个像素值与对应位置的权值相称并求和。从数学的角度来看，高斯滤波的过程是图像与高斯正态分布做卷积操作。<br>​        注意: 高斯滤波是将二维高斯正态分布放在图像矩阵上做卷积运算。考虑的是邻域内像素值的空间距离关系，因此对彩色图像处理时应分通道进行操作，也就是说操作的图像原矩阵时用单通道数据，最后合并为彩色图像。</p><p>一、几个概念</p><ol><li><p>什么是<a href="https://so.csdn.net/so/search?q=低通滤波&amp;spm=1001.2101.3001.7020">低通滤波</a>、平滑图像、图像模糊处理？<br>平滑图像与图像模糊处理是相同的含义。平滑处理即是通过操作后，使得图像的像素值与邻域内其他像素值的的变化程度减小。在一张图像上，边缘的像素值是变化程度最剧烈的地方，而其他相对平缓。因此，平滑图像最直观的表现是图像的上物体的边缘轮廓变得模糊。<strong>低通滤波是指仅允许低频率信号通过。一张图像上的大部分能量聚集在低频和中频上，而高频大多是图像中物体的边缘部分，也有可能是高频噪声点。在单通道中，各像素点的取值都在(0~255)中，因此，低通滤波通过一定的阙值设置，有去除高频信号和平缓边缘的效果。</strong></p></li><li><p>什么是核(又称为卷积核、掩模、矩阵)？<br><strong>核的本质其实就是一个大小固定、由数值参数组成的数学矩阵，例如一个3<em>3的核就是一个3</em>3的矩阵,而矩阵中的数据则为权值。</strong></p></li><li><p>什么是卷积运算？<br>卷积运算是指输入图像中某一像素点的邻域的各个值（包括该点）与卷积算子中的值做矩阵相乘运算，最后得到输出值。<br>卷积算子的公式:</p><script type="math/tex; mode=display">g=f*h</script><script type="math/tex; mode=display">g(i,j)=\sum_{k,l}f(i-k,j-l)h(k,l)=\sum_{k,l}f(k,l)h(i-k,j-l)</script></li></ol><p>g(i，j) 代表原图像矩阵上的(i，j)点的值，它是输出值。<br>f(i-k，j-l) 代表原图像矩阵上(i，j)点的邻域中的对应点的值。<br>h(k,，l) 代表与f(i-k ， j-l)这个值在核对应位置的点的值<br><strong>请看下图：这里用的是f(i-k,j-l)h(k,l)</strong></p><p><img src="SouthEast.png" alt="这里写图片描述"></p><p>由上图我们看到，矩阵f是将要进行操作的图像矩阵，当前的(i，j)是(2，2)点。h为核，其以中心(0，0)为参考点。因此f矩阵对应范围即为f(2，2)的邻域。矩阵g为图像输出矩阵，g(2，2)的值为输出值。<br>注意：卷积算子和相关算子在核上是180度翻转的矩阵，请不要搞混</p><p>4.核(卷积核、掩模、矩阵等)<br>在3的卷积运算中，用到的公式是：<br>g(i, j) = ∑ f(i-k, j-l)h(k, l) 。其中 k，l代表核上的坐标。而核的坐标明显与数组下标不一致。因此，我们需要做一个转换以满足用数组下标来访问该核的数据。<br>假设有3<em>3数组a，它与核的对应关系为<br>a(0, 0) ===&gt; h(-1, -1) a(0, 1) ===&gt; h(-1, 0) a(0, 2) ===&gt; h(-1, 1)<br>a(1, 0) ===&gt; h(0, -1) a(1, 1) ===&gt; h(0, 0) a(1, 2) ===&gt; h(0, 1)<br>a(2, 0) ===&gt; h(1, -1) a(2, 1) ===&gt; h(1, 0) a(2, 2) ===&gt; h(1, 1)<br>对于3</em>3数组，其下标是0开始的，假设该数组的参考点(ai, aj)为中心,则有<br>g(i, j) = ∑ f(i-(k-ai), j-(l-aj))h(k, l)<br>带入数组参考点(1, 1)，则有<br>g(i, j) = ∑ f(i-(k-1), j-(l-1))h(k, l)<br>此时，k，l可以从0开始取值<br><img src="SouthEast2.png" alt="这里写图片描述"></p><p> <strong>5.图像通道分离与合并(cv::Mat)</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; src 原图像，多通道&#x2F;&#x2F; [1] 彩色图片通道分离std::vector&lt;cv::Mat&gt; channels;cv::split(&amp;src, channels);&#x2F;&#x2F; [3] 滤波&#x2F;&#x2F; OpenCV中操作&#x2F;&#x2F; channels[0]  &#x3D;&#x3D;&gt;  B通道&#x2F;&#x2F; channels[1]  &#x3D;&#x3D;&gt;  G通道&#x2F;&#x2F; channels[2]  &#x3D;&#x3D;&gt;  R通道&#x2F;&#x2F; 省略对各个通道的处理&#x2F;&#x2F; [4] 合并返回cv::merge(channels, *dst);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二、高斯函数"><a href="#二、高斯函数" class="headerlink" title="二、高斯函数"></a>二、高斯函数</h4><p>高斯滤波，顾名思义，这是一个建立在高斯正态分布基础上的滤波器。首先我们来了解高斯函数。(图片来源于网络)<br>一维高斯函数：<br>可以看到，G(x)的跟<a href="https://so.csdn.net/so/search?q=sigma&amp;spm=1001.2101.3001.7020">sigma</a>的取值有极大的关系。sigma取值越大，图像越平缓，sigma取值越小，图像越尖锐。</p><p><img src="SouthEast10.png" alt="这里写图片描述"><br><img src="SouthEast3.png" alt="这里写图片描述"></p><p>二维高斯函数：<br>二维高斯是构建高斯滤波器的基础。可以看到，G(x,y)在x轴y轴上的分布是一个突起的帽子的形状。这里的sigma可以看作两个值，一个是x轴上的分量sigmaX，另一个是y轴上的分量sigmaY。对图像处理可以直接使用sigma并对图像的行列操作，也可以用sigmaX对图像的行操作，再用sigmaY对图像的列操作。它们是等价的。<br>当sigmaX和sigmaY取值越大，整个形状趋近于扁平；当sigmaX和sigmaY取值越小，整个形状越突起。<br><img src="SouthEast4.png" alt="这里写图片描述"></p><p>高斯滤波原理就是将上图的二维正态分布应用在二维的矩阵上，G(x,y)的值就是矩阵上的权值，将得到的权值进行<a href="https://so.csdn.net/so/search?q=归一化&amp;spm=1001.2101.3001.7020">归一化</a>，将权值的范围约束在[0,1]之间，并且所有的值的总和为1。<br>假设一个3*3的核，sigma取值1.5以及sigma取5.0，归一化后其权值分布分别是：</p><p><img src="SouthEast5.png" alt="这里写图片描述"></p><p>假设一个5*5的核，sigma取值1.5以及sigma取5.0，经归一化后其权值分布分别是：<br><img src="SouthEast6.png" alt="这里写图片描述"><br><img src="SouthEast7.png" alt="这里写图片描述"></p><p>可以看到，权值的分布是以中间高四周低来分布的。并且距离中心越远，其对中心点的影响就越小，权值也就越小。<br>因此可以总结：<br>（1）在核大小固定的情况下，sigma值越大，权值分布越平缓。因此，邻域各个点的值对输出值的影响越大，最终结果造成图像越模糊。<br>（2）在核大小固定的情况下，sigma值越小，权值分布越突起。因此，邻域各个点的值对输出值的影响越小，图像变化也越小。假如中心点权值为1，其他点权值为0，那么最终结果是图像没有任何变化。<br>（3）sigma固定时，核越大图像越模糊。<br>（4）sigma固定时，核越小图像变化越小。</p><p>三、高斯滤波器实现<br>首先看效果：<br>对于椒盐图作处理</p><p><img src="SouthEast8.png" alt="这里写图片描述"></p><p>对于高斯噪声图作处理<br><img src="SouthEast9.png" alt="这里写图片描述"></p><p>（1）main函数：读取图片 ==&gt; 高斯滤波 ==&gt; 结果显示</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// [1] src读入图片</span>    cv<span class="token double-colon punctuation">::</span>Mat src <span class="token operator">=</span> cv<span class="token double-colon punctuation">::</span><span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"Median_pic.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// [2] dst目标图片</span>    cv<span class="token double-colon punctuation">::</span>Mat dst<span class="token punctuation">;</span>    <span class="token comment">// [3] 高斯滤波  sigma越大越平越模糊</span>    <span class="token function">myGaussianFilter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>src<span class="token punctuation">,</span> <span class="token operator">&amp;</span>dst<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// [4] 窗体显示</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"src"</span><span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"dst"</span><span class="token punctuation">,</span> dst<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">destroyAllWindows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）彩色图像通道分离处理，每个通道都进行高斯滤波，最后合并</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void myGaussianFilter(cv::Mat *src, cv::Mat *dst, int n, double sigma)&#123;    &#x2F;&#x2F; [1] 初始化    *dst &#x3D; (*src).clone();    &#x2F;&#x2F; [2] 彩色图片通道分离    std::vector&lt;cv::Mat&gt; channels;    cv::split(*src, channels);    &#x2F;&#x2F; [3] 滤波    &#x2F;&#x2F; [3-1] 确定高斯正态矩阵    double **array &#x3D; getGaussianArray(n, sigma);    &#x2F;&#x2F; [3-2] 高斯滤波处理    for (int i &#x3D; 0; i &lt; 3; i++) &#123;        gaussian(&amp;channels[i], array, n);    &#125;    &#x2F;&#x2F; [4] 合并返回    cv::merge(channels, *dst);    return ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）生成高斯正态分布核(<a href="https://so.csdn.net/so/search?q=卷积核&amp;spm=1001.2101.3001.7020">卷积核</a>，掩模等)</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;* 获取高斯分布数组               (核大小， sigma值) *&#x2F;double **getGaussianArray(int arr_size, double sigma)&#123;    int i, j;    &#x2F;&#x2F; [1] 初始化权值数组    double **array &#x3D; new double*[arr_size];    for (i &#x3D; 0; i &lt; arr_size; i++) &#123;        array[i] &#x3D; new double[arr_size];    &#125;    &#x2F;&#x2F; [2] 高斯分布计算    int center_i, center_j;    center_i &#x3D; center_j &#x3D; arr_size &#x2F; 2;    double pi &#x3D; 3.141592653589793;    double sum &#x3D; 0.0f;    &#x2F;&#x2F; [2-1] 高斯函数    for (i &#x3D; 0; i &lt; arr_size; i++ ) &#123;        for (j &#x3D; 0; j &lt; arr_size; j++) &#123;            array[i][j] &#x3D;                 &#x2F;&#x2F;后面进行归一化，这部分可以不用                &#x2F;&#x2F;0.5f *pi*(sigma*sigma) *                 exp( -(1.0f)* ( ((i-center_i)*(i-center_i)+(j-center_j)*(j-center_j))&#x2F; (2.0f*sigma*sigma) ));                                    sum +&#x3D; array[i][j];        &#125;    &#125;    &#x2F;&#x2F; [2-2] 归一化求权值    for (i &#x3D; 0; i &lt; arr_size; i++) &#123;        for (j &#x3D; 0; j &lt; arr_size; j++) &#123;            array[i][j] &#x2F;&#x3D; sum;            printf(&quot; [%.15f] &quot;, array[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return array;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）进行高斯滤波操作</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;* 高斯滤波 (待处理单通道图片, 高斯分布数组， 高斯数组大小(核大小) ) *&#x2F;void gaussian(cv::Mat *_src, double **_array, int _size)&#123;    cv::Mat temp &#x3D; (*_src).clone();    &#x2F;&#x2F; [1] 扫描    for (int i &#x3D; 0; i &lt; (*_src).rows; i++) &#123;        for (int j &#x3D; 0; j &lt; (*_src).cols; j++) &#123;            &#x2F;&#x2F; [2] 忽略边缘            if (i &gt; (_size &#x2F; 2) - 1 &amp;&amp; j &gt; (_size &#x2F; 2) - 1 &amp;&amp;                i &lt; (*_src).rows - (_size &#x2F; 2) &amp;&amp; j &lt; (*_src).cols - (_size &#x2F; 2)) &#123;                &#x2F;&#x2F; [3] 找到图像输入点f(i,j),以输入点为中心与核中心对齐                &#x2F;&#x2F;     核心为中心参考点 卷积算子&#x3D;&gt;高斯矩阵180度转向计算                &#x2F;&#x2F;     x y 代表卷积核的权值坐标   i j 代表图像输入点坐标                &#x2F;&#x2F;     卷积算子     (f*g)(i,j) &#x3D; f(i-k,j-l)g(k,l)          f代表图像输入 g代表核                &#x2F;&#x2F;     带入核参考点 (f*g)(i,j) &#x3D; f(i-(k-ai), j-(l-aj))g(k,l)   ai,aj 核参考点                &#x2F;&#x2F;     加权求和  注意：核的坐标以左上0,0起点                double sum &#x3D; 0.0;                for (int k &#x3D; 0; k &lt; _size; k++) &#123;                    for (int l &#x3D; 0; l &lt; _size; l++) &#123;                        sum +&#x3D; (*_src).ptr&lt;uchar&gt;(i-k+(_size&#x2F;2))[j-l+(_size&#x2F;2)] * _array[k][l];                    &#125;                &#125;                &#x2F;&#x2F; 放入中间结果,计算所得的值与没有计算的值不能混用                temp.ptr&lt;uchar&gt;(i)[j] &#x3D; sum;            &#125;        &#125;    &#125;    &#x2F;&#x2F; 放入原图    （*_src） &#x3D; temp.clone();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><p>​        什么是中值？就是排序取中间的中位数。那就直接把目标像素点直接换成中位数跑路！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">median<span class="token operator">=</span>cv2<span class="token punctuation">.</span>medianBlur<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"median"</span><span class="token punctuation">,</span>median<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"median.png"</span><span class="token punctuation">,</span>median<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <img src="median.png" alt="median"></p><p>​        可以看到效果很好。令人满意。</p><h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><pre><code>    一、概述    使用中值滤波器模糊图像。    该函数使用具有 ksize×ksize 孔径的中值滤波器对图像进行平滑处理。 多通道图像的每个通道都是独立处理的。    中值滤波器在内部使用 BORDER_REPLICATE 来处理边界像素，请参阅 BorderTypes。    下图描述了一个ksize=3×3的滑动窗口（或称滤波器模板、kernel），如黄色部分所示。用这个ksize=3×3的窗口作用于原始图像上的每一个像素，如下图的绿色部分所示，被这个窗口覆盖的9个像素点都参与计算，这样在该像素点上就会得到一个新的像素值，当窗口沿着图像逐个像素进行计算，就会得到一幅新的图像。</code></pre><p><img src="https://img-blog.csdnimg.cn/9f8842b4f8da4836a54e1b6a66ab13fa.png" alt="img"></p><pre><code>     上图中滤波器模板的不同就构成了滤波算法的差异，比如均值平滑算法中滑动窗口中各个像素点的系数均为1/(窗口高*窗口宽)，高斯平滑中系数和中心点的距离满足高斯分布。    中值平滑和均值平滑一样也用到了滑动窗口，但是它并不是计算滑动窗口中的某种加权和，而是使用原图像滑动窗口中所有像素值排序后的中值作为新图像的像素值。    从上图也可以看到，当滑动窗口作用于图像边沿的时候，滑动窗口的某些像素并没有和图像重合，这时就需要对边沿做特殊处理，常用的方法有填0、填1、复制边沿等方式。</code></pre><p>二、medianBlur函数<br>1、函数原型<br>cv::medianBlur (InputArray src, OutputArray dst, int ksize)<br>2、参数详解<br>src    ：输入 1、3 或 4 通道图像； ksize 为 3 或 5 时，图像深度应为 CV_8U、CV_16U 或 CV_32F，对于较大的光圈尺寸，只能为 CV_8U。</p><p>dst    ：与 src 大小和类型相同的目标数组。</p><p>ksize    ：孔径线性尺寸； 它必须是奇数且大于 1，例如：3、5、7 …<br>三、OpenCV源码<br>1、源码路径</p><pre class="line-numbers language-none"><code class="language-none">opencv\modules\imgproc\src\median_blur.dispatch.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、源码代码</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void medianBlur( InputArray _src0, OutputArray _dst, int ksize )&#123;    CV_INSTRUMENT_REGION();CV_Assert(!_src0.empty()); CV_Assert( (ksize % 2 &#x3D;&#x3D; 1) &amp;&amp; (_src0.dims() &lt;&#x3D; 2 )); if( ksize &lt;&#x3D; 1 || _src0.empty() )&#123;   _src0.copyTo(_dst);    return;&#125; CV_OCL_RUN(_dst.isUMat(),         ocl_medianFilter(_src0,_dst, ksize)         ) Mat src0 &#x3D; _src0.getMat();_dst.create( src0.size(), src0.type() );Mat dst &#x3D; _dst.getMat(); CALL_HAL(medianBlur, cv_hal_medianBlur, src0.data, src0.step, dst.data, dst.step, src0.cols, src0.rows, src0.depth(),    src0.channels(), ksize    ); CV_OVX_RUN(true,           openvx_medianFilter(_src0, _dst, ksize)) &#x2F;&#x2F;CV_IPP_RUN_FAST(ipp_medianFilter(src0, dst, ksize)); CV_CPU_DISPATCH(medianBlur, (src0, dst, ksize),    CV_CPU_DISPATCH_MODES_ALL    );&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>四、效果图像示例</p><p>原图：</p><p><img src="https://img-blog.csdnimg.cn/7a3c9fa7cb44463cb9c29ea0e1def515.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/9d19f5513c46421094abc1e260e2352d.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/9173c63503904f4eb03c876c4048cfa1.png" alt="img"></p><p>版权声明：本才来哦为CSDN博主「坐望云起」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/bashendixie5/article/details/125255049">https://blog.csdn.net/bashendixie5/article/details/125255049</a></p><h3 id="图像拼接"><a href="#图像拼接" class="headerlink" title="图像拼接"></a>图像拼接</h3><p>​        现在我们使用Numpy的hstack方法拼接一下图片：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res<span class="token operator">=</span>np<span class="token punctuation">.</span>hstack<span class="token punctuation">(</span><span class="token punctuation">(</span>blur33<span class="token punctuation">,</span>Gaussain<span class="token punctuation">,</span>median<span class="token punctuation">)</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Compare!"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">"Compare.png"</span><span class="token punctuation">,</span>res<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="Compare.png" alt="Compare"></p><p>​        起到对比效果（显然不是那么好。。。）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（3）</title>
      <link href="/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%883%EF%BC%89/"/>
      <url>/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学教程（8）不定积分"><a href="#高等数学教程（8）不定积分" class="headerlink" title="高等数学教程（8）不定积分"></a>高等数学教程（8）不定积分</h1><p>​        这一章内容通俗的说：就是求导的反向操作：我们需要求出谁求导的到现在的东西</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​        假设一个函数$f(x)$是一个函数$F(x)$求导的结果，那么称$F(x)$是$f(x)$的一个愿函数</p><p>这是因为$F(x)+C$(C是一个常数)求导也是$f(x)$</p><p>​        原函数存在定理：<strong>连续的函数一定有原函数</strong></p><p>​        说了这么多，我们又该怎么表示一个函数的原函数呢</p><script type="math/tex; mode=display">\int f(x)dx=F(x)+C</script><p>​        比如说：$\int x^2dx=\frac{x^3}{3}+C$</p><p>​        但是注意：这个容易错：$\int \frac{1}{x}dx=\ln{|x|}+C$</p><p>​        因为（x&lt;0）下$\ln{x}$无定义，可以把$\frac{-1}{-x}$看，这样就好了。</p><p>​        下面来看一些式子：</p><script type="math/tex; mode=display">\frac{d}{dx}[\int f(x)dx]=f(x)</script><script type="math/tex; mode=display">d[\int f(x)dx]=f(x)dx</script><p>​        说明了积分号在内微分号在外的式子，没有常数C（本质是$df(x)=f’(x)dx$）</p><p>​        </p><script type="math/tex; mode=display">\int F'(x)dx=F(x)+C</script><p>​        说明了积分号在外微分号在内的式子，有常数C（本质是$\int f(x)dx=F(x)+C$）</p><h3 id="积分表"><a href="#积分表" class="headerlink" title="积分表"></a>积分表</h3><p>​        幂函数的积分</p><script type="math/tex; mode=display">\int x^\mu dx=\frac{x^{\mu+1}}{\mu+1}+C</script><p>​        常数的不定积分：</p><script type="math/tex; mode=display">\int kdx=kx+C</script><p>​        </p><script type="math/tex; mode=display">\int \frac{dx}{1+x^2}dx=\arctan{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\sqrt {1-x^2}}dx=\arcsin{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\cos^2{x}}=\int \sec^2{x}=\tan{x}+C</script><script type="math/tex; mode=display">\int \frac{dx}{\sin^2{x}}=\int \csc^2{x}=-\cot{x}+C</script><script type="math/tex; mode=display">\int \sec{x}\tan xdx=\sec{x}+C</script><script type="math/tex; mode=display">\int \csc{x}\cot{x}dx=-\csc{x}+C</script><script type="math/tex; mode=display">\int \frac{1}{x}dx=\ln |x|+C</script><script type="math/tex; mode=display">\int \cos{x}dx=\sin{x}+C</script><script type="math/tex; mode=display">\int \sin{x}dx=-\cos{x}+C</script><script type="math/tex; mode=display">\int e^xdx=e^x+C</script><script type="math/tex; mode=display">\int a^xdx=\frac{a^x}{\ln{a}}+C</script><h3 id="不定积分的性质"><a href="#不定积分的性质" class="headerlink" title="不定积分的性质"></a>不定积分的性质</h3><p>​        1）$\int [f(x)\pm g(x)]dx=\int f(x)dx \pm \int g(x)dx$</p><p>​        2)$\int kf(x)dx=k\int f(x)dx$</p><h3 id="第一类换元积分（凑微分法）"><a href="#第一类换元积分（凑微分法）" class="headerlink" title="第一类换元积分（凑微分法）"></a>第一类换元积分（凑微分法）</h3><p>​        首先回到这里：$\int 1 dF(u)=F(u)+C$,现在假设$u=\varphi (x)$,这样，我们就有$\int 1dF(\varphi(x))=F(\varphi(x))+C$,进一步的：$\int f(\varphi(x))\varphi ‘(x)dx=F(\varphi(x))+C$</p><p>说白了，就是复合求导的逆过程，我们的核心过程就是通过合并至d后面从而化简函数：</p><p>1）$\int 2\cos 2xdx$</p><p>解：$\int \cos 2xd(2x)=sin(2x)+C$</p><p>2)$\int \frac{1}{3+2x}dx$</p><p>解：$\int \frac{1}{2}\frac{1}{3+2x}d(2x+3)=\frac{1}{2}\ln|(2x+3)|+C$</p><p>3)$\int 2x e^{x^2}dx$</p><p>解：$\int  e^{x^2}dx^2= e^{x^2}+C$</p><p>4)$\int x\sqrt{1-x^2}dx$</p><p>解：$-\frac{1}{2}\int \sqrt{1-x^2}d(1-x^2)=-\frac{1}{3}(1-x^2)^{1.5}+C$</p><p>5)$\int \frac{x^2}{(x+2)^3}dx$</p><p>解:</p><p>$令:x+2=u$,$\int \frac{(u-2)^2}{u^3}du=\int (\frac{1}{u}-\frac{4}{u^2}+\frac{4}{u^3})du=\ln |u|+\frac{4}{u}-2\frac{1}{u^2}$</p><p>于是:$\ln |x+2|+\frac{4}{x+2}-2\frac{1}{(x+2)^2}$</p><p>6)$\int \frac{1}{a^2+x^2}dx(a\neq 0)$</p><p>解：$=\frac{1}{a}\int \frac{1}{1+(\frac{x}{a})^2}d(\frac{x}{a})=\frac{1}{a}\arctan \frac{x}{a}+C$</p><p>7)$\int \frac{dx}{\sqrt{a^2-x^2}}$</p><p>解：$\frac{1}{a}\int \frac{dx}{\sqrt{1-(\frac{x}{a})^2}}=\arcsin \frac{x}{a}+C$</p><p>8)$\int \frac{dx}{x^2-a^2}$</p><p>解：$\frac{1}{2a}\int (\frac{1}{x-a}-\frac{1}{x+a})dx=\frac{1}{2a}\ln|\frac{x-a}{x+a}|+C$</p><p>9)$\int \frac{dx}{x(1+2\ln x)}$</p><p>解：$\int \frac{d\ln{x}}{1+2\ln x}=\frac{1}{2}\ln|1+2\ln x|+C$</p><p>10）$\int \frac{e^{3\sqrt{x}}}{\sqrt{x}}dx$</p><p>解：$=2\int e^{3\sqrt{x}}d{\sqrt{x}}=\frac{2}{3}e^{3\sqrt{x}}+C$</p><p>11)$\int \sin^3xdx$</p><p>解：$\int sin^2xd\cos x=\int (1-cos^2x)d\cos x=-\cos x-\frac{1}{3}\cos^3x+C$</p><p>12)$\int \sin^2x\cos^5xdx$</p><p>解：$\int \sin^2\cos^4xd\sin x=\int \sin^2x(1-\sin^2x)^2d\sin x=\frac{\sin^3x}{3}-\frac{2\sin^5x}{5}+\frac{\sin^7x}{7}+C$</p><p>13)$\int \tan xdx$</p><p>解：</p><p>$\int \frac{\sin x}{\cos x}dx=-\int \frac{1}{\cos x}d\cos x=-\ln|cos(x)|+C$</p><p>14)$\int \cos^2xdx$</p><p>解：$\int \frac{1+\cos2x}{2}dx=\frac{x}{2}+\frac{\sin 2x}{4}+C$</p><p>15)$\int \sin^2x\cos^4xdx$</p><p>解：$\int \frac{1-\cos{2x}}{2}(\frac{1+\cos{2x}}{2})^2dx=\frac{1}{8}(x+\frac{1}{2}\sin 2x-\frac{1}{2}x-\frac{1}{8}\sin 4x-\frac{1}{2}(\sin 2x-\frac{sin^3 2x}{3}))+C$</p><p>16)$\int \sec^6xdx$</p><p>解：$\int \sec^4xd\tan x=\int (\tan^2x+1)^2d\tan x=\frac{\tan^5x}{5}+\frac{2\tan^3x}{3}+\tan x+C$</p><p>17)$\int \csc xdx$</p><p>解：$\int \frac{1}{\sin x}dx=\frac{\cos \frac{x}{2}dx}{2\sin \frac{x}{2}\cos^2\frac{x}{2}}=\int \frac{\sec^2\frac{x}{2}}{\tan\frac{x}{2}}d(\frac{x}{2})=\int \frac{d\tan\frac{x}{2}}{\tan \frac{x}{2}}=\ln|\tan \frac{x}{2}|+C$</p><p>总结下：三角函数者：奇次提，偶次被倍角公式替换</p><h3 id="第二类换元积分"><a href="#第二类换元积分" class="headerlink" title="第二类换元积分"></a>第二类换元积分</h3><p>​        我们把d()内的东西往外提，化而言之：就是换元$x=\varphi(t)$再求积分：</p><p>$\int f(x)dx=\int f(\varphi(t))\varphi’(t)dt$</p><p>1)$\int \sqrt{a^2-x^2}dx(a&gt;0)$</p><p>解:令：$x=a\sin t,t\in(-\frac{\pi}{2},\frac{\pi}{2})$</p><p>故：$\int \sqrt{a^2-x^2}dx=a\cos tdx$</p><p>$dx=a\cos t$</p><p>因此：$\int a^2\cos^2tdt=a^2(\frac{t}{2}+\frac{\sin2t}{4})+C=a^2t+a^2\frac{\sin t\cos t}{2}+C$</p><p>又$\sin t=\frac{x}{a},\cos t=\frac{\sqrt{a^2-x^2}}{a}$</p><p>这样：$\frac{a^2}{2}\arcsin\frac{x}{a}+\frac{x}{2}\sqrt{a^2-x^2}+C$</p><p>2)$\int \frac{dx}{\sqrt{x^2+a^2}}(a&gt;0)$</p><p>现令：$x=a\tan t$</p><p>则：$\int \frac{dx}{a\sec x}$</p><p>又：$dx=a\sec^2 tdt$</p><p>那么：$\int \sec tdt=\ln|\sec t+\tan t|+C$</p><p>我们可以使用三角形法来看：</p><p><img src="image-20230120122352772.png" alt="image-20230120122352772"></p><p>这下，我们找到了：$\tan t=\frac{x}{a},\sec t= \frac{\sqrt{x^2+a^2}}{a}$</p><p>于是：$=\ln|\frac{\sqrt{x^2+a^2}}{a}+\frac{x}{a}|+C=\ln(\sqrt{x^2+a^2}+x)+C’$</p><p>3)$\int \frac{dx}{\sqrt{x^2-a^2}}$</p><p>解：</p><p>令：$x=a\sec t,则：\int \frac{dx}{a\tan t}$</p><p>$dx=a\sec t\tan tdt$</p><p>于是：$\int \sec tdt=\ln(x+\sqrt{x^2-a^2})+C$</p><p><strong>小总结：</strong></p><p>$\sqrt{a^2-x^2}\longrightarrow x=a\sin t,|a\cos t|$</p><p><strong>$\sqrt{x^2-a^2}\longrightarrow x=a\sec t,|a\tan t|$</strong></p><p>$\sqrt{a^2+x^2}\longrightarrow x=a\tan t,|a\sec t|$</p><p>4)$\int \frac{\sqrt{a^2-x^2}}{x^4}dx$</p><p>解：令：$x=\frac{1}{t}$得：</p><p>$dx=-\frac{1}{t^2}dt,-\int (a^2t^2-1)^{0.5}|t|dt$</p><p>由此：$x&gt;0下 ,=-\frac{(a^2-x^2)^{1.5}}{2a^2x^3}+C$</p><p>或者使用三角函数也可以：</p><p><img src="image-20230120124326362.png" alt="image-20230120124326362"></p><h3 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h3><p>​        我们来看：$\int udv=uv-\int vdu$</p><p>我们就可以化简积分了：如：</p><p>1)$\int xe^xdx=\int xde^x=xe^x-e^x=(x-1)e^x+C$</p><p>有的时候，我们可以尝试的去试试看谁做微分是简单的</p><p>往往$e^x$要放到微分里。</p><p>2)$\int x\cos xdx=\int xd\sin x=x\sin x-\int \sin xdx=x\sin x+\cos x+C$</p><p>往往三角函数要放到微分里。</p><p>那这样呢：</p><p>$\int \sin x e^xdx$</p><p>注意：$=\sin xe^x-\int e^x\cos xdx=\sin x e^x-\cos xe^x-\int \sin x e^xdx$</p><p>居然出现了我们要求的东西：</p><p>于是：$\int \sin x e^xdx=\frac{1}{2}(\sin x e^x-\cos xe^x)$</p><p>3)$\int \arccos xdx=x\arccos x-\frac{1}{2}\int \frac{d(1-x^2)}{\sqrt{1-x^2}}=x\arccos x-\sqrt{1-x^2}+C$</p><h3 id="有理函数"><a href="#有理函数" class="headerlink" title="有理函数"></a>有理函数</h3><p>​        这是针对$\frac{P(x)}{Q(x)}$的有理分式的积分方法：我们主要是添项拆项从而分离成若干简单分式的和差，从而方便我们的积分</p><p>1）P(x)的阶高于Q(x)</p><p>​        我们分离常数使之所有的子分式的分母阶比分子高：</p><p>2）P(x)的阶低于Q(x)</p><p>i.分母一阶的，直接$\ln$</p><p>ii.分母二阶的：</p><p>可以因式分解的：分解因式化简</p><p>不可以因式分解的：配方后变成$(ax+b)^2+C$的$\arctan$类型积分</p><p><img src="image-20230120130430538.png" alt="image-20230120130430538"></p><p>iii.分子分母差一次、</p><p>把分子扔进d里面升次</p><p><img src="image-20230120130642841.png" alt="image-20230120130642841"></p><p>iv.一般的</p><p>我们假设一个式子可以分解成若干的分式和，其分式的特点是：分子比分母底一阶，分子假设为全项的多项式：</p><p>如</p><p><img src="image-20230120130943140.png" alt="image-20230120130943140"></p><p>根式：</p><p>令t为根式，换元即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（2）</title>
      <link href="/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/"/>
      <url>/2023/01/31/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学基础教程：导数的定义与使用"><a href="#高等数学基础教程：导数的定义与使用" class="headerlink" title="高等数学基础教程：导数的定义与使用"></a>高等数学基础教程：导数的定义与使用</h1><h2 id="一-基本定义和性质"><a href="#一-基本定义和性质" class="headerlink" title="一.基本定义和性质"></a>一.基本定义和性质</h2><h3 id="导数的定义"><a href="#导数的定义" class="headerlink" title="导数的定义"></a>导数的定义</h3><p>​        恭喜！你来到了导数这一章！现在，我们可以使用它来更精确的描述函数是怎么增长变动的！！！</p><p>​        首先，引入一个场景：讨论速度与位移，并且我们都用时间来表示：</p><p>那么，一个平均速度可以用如下这个式子来表达：$v=\frac{f(t)-f(t_0)}{t-t_0}$</p><p>​        这是我们中学就已经熟知的。</p><p>​        现在，让我们让$t\rightarrow{t_0}$ 也就是让t逼近$t_0$。这样，回到高中物理，我们就知道我们得到了瞬时速度。</p><p>​        其实，很多函数变化，都可以类比的使用这种办法得到函数在一个点的变化情况，下面，让我们统一一下，使用一个定义来综述：</p><p>$定义 y=f(x)在x_0的领域内有定义，对x_0取增量\Delta{x}，那么函数的增量就是\Delta{y}=f(x_0+\Delta{x})-f(x_0)，如果\lim\limits_{\Delta{x}\rightarrow{0}}\frac{\Delta{y}}{\Delta{x}}=\lim\limits_{\Delta{x}\rightarrow{0}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}$ $是存在的，我们就称呼y=f(x)在x_0处可导，且这个极限值就是y=f(x)在x_0处的导数$</p><p>​        记作$y’| _{x=x_0},f’(x_0),\frac{dy}{dx}|_{x=x_0}，\frac{df(x)}{dx}|_{x=x_0}$上面四个选一个</p><p>当然，导数还有另一个定义：就是</p><p>​      $如果\lim\limits_{x\rightarrow{x_0}}\frac{\Delta{y}}{\Delta{x}}=\lim\limits_{x\rightarrow{x_0}}\frac{f(x)-f(x_0)}{x-x_0}是存在的，我们就称呼y=f(x)在x_0处可导，且这个极限值就是y=f(x)在x_0处的导数$ </p><p>​        如果函数在一个区间内处处可导，我们就可以再用一个函数刻画导数：导函数$f’(x)$</p><p>​        下面来看一些函数的导（函）数（方便起见使用h代替$\Delta{x}$）</p><p>（1）$f(x)=C$</p><p>则：$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=0$</p><p>故$C’=0$</p><p>(2)$f(x)=x^n$</p><p>1.当n=1时:$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=1$</p><p>2.当n&gt;1时：$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=\lim\limits_{h\rightarrow{0}}\frac{(x+h)^n-x^n}{h}$</p><p>而：$(x+y)^n=x^n+nx^{n-1}y+\frac{n(n-1)}{2}x^{n-2}y^{2}+…+ny^{n-1}x+y^n$</p><p>于是$极限=\lim\limits_{h\rightarrow{0}}nx^{n-1}+(…)\times{h}=nx^{n-1}$</p><p>3.当$f(x)=x^{\mu},\mu\in{R}，(x\neq{0})$</p><p>于是：</p><p><img src="image-20221230201314473.png" alt="image-20221230201314473"></p><p>$(x^\mu)’=\mu{x^{\mu-1}}$</p><p>4.$f(x)=\sin{x}$</p><p>$\lim\limits_{h\rightarrow{0}}\frac{f(x+h)-f(x)}{h}=\lim\limits_{h\rightarrow{0}}\frac{\sin{(x+h)}-\sin{x}}{h}=\lim\limits_{h\rightarrow{0}}\frac{\cos(x+\frac{h}{2})\times{\sin{\frac{h}{2}}}}{\frac{h}{2}}=\cos{x}$</p><p>所以：$\sin’{x}=\cos{x}$</p><p>类似的$\cos’{x}=-\sin{x}$</p><p>5.$(a^x)’=a^x\ln{a},特别的(e^x)’=e^x$</p><p>6.$\log’_{a}{x}=\frac{1}{x\ln{a}},特别的\ln’x=\frac{1}{x}$</p><h3 id="单侧导数"><a href="#单侧导数" class="headerlink" title="单侧导数"></a>单侧导数</h3><p>​        导数也有单侧导数的这一概念，直观的讲，正是导数以不同的方式逼近一个点所产生的：</p><p>​        回忆我们先前的类似概念，左侧导数的定义是这样的：</p><p>​        </p><script type="math/tex; mode=display">f'_{-}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^-} }\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        更容易理解的：右导数的定义是这样的：</p><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^+}}\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        当然，也有第二定义</p><p>​        左导数：</p>$$f'_{-}(x_0)=\lim \limits_{ { x } \rightarrow{x_0^-} } \frac{f(x_0+h)-f(x_0)} {h}$$<p>​        右导数：</p><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{ { x} \rightarrow{x_0^+} }\frac{f(x_0+h)-f(x_0)}{h}</script><p>​        于是，可导的一种判断方式有了：在一个点的左右导数存在相等。</p><p>​        对于$y=|x|$ ，在$x_0$左侧的左导数为-1，右导数为1，这两个不相等，故$|x|$在$x=0$处不存在导数。</p><h3 id="导数也有几何意义"><a href="#导数也有几何意义" class="headerlink" title="导数也有几何意义"></a>导数也有几何意义</h3><p>​        导数也有几何意义，不错。那么，导数的几何意义是什么呢？直接说：导数的几何意义就是函数图像在某一点上的切线的斜率，一个处处可导的曲线必然光滑。</p><p><img src="image-20230104153906913.png" alt="image-20230104153906913"></p><p>​        于是，切线方程可以这样给出</p><script type="math/tex; mode=display">l:y-y_0=f'(x_0)(x-x_0)</script><p>​        有切线了，法线也会有：法线就是过切点的，垂直于切线的线：</p><script type="math/tex; mode=display">l':y-y_0=-\frac{1}{f'(x_0)}(x-x_0)</script><p>​        比如说，让我们求$y=\frac{1}{x}$在$(\frac{1}{2},2)$上的切线：</p><script type="math/tex; mode=display">证明:显然在x_0=\frac{1}{2}这个点上，f'(x_0)=-4</script><script type="math/tex; mode=display">于是切线方程为:y-2=-4(x-\frac{1}{2})</script><script type="math/tex; mode=display">法线方程为：y-2=\frac{1}{4}(x-\frac{1}{2})</script><h3 id="联系起来：探寻可导与连续的关系"><a href="#联系起来：探寻可导与连续的关系" class="headerlink" title="联系起来：探寻可导与连续的关系"></a>联系起来：探寻可导与连续的关系</h3><p>​        我们可以简单的理解认为可导就说明函数曲线的光滑，连续就是函数图像不产生间断。看来：函数如果光滑，则一定没有间断，函数没有间断却不一定光滑。那我们认为：<strong>可导必然连续，连续不一定可导。</strong></p><p>​        对于这件事情：可以想象一排自行车：如果他们想多米诺骨牌一样倒下了 （可 倒（导））说明他们一定连续的放置，反之，如果不去动他们，则他们就算连续放置也不会倒下，可以这样记。</p><p>​        回到数学的定义上，我们对比一下：</p><script type="math/tex; mode=display">连续:\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=0</script><script type="math/tex; mode=display">可导:\lim\limits_{\Delta{x}\rightarrow{0}}\frac{\Delta{y}}{\Delta{x}}=C(const)</script><p>​        于是，如果一个$\Delta{x}\rightarrow{0}$，同时，可导定义比出来的比值还必须是一个常数，由同阶无穷小的定义，我们不得不得出$\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=0$的结论，也就是连续。</p><p>​        反之，我们的$\Delta{y}$可能并不会与$\Delta{x}$属于同阶无穷小，因此，我们的可导定义极限可能发散。于是：就可能并不可导</p><h3 id="求导法则：和差商积"><a href="#求导法则：和差商积" class="headerlink" title="求导法则：和差商积"></a>求导法则：和差商积</h3><p>​        高中我们就接触过了：</p><p>​        首先定义$u,v$是两个可导函数，其值为$u’,v’$</p><script type="math/tex; mode=display">法则1: (u+v)'=u'+v'</script><script type="math/tex; mode=display">法则2:(u-v)'=u'-v'</script><script type="math/tex; mode=display">法则3:(uv)'=uv'+vu'</script><script type="math/tex; mode=display">法则4:(cu)'=cu'(c是常数)</script><script type="math/tex; mode=display">法则5:(\frac{u}{v})'=\frac{u'v-uv'}{v^2}</script><p>法则1234都可以扩展：</p><p>对于有限个$u_i$的可导函数：他们的和的导数为各自导数的和</p><script type="math/tex; mode=display">(u+v+w+...+...+s)'=u'+v'+w'+...+...+s'</script><p>对于有限个$u_i$的可导函数：他们的积的导数为所有$u_i$的积中轮流取出一个$u_k(k\in{(1,i)})$求一次导</p><script type="math/tex; mode=display">(uvw...s)'=u'vw...s+uv'w...s+uvw'...s+...+uvw...s'</script><h3 id="反函数的求导法则"><a href="#反函数的求导法则" class="headerlink" title="反函数的求导法则"></a>反函数的求导法则</h3><p>​        反函数也能求导。</p><script type="math/tex; mode=display">定理:x=f(y)在I_y内单调且可导，同时f'(y)\neq{0},</script><script type="math/tex; mode=display">那么反函数y=f^{-1}(x)的导函数如下：</script><script type="math/tex; mode=display">[f^{-1}(x)]'=\frac{1}{f'(y)}</script><p>​        超前一点，可以引入记号$\frac{dy}{dx}$表达$f(x)$的导数，而$\frac{dx}{dy}$就是反函数，于是：</p><script type="math/tex; mode=display">\frac{dx}{dy}=\frac{1}{\frac{dy}{dx}}</script><p>​        他让我们的导数公式可以扩充了：</p><p>​        例如:$x=\sin{y}$作为$y=\sin{x}$的反函数的公式</p><script type="math/tex; mode=display">因为:\frac{dx}{dy}=\frac{1}{\frac{dy}{dx}}=\frac{1}{\cos{y}}</script><script type="math/tex; mode=display">且:\sin^2{y}+\cos^2{y}=1\Longrightarrow{\cos{y}=\sqrt{1-\sin^2{y}}=\sqrt{1-x^2}}</script><p>​        于是：$y=\arcsin{x}$的导数公式正是：$\arcsin{x}’=\frac{1}{\sqrt{1-x^2}}$.</p><p>​        这样，我们也还可以求出其他公式：</p><script type="math/tex; mode=display">\arccos{x}'=-\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arctan{x}'=\frac{1}{1+x^2}</script><h3 id="复合函数的求导法则"><a href="#复合函数的求导法则" class="headerlink" title="复合函数的求导法则"></a>复合函数的求导法则</h3><p>​        下面，我们先从严肃的讲起：</p><p>​        假设，我说假设：$f(x)$是一个很复杂的东西：但好消息是，可以是做若干函数的嵌套：比如说$\ln{\sqrt{\frac{1}{cos{\ln{\sin^2{x}}}}}{sin{x}}}$云者，那这样的函数这么求导呢？复合求导法来力！</p><p>​        </p><script type="math/tex; mode=display">法则:简单的，视函数f(x)是由f(u),u=g(x)嵌套，那么它的导数是:</script><script type="math/tex; mode=display">f'(x)=f'(u)\times{g'(x)}</script><p>​        就是说，我们可以视$u$作一个整体，先想象成单一函数$f(x)$求导，不过$x$是$u$,随后对$u$求导，乘起来的时候u要换成x.</p><p>​        使用微分语言是这样描述的：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{dy}{du}\times\frac{du}{dx}</script><p>​        想象成分式乘法，我们自然可以：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{dy}{du}\times\frac{du}{dk}\times\frac{dk}{dw}...\times\frac{ds}{dx}</script><p>​        例如说：对$e^{x^{3}}$求导</p><p>​        我们首先设$u=x^3$，而$e^u$对$u$求导显然是$e^u$，那么$u$对$x$是$3x^2$根据法则，我们要把连着直接相乘$3e^u{x^2}$，但是还没换回来$x$,因此将$u=x^3$换回来得到结果$3e^{x^3}{x^2}$</p><p>​        那么：$y=\ln{\cos{e^x}}$如何？</p><p>​        直接设置$y=\ln{u},u=\cos{v},v=e^x$结合复合函数求导法则。</p><p>​        $y’=\frac{1}{u}\times{-\sin{v}}\times{e^x}$</p><p>​        换元：$y’=\frac{-\sin{e^x}\times{e^x}}{\cos{e^x}}$</p><h3 id="导数公式表"><a href="#导数公式表" class="headerlink" title="导数公式表"></a>导数公式表</h3><p>​        介绍完导数的求导法则，我们也就可以引入一系列的求导表了：</p><script type="math/tex; mode=display">(C)'=0</script><script type="math/tex; mode=display">(x^{\mu})'=\mu{x^{\mu-1}}</script><script type="math/tex; mode=display">\sin{x}'=\cos{x}</script><script type="math/tex; mode=display">\cos{x}'=-\sin{x}</script><script type="math/tex; mode=display">\tan{x}'=\sec^2{x}</script><script type="math/tex; mode=display">\cot{x}'=-\csc^2{x}</script><script type="math/tex; mode=display">\sec{x}'=\sec{x}\tan{x}</script><script type="math/tex; mode=display">\csc{x}'=-\csc{x}\cot{x}</script><script type="math/tex; mode=display">(a^x)'=\ln{a}\times{a^x},(e^x)'={e^x}</script><script type="math/tex; mode=display">\log_a{x}'=\frac{1}{x\ln{a}}</script><script type="math/tex; mode=display">\ln{x}'=\frac{1}{x}</script><script type="math/tex; mode=display">\arcsin{x}'=\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arccos{x}'=-\frac{1}{\sqrt{1-x^2}}</script><script type="math/tex; mode=display">\arctan{x}'=\frac{1}NaN</script><script type="math/tex; mode=display">arccot{x}'=-\frac{1}NaN</script><h3 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h3><p>​        就是对一个函数求有限次导数：比如说</p><script type="math/tex; mode=display">y=x^3,y'=3x^2,y''=6x,y'''=6,y^{(4)}=0</script><p>​        在微分学里也有专门的符号表示</p><script type="math/tex; mode=display">一阶导数:\frac{dy}{dx}</script><script type="math/tex; mode=display">二阶导数:\frac{d}{dx}(\frac{dy}{dx})=\frac{d^2y}{dx^2}</script><script type="math/tex; mode=display">N阶导数:\underbrace{\frac{d}{dx}\frac{d}{dx}...\frac{d}{dx}\frac{dx}{dy}}_{Ntimes}=\frac{d^ny}{dx^n}</script><p>一些常见的N阶导数公式是如下的：</p><script type="math/tex; mode=display">\sin^{(x)}x=\sin{(x+\frac{n}{2}{\pi})}</script><script type="math/tex; mode=display">\cos^{(x)}x=\cos{(x+\frac{n}{2}{\pi})}</script><script type="math/tex; mode=display">\ln^{(n)}{(x+1)}=(-1)^{n-1}\frac{(n-1)!}{(1+x)^n}</script><script type="math/tex; mode=display">x^{\mu{(n)}}=\mu{(\mu-1)}{(\mu-2)}...{(\mu-n+1)}x^{\mu-n}</script><p>一些法则也是成立的：</p><script type="math/tex; mode=display">(u+v)^{(n)}=u^{(n)}+v^{(n)}</script><p>但是乘法不是，是莱布尼兹公式：</p><script type="math/tex; mode=display">(uv)^{(n)}=\sum^{n}_{k=0}C^{k}_{n}u^{(u-k)}v^{k}</script><h3 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h3><p>​        我们现在接触的函数都是显函数，$y$与$x$都是显然分离的，比如说$y=\sin{x}$云者，有一些函数是$x$和$y$混在一起的，比如说如下的几个式子</p><p>​                                                $                e^{xy}+\sin{y^2}+x^3+8=0$</p><p>​                                                    $e^y-xy-e=0$</p><p>云者。这些被称为隐函数，或者说：关于x的一个方程。</p><p>​        下面，我们介绍这样函数的求导方式：</p><p>​        我们假设$y=y(x)$是一个x的函数，于是，这样的方程成为了一个恒等式：一个关于x的一个大函数$F(x,f(x))=0$的式子。，现在我们求导，就是使用求导法则运算解决问题：右侧作为常数，导数恒为0，对左侧求导即可。下面对：</p><p>​                                                    $e^y-xy-e=0$</p><p>求导</p><p>​        左侧：$e^y\cdot{y’}+y+xy’$</p><p>​        右侧：0</p><p>​        现在参数分离：$y’=-\frac{y}{e^y+x}$</p><p>​                                            $y^5+2y-x-3x^7=0$</p><p>求导：</p><p>​        左侧：$5y^4y’+2y’-1-21x^6=0$</p><p>​        右侧：0</p><p>​        现在参数分离：$y’=\frac{1+21x^6}{5y^4+2}$</p><h3 id="参数方程求导"><a href="#参数方程求导" class="headerlink" title="参数方程求导"></a>参数方程求导</h3><p>​        我们说一些函数可以用</p><script type="math/tex; mode=display">\begin{align*}\begin{split}\left \{\begin{array}{ll}  x= \psi{(t)}                    \\  y=  \varphi{(t)}                               \end{array}\right.\end{split}\end{align*}</script><p>表示，这个时候，可以使用微分形式的公式更好的表达求导：</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{\frac{dy}{dt}}{\frac{dx}{dt}}=\frac{\varphi{(x)}'}{\psi{(x)}'}</script><p>微分可以视作增量的一种表达：</p><p>​        回顾增量公式$\Delta{y}=f(x_0+\Delta{x})-f(x_0)$,我们常常发现以这种形式表达的$\Delta{y}$经常可以被写成$A\Delta{x}+o(\Delta{x})$的形式，注意到$A$与$\Delta{x}$是无关的。如果函数的增量可以这样表达：</p><script type="math/tex; mode=display">\Delta{y}=A\Delta{x}+o(\Delta{x})</script><p>​        $A$与$\Delta{x}$是无关,</p><p>​        那么，我们就改写成这样的形式：</p><script type="math/tex; mode=display">dy=Adx</script><p>​        同时，我们还说这样的函数在这一点是可微的：并且，可微一定可导，可导也一定可微：事实上，以此为基准</p><script type="math/tex; mode=display">dy=f'(x_0)dx</script><p>​        微分与导数就是变化率问题的等价表达</p><p>​        于是任何微分公式都可以由上述公式给出：</p><p>​        比如说：$y=x^2,dy=2xdx$</p><h3 id="微分在近似计算的应用"><a href="#微分在近似计算的应用" class="headerlink" title="微分在近似计算的应用"></a>微分在近似计算的应用</h3><p>​        回到上面讲的公式：</p><script type="math/tex; mode=display">\Delta{y}=f(x_0+\Delta{x})-f(x_0)</script><p>​        这个公式，我们可以对一个已知临近量的函数值求另一点相近的函数值的近似值，我们对公式移项：</p><script type="math/tex; mode=display">f(x_0+\Delta{x})=f'(x_0)\Delta{x}+f(x_0)</script><p><img src="image-20230104175543374.png" alt="image-20230104175543374"></p><h2 id="二-导数的应用"><a href="#二-导数的应用" class="headerlink" title="二.导数的应用"></a>二.导数的应用</h2><h4 id="Rolle（罗尔）定理"><a href="#Rolle（罗尔）定理" class="headerlink" title="Rolle（罗尔）定理"></a>Rolle（罗尔）定理</h4><p>​        事实上，为了更好的证明罗尔定理，一般我们需要严格的引入费马定理：</p><h4 id="费马定理"><a href="#费马定理" class="headerlink" title="费马定理"></a>费马定理</h4><p><strong>$f(x)$在$x_0$及其领域有定义，且在$x_0$处可导，如果$f(x)\leqslant{f(x_0)}$(或者$f(x)\geqslant{f(x_0)}$)</strong></p><p><strong>则$\forall{x}\in \cup(x_0)$(这表示领域)，$f’(x_0)=0$</strong></p><p><img src="image-20230106084644861.png" alt="image-20230106084644861"></p><p>​        看起来容易，怎么证明？我们不妨从$x_0$可导入手：</p><p>证明：以$f(x_0)$是最大值为例：函数$f(x)$在$x_0$处可导，那就要求：</p><script type="math/tex; mode=display">x\in \cup(x_0),f(x)\leqslant{f(x_0)}</script><p>​        同时注意到$x_0+\Delta{x}$也是在$\cup(x_0)$上的，于是也有：</p><script type="math/tex; mode=display">x_0+\Delta{x} \in \cup(x_0),f(x_0+\Delta{x})\leqslant{f(x_0)}</script><p>​        同时函数$f(x)$在$x_0$处可导：</p><script type="math/tex; mode=display">f'_{-}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^-}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}\leqslant{0}</script><script type="math/tex; mode=display">f'_{+}(x_0)=\lim\limits_{\Delta{x}\rightarrow{0^+}}\frac{f(x_0+\Delta{x})-f(x_0)}{\Delta{x}}\geqslant{0}</script><p>​        </p><script type="math/tex; mode=display">f'_{-}(x_0)=f'_{+}(x_0)</script><p>​        上面的三个式子联立：得到$f’_{-}(x_0)=f’_{+}(x_0)=f’(x_0)=0$</p><p>证毕。</p><p>​        于是：又把导数为0的点成为驻点，因为函数在这一点停靠在$y=f(x_0)$上不变化，他们是可能的极值点（会在后面阐述为什么是可能）</p><h4 id="罗尔定理"><a href="#罗尔定理" class="headerlink" title="罗尔定理"></a>罗尔定理</h4><p><strong>首先函数$f(x)$满足</strong></p><p><strong>1）在$[a,b]$上连续 2)在$(a,b)$上可导 3）$f(a)=f(b)$</strong></p><p><strong>则至少存在一点$\xi\in(a,b),f’(\xi)=0$</strong></p><p><img src="image-20230106090148355.png" alt="image-20230106090148355"></p><p>这个定理说明了在端点值相等的区间里函数必有<strong>至少</strong>一个驻点。</p><h4 id="拉格朗日中值定理"><a href="#拉格朗日中值定理" class="headerlink" title="拉格朗日中值定理"></a>拉格朗日中值定理</h4><p><strong>要求：1)$[a,b]$连续          2)$(a,b)$可导：</strong></p><p><strong>则函数$f(x)$在$(a,b)$上至少有一个点$\xi$,使得下面的式子成立：</strong></p><script type="math/tex; mode=display">f'(\xi)=\frac{f(b)-f(a)}{b-a}</script><p><img src="image-20230106090806236.png" alt="image-20230106090806236"></p><p>​        说白了，就是罗尔定理的扩展，我们链接两个端点，产生的直线称为函数的一条<strong>弦</strong>在函数上我们至少可以找到一个点的切线斜率等于这条线的斜率的大小。</p><h4 id="柯西中值定理"><a href="#柯西中值定理" class="headerlink" title="柯西中值定理"></a>柯西中值定理</h4><p>如果$f(x)$和$F(x)$满足：</p><p>1）$[a,b]$连续          2)$(a,b)$可导          3）$\forall{x}\in(a,b),F’(x)\neq{0}$</p><p>则至少有一个点$\xi$,使得$\frac{f(b)-f(a)}{F(b)-F(a)}=\frac{f’(\xi)}{F’(\xi)}$</p><p>​        这又是拉格朗日中值定理的推广。</p><h4 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a>洛必达法则</h4><p>​        这玩意干嘛的？求解未定式$\frac{0}{0}$,$\frac{\infty}{\infty}$的式子</p><p>注意：法则内容如下：</p><p>1）两个函数$f(x),F(x)$在$x\rightarrow a$都同时倾向于$0$或者$\infty$ </p><p>2）在$a$的去心领域内$f’(x),F’(x)$都存在且$F’(x)\neq 0$</p><p>3）$\lim\limits_{x\rightarrow a}\frac{f’(x)}{F’(x)}$存在（或者无穷大）</p><p>则$\lim\limits_{x\rightarrow a}\frac{f(x)}{F(x)}=\lim\limits_{x\rightarrow a}\frac{f(x)}{F(x)}$</p><p>例子：</p><script type="math/tex; mode=display">1)\lim\limits_{x\rightarrow 0}\frac{\sin{ax}}{\sin bx}=\lim\limits_{x\rightarrow 0}\frac{a\cos ax}{b \cos bx}=\frac{a}{b}</script><p>注意：如果使用完一次洛必达后的式子<strong>仍满足洛必达的条件</strong>可以继续使用</p><p>比如说</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow 1}\frac{x^3-3x+2}{x^3-x^2-x+1}=\lim\limits_{x\rightarrow 1}\frac{3x^2-3}{3x^2-2x-1}=\lim\limits_{x\rightarrow 1}\frac{6x}{6x-2}</script><p>​        到这里就不能再使用洛必达法则了：因为$\lim\limits_{x\rightarrow 1}\frac{6x}{6x-2}$不满足条件1)，所以：直接带值得到$\frac{3}{2}$结束</p><p>​        注意，我们可以使用这个法则分析一些常见函数的发散速度：</p><p>命题：比较$\ln x,x^n,e^{\lambda{x}}$的发散速度</p><p>比较$\ln x,x^n$</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{\ln x}{x^n}=\lim\limits_{x\rightarrow \infty}\frac{1}{nx^{n-1}\cdot{x}}=0</script><p>​        这意味这$\ln{x}$的发散速度小于$x^n$的发散速度。</p><p>比较$x^n，e^{\lambda{x}}$</p><script type="math/tex; mode=display">\lim\limits_{x\rightarrow \infty}\frac{x^n}{e^{\lambda{x}}}=\lim\limits_{x\rightarrow \infty}\frac{nx^{n-1}}{\lambda e^{\lambda{x}}}=\lim\limits_{x\rightarrow \infty}\frac{n(n-1)x^{n-2}}{\lambda ^2e^{\lambda{x}}}=...=\lim\limits_{x\rightarrow \infty}\frac{n!}{\lambda ^ne^{\lambda{x}}}=0</script><p>​    这意味这$x^n$的发散速度小于$e^{\lambda{x}}$的发散速度。</p><h4 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h4><p>​        泰勒公式是用若干多项式近似描述函数的一个公式：</p><script type="math/tex; mode=display">P_n(x)=\sum_{k=0}^{n} a_k(x-x_0)^k +R(x)=f(x)</script><p>​        这样一个过程。$R(x)$是高于n阶的一个误差数。</p><p>​        我们求$x_0$一阶导数得到：$f’(x_0)=a_1$</p><p>​        类似的$f’’(x_0)=1\cdot 2a_2$</p><p>​        $f’’’(x_0)=1\cdot 2 \cdot 3a_3$</p><p>​        …</p><p>​        $f^{(n)}(x)=n!a_n$</p><p>​        这样多项式的系数就确定了！替换一下：</p><script type="math/tex; mode=display">f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)</script><p>其中$R_n(x)=o(x-x_0)^n$当然，由拉格朗日中值定理，$R_n(x)$也可以这样表达：</p><script type="math/tex; mode=display">R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}</script><p>当然还有更紧凑的形式：</p><script type="math/tex; mode=display">f(x)=\sum_{k=0}^{n}\frac{f^{(k)}(x_0)}{k!}(x-x_0)^k+R_n(x)</script><p>我们使用泰勒公式看看一些函数的近似,为了简便，我们自然取$x_0=0$</p><script type="math/tex; mode=display">e^x=1+x+\frac{x^2}{2}+\frac{x^3}{6}+...+\frac{x^n}{n!}+R_n(x)=\sum_{k=0}^{n}\frac{(x-x_0)^k}{k!}+R_n(x)</script><script type="math/tex; mode=display">\sin{x}=x-\frac{x^3}{3!}+\frac{x^5}{5!}-...(-1)^{(m-1)}\frac{x^{(2m-1)}}{(2m-1)!}+R_{2m}(x)=\sum_{k=0}^{n}\frac{(-1)^{(m-1)}(x-x_0)^k}{(2m-1)!}+R_{2m}(x)</script><script type="math/tex; mode=display">\cos{x}=1-\frac{x^2}{2!}+\frac{x^4}{4!}-...(-1)^{(m-1)}\frac{x^{2m}}{(2m)!}+R_{2m}(x)=\sum_{k=0}^{n}\frac{(-1)^{(m-1)}(x-x_0)^k}{(2m)!}+R_{2m}(x)</script><script type="math/tex; mode=display">\ln{(x+1)}=x-\frac{x^2}{2}+\frac{x^3}{3}-...+(-1)^{(n-1)}\frac{x^n}{n}+\sum_{k=1}^{n}(-1)^{(n-1)}\frac{x^n}{n}+R_n(x)</script><script type="math/tex; mode=display">(1+x)^\alpha=1+\alpha{x}+\frac{\alpha(\alpha-1)}{2!}x^2+...+\frac{\alpha(\alpha-1)...(\alpha-n+1)}{n!}(x-x_0)^n=\sum_{k=0}^{n}\frac{C_k^{\alpha}}{k!}(x-x_0)^k</script><h4 id="函数的单调性"><a href="#函数的单调性" class="headerlink" title="函数的单调性"></a>函数的单调性</h4><p>​        现在，我们可以系统的分析函数的单调性了：</p><p>​        函数的单调性分为单调递增和单调递减：( x 在区间 I ,且函数连续)</p><script type="math/tex; mode=display">函数单调递增:f'(x)>0</script><script type="math/tex; mode=display">函数单调递减:f'(x)<0</script><p>​        于是下面给出定理：</p><script type="math/tex; mode=display">y=f(x)在[a,b]连续,(a,b)可导 且f'(x)\geqslant{0},更进一步的等号在有限个点取到</script><script type="math/tex; mode=display">那么我们说：函数在区间(a,b)上单调递增</script><p>​        同理：单调递减的也是类似的</p><script type="math/tex; mode=display">y=f(x)在[a,b]连续,(a,b)可导 且f'(x)\leqslant{0},更进一步的等号在有限个点取到</script><script type="math/tex; mode=display">那么我们说：函数在区间(a,b)上单调递减</script><p>​        函数的单调性与一阶导数息息相关，看一些例题 </p><script type="math/tex; mode=display">分析y=x-\sin x [-\pi,\pi]的单调性</script><p>​        </p><p>​        因为：</p><script type="math/tex; mode=display">y'=1-\cos{x}\geqslant 0</script><p>​        故函数总在$[-\pi,\pi]$单调递增。</p><p>​        这样的一些点是我们在求解一阶导数的时候需要注意的：</p><p>1）$f’(x)=0$  的点：又叫驻点。</p><p>2)导数不存在的点</p><p>例题：</p><script type="math/tex; mode=display">分析f(x)=2x^3-9x^2+12x-3 的单调性</script><script type="math/tex; mode=display">f'(x)=6x^2-18x+12=6(x-1)(x-2)</script><script type="math/tex; mode=display">所以：x<1单增，1\leqslant{x}\leqslant{2}单减，x\geqslant{2} 单增</script><h4 id="函数的凹凸性"><a href="#函数的凹凸性" class="headerlink" title="函数的凹凸性"></a>函数的凹凸性</h4><p>​        我们还要关注函数是怎样的单调递增或者单调递减，这就需要我们使用二阶导数分析函数的凹凸性。</p><p>​        首先我们来看定义：</p><p>​        <strong>仍对于$f(x)$在区间$I$上连续，如果对任意的$x_1,x_2 \in I (x_1\neq{x_2})$</strong></p><script type="math/tex; mode=display">f(\frac{x_1+x_2}{2})<\frac{f(x_1)+f(x_2)}{2}</script><p>​        <strong>我们就称呼$f(x)$在区间$I$上的图像是凹的（上凹）</strong></p><p>​        <strong>类比的：如果：</strong></p><script type="math/tex; mode=display">f(\frac{x_1+x_2}{2})>\frac{f(x_1)+f(x_2)}{2}</script><p>​        <strong>那么我们又称呼$f(x)$在区间I上的图像是凸的（下凹的）</strong></p><p><img src="image-20230107152418652.png" alt="image-20230107152418652"></p><p>​        函数$f(x)$如果在$I$上是凹（凸）的，那么$-f(x)$是凸(凹)的。</p><p><img src="image-20230107152556639.png" alt="image-20230107152556639"></p><p>​        我们先前就提到过：函数的凸凹性和函数的二阶导数密切相关，下面我们来一睹定理的芳容：</p><p>​        <strong>设$f(x)$在区间$I$上二阶可导，那么：</strong></p><p>​        <strong>（1）若在$I$上$f’’(x)&gt;0$，那么我们说函数是凹的</strong></p><p>​        <strong>（2）若在$I$上$f’’(x)&lt;0$，那么我们说函数是凹的</strong></p><h4 id="极值及其求法"><a href="#极值及其求法" class="headerlink" title="极值及其求法"></a>极值及其求法</h4><p>​        首先我们需要区分一下极值和最值：</p><p>​        极值：邻域内函数的最大最小值</p><p>​        最值：在全函数的定义域内函数的最大最小值</p><p>下面给出严肃的定义：</p><p>​        定义：$f(x)$在$x_0$的领域$\cup (x_0)$下有定义且连续,$\forall{x}\in\mathring{U}(x_0)$,$f(x)<f(x_0)(或者)(f(x)>f(x_0))$那么我们说$f(x_0)$是函数的极大值 or 极小值。</p><p>​        极值的定理 I:(必要条件)函数可导，且在此点$x_0$的导数 $f’(x_0)=0$</p><p>​        极值的定理 II:(第一充分条件)：$f(x)$在$x_0$处连续,且在$\mathring{U}(x_0)$处可导</p><p>（1）$x \in(x_0-\delta,x_0)$ 且$f’(x)&gt;0$,而$x \in(x_0,x_0+\delta)$ 且$f’(x)&lt;0$我们说函数在此点取上极大值</p><p>（2）$x \in(x_0-\delta,x_0)$ 且$f’(x)&lt;0$,而$x \in(x_0,x_0+\delta)$ 且$f’(x)&gt;0$我们说函数在此点取上极小值</p><p>如果不变号，那就不是极值点。</p><p>​        下面总结流程：</p><p>​        （1）求$f’(x)$</p><p>​        （2）求驻点和不可导点</p><p>​        （3）考察上面这些点的变号情况</p><p>例题：$f(x)=(x-4)\sqrt[3]{(x+1)^2}$的极值点.</p><p>$f’(x)=\frac{5(x-1)}{3\sqrt[3]{x+1}}$令$f’(x)=0$</p><p>得到 $x=1$是驻点，$x=-1$是不可导点</p><p>1)$x=-1$,$x&lt;-1$时，$f’(x)&gt;0$, $x&gt;-1$时，$f’(x)&lt;0$,所以这是一个极大值点</p><p>2）$x=1$,$x<1$时，$f'(x)<0$, $x>-1$时，$f'(x)>0$,所以这是一个极小值点</p><p>当然还有别的判断方式：</p><p>​        定理 II’（第二充分条件）函数$f(x)$二阶可导，$f’(x_0)=0,f’’(x_0)\neq{0}$</p><p>当：</p><p>1)$f’’(x)&lt;0$在$x_0$处取极大值</p><p>2)$f’’(x)&gt;0$,在$x_0$处极小值</p><h4 id="函数图像的绘制"><a href="#函数图像的绘制" class="headerlink" title="函数图像的绘制"></a>函数图像的绘制</h4><p>​        下面我们开始绘制函数的图像！这也是系统分析函数的步骤</p><p>​        1）分析函数的定义域，以及可能的奇偶性，周期性</p><p>​        2)求出一阶导数，二阶导数，和他们等于0的点</p><p>​        3)找出函数的间断点（从定义域得到），以及一阶导数，二阶导数不存在的点</p><p>​        4）由此求出函数的单调性凹凸性</p><p>​        5）看看是否有渐近线（铅锤，水平，斜的渐近线）</p><p>​        6）确定极值（带点）</p><p>例如：$y=x^3-x^2-x+1$</p><p>​        显然函数的定义域为$R$，且无奇偶性，周期性</p><p>​        $f’(x)=3x^2-2x-1,f’’(x)=2(3x-1)$</p><p>​        令$f’(x)=0,x=-\frac{1}{3}或x=1$,当$f’’(x)=0,x=\frac{1}{3}$</p><p>​        确定函数的分间断是：$(-\infty,-\frac{1}{3}),[-\frac{1}{3},\frac{1}{3}],[\frac{1}{3},1],[1,+\infty]$</p><p>​        并且列表时按照如下格式列</p><p>![image-20230107161122390]image-20230107161122390.png)</p><p>补充：函数的渐近线是如下公式确定的：</p><script type="math/tex; mode=display">if :\lim{\frac{f(x)}{x}}=k存在，那就有斜渐近线存在</script><script type="math/tex; mode=display">如果存在:则b=\lim{(f(x)-kx)},直线的方程就是y=kx+b</script><p>至于水平渐近线就是$\lim\limits_{x\rightarrow{\infty}}(f(x)-b)=0$那么就是$y=b$</p><p>铅锤渐近线:$\lim\limits_{x\rightarrow{a}}f(x)\rightarrow\infty$则就是$x=a$</p><h4 id="曲率分析："><a href="#曲率分析：" class="headerlink" title="曲率分析："></a>曲率分析：</h4><p>​        我们使用曲率来分析曲线的弯曲程度：</p><p><img src="image-20230107161834749.png" alt="image-20230107161834749"></p><p>​        这样看</p><p><img src="image-20230107161907141.png" alt="image-20230107161907141"></p><p>​        可以看到，如果$M$移动相同单位，其倾角变化越大，那就称之曲率越大：</p><script type="math/tex; mode=display">\overline{K}=|\frac{\Delta{\alpha}}{\Delta s}|</script><p>​        如果我们让图片里的$M,M’$靠拢，不久类比的得到一个点的曲率了吗 ？（ds是弧微分，后面有图片展示）</p><p>​        </p><script type="math/tex; mode=display">K=\lim\limits_{\Delta s \rightarrow 0}|\frac{\Delta{\alpha}}{\Delta s}|=|\frac{d\alpha}{ds}|</script><p>​        这样：直线的曲率:$K=0$</p><p>​        圆的曲率:$K=\frac{1}{r}$（ r 是圆的半径）</p><p><img src="image-20230107162607705.png" alt="image-20230107162607705"></p><p>​        曲率的公式在直角坐标系的公式可以从定义得到:</p><p>​        $y’=\tan{\alpha}$,$y’’=\sec^2{\alpha}$,于是:</p><script type="math/tex; mode=display">|\frac{d\alpha}{dx}|=\frac{y''}{\sec^2{x}}=\frac{y''}{1+\tan^2{\alpha}}=\frac{y''}{1+y'^2}</script><p>​        而$ds=$$\sqrt{1+y’^2}$</p><p><img src="image-20230107163229852.png" alt="image-20230107163229852"></p><p>​                                                                        弧微分</p><p>​        于是：</p><script type="math/tex; mode=display">|\frac{d\alpha}{ds}|=|\frac{\frac{y''}{1+y'^2}}{\sqrt{1+y'^2}}|=|\frac{y''}{(1+y'^2)^\frac{3}{2}}|</script><p>​        类比的，在参数方程下：</p><p><img src="image-20230107163642181.png" alt="image-20230107163642181"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（1）</title>
      <link href="/2023/01/30/%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/30/%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h3 id="认识时间复杂度"><a href="#认识时间复杂度" class="headerlink" title="认识时间复杂度"></a>认识时间复杂度</h3><p>​        我们有一些操作是常数时间完成的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int a &#x3D;arr[i];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为我们直接计算偏移量直接取出的</p><p>​        但是这个不是</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int t&#x3D;list.get(i);&#x2F;&#x2F;链表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        因为链表必须遍历，才能找到元素</p><p>​        以及加减乘除的操作是常数操作。</p><p>​        总而言之：涉及到数据量的操作都是<strong>非常数操作</strong></p><p>​        举个例子，选择排序：这个排序是一种选择某一个数与前面已经排好的数组开始对比。怎么保证前面的已经有序了呢？我们把算法作用在第一个元素上，这个时候那他与第二个元素排序，成功后就是一个有序小数组，这样就满足了递归的条件：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Part I:C version without recurssion#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;&#x2F;&#x2F;using Choose sort to sort the array&#x2F;&#x2F;rand num getterint getRandNum(int maxRange)&#123;    srand((unsigned int)clock());    Sleep(10);    return rand()% maxRange;&#125;void printCurrentArray(int* array,int arraySize)&#123;    printf(&quot;Current array is shown:\n&quot;);    for(int i&#x3D;0; i&lt;arraySize; i++)    &#123;        printf(&quot;%d &quot;,array[i]);    &#125;    printf(&quot;\n&quot;);&#125;void swapInt(int* e1, int* e2)&#123;    int temp&#x3D;*e1;    *e1&#x3D;*e2;    *e2&#x3D;temp;&#125;int main()&#123;    &#x2F;&#x2F;get a rand array    int arr[10]&#x3D;&#123;0&#125;;    for(int i&#x3D;0; i&lt;10; i++)    &#123;        arr[i]&#x3D; getRandNum(100);    &#125;    &#x2F;&#x2F;Sort starts!    for(int i&#x3D;1; i&lt;10; i++)    &#123;        &#x2F;&#x2F;from the second one        &#x2F;&#x2F;Compared with the previous one and the front one        for(int j&#x3D;i;j&gt;0;j--)        &#123;            &#x2F;&#x2F;If inverted,invert them back            if(arr[j]&lt;arr[j-1])            &#123;                swapInt(&amp;arr[j], &amp;arr[j - 1]);            &#125;        &#125;        &#x2F;&#x2F;Target the Current Key and show:        printf(&quot;Current key is:%d\n&quot;,arr[i]);        printCurrentArray(arr,10);        printf(&quot;Enter the newline to go forward!&quot;);        getchar();    &#125;    printf(&quot;Eventually...\n&quot;);    printCurrentArray(arr,10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Or Recussion type#define _CRT_SECURE_NO_WARNINGS 1#include&lt;windows.h&gt;#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;&#x2F;&#x2F;using Choose sort to sort the array&#x2F;&#x2F;rand num getterint getRandNum(int maxRange)&#123;    srand((unsigned int)clock());    Sleep(10);    return rand() % maxRange;&#125;void printCurrentArray(int* array, int arraySize)&#123;    printf(&quot;Current array is shown:\n&quot;);    for (int i &#x3D; 0; i &lt; arraySize; i++)    &#123;        printf(&quot;%d &quot;, array[i]);    &#125;    printf(&quot;\n&quot;);&#125;void swapInt(int* e1, int* e2)&#123;    int temp &#x3D; *e1;    *e1 &#x3D; *e2;    *e2 &#x3D; temp;&#125;void insertSort(int* array, int arraySize, int cur_sort_place)&#123;    if (cur_sort_place &gt; arraySize-1)        return;    int j &#x3D; cur_sort_place;    while (j &gt; 0)    &#123;        if (array[j] &lt; array[j - 1])            swapInt(&amp;array[j], &amp;array[j - 1]);        j--;    &#125;    choiceSort(array, arraySize, cur_sort_place + 1);&#125;int main()&#123;    int arr[10] &#x3D; &#123; 0 &#125;;    for (int i &#x3D; 0; i &lt; 10; i++)    &#123;        arr[i] &#x3D; getRandNum(100);    &#125;    insertSort(arr, 10, 1);    printCurrentArray(arr, 10);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个算法的时间复杂度就是O($N^2$)，这是因为操作表达式的最高阶是$N^2$.</p><p>​        注意到O(N)表达的是表达式的最高此项，是衡量巨大数量下算法的优良度</p><p><img src="image-20230126193633933.png" alt="image-20230126193633933"></p><p>​        当时间复杂度相同时，通过==比较常数项==作出判断是否可靠。更多的时候我们选择直接开跑看看怎么样：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public static void Process1()&#123;    int N&#x3D;1000;    int a&#x3D;1;    for(int i&#x3D;0 ; i&lt;N; i++)    &#123;        a*&#x3D;10;        a&#x3D;a+10;        a&#x3D;6127*9876;    &#125;&#125;public static void Process2()&#123;     int N&#x3D;1000;    int a&#x3D;1;    for(int i&#x3D;0 ; i&lt;N; i++)    &#123;        a&#x3D;10|1;        a^&#x3D;10;        a&#x3D;a&amp;9876;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对，就是这种。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>​        回顾上面的实例代码：我们使用Java写出另一个版本：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">seletionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> minIndex<span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            minIndex<span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token operator">?</span>j<span class="token operator">:</span>minIndex<span class="token punctuation">;</span><span class="token comment">//直接找到最小的地方</span>        <span class="token punctuation">&#125;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Using in swap minindex with arr[i]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>​        我们也可以使用冒泡排序排数，就像大的泡泡向下沉，小的泡泡向上浮。就好了。值得注意的是，我们换完产生的最值区已经换好了，没有必要再参与排序。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>N<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>N<span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>conditions<span class="token punctuation">)</span>            swap data<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="交换的离奇写法"><a href="#交换的离奇写法" class="headerlink" title="交换的离奇写法"></a>交换的离奇写法</h3><p>请看这个</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>异或：相同为0，不同为1：</p><p>例如：</p><p>A:1011110101001</p><p>B:1000101011001</p><p>  A^B: 0011011110000                        </p><p>也可以理解为无进位相加：</p><p>性质1：0^N=N,N^N=0</p><p>性质2：满足交换律和结合律</p><p>那这是怎么交换的？</p><p>a=a^b  1)</p><p>b=a^b</p><p>a=a^b</p><p>假设a= A,b=B;</p><p>1)a=A^B b=B</p><p>2)a=A^B,b=(A^B)^B =A^(B^B)=A</p><p>3)a=A^B^A=B b=A</p><p>交换完毕</p><p>但是注意：这样的方法不适用于同一块内存，否则会洗成0.</p><p>例题：1）现在有一个整型数组：里面有诺干出现了偶数次的数和一个出现奇数次的数，找出那个奇数次数的数：</p><p>EG：[2,1,3,1,3,1,3,2,1]——-&gt;3</p><p>Solutions：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int ero&#x3D;0;for(int i&#x3D;0;i&lt;arr.length;i++)&#123;ero^&#x3D;arr[i];&#125;printf(&quot;%d &quot;,ero);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这是因为异或顺序无关，偶数次数的全消成了0.于是可以引用在奇偶相关次序无关的题目。</p><p>2）现在有一个整型数组：里面有诺干出现了偶数次的数和两个出现奇数次的数，找出那两个奇数次数的数：</p><p>Ok，当我们依旧沿袭上面的方法的时候，我们发现：eor=a^b,这是因为一切出现了偶数次的异或为0，a和b也最后削成一个a^b。下面怎么办？</p><p>注意到a$\neq$b，这样的话：因为最右边的1是a,b作为二进制的特征数（用它来区分a,b），我们就可以提取出来：int rightOne=eor&amp;(~eor+1)，也就是源码与上补码，提取eor上的第右边的1，随后只与这个位置上是1的数，就得到a或者是b了</p><p>​        <img src="image-20230127113335433.png" alt="image-20230127113335433"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printOddTimeNum2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> eor<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        eor<span class="token operator">^</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> rightOne<span class="token operator">=</span>eor<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span>eor<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//找出来最右边的数</span>    <span class="token keyword">int</span> onlyOne<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//eor'</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur<span class="token operator">:</span>arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cur<span class="token operator">&amp;</span>rightOne<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">//别写1，因为出来的只能是0或者是rightOne，如果想要另一个就!=0;</span>            onlyOne<span class="token operator">^=</span>cur<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printIn</span><span class="token punctuation">(</span>onlyOne<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span><span class="token punctuation">(</span>ero<span class="token operator">^</span>onlyOne<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>​        这个就是最上面的代码，就是相当于插牌。这个算法的表现是波动较大的：O(N)~O($N^2$)。</p><p>​        但是算法的复杂度是看最差情况的，所以是O($N^2$).</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token comment">//...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h3><p>​        注意，这个只使用于有序数组。这个数组使用二分查找是最快的。主要思想：找中间，比大小，挪边界，继续二分。这个算法的复杂度因此是$O(\log n)$.</p><h3 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h3><p>​        假设我们要进行测试方法A，我们使用随机样本产生器，我们随机的产生数据放到多个方法，他们结果要是不一样，那要不就是A错，要不就是B错，要不就是都错了。这个时候人工干预的方式修改方法。</p><h3 id="递归行为下时间复杂度的计算"><a href="#递归行为下时间复杂度的计算" class="headerlink" title="递归行为下时间复杂度的计算"></a>递归行为下时间复杂度的计算</h3><h4 id="求取中点的方法"><a href="#求取中点的方法" class="headerlink" title="求取中点的方法"></a>求取中点的方法</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">int mid&#x3D;L+((R-L)&gt;&gt;1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    为什么这样书写：防止R+L溢出int上限、</p><h4 id="使用递归求解数组最大值："><a href="#使用递归求解数组最大值：" class="headerlink" title="使用递归求解数组最大值："></a>使用递归求解数组最大值：</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">L</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">L</span><span class="token operator">==</span><span class="token class-name">R</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token class-name">L</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> leftMax<span class="token operator">=</span><span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token class-name">L</span><span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rightMax<span class="token operator">=</span><span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftMax<span class="token punctuation">,</span>rightMax<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个写法我们是在二分类是常用的：先处理递归左边，再递归处理右边，最后从小到大的返回各层的最大值，最后得到整体的最大值。下面也有C++版本的</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;Windows.h&gt;class Finder &#123;public:int getMax(std::vector&lt;int&gt; s) &#123;return Dofindmax(s, 0, s.size()-1);&#125;int Dofindmax(std::vector&lt;int&gt; s, int left, int right)&#123;if (left &#x3D;&#x3D; right)return s[left];int mid &#x3D; left + ((right - left) &gt;&gt; 1);int leftMax &#x3D; Dofindmax(s, left, mid);int rightMax &#x3D; Dofindmax(s, mid + 1, right);return leftMax &gt; rightMax ? leftMax : rightMax;&#125;&#125;;void PrintVector(std::vector&lt;int&gt; s)&#123;for (std::vector&lt;int&gt;::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++)std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;std::cout&lt;&lt;std::endl;&#125;int getRandNum()&#123;srand((unsigned int)clock());Sleep(10);return rand() % 100;&#125;int main()&#123;std::vector&lt;int&gt; s;for (int i &#x3D; 0; i &lt; 10; i++)s.push_back(getRandNum());PrintVector(s);Finder f;int t &#x3D; f.getMax(s);std::cout &lt;&lt; t;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然，别太常用，因为容易把栈搞炸</p><p><img src="image-20230127160815732.png" alt="image-20230127160815732"></p><p>画个递归树</p><h3 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h3><script type="math/tex; mode=display">if:T(N)=a*T(\frac{N}{b})+O(N^d)</script><script type="math/tex; mode=display">then:1)\log_ba>d->T(N^{\log_ba})</script><script type="math/tex; mode=display">2)\log_ba=d->T(N^{d}log N)</script><script type="math/tex; mode=display">3)\log_ba<d->T(N^{d})</script><p>有人话版本吗？有的：就是说我们的一次递归可以拆分一个问题为b个子问题，当然右额外开销$N^d$,这样，我们就有分层级讨论：比较$\log_ba$与d的大小从而一步写出公式。</p><p>以上面为例：上面的问题把问题拆成两个子问题：b=2,并且在单个函数体内调用了两次：a=2,剩下的时间复杂度为O(1).这下，我们的公式就是：</p><script type="math/tex; mode=display">T(N)=2*T(N/2)+O(1)</script><p>这样就直接带入公式:T(N)=O(logn).</p><h3 id="补充Reading"><a href="#补充Reading" class="headerlink" title="补充Reading"></a>补充Reading</h3><p>​        平时设计或者阅读一个算法的时候，必然会提到算法的复杂度（包括时间复杂度和空间复杂度）。比如我们说一个二分查找算法的平均时间复杂度为 O(log n)，快速排序可能是 O(n log n)。那这里的 O 是什么意思？这样的表达是否准确呢？</p><p>​        今天来复习一下与算法复杂度相关的知识：函数渐进阶，记号 O、Ω、θ和 o；Master 定理。</p><p>​        先插一句，在算法复杂度分析中，log 通常表示以 2 为底的对数。</p><p>​        算法复杂度（算法复杂性）是用来衡量算法运行所需要的计算机资源（时间、空间）的量。通常我们利用渐进性态来描述算法的复杂度。</p><p>​        用 n 表示问题的规模，T(n) 表示某个给定算法的复杂度。所谓渐进性态就是令 n→∞ 时，T(n) 中增长最快的那部分。严格的定义是：如果存在 $T’(n)$，当 n→∞ 时，有:</p><script type="math/tex; mode=display">\frac{T(n)-T'(n)}{T(n)}\rightarrow 0</script><p>​        我们就说$T’(n)$是 T(n) 当 n→∞ 时的渐进性态。</p><p>​        比如 T(n) = 2 <em> n ^ 2 + n log n + 3，那么显然它的渐进性态是 2 </em> n ^ 2，因为当 n→∞ 时，后两项的增长速度要慢的多，可以忽略掉。引入渐进性态是为了简化算法复杂度的表达式，只考虑其中的主要因素。当比较两个算法复杂度的时候，如果他们的渐进复杂度的阶不相同，那只需要比较彼此的阶（忽略常数系数）就可以了。</p><p>​        总之，分析算法复杂度的时候，并不用严格演算出一个具体的公式，而是只需要分析当问题规模充分大的时候，复杂度在渐进意义下的阶。记号 O、Ω、θ和 o 可以帮助我们了解函数渐进阶的大小。</p><p>​        假设有两个函数 f(n) 和 g(n)，都是定义在正整数集上的正函数。上述四个记号的含义分别是：</p><ul><li>f(n) = O(g(n))：$∃c&gt;0,n_0∈N,∀n≥n_0,f(n)≤cg(n)$；f 的阶<strong>不高于</strong> g 的阶。</li><li>f(n) = Ω(g(n))：$∃c&gt;0,n_0∈N,∀n≥n_0,f(n)≥cg(n)$；f 的阶<strong>不低于</strong> g 的阶。</li><li>f(n) = θ(g(n))：⟺$f(n)=O(g(n))\&amp;\&amp;f(n)=Ω(g(n))$；f 的阶<strong>等于</strong> g 的阶。</li><li>f(n) = o(g(n))：$∀\varepsilon&gt;0,∃n_0∈N,∀n≥n_0,f(n)/g(n)&lt;\varepsilon$；f 的阶<strong>低于</strong> g 的阶。</li></ul><p>​        可见，记号 O 给出了函数 f(n) 在渐进意义下的上界（但不一定是最小的），相反，记号Ω给出的是下界（不一定是最大的）。如果上界与下界相同，表示 f(n) 和 g(n) 在渐进意义下是同阶的（θ），亦即复杂度一样。</p><p>​        列举一些常见的函数之间的渐进阶的关系：</p><p><img src="image-20230127163435272.png" alt="image-20230127163435272"></p><p>​        有些人可能会把这几个记号跟算法的最坏、最好、平均情况复杂度混淆，它们有区别，也有一定的联系。</p><p>​        即使问题的规模相同，随着输入数据本身属性的不同，算法的处理时间也可能会不同。于是就有了最坏情况、最好情况和平均情况下算法复杂度的区别。它们从不同的角度反映了算法的效率，各有用处，也各有局限。</p><p>​        有时候也可以利用最坏情况、最好情况下算法复杂度来粗略地估计算法的性能。比如某个算法在最坏情况下时间复杂度为θ(n ^ 2)，最好情况下为θ(n)，那这个算法的复杂度一定是 O(n ^ 2)、Ω(n) 的。也就是说 n ^ 2 是该算法复杂度的上界，n 是其下界。</p><p>​        接下来看看 Master 定理。</p><p>​        有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的：</p><p>​        设常数 a &gt;= 1，b &gt; 1，f(n) 为函数，T(n) 为非负整数，T(n) = a T(n / b) + f(n)，则有：</p><p><img src="C:\Users\陈冠豪\Desktop\Hexo-Blog\source\_posts\算法（1）\image-20230127163457999.png" alt="image-20230127163457999"></p><p>​        比如常见的二分查找算法，时间复杂度的递推方程为 T(n) = T(n / 2) + θ(1)，显然有 $n^{\log _b^a}⁡=n^0=Θ(1)$，满足 Master 定理第二条，可以得到其时间复杂度为 T(n) = θ(log n)。</p><p>​        再看一个例子，T(n) = 9 T(n / 3) + n，可知 $n^{\log_b^a}=n^2$，令ε取 1，显然满足 Master 定理第一条，可以得到 T(n) = θ(n ^ 2)。</p><p>​        来一个稍微复杂一点儿例子，T(n) = 3 T(n / 4) + n log n。$n^{\log_b^a}=O(n^{0.793})$，取ε = 0.2，显然当 c = 3 / 4 时，对于充分大的 n 可以满足 a <em> f(n / b) = 3 </em> (n / 4) <em> log(n / 4) &lt;= (3 / 4) </em> n <em> log n = c </em> f(n)，符合 Master 定理第三条，因此求得 T(n) = θ(n log n)。</p><p>​        运用 Master 定理的时候，有一点一定要<strong>特别注意</strong>，就是第一条和第三条中的ε必须<strong>大于零</strong>。如果无法找到大于零的ε，就不能使用这两条规则。</p><p>​        举个例子，T(n) = 2 T(n / 2) + n log n。可知 $n^{\log_b^a}=n$，而 f(n) = n log n，显然不满足 Master 定理第二条。但对于第一条和第三条，也无法找到大于零的ε使得 nlog⁡n=O$(n^{1−\varepsilon})$ 或者Ω$(n^{1−\varepsilon})$，因此不能用 Master 定理求解，只能寻求别的方式求解。比如可以利用递归树求出该算法的复杂度为 $T(n)=O(n\log^2n)$。简单的说一下计算过程：</p><p>​        递归树的建立过程，就像是模拟算法的递推过程。树根对应的是输入的规模为 n 的问题，在递归处理子问题之外，还需要 n log n 的处理时间。然后根据递推公式给根节点添加子节点，每个子节点对应一个子问题。这里需要两个子节点，每个节点处理规模为 n / 2 的问题，分别需要 (n / 2) <em> log(n / 2) 的时间。因此在第二层一共需要 n </em> (log n - 1) 的时间。第三层节点就是将第二层的两个节点继续分裂开，得到四个各需要 (n / 4) <em> log(n / 4) 时间的节点，总的时间消耗为 n </em> (log n - 2)。依此类推，第 k（设树根为 k = 0）层有 2 ^ k 的节点，总的时间为 n * (log n - k)。而且可以知道，这棵树总共有 log n 层（最后一层每个节点只处理规模为 1 的子问题，无须再分治）。最后将每一层消耗的时间累加起来，得到：</p><p><img src="image-20230127163854294.png" alt="image-20230127163854294"></p><h3 id="归并排序（MergeSort）"><a href="#归并排序（MergeSort）" class="headerlink" title="归并排序（MergeSort）"></a>归并排序（MergeSort）</h3><p>​        1）整体就很简单，就是一个简单的递归，左边排好序，右边排好序，然后整体就有序。</p><p>​        2）让其整体有序的方式用了排外序方法</p><p>​        3）继续使用master公式求解:$O(N\log N)$，空间复杂度O(N)</p><p>​        4）归并排序的实质</p><p>思路</p><p><img src="image-20230127164408704.png" alt="image-20230127164408704"></p><p>​        对于一块区域，我们使用指针访问：左右双指针法。开辟一块小空间，如果左边的大于右边的，左边指针拷贝同时指针后移一个，右边大于左边的同理。</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class Solution&#123;    public static void mergeSort(int[] arr)    &#123;        if(arr&#x3D;&#x3D;null||arr.length&lt;2)            return;        process(arr,0,arr.length-1);    &#125;    public static void process(int[] arr,int L, int R)    &#123;        if(L&#x3D;&#x3D;R)            return;      int mid &#x3D; left + ((right - left) &gt;&gt; 1);        process(arr,L,mid);        process(arr,mid+1,R);        merge(arr,L,mid,R);    &#125;    public static void merge(int[] arr,int L,int M,int R)&#123;        int[] helpSort&#x3D;new int[R-L+1];&#x2F;&#x2F;这是辅助空间        int i&#x3D;0;        int p1&#x3D;L;        int p2&#x3D;M+1;&#x2F;&#x2F;划分区域        while(p1&lt;&#x3D;M&amp;&amp;p2&lt;&#x3D;R)&#123;            helpSort[i++]&#x3D;arr[p1]&lt;&#x3D;arr[p2]?arr[p1++]:arr[p2++];            &#125;        while(p1&lt;&#x3D;M)&#123;           helpSort[i++]&#x3D;arr[p1++];        &#125;        while(p2&lt;&#x3D;R)&#123;            helpSort[i++]&#x3D;arr[p2++];        &#125;        for(i&#x3D;0;i&lt;helpSort.length;i++)&#123;            arr[L+i]&#x3D;helpSort[i];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C++:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;using namespace std; void Merge(int arr[],int low,int mid,int high)&#123;    &#x2F;&#x2F;low为第1有序区的第1个元素，i指向第1个元素, mid为第1有序区的最后1个元素    int i&#x3D;low,j&#x3D;mid+1,k&#x3D;0; &#x2F;&#x2F;mid+1为第2有序区第1个元素，j指向第1个元素    int *temp&#x3D;new(nothrow) int[high-low+1]; &#x2F;&#x2F;temp数组暂存合并的有序序列    if(!temp)&#123; &#x2F;&#x2F;内存分配失败        cout&lt;&lt;&quot;error&quot;;        return;    &#125;    while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;high)&#123;        if(arr[i]&lt;&#x3D;arr[j]) &#x2F;&#x2F;较小的先存入temp中            temp[k++]&#x3D;arr[i++];        else            temp[k++]&#x3D;arr[j++];    &#125;    while(i&lt;&#x3D;mid)&#x2F;&#x2F;若比较完之后，第一个有序区仍有剩余，则直接复制到t数组中        temp[k++]&#x3D;arr[i++];    while(j&lt;&#x3D;high)&#x2F;&#x2F;同上        temp[k++]&#x3D;arr[j++];    for(i&#x3D;low,k&#x3D;0;i&lt;&#x3D;high;i++,k++)&#x2F;&#x2F;将排好序的存回arr中low到high这区间arr[i]&#x3D;temp[k];    delete []temp;&#x2F;&#x2F;删除指针，由于指向的是数组，必须用delete []&#125; &#x2F;&#x2F;用递归应用二路归并函数实现排序——分治法void MergeSort(int arr[],int low,int high)&#123;    if(low&lt;high)&#123;        int mid&#x3D;(low+high)&#x2F;2;        MergeSort(arr,low,mid);        MergeSort(arr,mid+1,high);        Merge(arr,low,mid,high);    &#125;&#125; int main()&#123;    int a[10]&#x3D;&#123;5,1,9,3,7,4,8,6,2,0&#125;;    MergeSort(a,0,9);    for(int i&#x3D;0;i&lt;10;i++)        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩展我们的归并排序问题"><a href="#扩展我们的归并排序问题" class="headerlink" title="扩展我们的归并排序问题"></a>扩展我们的归并排序问题</h3><p>​        小和问题：对一个数组中，每个数左边比当前数小的数累加起来，叫做这个数的小和：请写一个程序：求解一个数组的小和。</p><p>Example:[1,3,4,2,5]产生的单个小和是[0,1,4,1,10],故数组的小和是16.</p><p>​        逆序问题：在一个数组中，左边的数如果比右边的数大，则这连哥哥数构成一个逆序对，请打印所有的逆序对。</p><p>​        （1）暴力解法是很简单的：对于位置i直接暴力遍历，但是$O(N^2)$</p><p>​        有没有更快的：有！</p><p>​        仔细思考一下：我们的小和可以这样产生！看一个数右边走，如果有别的数大于它就加一次这个数本身。如[1,3,4,2,5]：看1，右边四个数比他大，就加四次1，看3，右边两个数比他大，就加两个3，依次类推。。。</p><p>​        现在，我们对全数组进行二分。针对拆分后的数组一级一级使用我们新的求小和的过程，我们在比较的同时也排序：如：[1，3，4，2，5]下，拆分成2级[1,3,4]和[2,5]，然后又是:[1,3] [4]  和[2]  [5]最后是:[1] [3] [4] [2] [5]，现在返回去合并：[1,3]产生小和1，[1,3,4]产生1个1，1个3，（左侧小，左侧加小和，左侧移动指针到下一个，于是产生）[2,5]合并产生一个2，之后再次合并产生一个1，一个3，一个4，现在完事了：1+1+1+3+2+1+3+4=16</p><p>​        这个算法为什么是O(NlogN),就是因为排序的时候不需要在暴力遍历之后才知道有几个数比当前的数小。这才省略了新的遍历。</p><p>​        可能不一样的是：在这题里面，我们必须在左右数字相等的时候先拷贝右边的，再拷贝左边的.</p><p>​        （2）类似的，仍可以使用mergeSort，也就是说，只要产生小和操作就是说明产生了逆序。我们只要统计这个就好了</p><p>​        荷兰国旗问题：指定一个数，比他大的放右边，小的放左边，但是注意空间复杂度O(1)</p><p>​        思路：我们把使用两个指针。把小于num的放到左边，与小于区的下一个数字直接交换就好了。这样小于区右扩，否则指针直接右移。</p><p>​        荷兰国旗问题（2）：指定一个数，比他大的放右边，小的放左边，相等的放中间。但是注意空间复杂度O(1)</p><p>​        </p><p>​        还是类似，只不过有趣的是我们可以：</p><p>​        小于：[i]和小于区域的下一个交换，小于区东扩</p><p>​        相等：直接++</p><p>​        大于：[i]和大于区域的上一个交换，大于区西扩，但是i不动（我们还没排序那个交换过来的数嘞！）。</p><p>看看代码实现（看2就好了）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void swap(int* e1, int* e2)&#123;int temp &#x3D; *e1;*e1 &#x3D; *e2;*e2 &#x3D; temp;&#125;typedef struct Pair_ &#123;int pair1;int pair2;&#125;Pair;void arrangeArray(Pair* pair, int* arr, int arrsize,int sortnum)&#123;if (!pair &amp;&amp; !arr)return;if (arrsize &lt; 0)return;int* smaller &#x3D; &amp;arr[-1];int* bigger &#x3D; &amp;arr[10];int* check &#x3D; arr;while (check &lt; bigger)&#123;if (*check &lt; sortnum)&#123;swap(check, smaller + 1);check++;smaller++;&#125;else if (*check &#x3D;&#x3D; sortnum)&#123;check++;&#125;else&#123;swap(check, bigger - 1);bigger--;&#125;&#125;pair-&gt;pair1 &#x3D; smaller - arr;pair-&gt;pair2 &#x3D; bigger - arr;&#125;void PrintArr(int* arr, int arr_size)&#123;for (int i &#x3D; 0; i &lt; arr_size; i++)&#123;printf(&quot;%d &quot;, arr[i]);&#125;printf(&quot;\n&quot;);&#125;int main()&#123;int arr[10] &#x3D; &#123; 3,5,6,3,4,5,2,6,9,0 &#125;;PrintArr(arr, 10);Pair* p&#x3D;(Pair*)malloc(sizeof(Pair));p-&gt;pair1 &#x3D; 0;p-&gt;pair2 &#x3D; 0;arrangeArray(p, arr, 10, 5);PrintArr(arr, 10);printf(&quot;%d\n&quot;, arr[p-&gt;pair1]);printf(&quot;%d\n&quot;, arr[p-&gt;pair2]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        C++:</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;class Array &#123;public:void initVal(int* arr, int size) &#123;int* arrayData &#x3D; new int[size];for (int i &#x3D; 0; i &lt; size; i++)&#123;arrayData[i] &#x3D; arr[i];&#125;arraydata &#x3D; arrayData;arraysize &#x3D; size;&#125;void swapPartialData(int swap1,int swap2)&#123;int temp &#x3D; arraydata[swap1];arraydata[swap1] &#x3D; arraydata[swap2];arraydata[swap2] &#x3D; temp;&#125;void arrangeandSort(int sortnum)&#123;int smaller &#x3D; -1;int bigger &#x3D; arraysize;int check &#x3D; 0;while (check &lt; bigger)&#123;if (arraydata[check] &lt; sortnum)&#123;swapPartialData(check, smaller + 1);check++;smaller++;&#125;else if (arraydata[check] &#x3D;&#x3D; sortnum)&#123;check++;&#125;else&#123;swapPartialData(check, bigger - 1);bigger--;&#125;&#125;&#125;void PrintVal()&#123;for (int i &#x3D; 0; i &lt; arraysize; i++)&#123;std::cout &lt;&lt; arraydata[i] &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl;&#125;private:int* arraydata;int arraysize;&#125;;int main()&#123;int arr[10] &#x3D; &#123; 3,5,6,3,4,5,2,6,9,0 &#125;;Array a;a.initVal(arr, 10);a.PrintVal();a.arrangeandSort(5);a.PrintVal();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>​        快速排序请先把上面的代码琢磨明白：快速排序使得我们以一个数区分好了左右，排除掉标杆数我们只要对左右再次区分直到一个尽头结束。这次我们直接拿最后一个数当作标杆进行快排，这样我们就使得整个数组有序了。</p><p>​        这个思想还可以进一步优化：直接把标杆数（最后一个）直接放到中间，左右再递归。</p><p>​        当然，这个时间复杂度很不稳定：当划分值再中间的时候：</p><script type="math/tex; mode=display">T(n)=2T(\frac{T}{2})+O(N)</script><p>​        但是如果划分值再最左边和最右边：则就是经典排序为O($N^2$)。</p><p>​        我们继续改进：如果我们在一个划分区域随机选一个数，是不是就更多的避免了总是遇到最差情况？是的，这就是随机快速排序。这下，我们就可以</p><p><img src="image-20230130193038830.png" alt="image-20230130193038830"></p><p>​        对所有的情况求时间期望:$O(N\log N)$</p><h3 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h3><p>​        堆在逻辑结构上是一个完全二叉树。也就是说，每个非叶子节点必有左节点。怎么实现呢？我们可以将天然的一维数组视作一棵完全二叉树。</p><p><img src="C:\Users\陈冠豪\Desktop\Hexo-Blog\source\_posts\算法（1）\image-20230131092857709.png" alt="image-20230131092857709"></p><p>我们可以使用这个公式快速找到左孩子的节点下标：(i是当前节点的下标)</p><script type="math/tex; mode=display">I_{left}=2i+1</script><p>类似的：</p><script type="math/tex; mode=display">I_{right}=2i+2</script><p>父节点：</p><script type="math/tex; mode=display">I_{father}=\frac{i-1}{2}</script><p>完全二叉树的高度也可以求解：</p><script type="math/tex; mode=display">H=logN+1</script><p>堆在这个概念上派生：他是一个特殊的完全二叉树。大根堆中其父节点总是大于子节点，比如说</p><p><img src="C:\Users\陈冠豪\Desktop\Hexo-Blog\source\_posts\算法（1）\image-20230131093338557.png" alt="image-20230131093338557"></p><p>类比的：小根堆就是父节点总是小于子节点。怎么创建一个堆呢？</p><p>​        假设：我们有一个干净的数组，现在往数组里放数。现在，标记一下一个heapsize:他描述我们现在已经成型的堆的大小。显然刚开始heapsize一定是0！因为压根数没来呢！随着数进来，如果一个数比父节点大，那就准备交换父节点！</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">swap(arr[i],arr[(i-1)&#x2F;2]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        如果作为上一级的子节点还是比父节点大，那不就是又要交换？是的。这就是一个递归算法。但是如果相等呢？没关系，就停在那里就好了！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//不用担心0位置的问题，因为根节点的父节点还是他自己，取等依旧跳出循环</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">></span>add<span class="token punctuation">[</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>index<span class="token punctuation">,</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        index<span class="token operator">=</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><p>​        这下很容易了：arr[0]就是我们的最大值，返回出去就好了。那如果我们要把它抹掉，然后还是一个大根堆。这又如何？很简单，与最后一个数交换，或者是被覆盖。然后heapsize—.然后，我们让父节点和子节点比较。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index，<span class="token keyword">int</span> heapsize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//得到左孩子下标</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> index<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">//一旦left&lt;heapsize那显然我们的当前节点就没有孩子节点了</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>heapsize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//比较两个孩子节点谁大，把大的那个下标给largest</span>        <span class="token keyword">int</span> largest<span class="token operator">=</span>            <span class="token comment">//万一没右孩子嘞？判断一下！</span>            left<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>heapsize            <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span>            <span class="token operator">?</span> left<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">:</span> left <span class="token punctuation">;</span>        <span class="token comment">//父亲和孩子之间谁大？谁大把谁的下表交给largest</span>        largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span>        <span class="token comment">//如果到位了，退出循环！</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">==</span> largest<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//反之，交换，继续跑路</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>largest<span class="token punctuation">,</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        index<span class="token operator">=</span>largest<span class="token punctuation">;</span>        left <span class="token operator">=</span> index<span class="token operator">*</span> <span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        OK，现在我们的用户又抽风了，现在它随即指定一个节点变成?，那怎么怎么让他成为一个新的堆？很简单！如果变大了，只能往上走，就像上heapify,变小了那就是向下走。</p><p>​        算法复杂度如何？我们发现他就是遍历了树的高度：也就是说</p><script type="math/tex; mode=display">T(N)=O(\log N)</script><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>​        现在我们拿到一个数组，想要进行堆排序，就首先需要构建堆。使用heapInsert就好了。然后怎么排序？我们想到，heap总是确定最大值，只需要：最大值和最后一个值交换，在heapsize—再堆排序。这是一个逐步弹出最大值的算法排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Array</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">||</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> heapsize<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">--</span>heapsize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>heapSize<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">--</span>heapsize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            这个算法：空间复杂度:O(1) 时间复杂度: O(nlogn)</p><p>下面是C++版本：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class Array &#123;public:void Updatearray(int* arr, int size) &#123;int* trans &#x3D; new int[size];for (int i &#x3D; 0; i &lt; size; i++) &#123;trans[i] &#x3D; arr[i];&#125;this-&gt;array &#x3D; trans;this-&gt;arraysize &#x3D; size;&#125;void swap(int i1, int i2) &#123;int temp &#x3D; array[i1];array[i1] &#x3D; array[i2];array[i2] &#x3D; temp;&#125;int* getArrayDataPointer() &#123;return this-&gt;array;&#125;int getsize()&#123;return this-&gt;arraysize;&#125;void printArray() &#123;for (int i &#x3D; 0; i &lt; arraysize; i++)&#123;std::cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;&#125;std::cout &lt;&lt; std::endl;&#125;private:int* array;int arraysize;&#125;;class heapSort &#123;public:void heapInsert(Array a, int index) &#123;while (            a.getArrayDataPointer()[index]             &gt;             a.getArrayDataPointer()[(index - 1) &#x2F; 2]              )         &#123;a.swap(index, (index - 1) &#x2F; 2);index &#x3D; (index - 1) &#x2F; 2;&#125;&#125;void heapify(Array a, int index, int heapsize) &#123;int left &#x3D; 2 * index + 1;while (left &lt; heapsize) &#123;int largest &#x3D;left + 1 &lt; heapsize&amp;&amp;a.getArrayDataPointer()[left + 1] &gt; a.getArrayDataPointer()[left]? left + 1 : left;largest &#x3D; a.getArrayDataPointer()[largest] &gt; a.getArrayDataPointer()[index] ? largest : index;if (index &#x3D;&#x3D; largest)&#123;break;&#125;a.swap(largest, index);index &#x3D; largest;left &#x3D; index * 2 + 1;&#125;&#125;void heapsort(Array a) &#123;if (a.getArrayDataPointer() &#x3D;&#x3D; NULL || a.getsize() &lt; 2)&#123;return;&#125;for (int i &#x3D; 0; i &lt; a.getsize(); i++)heapInsert(a, i);int heapsize &#x3D; a.getsize();a.swap(0, --heapsize);while (heapsize &gt; 0) &#123;heapify(a, 0, heapsize);a.swap(0, --heapsize);&#125;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对于几乎排好序的（向我保证在-K~K内有序）数组，我们可以使用小根堆来排序，把小数往前弹就可以了。</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>​        这个算法跟之前的不一样，之前的算法都是基于比较的排序算法，现在介绍一个更逆天的算法：计数排序。这个算法的局限性极大：就是必须为整形，同时空间复杂度为O(N)，这样，我们得知了一个数据范围[K1,K2]，我们创造一个大小为[k2-k1+1]的数组，遇到一个数就在这个数对应的位置上+1，使用位置来衡量这个值的大小。随后，根据值来覆写数组。比如说统计到1的个数10，那就在数组里写10个1.但是，一旦数据量大起来就是寄！</p><p>​        现在，引入一个全新的算法：基数算法：我们首先确定数据的最大几位，对其他数字补齐0操作：如[72,100]-&gt;[072,100]就好了。然后基于个位数，创造10个桶。个位数是0的去0，1去1.。。以此类推，然后，从小到大导倒出来，随后比十位，再百位。。。以此类推</p><p>​        比如说：[17,13,25,100,72]-&gt;[ 017 , 013 , 025 , 100 , 072 ],然后个位入桶。再导出来</p><p><img src="image-20230131115105002.png" alt="image-20230131115105002"></p><p>然后把这个数组再倒入桶，这次按十位数</p><p><img src="image-20230131115241365.png" alt="image-20230131115241365"></p><p>然后把这个数组再倒入桶，这次按百位数</p><p><img src="image-20230131115325430.png" alt="image-20230131115325430"></p><p>倒出来，排好序了</p><p><img src="image-20230131115343881.png" alt="image-20230131115343881"></p><p>本质上，我们是按照位数排序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> _RadixSort<span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token operator">==</span><span class="token keyword">null</span><span class="token operator">||</span>arr<span class="token punctuation">.</span>length<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>         <span class="token function">radixsort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token function">maxbits</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>       <span class="token comment">//这个函数的本质是求解digit 表示最大的数有几个十进制位数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">maxbits</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> max<span class="token operator">=</span><span class="token class-name">Interger</span><span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            max<span class="token operator">=</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>max<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            res<span class="token operator">++</span><span class="token punctuation">;</span>            max<span class="token operator">/=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">//digit 表示最大的数有几个十进制位数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">L</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">,</span><span class="token keyword">int</span> digit<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> radix<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//准备空间</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">R</span><span class="token operator">-</span><span class="token class-name">L</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>d<span class="token operator">&lt;=</span>digit<span class="token punctuation">;</span>d<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token comment">//有多少位就进出多少次，从个位起步</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> count <span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>radix<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//这个代码统计数字频率，改进后则是统计小于等于该位置数的个数</span>             <span class="token comment">//这个count[i]表示小于等于i有count[i]个，数组代替了队列使得我们保证了后进后出</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token class-name">L</span><span class="token punctuation">,</span>i<span class="token operator">&lt;=</span><span class="token class-name">R</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                j<span class="token operator">=</span><span class="token function">getDigit</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>                count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span>radix<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//改进count</span>            count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>count<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token class-name">R</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token class-name">L</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token comment">//取出位数</span>            j<span class="token operator">=</span><span class="token function">getDigit</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//放到辅助数组</span>             bucket<span class="token punctuation">[</span>count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">//我们放置一个,就在频数上减一</span>            count<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">--</span>        <span class="token punctuation">&#125;</span>                <span class="token comment">//出桶</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token class-name">L</span><span class="token punctuation">,</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token class-name">R</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">,</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> d<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">/</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>d<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv in Pycharm</title>
      <link href="/2023/01/29/Opencv-in-Pycharm/"/>
      <url>/2023/01/29/Opencv-in-Pycharm/</url>
      
        <content type="html"><![CDATA[<h1 id="Pycharm下的opencv使用1：基本图像操作导论"><a href="#Pycharm下的opencv使用1：基本图像操作导论" class="headerlink" title="Pycharm下的opencv使用1：基本图像操作导论"></a>Pycharm下的opencv使用1：基本图像操作导论</h1><h3 id="在Pycharm中导入opencv"><a href="#在Pycharm中导入opencv" class="headerlink" title="在Pycharm中导入opencv"></a>在Pycharm中导入opencv</h3><p>​        笔者被C++实现的opencv干到心态炸裂了，所以这里先整一篇基于python的opencv的博客。</p><p>​        在pycharm中导入opencv很容易：只需要在Project的setting里给解释器安装上opencv-python库就好了。使用这个程序跑一下看看可不可以读取图像：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#向工程文件下新建一个img文件夹,放好你的图片，我这里放的是test.png</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20230129194508512.png" alt="image-20230129194508512"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2img_path<span class="token operator">=</span><span class="token string">"img/test.png"</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"Test img can be shown below!"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        跳出这个即为成功！开始你的opencv的欢乐时间！</p><p><img src="image-20230129194919800.png" alt="image-20230129194919800"></p><h3 id="计算机眼中的图片"><a href="#计算机眼中的图片" class="headerlink" title="计算机眼中的图片"></a>计算机眼中的图片</h3><p>​        在计算机眼中，图像由矩阵构成</p><p><img src="image-20230115212443109.png" alt="image-20230115212443109"></p><p>​        </p><p>​        数值的大小表明了图像的亮度，而通道表明了一个颜色：一个R通道上的255表明这是在Red上很亮</p><p>​        下面，我们来介绍一下我们应该怎么读取图像：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token comment">#不同于RGB，我们读取的格式是BGR</span><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment">#caution:the input should be the addr of the img</span>img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"\\imgpath!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>读取的结果是：一个nd array</p><p>好抽象：可不可以直接展示图片啊：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'img'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们试一下这个：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> showimg <span class="token keyword">as</span> simg<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'1.png'</span><span class="token punctuation">)</span>simg<span class="token punctuation">.</span>imgshow<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以封装一个函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cv_show</span><span class="token punctuation">(</span>nameWindow<span class="token punctuation">,</span>img<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">&#123;</span>     cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>nameWindow<span class="token punctuation">,</span>img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们也可以查看一个图片的大小：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">.</span>shape<span class="token comment">#(175, 286, 3)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们可以设置读入的方式：比如说读入灰度图</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"\\imgpath!"</span>，cv2<span class="token punctuation">.</span>IMREAD_GREYSCALE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存我们产出的图像</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span><span class="token string">'savedfilename'</span><span class="token punctuation">,</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 可以计算像素点的个数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>​        视频由图像组成，也就是说，我们可以读取视频：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">vc<span class="token operator">=</span>cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">'videofilepath'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        我们是不是读取成功了？这个看如下的代码判断：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> vc<span class="token punctuation">.</span>isOpened<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">open</span><span class="token punctuation">.</span>frame<span class="token operator">=</span>vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span><span class="token builtin">open</span><span class="token operator">=</span><span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们来运行的读取视频</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">while</span> <span class="token builtin">open</span><span class="token punctuation">:</span>ret<span class="token punctuation">,</span>frame<span class="token operator">=</span>vc<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> frame <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        <span class="token keyword">break</span>    <span class="token keyword">if</span> ret<span class="token operator">==</span><span class="token boolean">True</span><span class="token punctuation">:</span>        gray<span class="token operator">=</span>cv2<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>frame<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>COLOR_BGR2GRAY<span class="token punctuation">)</span>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">,</span>gray<span class="token punctuation">)</span>        <span class="token keyword">if</span> cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFF</span><span class="token operator">==</span><span class="token number">27</span><span class="token punctuation">:</span><span class="token comment">#按下ESC退出或者视频播放完毕</span>            <span class="token keyword">break</span>vc<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="截取部分图片（ROI）"><a href="#截取部分图片（ROI）" class="headerlink" title="截取部分图片（ROI）"></a>截取部分图片（ROI）</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imgread<span class="token punctuation">(</span><span class="token string">'Path'</span><span class="token punctuation">)</span>cat<span class="token operator">=</span>img<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">]</span>cv_show<span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">,</span>cat<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样我们就利用切片截取了部分图片了.</p><h3 id="颜色通道提取"><a href="#颜色通道提取" class="headerlink" title="颜色通道提取"></a>颜色通道提取</h3><p>我们可以分离图片，通过不同的颜色通道提取：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token operator">=</span>cv2<span class="token punctuation">.</span>split<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是效果：1，2，3分别代表b,g,r</p><p><img src="2.png" alt="2"> </p><p>1:</p><p><img src="b.png" alt="b"></p><p>2:</p><p><img src="g.png" alt="g"></p><p>3:<img src="r.png" alt="r"></p><p>当然也可以合回去：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token operator">=</span>cv2<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>b<span class="token punctuation">,</span>g<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们也可以单独保留，直接修改：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment">#只保留R</span>cur_img<span class="token operator">=</span>img<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>cur_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span>cur_img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="边界填充"><a href="#边界填充" class="headerlink" title="边界填充"></a>边界填充</h3><p>我们可以扩充图像，通过一些方式来对图像进行扩充：请看这里：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token comment">#定位点</span>replicate<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REPLICATE<span class="token punctuation">)</span>reflect<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT<span class="token punctuation">)</span>reflect101<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_REFLECT_101<span class="token punctuation">)</span>wrap<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_WRAP<span class="token punctuation">)</span>constant<span class="token operator">=</span>cv2<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img<span class="token punctuation">,</span>top_size<span class="token punctuation">,</span>bottom_size<span class="token punctuation">,</span>left_size<span class="token punctuation">,</span>right_size<span class="token punctuation">,</span>borderType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">,</span>value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        我们得到了五张图像，随后，我们使用imwrite输出图像，同时导入matplotlib的pyplot子库进行观察：</p><p>​        这是总的效果：</p><p><img src="matplot_version.png" alt="matplot_version"></p><p>​         仔细观察：</p><p><img src="replicate.png" alt="replicate"></p><p><img src="reflect.png" alt="reflect"></p><p><img src="reflect101.png" alt="reflect101"></p><p><img src="wrap.png" alt="wrap"></p><p><img src="constant.png" alt="constant"></p><p>​        第一张图是展示了</p><p>​        replicate：这个单词是复制的意思：直接复制最边缘的像素</p><p>​        reflect：对感兴趣的部分进行两边复制：fedcba|abcdef|fedcba</p><p>​        reflect101:但是是对最边缘的像素为对称轴进行复制:gfedcba|abcdefgh|gfedcba</p><p>​        wrap:外包装：cdefgh|abcdefgh|abcdefg</p><p>​        constant:对图像以默认黑值填充</p><h3 id="对图像进行数值操作"><a href="#对图像进行数值操作" class="headerlink" title="对图像进行数值操作"></a>对图像进行数值操作</h3><p>​        我们可以对numpy进广播操作。人话翻译成C++就是cv2库重载了运算符号，使之我们可以对矩阵进行广义的加法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_cat<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'cat.jpg'</span><span class="token punctuation">)</span>img_cat_GeneralAdd<span class="token operator">=</span>img_cat<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">;</span>img_cat<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>img_cat2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        在控制台上输出就可以发现矩阵里每一个数值都加上了一个10。</p><p><img src="image-20230129191422226.png" alt="image-20230129191422226"></p><p>​        （懒得自己跑，截个图）</p><p>​        那可不可以狭义相加呢？当然可以，结合线性代数的常识，相加的矩阵必须满足大小完全一致。假设我们已经满足了这个前提，直接相加得到的结果是不是就是放到矩阵的值呢？</p><p>​        显然不是！因为RGB有界，不可以超过255.在重载的+中，矩阵的RGB值自动%256，就是除以2256取它的余数放到矩阵里。那还有别的加法吗？有：使用方法add，传入cv2.add(img_cat,img_cat2)就可以了，达到255之后就不会取模，只会停在255不动</p><h3 id="图像叠加"><a href="#图像叠加" class="headerlink" title="图像叠加"></a>图像叠加</h3><p>​        我们也可以对图像进行叠加。但是注意，我们首先要调整图像大小一致：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_cat<span class="token punctuation">.</span>shapeimg_dog<span class="token operator">=</span>imread<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token comment"># path是路径</span>img_dog<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_dog<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">/</span><span class="token operator">*</span>size required to resize<span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="image-20230129192417117.png" alt="image-20230129192417117"></p><p>​        同样的还有其他resize方法：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">required_pic<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_required_resize<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>fx<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>fy<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这是个什么玩意呢？指的是我们依照某个点把图像在X轴上拉长3倍数，Y轴不变。</p><p>​        现在，我们使用addWeighted来叠加图像，以混合图片特征。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">res<span class="token operator">=</span>cv2<span class="token punctuation">.</span>addWeighted<span class="token punctuation">(</span>img_cat<span class="token punctuation">,</span><span class="token number">0.4</span><span class="token punctuation">,</span>img_dog<span class="token punctuation">,</span><span class="token number">0.6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">#img_cat*0.4+img_dog*0.6+0//最后一项是亮度提升</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h3><p>​        我们可以使用一些参数，对图像进行有条件的处理</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ret<span class="token punctuation">,</span>dst<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>src<span class="token punctuation">,</span>thresh<span class="token punctuation">,</span>maxval<span class="token punctuation">,</span><span class="token builtin">type</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>src:输入，只能输入单通道图像，通常是灰度图</p><p>dst：输出图</p><p>thresh:执行阈值</p><p>maxval:超过或小于阈值后所赋予的值</p><p>type:方法，如下：</p><p>1.cv2.THRESH_BINARY：超过阈值的取maxval,否则取0</p><p>2.cv2.THRESH_BINARY_INV反过来</p><p>3.THRESH_TRUNC大于阈值的设置成阈值</p><p>4.THRESH_TOZERO大于阈值的不变，否则设置成0</p><p>5.THRESH_TOZERO_INV反转</p><p>我们依旧使用matplotlib的pyplot库放送一下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltimg<span class="token operator">=</span>cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'2.png'</span><span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh1<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_BINARY<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh2<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_BINARY_INV<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh3<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TRUNC<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh4<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO<span class="token punctuation">)</span>ret<span class="token punctuation">,</span>thresh5<span class="token operator">=</span>cv2<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>img<span class="token punctuation">,</span><span class="token number">127</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>THRESH_TOZERO_INV<span class="token punctuation">)</span>titles<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Original Image'</span><span class="token punctuation">,</span><span class="token string">'BINARY'</span><span class="token punctuation">,</span><span class="token string">'BINARY_INV'</span><span class="token punctuation">,</span><span class="token string">'THRESH_TRUNC'</span><span class="token punctuation">,</span><span class="token string">'TOZERO'</span><span class="token punctuation">,</span><span class="token string">'TOZERO_INV'</span><span class="token punctuation">]</span>images<span class="token operator">=</span><span class="token punctuation">[</span>img<span class="token punctuation">,</span>thresh1<span class="token punctuation">,</span>thresh2<span class="token punctuation">,</span>thresh3<span class="token punctuation">,</span>thresh4<span class="token punctuation">,</span>thresh5<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'gray'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>titles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>plt<span class="token punctuation">.</span>yticks<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看看：</p><p><img src="Figure_1.png" alt="Figure_1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高等数学教程（1）</title>
      <link href="/2023/01/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/28/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="高等数学教程笔记1"><a href="#高等数学教程笔记1" class="headerlink" title="高等数学教程笔记1"></a>高等数学教程笔记1</h1><h2 id="极限运算与函数分析基础"><a href="#极限运算与函数分析基础" class="headerlink" title="极限运算与函数分析基础"></a>极限运算与函数分析基础</h2><h4 id="函数与极限"><a href="#函数与极限" class="headerlink" title="函数与极限"></a>函数与极限</h4><p>函数部分主要是奠基于高中的一些基础，这里做一些简单的复习</p><p>1.映射与函数</p><p>首先来了解以下映射：4</p><p>​        先定义X，Y是两个非空集合。现在有一个法则f，使得X中的每个元素$x$（$X$={$x_0$,$x_1$,$x_2$,…}）,都有<strong>唯一</strong>的y($Y$={$y_0$,$y_1$,$y_2$,$y_3$,…})与之对应。那么，我们称f是一个<strong>映射</strong>。</p><p>​        也就是说，这个定义是围绕f的。他是一个这样的法则（或者说规则）让两个非空的集合建立起如定义所言的联系，仅此而已。</p><p>​        也不必太过担心，映射在这本笔记里大概不会再次出现了。</p><p>不过，我们把它引出来必有我们的目的：回过头来，我们实际上用一大长串定义干了这样一件事：</p><script type="math/tex; mode=display">{X}\xrightarrow{f}Y</script><p>现在，让我们开始取其名字：</p><p>X：是一个定义域，有写法D,或者写法更明确一些：$D_f$</p><p>实际上这是Domain的意思</p><p>Y：是一个值域，有写法R,或者同样更明确一些：$R_f$</p><p>实际上这是Range的意思。</p><p>至于：f，我们刚刚讲过了，这就是一个法则，表明一种对应关系。</p><p>依然有这样的更简单的写法：</p><script type="math/tex; mode=display">X\xrightarrow{f}R_f</script><p>重复一些以下的要点：</p><p>（1）上述定义阐述了三要素：X（定义域），f(法则)，Rf(对应值域)</p><p>（2）对于x属于X这回事，对应的y是唯一的。不可以又对应y1同时对应y2.</p><p>Q:可以多个x对应一个y吗？可以！事实上，用图片表示是这样的：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221226141035208.png" alt="image-20221226141035208"></p><p>（3）Rf属于Y，但不是Y！！！但特别的：当Rf=Y下，我们又称这样厉害的f叫满射。</p><p>（4）在众多的映射中，还有一种特殊的映射：单射。人话就是一一对应</p><p>（5）那么，又是单射又是满射如何？这又有名字：一一映射（一夫一妻）因为必须全部对应且一一对应。</p><p>正过来叫映射，倒过来又如何？</p><p>设 f有如下关系：</p><script type="math/tex; mode=display">X\longrightarrow{Y}</script><p>是一个单射，那么，我们可以倒过来：对于Y属于Rf而言都有唯一的一个$x$属于$X$.这又是一组对应关系，不过是倒过来的。记作如下：</p><script type="math/tex; mode=display">g:R_f\longrightarrow{X}</script><p>这样看不出什么联系，我们采用与 f 相关的表示：</p><script type="math/tex; mode=display">f^-1:D_{f^-1}\longrightarrow{D_f}</script><p>好吧，太复杂了，好好回味一下，我们继续折磨：</p><p>现在我们来看这样一个内容：</p><p>在学习完映射之后，我们来看这样的一个D(定义域),且</p><script type="math/tex; mode=display">D\subset{R}</script><p>换而言之，这个数集是R里的一部分，而f是一个使得：</p><script type="math/tex; mode=display">f:D\longrightarrow{R}</script><p>的映射。</p><p>那么，这样来看我们构造了一个映射使得一个实数集映射到了另一个实数集上。这样的映射有一个大家熟悉的名字：函数，简记作：</p><script type="math/tex; mode=display">y=f(x),x\in{D}</script><p>这下看懂了：</p><p>x是一个自变量，y是一个因变量 ，定义域为D，值域是R（不是实数集的R！！！）</p><p>构成一个函数的两要素，就可以从动态的角度来看了，这使得我们信息的表达可以更为浓缩：$D_f$ ,$ f$ 就可以了</p><p>函数的表达有三种：表格法，图形法，解析法。这个是大家高中就已经熟知的了</p><p>说完了定义和表示，我们来看一个函数最广泛的几个性质：</p><h4 id="1-有界性"><a href="#1-有界性" class="headerlink" title="1.有界性"></a>1.有界性</h4><p>听名字就知道：表明的是一些函数可能是有界限的。但这样的表达不规范。</p><p>仔细思考，函数的界限分为两种：不大于一个数和不小于一个数（当然，也可以说是小于一个数或者是大于一个数）</p><p>那么，我们说：对于总是一个小于一个数或者是不大于一个数的函数，我们说他有上界。表达是这样的：</p><script type="math/tex; mode=display">\exists{k_1},f(x)\leqslant{k_1}</script><p>这是什么东西呢？先别急，它还有另一个符号，也是在数学中相当常见的：$\exists$ , $\forall$</p><p>上面的两个符号，一个表示：存在；另一个表示任意。</p><p>那么，上界是唯一的吗？不是的。比如说：</p><script type="math/tex; mode=display">f(x)=x , x\in{(-\infty,1]}</script><p>这就有无穷个上界：可以是1，可以是2，可以是$\pi$…总而言之，并不唯一。</p><p>那么与之对应的，还会有一个下界：</p><script type="math/tex; mode=display">\exists{k_2} ,f(x)\geqslant{k_2}</script><p>我们说：对于总是一个大于一个数或者是不小于一个数的函数，我们说他有下界。</p><p>同样的，下界也不唯一。</p><p>这在我们后面证明极限的存在时是很有必要的！！！</p><p>统称起来，我们就可以说：函数是有界的：上下界都有！总而言之，这种情况称为有界的。反之，一个函数若是既没有上界有没有下界，或者是只有上界，或者是只有下界，则称这个函数无界。用数学符号定义有界是这样的：</p><script type="math/tex; mode=display">\exists M>0,|f(x)|\leqslant{M}</script><p>那么，无界的是这样定义的：</p><script type="math/tex; mode=display">\forall{M}>0,\exists x_1\in{x},|f(x)|>M</script><h4 id="2-单调性"><a href="#2-单调性" class="headerlink" title="2.单调性"></a>2.单调性</h4><p>这个性质是讨论函数的变化趋势的：是增加还是减少？我们用这个性质衡量：</p><p>当在一个区间里：</p><script type="math/tex; mode=display">x_1<x_2,f(x_1)<f(x_2)</script><p>这样的性质叫单调递增，</p><p>反之：</p><script type="math/tex; mode=display">x_1 < x_2,f( x_1 )>f( x_2 )</script><p>这样的性质叫单调递减，但是注意，这称之为严格单调，后面我们会讲述什么是严格单调什么是广义单调的。</p><h4 id="3-奇偶性"><a href="#3-奇偶性" class="headerlink" title="3.奇偶性"></a>3.奇偶性</h4><p>首先声明一点：我们的函数的定义域必须对称：也就是说：函数的$D_f$必须关于原点对称：</p><p>实数域$R$是对称的，$[-1,1]$是对称的，以此类推。当：$f(x)=f(-x)$时，我们称呼这样的函数是一个偶函数，反之：$f(-x)=-f(x)$或者$-f(-x)=f(x)$ 则称之为奇函数。</p><p>有趣的是：在图像法表达函数时：奇函数关于原点对称，偶函数关于$y$轴对称。</p><h4 id="4-周期性"><a href="#4-周期性" class="headerlink" title="4.周期性"></a>4.周期性</h4><p>有一些函数很有意思，伴随$x$的增大，我们甚至可以看到$f(x)$会有周期的重现。这时候，我们说这个函数具有周期性，用数学语言的表达是如下的：</p><script type="math/tex; mode=display">\exists l>0 , f(x+l)=f(x)</script><p>这个$l$就是周期，同时，我们讨论的周期常常是最小正周期。</p><p>比如说：</p><script type="math/tex; mode=display">y=\sin(x)</script><p>这个函数的（最小正）周期就是2$\pi$。</p><p>但是，不是所有的函数都有最小的正周期。如</p><script type="math/tex; mode=display">D(x)=\begin{cases}1 &  x\in{Q}\\ 0 & x\in{Q^C} \\\end{cases}</script><h4 id="5-反函数"><a href="#5-反函数" class="headerlink" title="5.反函数"></a>5.反函数</h4><p>有点像逆映射的感觉了：</p><p>设$f:D\rightarrow{f(D)}$是一个单射，且$f$单调 则有$f^-1:f(D)\rightarrow{D}$ ，且$f^-1$单调，单调性跟 $f$一致</p><p>那么称$x=f^-1(y)$ 是$y=f(x)$的反函数，且这两个函数的图像是关于$y=x$对称的</p><h4 id="6-复合函数"><a href="#6-复合函数" class="headerlink" title="6.复合函数"></a>6.复合函数</h4><p>引入两个函数：$y=f(t) , t=g(x)$ ,把$t$换成$g(x)$，我们就得到了一个复合函数$f(g(x))$。</p><p>值得注意的是：我们如此操作是把 $t =g(x)$视作了一个自变量， $t$的取值范围（f(x)的自变量范围）由我们的$g(x)$决定了，这就是$g(x)$的值域决定了$f(x)$的定义域， 于是，复合函数想要有定义，其$g(x)$的值域必须在$f(x)$的定义域内部才可以。</p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>下面引入两个函数：$f(x),g(x)$ 其中：其定义域以次为$D_f,D_g$ ，产生的新函数的定义域为$D=D_f\cap{D_g}$</p><p>函数的和差：</p><script type="math/tex; mode=display">(f\pm{g})(x)=f(x)\pm{g(x)}</script><p>函数的乘积：</p><script type="math/tex; mode=display">(f\cdot{g})(x)=f(x)\cdot{g(x)}</script><p>函数的相除：</p><script type="math/tex; mode=display">(\frac{f}{g})(x)=\frac{f(x)}{g(x)}, g(x)\neq0</script><h4 id="常见的初等函数"><a href="#常见的初等函数" class="headerlink" title="常见的初等函数"></a>常见的初等函数</h4><p>幂函数：$y=a^{\mu}$</p><p>指数函数:$y=a^x$</p><p>对数函数$y=log_a{x}$, 当$a=e$时，记作：$y=e^x$</p><p>特别的：当$a=e$时，又记成$y=\ln(x)$，当$a=10$时，又记成 $y=\lg(x)$.</p><p>三角函数：$\sin(x)$</p><p>反三角函数:$\arcsin(x)$</p><p>所有的这些函数经过有限次数的组合，运算得到的函数都是初等函数。</p><h2 id="极限定义与使用"><a href="#极限定义与使用" class="headerlink" title="极限定义与使用"></a>极限定义与使用</h2><h4 id="数列的极限的定义"><a href="#数列的极限的定义" class="headerlink" title="数列的极限的定义"></a>数列的极限的定义</h4><p>​            数列可以简单的理解为一列数：按照一定的规律排放：{$x_1,x_2,x_3,x_4,x_5…$}，我们简记作：$\{x_n\}$（注意到N是无穷大的）,比如说：</p><p>​                                                        $\{\frac{1}{2^n}\}$:$\{\frac{1}{2},\frac{1}{4},\frac{1}{8},\frac{1}{16}…\}$</p><p>其中，我们单取出来一项：这是数列的一个项。对于$\frac{1}{2^n}$这个东西，则我们叫做一般项：因为我们可以通过带入N的值来求得第N项的值来。</p><p>​        再来看一些数列：</p><p>​                                            $\{\frac{1}{n}\}$:{1,$\frac{1}{2},\frac{1}{3},\frac{1}{4},\frac{1}{5},\frac{1}{6},\frac{1}{7}$…}</p><p>​        这些数列似乎都随着N的增大逼近一个数，比如说，上面的这些数列都在$N\rightarrow\infty$下，{$x_n$}都在逼近一个数，比如和上面两个都在向0逼近。</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221227094255924.png" alt="image-20221227094255924"></p><p>​        这是$\{\frac{1}{n}\}$在数轴上的表示：当N越来越大下，数代表的点越来越靠近0代表的点。</p><p>我们称数列随着$N\rightarrow\infty$下，逼近的那一个数称之为这个数列的极限。</p><p>​        大概如此，所以我们来看看数学分析下定义的极限：</p><p>​        定义：$\{x_n\}$作为一个数列，$\forall \varepsilon&gt;0$，总$\exists{N},$当$n&gt;N$下，$|x_n-a|&lt;\varepsilon$</p><p>​        好吧，看一脸懵逼。那这个是什么意思呢？为什么引出这个抽象的定义？</p><p>​        注意到：$\forall \varepsilon&gt;0$ :这个是表明任意的一个$ \varepsilon$，只要它大于0都算，都要让上面的式子成立。</p><p>​        这就是说，我的$ \varepsilon$可以取得任意的小，多小都得行！，而$\exists{N},$表明了存在数列的一个项：使得在之后的项（这在$n&gt;N$已经说明白了）都与一个数a的差的绝对值（嘛，就是之后的项与这个数a的距离）为任意小。还不是相等，是一个动态的过程，因为如同</p><p>$\{\frac{1}{n}\}$中$n=10000000000000$一样，只是$x_n=\frac{1}{10000000000000}$罢了，但绝对不是0！但是，伴随这N取的越来越大，我们的{$x_n$}会越来越逼近0的。这描述的是一个动态的过程。</p><p>下面我们来引入一道经典例题：</p><p>​                                                            $2,\frac{1}{2},\frac{4}{3},\frac{3}{4}…\frac{n+(-1)^{n-1}}{n}$</p><p>​        这个数列的极限如何？</p><p>​        首先分析以下大通项：$\frac{n+(-1)^{n-1}}{n}$，它可以做出分离：$1+\frac{(-1)^{n-1}}{n}$ 注意到$(-1)^{n-1}$是一个震荡的数，在-1与1之间震荡，如果看作是一个函数的话，他是有界的，而$\frac{1}{n}$或者是$-\frac{1}{n}$无论如何都会随N增大而趋向于0.那么，这个数列的极限很明了了：</p><p>​    那我们使用数列的极限来证明：</p><p>​    $证明：$</p><p>​    $    因为 |x_n-1|=|\frac{(-1)^{n-1}}{n}|=\frac{1}{n}$</p><p>​    $于是\forall \varepsilon&gt;0,取{N=[\frac{1}{n}]+1}, 此时|x_n-1|=|\frac{(-1)^{n-1}}{n}|=\frac{1}{n}&lt;\varepsilon$</p><p>​    于是数列的极限是1.</p><p>​    我们再来看一个例题：</p><p>​    证明：$x_n=\frac{(-1)^n}{(n+1)^2}$的极限是0：</p><p>​    这是好说的：我们照猫画虎：</p><p>​    $证明：$</p><p>​    $    因为：|x_n-1|=\frac{1}{(n+1)^2}&lt;\frac{1}{n^2}$</p><p>​    $于是\forall \varepsilon&gt;0，取N=[\frac{1}{\sqrt{ \varepsilon}}]+1,此时有 |x_n-1|=\frac{1}{(n+1)^2}&lt;\frac{1}{n^2}&lt;\varepsilon$</p><p>​    于是数列的极限为0.</p><p>​    收敛数列的性质：</p><p>​    我们讨论一个收敛数列，是要关注他有什么特性的：</p><p>​    显然：</p><p>（1）收敛数列的极限唯一。</p><p>​    不太好证，所以我们来引入反证法：</p><p>​    证明：假设$x_n\rightarrow{a}同时x_n\rightarrow{b}$ ($a\neq{b}$),我们取$\varepsilon=\frac{b-a}{2}$（1）,</p><p>​    $于是：\exists{N_1},当n&gt;N_1下 |x_n-a|&lt;\frac{b-a}{2}$（2）</p><p>​    同时，又有$\exists{N_2},当n&gt;N_2下 |x_n-b|&lt;\frac{b-a}{2}$</p><p>​    这个时候，我们处理一下上面的式子：（展开我们的绝对值写成不等式）</p><p>​    此时由（1）得到的是：$x_n&lt;\frac{a+b}{2}$</p><p>​    由（2）得到的是：$x_n&gt;\frac{a+b}{2}$</p><p>​    毫无疑问这是矛盾的。所以，我们的极限不可以同时趋近于两个数。</p><p>​    （2）收敛数列一定有界。</p><p>​    证明：设$\lim\limits_{n\to+\infty}{x_n}=a$，此时此刻，我们可以随意的取一个$\varepsilon=1,\exists {N},当n&gt;N下，|x_n-a|&lt;1$</p><p>​    这个时候：</p><p>​    $    |x_n|=|x_n-a+a|\leqslant|x_n-a|+|a|&lt;1+|a|$</p><p>​        这显然符合有界的定义。但是呢？这是保证了$x&gt;N$的形况下，这个时候，我们只需要取出$M=max\{x_1,x_2,…x_N,1+|a|\}$（取出前N个里中最大的与1+$|a|$中还要大的那个，此时，M就是$\{x_n\}$下最大的一项了），这下子：$x_n\leqslant{M}$肯定有界了</p><p>（3）收敛数列具有保号性</p><p>​        这是什么意思呢？就是说：如果一个数列的极限为正（为负），那么，我们的数列在某一项之后肯定都是正的（负的）</p><p>​        数学的表达是这样的：</p><p>​        $\lim\limits_{n\to+\infty}{x_n}=a$,且$a&gt;0$，$\exists{N},$当$n&gt;N下,x_n&gt;0$</p><p>证明：</p><p>​        $a&gt;0$时，取$\varepsilon=\frac{a}{2}&gt;0,\exists{N},$当$n&gt;N$下,$|x_n-a|&lt;\frac{a}{2},$此后，我们的$0&lt;\frac{a}{2}&lt;x_n&lt;\frac{3a}{2}$</p><p>证毕。</p><p>​        反过来讲，如果数列从一项起都大于（小于）0，并且：$\lim\limits_{n\to+\infty}{x_n}=a$，那么：$a\geqslant0(\leqslant0)$</p><p>​    （4）收敛数列的任意子数列都收敛于同一极限</p><p>子数列：就是从原本的数列中抽取一些元素组成一个全新的数列。</p><p>$x_{n_k}$就是一种表示。</p><p>​        证明:</p><p>记：$\{x_{n_k}\}$是$\{x_{n}\}$的一个子数列，并且$\lim\limits_{n\to+\infty}{x_n}=a$</p><p>则$\forall \varepsilon&gt;0,\exists N&gt;0,n&gt;N下$</p><p>$|x_n-a|&lt;\varepsilon,这时，我们取K=N,k&gt;K时，n_k&gt;n_K=n_N\geqslant{N}$</p><p>${|x_{n_k}-a|}&lt;\varepsilon$</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145330449.png" alt=""></p><p>​        于是，我们又多了一种证明方式：如果一个数列中，存在两个子数列收敛于不同的极限，则我们说这个数列是发散。</p><p>补充：</p><p>​        反三角函数：三角函数的反函数时反三角函数。有如下的对应关系：</p><p>$sin(x)\rightarrow{arcsin(x)}$</p><p>$cos(x)\rightarrow{arccos(x)}$</p><p>$tan(x)\rightarrow{arctan(x)}$</p><p>​        实际上，就是$x=siny$的离谱写法我们看不惯，于是我们选择用一个全新的表达来表达一个全新的函数</p><p>​        图像上，回忆第一小节的笔记，图像关于$y=x$对称，做出来的图像就如下图所示：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145914221.png" alt="image-20221228145914221"></p><p>​        同时，为了保证是函数（还是第一小节的知识），截取我们的函数得到：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228145933050.png" alt="image-20221228145933050"></p><p>​        于是：$x\in[-1,1],y\in[-\frac{\pi}{2},\frac{\pi}{2}]$</p><p>​        一些常见的函数值对应表：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228150223124.png" alt="image-20221228150223124"></p><p>其他的：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221228150313511.png" alt="image-20221228150313511"></p><h5 id="（二）函数的极限"><a href="#（二）函数的极限" class="headerlink" title="（二）函数的极限"></a>（二）函数的极限</h5><p>​        1）$x\rightarrow{a}$下的函数极限</p><p>​        $f(x)$在$x_0$的去心领域内有定义，在我们的$x\rightarrow{a}$之下（这就意味着$x=a$处是可以没有定义的！！！这很重要，后面还会有其他类似的概念！！！）,当$\exists A,\forall\varepsilon&gt;0,\exists{\delta}&gt;0,使得在0&lt;|x-x_0|&lt;\delta时：|f(x)-A|&lt;\varepsilon$.这一大长串，简记成如下：</p><p>法1）$\lim\limits_{x\rightarrow{x_0}}f(x)=A$</p><p>法2)$f(x)\rightarrow{A}(x\rightarrow{x_0})$</p><p>​        这定义还是很抽象：我们用人话讲：就是只要$x到{x_0}$是充分接近的，$f(x)$到$A$的距离可以为任意小。</p><p>​        但是，我们的${x}$可以从左右两侧逼近于${x_0}$，这就要求我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。</p><p>下面我们就使用这个定义来证明一些命题：</p><p>$(1)\lim\limits_{x\rightarrow x_0}C=C$</p><p>证明：$\forall\varepsilon&gt;0,\exists\delta=N(N&gt;0)$</p><p>使得$0&lt;|x-x_0|&lt;\delta,|f(x)-A|=0,这明显小于\varepsilon$</p><p>证毕</p><p>$(2)\lim\limits_{x\rightarrow{1}}(2x-1)=1$</p><p>证明：</p><p>$\forall\varepsilon&gt;0,\exists\delta=\frac{\varepsilon}{2}(N&gt;0)$</p><p>使得$0&lt;|x-1|&lt;\delta,|f(x)-A|=2|x-1|&lt;\varepsilon$</p><p>$(3)\lim\limits_{x\rightarrow{1}}\frac{x^2-1}{x-1}=2$</p><p>证明：</p><p>$\forall\varepsilon&gt;0,\exists\delta={\varepsilon}(N&gt;0)$</p><p>使得$0&lt;|x-1|&lt;\delta,|f(x)-A|=|x-1|&lt;\varepsilon$</p><p>证毕</p><p>​        回到我刚刚讲到的：因为我们的${x}$可以从左右两侧逼近于${x_0}$，这就要求我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。为了方便描述，我们引入左，右极限的概念来描述从左侧右侧来逼近函数一点时产生的极限</p><p>左极限:$\lim\limits_{x\rightarrow{x_0^-}}f(x)=A$</p><p>右极限:$\lim\limits_{x\rightarrow{x_0^+}}f(x)=A$</p><p>那么，回到这个定义：</p><p>​        $f(x)$在$x_0$的去心领域内有定义，在我们的$x\rightarrow{a}$之下（这就意味着$x=a$处是可以没有定义的！！！这很重要，后面还会有其他类似的概念！！！）,当$\exists A,\forall\varepsilon&gt;0,\exists{\delta}&gt;0,使得在0&lt;|x-x_0|&lt;\delta时：|f(x)-A|&lt;\varepsilon$.</p><p>​    其中$x$怎么趋近的方式是已经确定的，于是上面的$|x-x_0|$就可以拆成$x-x_0$或者是$x_0-x$了</p><p>那么，我们再次阐述：</p><p>​        我们的函数必须左右两侧方式逼近同一点时，我们的函数值相同。</p><p>这个定理：$x\rightarrow{x_0}$,$f(x)$的极限存在$\Leftrightarrow$ 左右极限存在且相等</p><p>比如说</p><p>$\begin{equation}f(x)=\left\{\begin{array}{cl}x+1 &amp;  x &gt; 0 \\0  &amp;  x = 0 \\x-1 &amp;  x &lt; 0 \\\end{array} \right.\end{equation}$</p><p>$\lim\limits_{x\rightarrow{0^-}}f(x)=-1$</p><p>$\lim\limits_{x\rightarrow{0^+}}f(x)=1$</p><p>两者不相等，于是$f(x)$在0处的极限是不存在的。</p><p>​        2）$x\rightarrow{\infty}$下的函数极限</p><p>​        假设啊，我们的函数在无穷远处有定义的：这个时候，我们的$x$越远，我们的函数值越是接近某一个数。用数学语言表达是这样的：</p><p>​        $\forall{\varepsilon}&gt;0,\exists X&gt;0,\mbox{使得}|x|&gt;X时，|f(x)-A|&lt;\varepsilon$</p><p>此时，我们简记作$\lim\limits_{x\rightarrow{\infty}}=A$</p><p>例题：</p><p>​        $(1)\lim\limits_{x\rightarrow{\infty}}{\frac{1}{x}=0}$</p><p>证明：</p><p>​        $\forall{\varepsilon}&gt;0,\exists X=\frac{1}{\varepsilon},\mbox{使得}|x|&gt;X时，|\frac{1}{x}|&lt;\varepsilon$</p><p>证明完毕</p><p>​        </p><p>​        说完了，让我们谈谈性质</p><p>​        1)函数的极限唯一性</p><p>​        2)函数的局部有界限：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,\exists{M&gt;0},\forall{\delta&gt;0},0&lt;|x-x_0|&lt;\delta时，|f(x)|\leqslant{M}$</p><p>​        3)局部保号性：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,A&gt;0,\exists{\delta&gt;0}则在0&lt;|x-x_0|&lt;\delta,f(x)&gt;0$</p><p>​        4）$Henn$定理：$\lim\limits_{x\rightarrow{x_0}}f(x)=A,\{x_n\}\rightarrow{x_0},\lim\limits_{n\rightarrow{\infty}}f(x_n)=\lim\limits_{x\rightarrow{x_0}}f(x)$</p><h6 id="无穷小和无穷大"><a href="#无穷小和无穷大" class="headerlink" title="无穷小和无穷大"></a>无穷小和无穷大</h6><p>​        无穷小：趋于0的一个量（动态的！），是正是负和0都叫无穷小。同时，无穷小除了0意外，无穷小都不确定。具体的定义是这样的：</p><p>​        定义：$x\rightarrow{x_0}(x\rightarrow{\infty})$时，$f(x)$ 的极限为0，称$f(x)$是当$x\rightarrow{x_0}(x\rightarrow{\infty})$下的无穷小</p><p>​        这么说来，无穷小并不唯一，有无穷多个无穷小</p><p>下面介绍以下无穷小的一些性质:</p><p>​        定义$a,b$是两个无穷小</p><p>​        $a+b$是一个无穷小；</p><p>​        $a-b$是一个无穷小;</p><p>​        $a\times b$是一个无穷小;</p><p>​        $c\times{a}$是一个无穷小;</p><p>​        注意！！！$a\div{b}$是未定式，在没有给定a,b的具体情况，我们是不知道这个值究竟是多少的！它本身可以是任何数！！！</p><p>​        无穷大：这个有特定的符号：$\infty$</p><p>​        他也是有定义的：$\lim\limits_{ {x\rightarrow{x_0} } }f(x)= \infty$或者$\lim\limits_{ {x\rightarrow{\infty} } }f(x)=\infty$</p><p>​        注意！！！注意！！！无穷大可以是正无穷大或者是负无穷大！！！于是</p><p>​        引入两个无穷大记作$a,b$</p><p>​        无论是$a+b还是a-b$都是未定义的</p><p>​        但是$a\times{b}$一定是无穷大，$c\times{ \infty }(c\neq{ 0 })$一定是无穷大</p><p>​        $a\div{ b }$结果未知</p><p>​        定理：$f(x)$如果是无穷大，那么$\frac{1}{f(x)}$是无穷小。</p><p>​        $f(x)$如果是无穷小，那么$\frac{1}{f(x)}$是无穷大。（$f(x)\neq{0}$）</p><p>​        极限运算法则</p><p>​        法则1：两个甚至是若干有限个的无穷小的和是无穷小的</p><p>​        <strong>法则2：有界函数与无穷小的乘积是无穷小</strong></p><p>​        推论：常数乘以无穷小还是无穷小</p><p>​                    有限个无穷小的乘积还是无穷小</p><p>​        定理：记：$\lim{f(x)}=A,\lim{g(x)}=B$</p><p>​        1)$\lim{f(x)\pm{g(x)}}=A\pm{B}$</p><p>​        2)$\lim{f(x)\times{g(x)}}=A\times{B}$</p><p>​        3)$\lim{\frac{f(x)}{g(x)}}=\frac{A}{B}(B\neq{0})$</p><p>​        4)$\lim{cf(x)}=c\lim{f(x)}$</p><p>​        5)$\lim{ {f(x)}^n}=[{\lim{f(x) } }]^n$</p><p>对于数列还是一样的</p><p>​        定理:$\psi(x)\geqslant\varphi(x)$,$\lim{\psi(x)}&gt;\lim{\varphi(x)}$</p><p>哎，这后面这么没有等号了呢?举个例子:$\frac{1}{x}$,$-\frac{1}{x}$</p><h5 id="极限存在准则，两个重要极限"><a href="#极限存在准则，两个重要极限" class="headerlink" title="极限存在准则，两个重要极限"></a>极限存在准则，两个重要极限</h5><p>准则I：对于数列$\{x_n\},\{y_n\}$,${z_n}$ (1)$\exists {n_0}\in{N},y_n\leqslant{x_n}\leqslant{z_n}$(2)$\lim{y_n}=lim{z_n}=a$那么：$\lim{x_n}=a$</p><p>准则I’ :对于函数f(x),g(x),h(x),且(1)$g(x)\leqslant{f(x)}\leqslant{h(x)}$(2)$\lim{g(x)}=\lim{h(x)}=A$那么：$lim{f(x)}=A$</p><p>两个重要极限：</p><h6 id="I-lim-limits-x-rightarrow-0-frac-sin-x-x-1"><a href="#I-lim-limits-x-rightarrow-0-frac-sin-x-x-1" class="headerlink" title="I:$\lim\limits_{x\rightarrow{0}}\frac{\sin{x}}{x}=1$"></a>I:$\lim\limits_{x\rightarrow{0}}\frac{\sin{x}}{x}=1$</h6><p>注意一定是$x\rightarrow{0}$！！！</p><p>同时！！！也可以有推广：</p><h6 id="I’-lim-limits-Box-rightarrow-0-frac-sin-Box-Box-1"><a href="#I’-lim-limits-Box-rightarrow-0-frac-sin-Box-Box-1" class="headerlink" title="I’:$\lim\limits_{\Box\rightarrow {0}}\frac{\sin{\Box}}{\Box}=1$"></a>I’:$\lim\limits_{\Box\rightarrow {0}}\frac{\sin{\Box}}{\Box}=1$</h6><p>其他派生的极限：</p><p>$\lim\limits_{x\rightarrow{0}}\frac{\tan(x)}{x}=1$</p><p>这是因为：$\lim\limits_{x\rightarrow{0}}\frac{\tan(x)}{x}=\lim\limits_{x\rightarrow{0}}(\frac{\sin{x}}{x})\times(\frac{1}{\cos{x}})$=1</p><p>例题：$\lim\limits_{x\rightarrow{0}}\frac{1-\cos{x}}{x^2}$</p><p>解：<img src="C:\Users\陈冠豪\Desktop\image-20221229164852173.png" alt="image-20221229164852173"></p><p>等价无穷小：（I派生）</p><p>$\sin{x}\backsim{x}$ , $\tan{x}\backsim{x}$, $\arcsin{x}\backsim{x}$</p><h4 id="准则II：单调有界数列必有极限！"><a href="#准则II：单调有界数列必有极限！" class="headerlink" title="准则II：单调有界数列必有极限！"></a>准则II：单调有界数列必有极限！</h4><p>性质：收敛必有界，而有界不一定收敛</p><p>为什么有界不一定收敛呢？举个反例：$\{(-1)^{N}\}$就可以了，这个数列显然有界：</p><p>II:$\lim\limits_{x\rightarrow{\infty}}(1+\frac{1}{x})^{x}=e$</p><p>注意$x$一定是趋于无穷！！！</p><p>派生的还有。。。</p><p>II’$\lim\limits_{\Box\rightarrow{\infty}}(1+\frac{1}{\Box})^{\Box}=e$</p><p>II’’$\lim\limits_{x\rightarrow{0}}(1+{x})^\frac{1}{x}=e$</p><p>补充：Cauchy极限审敛法：</p><p>$\{x_n\}收敛\Leftrightarrow \forall{\varepsilon&gt;0},\exists N,当m&gt;N时，|x_n-x_m|&lt;\varepsilon$</p><p>无穷小的比较：</p><p>​        不同无穷小趋于0的速度不一样，我们比较无穷小就是比较不同无穷小趋于0的速度：</p><p>方法是简单的，看他们的商的极限即可：</p><p>如：$\lim\limits_{x\rightarrow{0}}x=0,\lim\limits_{x\rightarrow{0}}\sqrt{x}=0$,而$\lim\limits_{x\rightarrow{0}}\frac{x}{\sqrt{x}}=\lim\limits_{x\rightarrow{0}}\sqrt{x}=0$</p><p>于是：我们发现这个极限为0，说明在趋近速度上$x&gt;\sqrt{x}$</p><p>这样，我们就比较出来了</p><p>定义：</p><p>$若\lim\frac{\beta}{\alpha}=0,则称\beta是\alpha的高阶无穷小，记作\beta=o(\alpha)$</p><p>$若\lim\frac{\beta}{\alpha}=\infty,则称\beta是\alpha的低阶无穷小$</p><p>$若\lim\frac{\beta}{\alpha}=c(c\neq{0}),则称\beta是\alpha的同阶无穷小,特别的，当c=1时，又称等价无穷小,记作{\beta}\backsim{\alpha}$</p><p>$若\lim\frac{\beta}{\alpha^k}=c(c\neq{0}),则称\beta是\alpha的k阶无穷小$</p><p>下面是一些常见的等价无穷小：</p><p>1)$x\rightarrow{0}时，\sqrt[n]{1+x}-1\backsim\frac{x}{n},\sin(x)\sim{x}$</p><p>定理：</p><p>1）$\beta于\alpha等价\Leftrightarrow \beta=\alpha+o(\alpha)$</p><p>2)$\alpha\sim\widetilde{\alpha},\beta\sim\widetilde{\beta},且\lim{\frac{\widetilde{\alpha}}{\widetilde{\beta}}}是存在的，则:\lim\frac {\alpha}{\beta}=\lim{\frac{\widetilde{\alpha}}{\widetilde{\beta}}}$</p><p>于是：</p><p>2)$\tan{x}\sim{x},\arcsin{x}\sim{x}$</p><p>上面的$x$都可以被替换成$\Box$</p><p>定理：</p><p>1）两个无穷小相比的极限时，分子分母可以用等价无穷小替换</p><p>2）如果分子或分母是若干因子的乘积，则我们可以对其中一个或者几个无穷小做替换，但是因子用加减法是不可以的！！！！！！！！！！！！！！！！</p><h4 id="函数的连续性"><a href="#函数的连续性" class="headerlink" title="函数的连续性"></a>函数的连续性</h4><p>对于函数增量的定义：</p><p><img src="C:\Users\陈冠豪\Desktop\image-20221229174949222.png" alt="image-20221229174949222"></p><p>则增量$\Delta f(x)=f(x+\Delta{x})-f(x)$</p><p>实际上，叫做改变量更切合实际，因为函数也可以递减</p><p>那么，连续的定义由此引出：</p><p>若$\lim\limits_{\Delta{x}\rightarrow{0}}\Delta{y}=\lim\limits_{\Delta{x}\rightarrow{0}}(f(x_0+\Delta{x})-f(x_0))=0$时，则函数在$x_0$处连续</p><p>或者</p><p>$\lim\limits_{x\rightarrow{x_0}}f(x)=f(x_0)$时，则函数在$x_0$处连续</p><p>总结而言，一个函数若是想在$x_0$ 处有极限，且有定义，并且函数值与极限值必须相等，三个条件缺一不可！！！</p><p>既然有左右极限，于是也使得函数也有左右连续。函数的左右极限就是由$x$以不同的方向逼近产生的。</p><p>左连续：$\lim\limits_{x\rightarrow{x_0^-}}f(x)=f(x_0)$</p><p>右连续：$\lim\limits_{x\rightarrow{x_0^+}}f(x)=f(x_0)$</p><p>类似的：函数的连续的充要条件是函数即左连续又右连续。</p><h4 id="间断点"><a href="#间断点" class="headerlink" title="间断点"></a>间断点</h4><p>回到连续需要满足的条件：</p><p>一个函数若是想在x_0 处有极限，且有定义，并且函数值与极限值必须相等，三个条件缺一不可！！！于是，间断点也就有三种产生原因：</p><p>1)在$x_0$无定义</p><p>2)$\lim\limits_{x\rightarrow{x_0}}f(x)$不存在</p><p>3）$\lim\limits_{x\rightarrow{x_0}}f(x)\neq{f(x_0)}$</p><p>举例子：</p><p>1)$y=\tan{x}在x=\frac{\pi}{2}$处无定义，所以在这一点上不连续这是可去间断点.</p><p>2)$y=\sin{\frac{1}{x}}$在x=0处极限不存在，所以在这一点上不连续.</p><p>3）</p><script type="math/tex; mode=display">\begin{equation}f(x)=\left\{\begin{array}{cl}\frac{x^2-1}{x-1} &  x \neq 0 \\0  & x = 0 \\\end{array} \right.\end{equation}</script><p>，这个函数在x=1处不连续。这个间断点叫跳跃间断点</p><p>间断点有两类：</p><p>第一类：左右极限都存在</p><p>有可去间断点，跳跃间断点</p><p>第二类：左右极限不都存在</p><p>有震荡间断点</p><p>连续函数的性质：</p><p>对于$[a,b]$上，且$f(a)f(b)&lt;0$时，则其中至少存在一个点$\xi \in[a,b]，$使得$f(\xi)=0$</p><p>推广：</p><p>定理：$f(x)在[a,b]$上连续,$f(a)=A,f(b)=B$,则$\exists C\in[A ,B]$,至少有一个$\xi \in [a,b]$使得，$f(\xi)=C$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Math Works </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C简单教程（1）</title>
      <link href="/2023/01/28/C%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/"/>
      <url>/2023/01/28/C%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简单C教程1"><a href="#简单C教程1" class="headerlink" title="简单C教程1"></a>简单C教程1</h1><p>​        首先打开你的VS，或者是已经配置好GCC和相关插件的Vscode,亦或者Dev C++这个东西，以及切换到英文输入法！！！！！！！！！！！！小心中文的分号给你小小的计算机震撼</p><p>​        我们首先明确：C语言是一个人和计算机交流的语言。语言既然有发展的历史，那么，计算机语言也有发展的过程</p><p>​        最开始的时候：我们使用0，1来代表正电负电，后来用助记符 ，而后有用更高级的语言表达一些固定的助记符。C语言由此诞生。</p><p>​        C语言也有标准：C89/C90是我们这个时候学习的主力。</p><h3 id="My-Fisrt-C-Project"><a href="#My-Fisrt-C-Project" class="headerlink" title="My Fisrt C Project"></a>My Fisrt C Project</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token expression"><span class="token operator">&lt;</span>stdio<span class="token punctuation">.</span>h</span><span class="token comment">//1</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//2</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//3</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        //1:首先，我们首先引入头文件stdio.h，这个文件里包含了我们以后要使用的函数，我需要把他们包含进来才可以使用，否则编译器不认识他们。</p><p>​        //2:接着，main是主函数的意思，这是我们程序的入口：只能有一个main函数不可以有第二个，更不可以没有main函数，int是integer的缩写，表明的是整形。这个表达的是这个函数返回的是一个整形。这个函数负责完成任务</p><p>​        //3：返回0：这是因为函数需要返回东西，我们返回0表达的是成功完成任务</p><p>​        //4：printf:print formatly标准的打印，里面放进去的是一个字符串”hello world\n”,\n是一个换行符</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><div class="table-container"><table><thead><tr><th style="text-align:left">char</th><th>short</th><th>long</th><th>int</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td style="text-align:left">long long</td><td>float</td><td>double</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>​    数据类型有上面这几种，生活中无非就是小数，整数。上面就是引申出来的七种类型</p><p>1.char类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;char ch&#x3D;&#39;A&#39;;&#x2F;&#x2F;存放一个字符，我们起了一个名字ch，里面放了一个A    printf(&quot;%c&quot;,ch);&#x2F;&#x2F;使用%c来输出一个字符变量的内容，函数以这样的方式取出一个字符    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.int类型</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;int stdint&#x3D;114514;&#x2F;&#x2F;存储一个整形，我们起了一个名字叫stdint，里面放了一个114514printf(&quot;%d&quot;,stdint);&#x2F;&#x2F;使用%d来输出一个整形变量的内容，函数以这样的方式取出一个整形return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.long, long long（C99）</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;long stdint&#x3D;114514;&#x2F;&#x2F;存储一个长整形，我们起了一个名字叫stdint，里面放了一个114514printf(&quot;%ld&quot;,stdint);&#x2F;&#x2F;使用%ld来输出一个长整形变量的内容，函数以这样的方式取出一个长整形return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.float，double</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;float stdflt&#x3D;114514.1919810;&#x2F;&#x2F;存储一个浮点型，我们起了一个名字叫stdflt，里面放了一个114514.1919810printf(&quot;%f&quot;,stdflt);&#x2F;&#x2F;使用%f来输出一个浮点型变量的内容，函数以这样的方式取出一个浮点型    double stddbl&#x3D;114514.1919810;&#x2F;&#x2F;存储一个双精度浮点型，我们起了一个名字叫stddbl，里面放了一个114514.1919810    printf(&quot;%lf&quot;,stddbl);&#x2F;&#x2F;使用%lf来输出一个双精度浮点型变量的内容，函数以这样的方式取出一个双精度浮点型return 0;&#125;&#x2F;&#x2F;打印还有其他方式访问：%p声明打印地址，%x以十六进制的方式打印，%o以八进制的方式打印<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        问题来了，为什么整这么多花里胡哨的东西呢？一个不香吗？</p><p>​        首先我们区分他们在计算机在内存中占用的内存。使用一个运算符叫做sizeof(),我们的括号里面放的就是类型。大伙看一看，有什么区别</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()&#123;    printf(&quot;%d\n&quot;,sizeof(char));&#x2F;&#x2F;char申请内存的大小    printf(&quot;%d\n&quot;,sizeof(short));&#x2F;&#x2F;short申请内存的大小    printf(&quot;%d\n&quot;,sizeof(int));&#x2F;&#x2F;int申请内存的大小    printf(&quot;%d\n&quot;,sizeof(long));&#x2F;&#x2F;long申请内存的大小    printf(&quot;%d\n&quot;,sizeof(float));&#x2F;&#x2F;float申请内存的大小    printf(&quot;%d\n&quot;,sizeof(double));&#x2F;&#x2F;double申请内存的大小&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20230129173130931.png" alt="image-20230129173130931"></p><p>​        等等，我们是得到了数，单位是什么呢？字节（byte）。下面插一个小科普：计算机的单位有以下几个层级：</p><p>​        bit                    byte            kb            mb            gb            tb            pb </p><p>​        计算机力最小的单位是怎么定义的呢？</p><p>​        计算机通电工作，这些硬件下通过的电流分为正电和负电，分别代表0和1。（高低电平）这就是2进制的来源，我们用一系列的0和1来表达数据或者物体的状态。1个比特位就可以存储一个0或者是1，8个比特位构成一个字节，随后k,m,g,t,p的进位关系是1024倍数的关系。就是说：一个char的大小是8个比特位，一个int由32个比特位构成。我们的这些类型就是为了更加方便和丰富的表达生活的类型，所以才产生的。</p><h3 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h3><p>​        我们针对数据变不变来区分出来数据是常量还是变量。</p><p>​        比如说：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int age&#x3D;10;&#x2F;&#x2F;向内存申请4个字节存放一个20，而这个字节表达的含义是age<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        这个age是可以变动的：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int age&#x3D;10;printf(&quot;%d\n&quot;,age);age&#x3D;20;printf(&quot;%d\n&quot;,age);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的代码打出来了10和20 。</p><p>​        定义变量的方法是这样的：</p><pre class="line-numbers language-none"><code class="language-none">类型 变量名 &#x3D; 值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        变量自身也有分类：局部变量和全局变量，区别又是什么呢？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int num1&#x3D;20;int main()&#123;    int num2&#x3D;10;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        不难猜到：num1是全局变量，num2是局部变量。全局变量指的是定义在代码块{ }之外的变量。反之，在{ }内的是全局变量。问题来了：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int global &#x3D;2023;int main()&#123;    int local&#x3D;2022;    &#x2F;&#x2F;?So what about the next line?int global&#x3D;2022;    printf(&quot;global here is %d\n&quot;,global);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​         当你在VS2022一敲出来，高亮颜色就告诉你，答案是2022：</p><p>​        <img src="image-20230129180112913.png" alt="image-20230129180112913"></p><p>​        能同时共存，而且：<strong>局部变量优先</strong> 这里给出建议：</p><p>​        <strong>打代码的时候不要使用同名的局部变量和全局变量，如果相同了，记住一件事情：局部变量优先！</strong></p><p>​        下面我们继续玩一个新的函数：scanf函数。</p><p>​        我说停停！！！先别函数玩的欢乐，这是因为在新标准下，C标准委员会嫌这东西不安全（为什么不安全这里先不扯，简单来讲就是这个函数读到什么东西就往里塞，实在读不进去就直接扔回一个-1摆烂，导致程序安全性很差）, 所以整了一个船新函数scanf_s ,这个函数我的评价是VS用用行，但是移植到别的编译器还要切换标准，怎么办呢？在VS编译器下面使用一个宏定义#define _CRT_SECURE_NO_WARNINGS 1 让编译器赶紧闭嘴通过就完事，这个宏（可以先不追究这是什么东西）扔到程序的最前面就可以了</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Example#define _CRT_SECURE_NO_WARNINGS 1&#x2F;&#x2F;Looking here#include&lt;stdio.h&gt;int global &#x3D; 2023;int main()&#123;    int local &#x3D; 2022;    &#x2F;&#x2F;?So what about the next line?    int global &#x3D; 2022;    printf(&quot;global here is %d\n&quot;, global);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        这个函数读取键盘的输入，使用方法如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;A basic program that reads two numbers then returns the sum of themint num1&#x3D;0;int num2&#x3D;0;scanf(&quot;%d%d&quot;,&amp;num1,&amp;num2);&#x2F;&#x2F;字符串里面不要塞上空格！不要塞上空格int sum&#x3D;num1+num2;printf(&quot;%d&quot;,sum);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        对了，这个&amp;是什么捏？取地址符号，后面我们提到指针的时候我们会天天见到他。人话就是这样讲：告诉这个函数，这两个变量在计算机的哪里。</p><p>​        认真的讲，计算机有巨大的内存，那么多数据，我们的计算机怎么哪里是哪里？使用地址，就像你们家的门牌号一样。</p><p>​        变量也有作用域：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int global&#x3D;10;int main()&#123;    int numlevel1&#x3D;10;    &#123;        int numlevel2&#x3D;20;    &#125;    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel1);    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        你的编译器很快（也很不幸的）告诉你，我不到numlevel2是什么啊。那就对了，因为每个变量都有它的作用域：范围就是从他定义的位置到当前它在的大括号区域}结束处：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;int global&#x3D;10;int main()&#123;printf(&quot;%d&quot;,numlevel1);&#x2F;&#x2F;NOOOO,变量还没被声明，不要用:(    int numlevel1&#x3D;10;&#x2F;&#x2F;----init numlevel1    &#123;       int numlevel2&#x3D;20;&#x2F;&#x2F;----init numlevel2    &#125;&#x2F;&#x2F;----destroy numlevel2 Sadly    &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel1);   &#x2F;&#x2F;How about this one?    printf(&quot;%d&quot;,numlevel2);&#125;&#x2F;&#x2F;----destroy numlevel1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的图就表示了程序变量的生命周期或者说作用域：创建完之后到被回收之前，变量才是被允许使用的。所以，当你的编译器不知道你想要使用的变量的时候，他会指出错误：未声明的标识符。这个时候回去看看你的代码哪里出现了问题⑧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
