<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Windows-API-程序设计（1） | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="系统学习Windows API数据类型一看​        原生C数据类型 int float double ... ​        Windows自己的： BOOL BYTE CHAR CONST DWORD DOWRD32 DWORD64 FLOAT HANDLE HICON HINSTANCE HKEY HMODULE HWND INT INT_PTR INT32 INT64 ​">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows-API-程序设计（1）">
<meta property="og:url" content="http://charliechen114514.github.io/2023/05/16/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="系统学习Windows API数据类型一看​        原生C数据类型 int float double ... ​        Windows自己的： BOOL BYTE CHAR CONST DWORD DOWRD32 DWORD64 FLOAT HANDLE HICON HINSTANCE HKEY HMODULE HWND INT INT_PTR INT32 INT64 ​">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-05-16T12:32:45.000Z">
<meta property="article:modified_time" content="2023-05-16T12:37:49.921Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Windows 32API">
<meta property="article:tag" content="摸鱼ing">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/05/16/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Windows-API-程序设计（1）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-16 20:37:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Windows-API-程序设计（1）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-16T12:32:45.000Z" title="发表于 2023-05-16 20:32:45">2023-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-16T12:37:49.921Z" title="更新于 2023-05-16 20:37:49">2023-05-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Windows-API-程序设计（1）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="系统学习Windows-API"><a href="#系统学习Windows-API" class="headerlink" title="系统学习Windows API"></a>系统学习Windows API</h1><h2 id="数据类型一看"><a href="#数据类型一看" class="headerlink" title="数据类型一看"></a>数据类型一看</h2><p>​        原生C数据类型</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int float double ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Windows自己的：</p>
<pre class="line-numbers language-none"><code class="language-none">BOOL BYTE CHAR CONST DWORD DOWRD32 DWORD64 FLOAT HANDLE HICON HINSTANCE
HKEY HMODULE HWND INT INT_PTR INT32 INT64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        看看这个：</p>
<pre class="line-numbers language-none"><code class="language-none">LPSTR szString &#x3D; L&quot;this is a long pointer to string.&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        跳转得到：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;
&#x2F;&#x2F; ANSI (Multi-byte Character) types
&#x2F;&#x2F;
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef CONST CHAR *LPCCH, *PCCH;

typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        进一步针对CHAR类型跳转</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef char CHAR;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        微软搞那么多宏，一方面是历史遗留，另一方面是方便他们的工程师更容易区分</p>
<p>​        Dword是这个东西：一个四个字节的数据类型</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DWORD dwMax &#x3D; 0xFFFFFFFF<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef unsigned long       DWORD;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        于是INT就是有符号的，DWORD是无符号的。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;
#include&lt;Windows.h&gt;

int main()
&#123;

	LPSTR szString &#x3D; L&quot;this is a long pointer to string.&quot;;

	INT a &#x3D; 10;

	DWORD dwMax &#x3D; 0xFFFFFFFF;

	MessageBox(NULL, szString, TEXT(&quot;LPSTR&quot;), MB_OK);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在C中我们有：memcpy</p>
<p>​        在Windows下，有一个函数叫CopyMemory()</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">CopyMemory(IpStr, szString, lstrlen(szString) + 1); &#x2F;&#x2F; add one to include the \0.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define CopyMemory RtlCopyMemory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Handle,也就是句柄，是这样被定义的：</p>
<p>​        他有如下的句柄：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void *HANDLE;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        HICON图标</p>
<pre class="line-numbers language-X" data-language="X"><code class="language-X">DECLARE_HANDLE(HICON);
#define DECLARE_HANDLE(name) struct name##__&#123;int unused;&#125;; typedef struct name##__ *name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        HInstance实例句柄</p>
<pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE(HINSTANCE);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        HKey注册表的句柄</p>
<pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE(HKEY);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Hmodule模块句柄</p>
<pre class="line-numbers language-none"><code class="language-none">typedef HINSTANCE HMODULE;      &#x2F;* HMODULEs can be used in place of HINSTANCEs *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        HWND窗口句柄</p>
<pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE            (HWND);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="API基础函数"><a href="#API基础函数" class="headerlink" title="API基础函数"></a>API基础函数</h2><p>​        WindowAPI大量的使用了Windows的数据类型！所有的API都有W版和A版，分别表示的是支持Unicode字符集和ASCII多字节字符集。下面我们来看一个Windows自己创建的demo，选择Win32项目创建。看到主文件下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; WindowsProject1.cpp : 定义应用程序的入口点。
&#x2F;&#x2F;

#include &quot;framework.h&quot;
#include &quot;WindowsProject1.h&quot;

#define MAX_LOADSTRING 100

&#x2F;&#x2F; 全局变量:
HINSTANCE hInst;                                &#x2F;&#x2F; 当前实例
WCHAR szTitle[MAX_LOADSTRING];                  &#x2F;&#x2F; 标题栏文本
WCHAR szWindowClass[MAX_LOADSTRING];            &#x2F;&#x2F; 主窗口类名

&#x2F;&#x2F; 此代码模块中包含的函数的前向声明:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
&#123;
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    &#x2F;&#x2F; TODO: 在此处放置代码。

    &#x2F;&#x2F; 初始化全局字符串
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_WINDOWSPROJECT1, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    &#x2F;&#x2F; 执行应用程序初始化:
    if (!InitInstance (hInstance, nCmdShow))
    &#123;
        return FALSE;
    &#125;

    HACCEL hAccelTable &#x3D; LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSPROJECT1));

    MSG msg;

    &#x2F;&#x2F; 主消息循环:
    while (GetMessage(&amp;msg, nullptr, 0, 0))
    &#123;
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))
        &#123;
            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
        &#125;
    &#125;

    return (int) msg.wParam;
&#125;



&#x2F;&#x2F;
&#x2F;&#x2F;  函数: MyRegisterClass()
&#x2F;&#x2F;
&#x2F;&#x2F;  目标: 注册窗口类。
&#x2F;&#x2F;
ATOM MyRegisterClass(HINSTANCE hInstance)
&#123;
    WNDCLASSEXW wcex;

    wcex.cbSize &#x3D; sizeof(WNDCLASSEX);

    wcex.style          &#x3D; CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    &#x3D; WndProc;
    wcex.cbClsExtra     &#x3D; 0;
    wcex.cbWndExtra     &#x3D; 0;
    wcex.hInstance      &#x3D; hInstance;
    wcex.hIcon          &#x3D; LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));
    wcex.hCursor        &#x3D; LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  &#x3D; (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   &#x3D; MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1);
    wcex.lpszClassName  &#x3D; szWindowClass;
    wcex.hIconSm        &#x3D; LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassExW(&amp;wcex);
&#125;

&#x2F;&#x2F;
&#x2F;&#x2F;   函数: InitInstance(HINSTANCE, int)
&#x2F;&#x2F;
&#x2F;&#x2F;   目标: 保存实例句柄并创建主窗口
&#x2F;&#x2F;
&#x2F;&#x2F;   注释:
&#x2F;&#x2F;
&#x2F;&#x2F;        在此函数中，我们在全局变量中保存实例句柄并
&#x2F;&#x2F;        创建和显示主程序窗口。
&#x2F;&#x2F;
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
&#123;
   hInst &#x3D; hInstance; &#x2F;&#x2F; 将实例句柄存储在全局变量中

   HWND hWnd &#x3D; CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   &#123;
      return FALSE;
   &#125;

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
&#125;

&#x2F;&#x2F;
&#x2F;&#x2F;  函数: WndProc(HWND, UINT, WPARAM, LPARAM)
&#x2F;&#x2F;
&#x2F;&#x2F;  目标: 处理主窗口的消息。
&#x2F;&#x2F;
&#x2F;&#x2F;  WM_COMMAND  - 处理应用程序菜单
&#x2F;&#x2F;  WM_PAINT    - 绘制主窗口
&#x2F;&#x2F;  WM_DESTROY  - 发送退出消息并返回
&#x2F;&#x2F;
&#x2F;&#x2F;
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
&#123;
    switch (message)
    &#123;
    case WM_COMMAND:
        &#123;
            int wmId &#x3D; LOWORD(wParam);
            &#x2F;&#x2F; 分析菜单选择:
            switch (wmId)
            &#123;
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            &#125;
        &#125;
        break;
    case WM_PAINT:
        &#123;
            PAINTSTRUCT ps;
            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);
            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...
            EndPaint(hWnd, &amp;ps);
        &#125;
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    &#125;
    return 0;
&#125;

&#x2F;&#x2F; “关于”框的消息处理程序。
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
&#123;
    UNREFERENCED_PARAMETER(lParam);
    switch (message)
    &#123;
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) &#x3D;&#x3D; IDOK || LOWORD(wParam) &#x3D;&#x3D; IDCANCEL)
        &#123;
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        &#125;
        break;
    &#125;
    return (INT_PTR)FALSE;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们尝试加点东西，留心到</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在switch语句下面添加点东西（有注释//）:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
&#123;

    LPCWSTR msg_str1 &#x3D; L&quot;你单击了左键（乐）&quot;;&#x2F;&#x2F;
    LPCWSTR msg_str2 &#x3D; L&quot;你单击了右键（乐）&quot;;&#x2F;&#x2F;
    LPCWSTR title_str &#x3D; L&quot;这是一个标题&quot;;&#x2F;&#x2F;

    switch (message)
    &#123;
    case WM_COMMAND:
        &#123;
            int wmId &#x3D; LOWORD(wParam);
            &#x2F;&#x2F; 分析菜单选择:
            switch (wmId)
            &#123;
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            &#125;
        &#125;
        break;
    case WM_PAINT:
        &#123;
            PAINTSTRUCT ps;
            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);
            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...
            EndPaint(hWnd, &amp;ps);
        &#125;
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    case WM_LBUTTONDOWN:&#x2F;&#x2F;
        MessageBoxW(NULL,msg_str1,title_str, MB_OKCANCEL);&#x2F;&#x2F;
        break;&#x2F;&#x2F;
    case WM_RBUTTONDOWN:&#x2F;&#x2F;
        MessageBoxW(NULL, msg_str2, title_str, MB_OKCANCEL);&#x2F;&#x2F;
        break;&#x2F;&#x2F;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是我们频繁点击会产生大量的窗口！那就更改父窗口就好了，传入一个句柄！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">case WM_LBUTTONDOWN:
    MessageBoxW(hWnd,msg_str1,title_str, MB_OKCANCEL);
    break;
case WM_RBUTTONDOWN:
    MessageBoxW(hWnd, msg_str2, title_str, MB_OKCANCEL);
    break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在就好了！</p>
<p><img src="image-20230514113233694.png" alt="image-20230514113233694"></p>
<p><img src="image-20230514113445737.png" alt="image-20230514113445737"></p>
<p><img src="image-20230514113504873.png" alt="image-20230514113504873"></p>
<h2 id="读取文件demo"><a href="#读取文件demo" class="headerlink" title="读取文件demo"></a>读取文件demo</h2><p>​        在Windows下，使用</p>
<pre class="line-numbers language-none"><code class="language-none">CreateFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        宏来打开并创建一个文件句柄！</p>
<blockquote>
<p>from Microsoft API</p>
</blockquote>
<h2 id="read-file"><a href="#read-file" class="headerlink" title="read file"></a>read file</h2><p>​        我们使用readFile来读取文件：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#define BUFSIZE 256
#include&lt;tchar.h&gt;11

int main()
&#123;
	setlocale(LC_ALL, &quot;zh_CN.UTF-8&quot;); &#x2F;&#x2F; 设置正确的编码环境，防止读取乱码！

	HANDLE hFileRead;
	&#x2F;&#x2F; 创建文件句柄
	hFileRead &#x3D; CreateFile(L&quot;1.txt&quot;, GENERIC_READ, FILE_SHARE_READ, \
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFileRead &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;

		printf(&quot;Error in open the file:%x&quot;,GetLastError());

	&#125;

	DWORD nIn &#x3D; 0;

	CHAR buffer[BUFSIZE];

	while (ReadFile(hFileRead, buffer, BUFSIZE, &amp;nIn, NULL) &amp;&amp; nIn &gt; 0) &#123;
		printf(&quot;%s\n&quot;, buffer);
	&#125;

	CloseHandle(hFileRead);
	
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230514113206643.png" alt="image-20230514113206643"></p>
<h3 id="createFileW-函数-fileapi-h"><a href="#createFileW-函数-fileapi-h" class="headerlink" title="createFileW 函数 (fileapi.h)"></a>createFileW 函数 (fileapi.h)</h3><p>​        创建或打开文件或 I/O 设备。 最常用的 I/O 设备如下所示：文件、文件流、目录、物理磁盘、卷、控制台缓冲区、磁带驱动器、通信资源、mailslot 和管道。 该函数返回一个句柄，该句柄可用于访问不同类型的 I/O 的文件或设备，具体取决于文件或设备以及指定的标志和属性。</p>
<p>若要将此操作作为事务处理操作执行，这会导致可用于事务处理 I/O 的句柄，请使用 CreateFileTransacted 函数。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">HANDLE CreateFileW(
  [in]           LPCWSTR               lpFileName,
  [in]           DWORD                 dwDesiredAccess,
  [in]           DWORD                 dwShareMode,
  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  [in]           DWORD                 dwCreationDisposition,
  [in]           DWORD                 dwFlagsAndAttributes,
  [in, optional] HANDLE                hTemplateFile
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参数<br>        [in] lpFileName</p>
<p>​        要创建或打开的文件或设备的名称。 可以在此名称中使用正斜杠 (/) 或反斜杠 () 。</p>
<p>​        在此函数的 ANSI 版本中，名称限制为 MAX_PATH 个字符。 若要将此限制扩展到 32，767 宽字符，请使用此 Unicode 版本的函数，并将“\\？\”前面附加到路径。 有关详细信息，请参阅命名文件、路径和命名空间。</p>
<p>​        有关特殊设备名称的信息，请参阅 定义 MS-DOS 设备名称。</p>
<p>​        若要创建文件流，请指定文件的名称、冒号，然后指定流的名称。 有关详细信息，请参阅 文件流。</p>
<p>​        提示从Windows 10版本 1607 开始，对于此函数的 unicode 版本 (CreateFileW) ，你可以选择加入以删除MAX_PATH限制，而无需附加“\\？\”。 有关详细信息，请参阅 命名文件、路径和命名空间 的“最大路径长度限制”部分。<br>[in] dwDesiredAccess</p>
<p>​        请求对文件或设备的访问权限，可汇总为读取、写入或两者均不) 。</p>
<p>​        最常用的值是 GENERIC_READ、 GENERIC_WRITE或两者 () GENERIC_READ | GENERIC_WRITE 。 有关详细信息，请参阅 通用访问权限、 文件安全性和访问权限、 文件访问权限常量和 ACCESS_MASK。</p>
<p>​        如果此参数为零，则应用程序可以在不访问该文件或设备的情况下查询某些元数据，例如文件、目录或设备属性，即使 拒绝了GENERIC_READ 访问。</p>
<p>​        不能请求与已打开句柄的打开请求中 dwShareMode 参数指定的共享模式冲突的访问模式。</p>
<p>​        有关详细信息，请参阅本主题的“备注”部分和 “创建和打开文件”。</p>
<p>​        [in] dwShareMode</p>
<p>​        文件或设备请求的共享模式，可以读取、写入、删除、所有这些或无 (引用下表) 。 对属性或扩展属性的访问请求不受此标志的影响。</p>
<p>​        如果此参数为零且 CreateFile 成功，则文件或设备无法共享，并且无法在文件或设备的句柄关闭之前再次打开。 有关详细信息，请参见“备注”部分。</p>
<p>​        无法请求与具有打开句柄的现有请求中指定的访问模式冲突的共享模式。 CreateFile 将失败， GetLastError 函数将返回 ERROR_SHARING_VIOLATION。</p>
<p>​        若要启用进程在打开文件或设备时共享文件或设备，请使用以下一个或多个值的兼容组合。 有关此参数与 dwDesiredAccess 参数的有效组合的详细信息，请参阅 创建和打开文件。</p>
<p>​        <strong>注意</strong> 无论进程上下文如何，每个打开句柄的共享选项都将有效，直到该句柄关闭。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>0</strong>0x00000000</td>
<td style="text-align:left">如果文件或设备请求删除、读取或写入访问权限，则阻止对文件或设备上的后续打开操作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SHARE_DELETE</strong>0x00000004</td>
<td style="text-align:left">在文件或设备上启用后续打开操作以请求删除访问权限。否则，如果文件或设备请求删除访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开以删除访问权限，则函数将失败。<strong>注意</strong> 删除访问权限允许删除和重命名操作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SHARE_READ</strong>0x00000001</td>
<td style="text-align:left">在文件或设备上启用后续打开操作以请求读取访问权限。否则，如果文件或设备请求读取访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开以供读取访问，则函数将失败。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SHARE_WRITE</strong>0x00000002</td>
<td style="text-align:left">在文件或设备上启用后续打开操作以请求写入访问权限。否则，如果文件或设备请求写入访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开进行写入访问或具有写入访问权限的文件映射，则函数将失败。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] lpSecurityAttributes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向包含两个独立但相关数据成员的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85">SECURITY_ATTRIBUTES</a>) 结构的指针：可选的安全描述符，以及一个布尔值，该值确定返回的句柄是否可以由子进程继承。</p>
<p>​        此参数可以为 NULL。</p>
<p>​        如果此参数为 <strong>NULL</strong>，则 <strong>由 CreateFile</strong> 返回的句柄不能由应用程序可能创建的任何子进程继承，并且与返回的句柄关联的文件或设备获取默认的安全描述符。</p>
<p>​        结构的 <strong>lpSecurityDescriptor</strong> 成员指定文件或设备的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> 。 如果此成员为 <strong>NULL</strong>，则会为与返回的句柄关联的文件或设备分配一个默认的安全描述符。</p>
<p>​        <strong>CreateFile</strong> 在打开现有文件或设备时忽略 <strong>lpSecurityDescriptor</strong> 成员，但继续使用 <strong>bInheritHandle</strong> 成员。</p>
<p>​        结构的 <strong>bInheritHandle</strong> 成员指定是否可以继承返回的句柄。</p>
<p>​        有关详细信息，请参见“备注”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] dwCreationDisposition<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        对存在或不存在的文件或设备执行的操作。</p>
<p>​        对于文件以外的设备，此参数通常设置为 <strong>OPEN_EXISTING</strong>。</p>
<p>​        有关详细信息，请参见“备注”部分。</p>
<p>​        此参数必须是以下值之一，不能合并：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>CREATE_ALWAYS</strong>2</td>
<td style="text-align:left">始终创建新文件。如果指定的文件存在且可写，则函数将覆盖文件、函数成功，最后错误代码设置为 <strong>ERROR_ALREADY_EXISTS</strong> (183) 。如果指定的文件不存在且路径有效，则会创建一个新文件，该函数成功，最后一个错误代码设置为零。有关详细信息，请参阅本主题的“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CREATE_NEW</strong>1</td>
<td style="text-align:left">仅当该文件尚不存在时才创建一个新文件。如果指定的文件存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_EXISTS (</strong> 80) 。如果指定的文件不存在并且是可写位置的有效路径，则会创建新文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>OPEN_ALWAYS</strong>4</td>
<td style="text-align:left">始终打开文件。如果指定文件存在，则函数成功，最后一个错误代码设置为 <strong>ERROR_ALREADY_EXISTS (</strong> 183) 。如果指定的文件不存在并且是可写位置的有效路径，则函数将创建一个文件，最后一个错误代码设置为零。</td>
</tr>
<tr>
<td style="text-align:left"><strong>OPEN_EXISTING</strong>3</td>
<td style="text-align:left">仅当文件或设备存在时，才打开该文件或设备。如果指定的文件或设备不存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_NOT_FOUND (</strong> 2) 。有关设备的详细信息，请参阅“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>TRUNCATE_EXISTING</strong>5</td>
<td style="text-align:left">打开文件并截断该文件，使其大小为零字节，仅当它存在时。如果指定的文件不存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_NOT_FOUND</strong> (2) 。调用过程必须打开文件，并将 <strong>GENERIC_WRITE</strong> 位设置为 <em>dwDesiredAccess</em> 参数的一部分。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[in] dwFlagsAndAttributes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        文件或设备属性和标志， <strong>FILE_ATTRIBUTE_NORMAL</strong> 是文件最常见的默认值。</p>
<p>​        此参数可以包含可用文件属性的任意组合， <strong>(FILE_ATTRIBUTE_*</strong>) 。 所有其他文件属性都替代 <strong>FILE_ATTRIBUTE_NORMAL</strong>。</p>
<p>​        此参数还可以包含标志组合 <strong>， (FILE_FLAG_)</strong> <em>来控制文件或设备缓存行为、访问模式和其他特殊用途标志。 这些值与任何 <strong>FILE_ATTRIBUTE_</strong></em> 值结合使用。</p>
<p>​        此参数还可以通过指定 <strong>SECURITY_SQOS_PRESENT</strong> 标志来包含安全服务质量 (SQOS) 信息。 下表显示了其他与 SQOS 相关的标志信息，这些属性和标志表如下。</p>
<p>​        <strong>注意当CreateFile</strong> 打开现有文件时，它通常将文件标志与现有文件的文件属性组合在一起，并忽略作为 <em>dwFlagsAndAttributes</em> 的一部分提供的任何文件属性。 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”中详细介绍了特殊情况。</p>
<p>​        以下某些文件属性和标志只能应用于文件，不一定是 <strong>CreateFile</strong> 可以打开的所有其他类型的设备。 有关详细信息，请参阅本主题的“备注”部分和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”。    </p>
<p>​        有关对文件属性的更高级访问，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>。 有关所有文件属性及其值和说明的完整列表，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-attribute-constants">文件属性常量</a>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Attribute</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_ARCHIVE</strong>32 (0x20)</td>
<td style="text-align:left">该文件应存档。 应用程序使用此属性来标记要备份或删除的文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_ENCRYPTED</strong>16384 (0x4000)</td>
<td style="text-align:left">此文件或目录已加密。 对于文件来说，表示文件中的所有数据都是加密的。 对于目录，这意味着加密是新创建的文件和子目录的默认值。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。如果还指定 <strong>了FILE_ATTRIBUTE_SYSTEM</strong> ，则此标志无效。家庭版、家庭高级版、初学者版或 ARM 版 Windows 不支持此标志。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_HIDDEN</strong>2 (0x2)</td>
<td style="text-align:left">文件被隐藏。 不要将其包含在普通目录列表中。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_NORMAL</strong>128 (0x80)</td>
<td style="text-align:left">该文件没有设置其他属性。 此属性仅在单独使用时有效。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_OFFLINE</strong>4096 (0x1000)</td>
<td style="text-align:left">文件的数据不能立即可用。 此属性指示文件数据以物理方式移动到脱机存储。 此属性由远程存储（分层存储管理软件）使用。 应用程序不应随意更改此属性。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_READONLY</strong>1 (0x1)</td>
<td style="text-align:left">文件为只读文件。 应用程序可以读取文件，但无法写入或删除该文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_SYSTEM</strong>4 (0x4)</td>
<td style="text-align:left">该文件是操作系统的一部分或完全使用的文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_TEMPORARY</strong>256 (0x100)</td>
<td style="text-align:left">该文件用于临时存储。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">标志</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_BACKUP_SEMANTICS</strong>0x02000000</td>
<td style="text-align:left">正在为备份或还原操作打开或创建该文件。 系统确保调用进程在进程具有 <strong>SE_BACKUP_NAME</strong> 和 <strong>SE_RESTORE_NAME</strong> 特权时替代文件安全检查。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecBP/changing-privileges-in-a-token">更改令牌中的特权</a>。必须设置此标志才能获取目录的句柄。 目录句柄可以传递给某些函数，而不是文件句柄。 有关详细信息，请参见“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_DELETE_ON_CLOSE</strong>0x04000000</td>
<td style="text-align:left">文件在其所有句柄都关闭后立即被删除，其中包括指定的句柄和任何其他打开或重复的句柄。如果文件存在现有的打开句柄，则调用会失败，除非这些句柄都使用 <strong>FILE_SHARE_DELETE</strong> 共享模式打开。针对文件的后续打开请求将失败，除非指定 FILE_SHARE_DELETE 共享模式。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_NO_BUFFERING</strong>0x20000000</td>
<td style="text-align:left">文件或设备正在打开，没有系统缓存来读取和写入数据。 此标志不会影响硬盘缓存或内存映射文件。使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志成功使用 <strong>CreateFile</strong> 打开的文件有严格的要求，有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_OPEN_NO_RECALL</strong>0x00100000</td>
<td style="text-align:left">请求文件数据，但它应继续位于远程存储中。 不应将其传输回本地存储。 此标志供远程存储系统使用。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>0x00200000</td>
<td style="text-align:left">不会进行正常的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/reparse-points">重新分析点</a> 处理; <strong>CreateFile</strong> 将尝试打开重新分析点。 打开文件时，将返回文件句柄，无论控制重新分析点的筛选器是否正常运行。此标志不能与 <strong>CREATE_ALWAYS</strong> 标志一起使用。如果文件不是重新分析点，则忽略此标志。有关详细信息，请参见“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_OVERLAPPED</strong>0x40000000</td>
<td style="text-align:left">文件或设备正在为异步 I/O 打开或创建。在此句柄上完成后续 I/O 操作时， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件将设置为信号状态。如果指定了此标志，则该文件可用于同时读取和写入操作。如果未指定此标志，则即使对读取和写入函数的调用指定 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">了 OVERLAPPED</a> 结构，I/O 操作也会序列化。有关使用此标志创建的文件句柄时的注意事项，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#synchronous_and_asynchronous_i_o_handles">同步和异步 I/O 句柄</a> 部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_POSIX_SEMANTICS</strong>0x01000000</td>
<td style="text-align:left">访问将根据 POSIX 规则进行。 这包括允许具有名称的多个文件，仅在支持该命名的文件系统时有所不同。 使用此选项时应小心，因为使用此标志创建的文件可能无法由为 MS-DOS 或 16 位 Windows 编写的应用程序访问。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_RANDOM_ACCESS</strong>0x10000000</td>
<td style="text-align:left">访问是随机的。 系统可将此选项用作优化文件缓存的提示。如果文件系统不支持缓存的 I/O 和 <strong>FILE_FLAG_NO_BUFFERING</strong>，则此标志无效。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_SESSION_AWARE</strong>0x00800000</td>
<td style="text-align:left">文件或设备正在使用会话感知打开。 如果未指定此标志，则会话中的每个会话设备 (（例如使用 RemoteFX USB 重定向的设备) ）无法由会话 0 中运行的进程打开。 对于不在会话 0 中的调用方，此标志无效。 此标志仅在 Windows 的服务器版本上受支持。<strong>Windows Server 2008 R2 和 Windows Server 2008：</strong> Windows Server 2012之前不支持此标志。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_SEQUENTIAL_SCAN</strong>0x08000000</td>
<td style="text-align:left">访问旨在从头到尾的顺序。 系统可将此选项用作优化文件缓存的提示。如果读取隐藏 (（即使用反向扫描) ），则不应使用此标志。如果文件系统不支持缓存的 I/O 和 <strong>FILE_FLAG_NO_BUFFERING</strong>，则此标志无效。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_WRITE_THROUGH</strong>0x80000000</td>
<td style="text-align:left">写入操作不会经历任何中间缓存，它们将直接转到磁盘。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
</tbody>
</table>
</div>
<p><em>dwFlagsAndAttributes</em> 参数还可以指定 SQOS 信息。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/impersonation-levels">模拟级别</a>。 当调用应用程序将 <strong>SECURITY_SQOS_PRESENT</strong> 标志指定为 <em>dwFlagsAndAttributes</em> 的一部分时，它还可以包含以下一个或多个值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">安全标志</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>SECURITY_ANONYMOUS</strong></td>
<td style="text-align:left">模拟匿名模拟级别的客户端。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_CONTEXT_TRACKING</strong></td>
<td style="text-align:left">安全跟踪模式是动态的。 如果未指定此标志，则安全跟踪模式是静态的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_DELEGATION</strong></td>
<td style="text-align:left">模拟委托模拟级别的客户端。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_EFFECTIVE_ONLY</strong></td>
<td style="text-align:left">只有客户端安全上下文的已启用方面可供服务器使用。 如果未指定此标志，则客户端安全上下文的所有方面都可用。这允许客户端限制服务器在模拟客户端时可以使用的组和特权。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_IDENTIFICATION</strong></td>
<td style="text-align:left">模拟标识模拟级别的客户端。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_IMPERSONATION</strong></td>
<td style="text-align:left">模拟模拟级别的客户端。 如果未指定其他标志以及 <strong>SECURITY_SQOS_PRESENT</strong> 标志，则这是默认行为。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] hTemplateFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        具有 <strong>GENERIC_READ</strong> 访问权限的模板文件的有效句柄。 模板文件为正在创建的文件提供文件属性和扩展属性。</p>
<p>​        此参数可以为 NULL。</p>
<p>​        打开现有文件时， <strong>CreateFile</strong> 将忽略此参数。</p>
<p>​        打开新的加密文件时，该文件将从其父目录继承任意访问控制列表。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是指定文件、设备、命名管道或邮件槽的打开句柄。</p>
<p>​        如果函数失败，则返回值为 INVALID_HANDLE_VALUE。 要获得更多的错误信息，请调用 GetLastError。</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>​        <strong>CreateFile</strong> 最初专为文件交互而开发，但此后已扩展和增强，以包括 Windows 开发人员可用的大多数其他类型的 I/O 设备和机制。 本部分尝试介绍开发人员在不同上下文中使用不同的 I/O 类型使用 <strong>CreateFile</strong> 时可能遇到的各种问题。 仅当专门引用存储在文件系统上实际文件中的数据时，文本才会尝试使用单词 <em>文件</em> 。 但是，某些文件用法可能更普遍地引用支持类似 <em>文件的</em> I/O 对象。 由于前面提到的历史原因，这种自由使用术语 <em>文件</em> 在常量名称和参数名称中尤其普遍。</p>
<p>​        使用 <strong>CreateFile</strong> 返回的对象句柄完成应用程序后，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 函数关闭句柄。 这不仅释放了系统资源，而且可以对共享文件或设备以及将数据提交到磁盘等内容产生更广泛的影响。 本主题中会相应地说明具体内容。</p>
<p>​        <strong>Windows Server 2003 和 Windows XP：</strong> 如果尝试打开文件或目录以在远程计算机上删除，则发生共享冲突，当 <em>dwDesiredAccess</em> 参数的值是使用任何其他访问标志 (0x00010000) <strong>OR’ed</strong> 的 <strong>DELETE</strong> 访问标志，并且远程文件或目录尚未使用<strong>FILE_SHARE_DELETE</strong>打开。 为了避免此方案中的共享冲突，请仅打开具有 <strong>DELETE</strong> 访问权限的远程文件或目录，或者调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> ，而无需首先打开文件或目录进行删除。</p>
<p>​        某些文件系统（如 NTFS 文件系统）支持单个文件和目录的压缩或加密。 对于具有此支持的装载文件系统的卷，新文件继承其目录的压缩和加密属性。</p>
<p>​        不能使用 <strong>CreateFile</strong> 来控制文件或目录上的压缩、解压缩或解密。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">创建和打开文件</a>、 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-compression-and-decompression">文件压缩和解压缩</a>以及 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。</p>
<p>​        <strong>Windows Server 2003 和 Windows XP：</strong> 出于向后兼容性目的，在 <em>lpSecurityAttributes</em> 中指定安全描述符时，<strong>CreateFile</strong> 不会应用继承规则。 为了支持继承，以后查询此文件的安全描述符的函数可能会启发性地确定并报告继承是否有效。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">可继承 ACE 的自动传播</a>。</p>
<p>​        如前所述，如果 <em>lpSecurityAttributes</em> 参数为 <strong>NULL</strong>，则应用程序可能创建的任何子进程都无法继承 <strong>CreateFile</strong> 返回的句柄。 有关此参数的以下信息也适用：</p>
<ul>
<li>如果 <strong>bInheritHandle</strong> 成员变量不是 <strong>FALSE</strong>，这是任何非零值，则可以继承句柄。 因此，如果不希望句柄可继承，则此结构成员必须正确初始化为 <strong>FALSE</strong> 。</li>
<li>访问控制列表 (文件或目录的默认安全描述符中的 ACL) 继承自其父目录。</li>
<li>目标文件系统必须支持 <strong>lpSecurityDescriptor</strong> 成员对文件和目录的安全性，才能对其产生影响，这可以通过 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">使用 GetVolumeInformation</a> 来确定。</li>
</ul>
<p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">技术</th>
<th style="text-align:left">支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td>
<td style="text-align:left">请参阅备注</td>
</tr>
<tr>
<td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td>
<td style="text-align:left">请参阅备注</td>
</tr>
<tr>
<td style="text-align:left">群集共享卷文件系统 (CsvFS)</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">弹性文件系统 (ReFS)</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
</div>
<p>​        请注意，如果对已打开的备用数据流的文件执行，具有取代处置的 <strong>CreateFile</strong> 将失败。</p>
<h4 id="符号链接行为"><a href="#符号链接行为" class="headerlink" title="符号链接行为"></a>符号链接行为</h4><p>​        如果对此函数的调用创建文件，则行为没有变化。 此外，请考虑有关 <strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>的以下信息：</p>
<ul>
<li>如果指定了FILE_FLAG_OPEN_REPARSE_POINT<ul>
<li>如果打开现有文件并且它是符号链接，则返回的句柄是符号链接的句柄。</li>
<li>如果指定 <strong>了TRUNCATE_EXISTING</strong> 或 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> ，则受影响的文件是符号链接。</li>
</ul>
</li>
<li>如果未指定FILE_FLAG_OPEN_REPARSE_POINT：<ul>
<li>如果打开现有文件并且它是符号链接，则返回的句柄是目标句柄。</li>
<li>如果指定 <strong>CREATE_ALWAYS</strong>、 <strong>TRUNCATE_EXISTING</strong>或 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> ，则受影响的文件是目标。</li>
</ul>
</li>
</ul>
<h4 id="缓存行为"><a href="#缓存行为" class="headerlink" title="缓存行为"></a>缓存行为</h4><p><strong>CreateFile</strong> 使用 <em>dwFlagsAndAttributes</em> 参数的多个可能值来控制或影响系统缓存与句柄关联的数据的方式。 它们是：</p>
<ul>
<li><strong>FILE_FLAG_NO_BUFFERING</strong></li>
<li><strong>FILE_FLAG_RANDOM_ACCESS</strong></li>
<li><strong>FILE_FLAG_SEQUENTIAL_SCAN</strong></li>
<li><strong>FILE_FLAG_WRITE_THROUGH</strong></li>
<li><strong>FILE_ATTRIBUTE_TEMPORARY</strong></li>
</ul>
<p>如果未指定这些标志，系统将使用默认的常规用途缓存方案。 否则，系统缓存的行为与为每个标志指定。</p>
<p>不应合并其中一些标志。 例如，将 <strong>FILE_FLAG_RANDOM_ACCESS</strong> 与 <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong> 相结合是自败。</p>
<p>指定 <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong> 标志可以提高使用顺序访问读取大型文件的应用程序的性能。 对于主要按顺序读取大型文件的应用程序，性能提升可能更加明显，但偶尔会跳过小范围的字节。 如果应用程序移动文件指针进行随机访问，则很可能不会发生最佳缓存性能。 但是，仍可以保证正确的操作。</p>
<p><strong>标志FILE_FLAG_WRITE_THROUGH</strong>和<strong>FILE_FLAG_NO_BUFFERING</strong>是独立的，可以组合在一起。</p>
<p>如果使用 <strong>FILE_FLAG_WRITE_THROUGH</strong> 但 <strong>未指定FILE_FLAG_NO_BUFFERING</strong> ，以便系统缓存生效，则数据会写入系统缓存，但不会延迟地刷新到磁盘。</p>
<p>如果 <strong>同时指定了FILE_FLAG_WRITE_THROUGH</strong> 和 <strong>FILE_FLAG_NO_BUFFERING</strong> ，以便系统缓存无效，则数据会立即刷新到磁盘，而无需通过 Windows 系统缓存。 操作系统还会向永久性媒体请求硬盘本地硬件缓存的写入。</p>
<p><strong>注意</strong> 并非所有硬盘硬件都支持此写通功能。</p>
<p>正确使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志需要特殊的应用程序注意事项。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</p>
<p>通过 <strong>FILE_FLAG_WRITE_THROUGH</strong> 的写通请求还会导致 NTFS 刷新任何元数据更改，例如时间戳更新或重命名操作，这会导致处理请求。 因此， <strong>FILE_FLAG_WRITE_THROUGH</strong> 标志通常与 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志一起使用，作为每次写入后调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 函数的替代项，这可能会导致不必要的性能损失。 将这些标志一起使用可避免这些处罚。 有关文件和元数据缓存的一般信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-caching">文件缓存</a>。</p>
<p><strong>当FILE_FLAG_NO_BUFFERING</strong>与<strong>FILE_FLAG_OVERLAPPED</strong>结合使用时，标志提供最大的异步性能，因为 I/O 不依赖于内存管理器的同步操作。 但是，某些 I/O 操作需要更多时间，因为缓存中未保留数据。 此外，在创建空文件) 时，文件元数据仍可能 (缓存。 若要确保元数据刷新到磁盘，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 函数。</p>
<p>如果有足够的缓存内存可用，则指定 <strong>FILE_ATTRIBUTE_TEMPORARY</strong> 属性会导致文件系统避免将数据写回到大容量存储，因为应用程序在关闭句柄后删除临时文件。 在这种情况下，系统可以完全避免写入数据。 尽管它不直接控制数据缓存的方式与前面提到的标志相同， <strong>但FILE_ATTRIBUTE_TEMPORARY</strong> 属性确实会告知系统在系统缓存中尽可能多地保留，而无需写入，因此可能对某些应用程序感到担忧。</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>如果重命名或删除文件，然后在不久后还原该文件，系统将在缓存中搜索要还原的文件信息。 缓存信息包括其短/长名称对和创建时间。</p>
<p>如果在之前调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> 时挂起删除的文件上调用 <strong>CreateFile</strong>，该函数将失败。 操作系统会延迟文件删除，直到文件的所有句柄都关闭。 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_ACCESS_DENIED</strong>。</p>
<p><em>dwDesiredAccess</em> 参数可以是零，允许应用程序在不访问文件的情况下查询文件属性（如果应用程序正在运行且具有足够的安全设置）。 这可用于测试文件是否存在，而无需打开该文件进行读取和/或写入访问，或获取有关文件或目录的其他统计信息。 请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/obtaining-and-setting-file-information">获取和设置文件信息和</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a>。</p>
<p>如果指定 <strong>了CREATE_ALWAYS</strong> 和 <strong>FILE_ATTRIBUTE_NORMAL</strong> ， <strong>则 CreateFile</strong> 将失败，并将最后一个错误设置为 <strong>ERROR_ACCESS_DENIED</strong> （如果文件存在并且具有 <strong>FILE_ATTRIBUTE_HIDDEN</strong> 或 <strong>FILE_ATTRIBUTE_SYSTEM</strong> 属性）。 若要避免此错误，请指定与现有文件相同的属性。</p>
<p>当应用程序跨网络创建文件时，最好将 <em>dwDesiredAccess 用于 dwDesiredAccess</em>，而不是单独使用 <strong>GENERIC_WRITE</strong>。<code>GENERIC_READ | GENERIC_WRITE</code> 生成的代码速度更快，因为重定向程序可以使用缓存管理器，并发送更少的 SMB 和更多数据。 这种组合还避免了写入网络中的文件偶尔会返回 <strong>ERROR_ACCESS_DENIED</strong>的问题。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”。</p>
<h4 id="同步和异步-I-O-句柄"><a href="#同步和异步-I-O-句柄" class="headerlink" title="同步和异步 I/O 句柄"></a>同步和异步 I/O 句柄</h4><p><strong>CreateFile</strong> 用于创建同步或异步的文件或设备句柄。 同步句柄的行为使使用该句柄的 I/O 函数调用被阻止，直到它们完成，而异步文件句柄使系统能够立即从 I/O 函数调用返回，无论它们是否完成了 I/O 操作。 如前所述，此同步与异步行为通过指定 <em>dwFlagsAndAttributes</em> 参数中的<strong>FILE_FLAG_OVERLAPPED</strong>来确定。 使用异步 I/O 时存在多种复杂性和潜在缺陷;有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">同步和异步 I/O</a>。</p>
<h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><p>在 NTFS 文件系统上，可以使用 <strong>CreateFile</strong> 在文件中创建单独的流。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-streams">文件流</a>。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>应用程序无法使用 <strong>CreateFile</strong> 创建目录，因此对于此用例，只有 <strong>OPEN_EXISTING</strong> 值对 <em>dwCreationDisposition</em> 有效。 若要创建目录，应用程序必须调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a>。</p>
<p>若要使用 <strong>CreateFile</strong> 打开目录，请将 <strong>FILE_FLAG_BACKUP_SEMANTICS</strong> 标志指定为 <em>dwFlagsAndAttributes</em> 的一部分。 在没有 <strong>SE_BACKUP_NAME</strong> 和 <strong>SE_RESTORE_NAME</strong> 特权的情况下使用此标志时，仍适用适当的安全检查。</p>
<p>使用 <strong>CreateFile</strong> 在对 FAT 或 FAT32 文件系统卷进行碎片整理期间打开目录时，请不要指定 <strong>MAXIMUM_ALLOWED</strong> 访问权限。 如果这样做，则拒绝对目录的访问。 请改为指定 <strong>GENERIC_READ</strong> 访问权限。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/about-directory-management">“关于目录管理</a>”。</p>
<h4 id="物理磁盘和卷"><a href="#物理磁盘和卷" class="headerlink" title="物理磁盘和卷"></a>物理磁盘和卷</h4><p>对磁盘或卷的直接访问受到限制。</p>
<p><strong>Windows Server 2003 和 Windows XP：</strong> 以这种方式不限制对磁盘或卷的直接访问。</p>
<p>可以使用 <strong>CreateFile</strong> 函数打开物理磁盘驱动器或卷，该驱动器返回直接访问存储设备 (DASD) 句柄，该句柄可与 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 函数一起使用。 这样，便可以直接访问磁盘或卷，例如分区表等磁盘元数据。 但是，这种类型的访问也会向潜在的数据丢失公开磁盘驱动器或卷，因为使用此机制对磁盘进行不正确的写入可能会使其内容无法访问操作系统。 为了确保数据完整性，请务必熟悉 <strong>DeviceIoControl</strong> ，以及其他 API 的行为方式与直接访问句柄不同，而不是文件系统句柄。</p>
<p>必须满足以下要求才能成功进行此类调用：</p>
<ul>
<li>调用方必须具有管理权限。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecBP/running-with-special-privileges">使用特殊特权运行</a>。</li>
<li><em>dwCreationDisposition</em> 参数必须具有<strong>OPEN_EXISTING</strong>标志。</li>
<li>打开卷或软盘时， <em>dwShareMode</em> 参数必须具有 <strong>FILE_SHARE_WRITE</strong> 标志。</li>
</ul>
<p><strong>注意*</strong>dwDesiredAccess* 参数可以是零，允许应用程序在不访问设备的情况下查询设备属性。 这适用于应用程序来确定软盘驱动器的大小及其支持的格式，而无需驱动器中的软盘磁盘，例如。 它还可用于读取统计信息，而无需更高级别的数据读取/写入权限。</p>
<p>打开物理驱动器 <em>x</em>：时， <em>lpFileName</em> 字符串应采用以下形式：“.\PhysicalDrive<em>X</em>”。 硬盘编号从零开始。 下表显示了物理驱动器字符串的一些示例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">String</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“\.\PhysicalDrive0”</td>
<td style="text-align:left">打开第一个物理驱动器。</td>
</tr>
<tr>
<td style="text-align:left">“\.\PhysicalDrive2”</td>
<td style="text-align:left">打开第三个物理驱动器。</td>
</tr>
</tbody>
</table>
</div>
<p>若要获取卷的物理驱动器标识符，请打开卷的句柄，并使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-ioctl_volume_get_volume_disk_extents">IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS</a> 调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 函数。 此控制代码返回每个卷的一个或多个盘区的磁盘数和偏移量;卷可以跨越多个物理磁盘。</p>
<p>有关打开物理驱动器的示例，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/calling-deviceiocontrol">调用 DeviceIoControl</a>。</p>
<p>例如，打开卷或可移动媒体驱动器 (时，软盘驱动器或闪存内存拇指驱动器) ， <em>lpFileName</em> 字符串应采用以下形式：“.*X*：”。 请勿使用尾随反斜杠 () ，指示驱动器的根目录。 下表显示了驱动器字符串的一些示例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">String</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“\.\A：”</td>
<td style="text-align:left">打开软盘驱动器 A。</td>
</tr>
<tr>
<td style="text-align:left">“\.\C：”</td>
<td style="text-align:left">打开 C： 卷。</td>
</tr>
<tr>
<td style="text-align:left">“\.\C：\”</td>
<td style="text-align:left">打开 C： 卷的文件系统。</td>
</tr>
</tbody>
</table>
</div>
<p>还可以通过引用其卷名称打开卷。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-volume">命名卷</a>。</p>
<p>卷包含一个或多个装载的文件系统。 即使 <strong>CreateFile</strong> 中未指定非缓存选项，也可以按特定文件系统的任意方式打开卷句柄。 应假定所有 Microsoft 文件系统都以非缓存的形式打开卷句柄。 对文件的非缓存 I/O 的限制也适用于卷。</p>
<p>即使数据未缓存，文件系统也可能不需要缓冲区对齐。 但是，如果在打开卷时指定了非缓存选项，则会强制实施缓冲区对齐方式，而不管卷上的文件系统如何。 建议在所有文件系统上以非缓存方式打开卷句柄，并遵循非缓存 I/O 限制。</p>
<p><strong>注意</strong> 若要读取或写入卷的最后几个扇区，必须调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 并指定 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-fsctl_allow_extended_dasd_io">FSCTL_ALLOW_EXTENDED_DASD_IO</a>。 这表示文件系统驱动程序不会对分区读取或写入调用执行任何 I/O 边界检查。 相反，边界检查由设备驱动程序执行。</p>
<h4 id="更改器设备"><a href="#更改器设备" class="headerlink" title="更改器设备"></a>更改器设备</h4><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 的 <strong>IOCTL_CHANGER_*</strong> 控制代码接受变更器设备的句柄。 若要打开变更器设备，请使用以下格式的文件名：“\.\Changer<em>x</em>”，其中 <em>x</em> 是一个数字，指示要打开的设备，从零开始。 若要在用 C 或 C++ 编写的应用程序中打开变更器设备零，请使用以下文件名：“\\.\\Changer0”。</p>
<h4 id="磁带驱动器"><a href="#磁带驱动器" class="headerlink" title="磁带驱动器"></a>磁带驱动器</h4><p>可以使用以下格式的文件名打开磁带驱动器：“\.\TAPE<em>x</em>”，其中 <em>x</em> 是一个数字，指示要打开的驱动器，从磁带驱动器零开始。 若要在以 C 或 C++ 编写的应用程序中打开磁带驱动器零，请使用以下文件名：“\\.\\TAPE0”。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Backup/backup">备份</a>。</p>
<h4 id="通信资源"><a href="#通信资源" class="headerlink" title="通信资源"></a>通信资源</h4><p><strong>CreateFile</strong> 函数可以创建通信资源的句柄，例如串行端口 COM1。 对于通信资源， <em>dwCreationDisposition</em> 参数必须 <strong>OPEN_EXISTING</strong>， <em>dwShareMode</em> 参数必须是零 (独占访问) ， <em>并且 hTemplateFile</em> 参数必须为 <strong>NULL</strong>。 可以指定读取、写入或读/写访问权限，并且可以为重叠 I/O 打开句柄。</p>
<p>若要指定大于 9 的 COM 端口号，请使用以下语法：“.\COM10”。 此语法适用于允许指定 COM 端口号的所有端口号和硬件。</p>
<p>有关通信的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/communications-resources">通信</a>。</p>
<h4 id="机"><a href="#机" class="headerlink" title="机"></a>机</h4><p><strong>CreateFile</strong> 函数可以创建控制台输入 (CONIN$) 句柄。 如果进程由于继承或重复而具有打开的句柄，则它还可以创建活动屏幕缓冲区 (CONOUT$) 的句柄。 调用进程必须附加到继承的控制台或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/allocconsole">由 AllocConsole</a> 函数分配的控制台。 对于控制台句柄，请按如下所示设置 <strong>CreateFile</strong> 参数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">lpFileName</td>
<td style="text-align:left">使用 CONIN$ 值指定控制台输入。使用 CONOUT$ 值指定控制台输出。CONIN$ 获取控制台输入缓冲区的句柄，即使 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/setstdhandle">SetStdHandle</a> 函数重定向标准输入句柄。 若要获取标准输入句柄，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/getstdhandle">GetStdHandle</a> 函数。CONOUT$ 获取活动屏幕缓冲区的句柄，即使 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/setstdhandle">SetStdHandle</a> 重定向标准输出句柄。 若要获取标准输出句柄，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/getstdhandle">GetStdHandle</a>。</td>
</tr>
<tr>
<td style="text-align:left">dwDesiredAccess</td>
<td style="text-align:left">`GENERIC_READ</td>
<td>GENERIC_WRITE` 首选，但任一限制访问。</td>
</tr>
<tr>
<td style="text-align:left">dwShareMode</td>
<td style="text-align:left">打开 CONIN$时，请指定 <strong>FILE_SHARE_READ</strong>。 打开 CONOUT$时，请指定 <strong>FILE_SHARE_WRITE</strong>。如果调用进程继承控制台，或者子进程应能够访问控制台，则必须是 `FILE_SHARE_READ</td>
<td>FILE_SHARE_WRITE`此参数。</td>
</tr>
<tr>
<td style="text-align:left">lpSecurityAttributes</td>
<td style="text-align:left">如果希望继承控制台，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85">SECURITY_ATTRIBUTES结构的</a>)<strong>bInheritHandle</strong> 成员必须为 <strong>TRUE</strong>。</td>
</tr>
<tr>
<td style="text-align:left">dwCreationDisposition</td>
<td style="text-align:left">使用 <strong>CreateFile</strong> 打开控制台时，应指定<strong>OPEN_EXISTING</strong>。</td>
</tr>
<tr>
<td style="text-align:left">dwFlagsAndAttributes</td>
<td style="text-align:left">已忽略。</td>
</tr>
<tr>
<td style="text-align:left">hTemplateFile</td>
<td style="text-align:left">已忽略。</td>
</tr>
</tbody>
</table>
</div>
<p>下表显示了 <em>dwDesiredAccess</em> 和 <em>lpFileName</em> 的各种设置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">lpFileName</th>
<th style="text-align:left">dwDesiredAccess</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“CON”</td>
<td style="text-align:left"><strong>GENERIC_READ</strong></td>
<td style="text-align:left">打开用于输入的控制台。</td>
</tr>
<tr>
<td style="text-align:left">“CON”</td>
<td style="text-align:left"><strong>GENERIC_WRITE</strong></td>
<td style="text-align:left">打开用于输出的控制台。</td>
</tr>
<tr>
<td style="text-align:left">“CON”</td>
<td style="text-align:left">`GENERIC_READ</td>
<td style="text-align:left">GENERIC_WRITE`</td>
<td>导致 <strong>CreateFile</strong> 失败; <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_FILE_NOT_FOUND</strong>。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Mailslots"><a href="#Mailslots" class="headerlink" title="Mailslots"></a>Mailslots</h4><p>如果 <strong>CreateFile</strong> 打开 mailslot 的客户端端，则函数将返回 <strong>INVALID_HANDLE_VALUE</strong> 如果 mailslot 客户端尝试在 mailslot 服务器使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createmailslota">CreateMailSlot 函数创建本地 mailslot 之前打开本地 mailslot</a> 。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/mailslots">Mailslots</a>。</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>如果 <strong>CreateFile</strong> 打开命名管道的客户端端，该函数将使用处于侦听状态的命名管道的任何实例。 打开过程可以根据需要多次复制句柄，但在打开该句柄之后，另一个客户端无法打开命名管道实例。 打开管道时指定的访问必须与 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> 函数的 <em>dwOpenMode</em> 参数中指定的访问兼容。</p>
<p>如果在此操作之前未在服务器上成功调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> 函数，则管道将不存在， <strong>并且 CreateFile</strong> 将失败 <strong>并出现ERROR_FILE_NOT_FOUND</strong>。</p>
<p>如果至少有一个活动管道实例，但服务器上没有可用的侦听器管道，这意味着所有管道实例当前都已连接， <strong>则 CreateFile</strong> 会失败 <strong>并ERROR_PIPE_BUSY</strong>。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/pipes">管道</a>。</p>
<h3 id="ReadFile-函数-fileapi-h"><a href="#ReadFile-函数-fileapi-h" class="headerlink" title="ReadFile 函数 (fileapi.h)"></a>ReadFile 函数 (fileapi.h)</h3><p>从指定的文件或输入/输出 (I/O) 设备读取数据。 如果设备支持，则读取发生在文件指针指定的位置。</p>
<p>此函数适用于同步操作和异步操作。 有关专为异步操作设计的类似函数，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a>。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">ReadFile</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>                HANDLE       hFile<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">]</span>               LPVOID       lpBuffer<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>                DWORD        nNumberOfBytesToRead<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>     LPDWORD      lpNumberOfBytesRead<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPOVERLAPPED lpOverlapped
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] hFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设备句柄 (例如文件、文件流、物理磁盘、卷、控制台缓冲区、磁带驱动器、套接字、通信资源、mailslot 或管道) 。</p>
<p>必须使用读取访问权限创建 <em>hFile</em> 参数。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/generic-access-rights">通用访问权限</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-security-and-access-rights">文件安全性和访问权限</a>。</p>
<p>对于异步读取操作，<em>hFile</em> 可以是使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 函数的<strong>FILE_FLAG_OVERLAPPED</strong>标志打开的任何句柄，也可以是套接字或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> 函数返回的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock2/nf-winsock2-socket">套接字</a>句柄。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>指向接收从文件或设备读取数据的缓冲区的指针。</p>
<p>此缓冲区必须在读取操作期间保持有效。 在读取操作完成之前，调用方不得使用此缓冲区。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] nNumberOfBytesToRead<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要读取的最多字节数。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpNumberOfBytesRead<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>指向使用同步 <em>hFile</em> 参数时接收读取的字节数的变量的指针。 <strong>ReadFile</strong> 将此值设置为零，然后再执行任何工作或错误检查。 如果这是一个异步操作，请对此参数使用 <strong>NULL</strong> ，以避免潜在的错误结果。</p>
<p>仅当 <em>lpOverlapped</em> 参数不为 <strong>NULL</strong> 时，此参数才可为 <strong>NULL</strong>。</p>
<p><strong>Windows 7：</strong> 此参数不能为 <strong>NULL</strong>。</p>
<p>有关详细信息，请参见“备注”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in, out, optional] lpOverlapped<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong> 打开 <em>hFile</em> 参数，则需要指向 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的指针，否则可为 <strong>NULL</strong>。</p>
<p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong>打开 <em>hFile</em>，<em>则 lpOverlapped</em> 参数必须指向有效且唯一的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构，否则该函数无法错误地报告读取操作已完成。</p>
<p>对于支持字节偏移量的 <em>hFile</em> ，如果使用此参数，则必须指定从文件或设备开始读取的字节偏移量。 通过设置 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的 <strong>Offset</strong> 和 <strong>OffsetHigh</strong> 成员来指定此偏移量。 对于不支持字节偏移量的 <em>hFile</em>，将忽略 <strong>Offset 和 OffsetHigh</strong>。</p>
<p>有关 <em>lpOverlapped</em> 和 <strong>FILE_FLAG_OVERLAPPED</strong>的不同组合的详细信息，请参阅“备注”部分和 <strong>“同步和文件位置</strong> ”部分。</p>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>如果函数成功，则返回值为非零 (<strong>TRUE</strong>) 。</p>
<p>如果函数失败或异步完成，则返回值为零， (<strong>FALSE</strong>) 。 若要获取扩展的错误信息，请调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数。</p>
<p><strong>注意</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 代码<strong>ERROR_IO_PENDING</strong>不是失败;它指定读取操作正在异步等待完成。 有关详细信息，请参阅“备注”。</p>
<h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><p>发生以下情况之一时， <strong>ReadFile</strong> 函数将返回：</p>
<ul>
<li></li>
<li><p>读取请求的字节数。</p>
</li>
<li>写入操作在管道的写入端完成。</li>
<li>正在使用异步句柄，读取正在异步发生。</li>
<li>发生错误。</li>
</ul>
<p>每当有过多未完成的异步 I/O 请求时，<strong>ReadFile</strong> 函数可能会失败<strong>，**</strong>ERROR_INVALID_USER_BUFFER或ERROR_NOT_ENOUGH_MEMORY**。</p>
<p>若要取消所有挂起的异步 I/O 操作，请使用以下任一操作：</p>
<ul>
<li></li>
<li><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelio">CancelIo</a> - 此函数仅取消由指定文件句柄的调用线程发出的操作。</p>
</li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelioex-func">CancelIoEx</a> - 此函数取消指定文件句柄的线程发出的所有操作。</li>
</ul>
<p>使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</a> 取消挂起的同步 I/O 操作。</p>
<p>取消的 I/O 操作已完成，错误 <strong>ERROR_OPERATION_ABORTED</strong>。</p>
<p><strong>ReadFile</strong> 函数可能会失败<strong>，ERROR_NOT_ENOUGH_QUOTA</strong>，这意味着调用进程的缓冲区无法锁定页。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-setprocessworkingsetsize">SetProcessWorkingSetSize</a>。</p>
<p>如果某个文件的一部分被另一个进程锁定，并且读取操作与锁定部分重叠，则此函数将失败。</p>
<p>读取操作使用缓冲区时访问输入缓冲区可能会导致读取到该缓冲区的数据损坏。 在读取操作完成之前，应用程序不得读取、写入、重新分配或释放读取操作使用的输入缓冲区。 使用异步文件句柄时，这尤其有问题。 有关同步与异步文件句柄的其他信息，可以在 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/">“同步和文件位置</a> ”部分以及 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 参考主题中找到。</p>
<p>可以使用具有控制台输入句柄的 <strong>ReadFile</strong> 从控制台输入缓冲区读取字符。 控制台模式确定 <strong>ReadFile</strong> 函数的确切行为。 默认情况下，控制台模式 <strong>ENABLE_LINE_INPUT</strong>，指示 <strong>ReadFile</strong> 应在到达回车前读取。 如果按 Ctrl+C，则调用成功，但 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_OPERATION_ABORTED</strong>。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>。</p>
<p>从通信设备读取时， <strong>ReadFile</strong> 的行为由当前通信超时确定为集，并使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-setcommtimeouts">SetCommTimeouts</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-getcommtimeouts">GetCommTimeouts</a> 函数进行检索。 如果无法设置超时值，则可能会出现不可预知的结果。 有关通信超时的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/ns-winbase-commtimeouts">COMMTIMEOUTS</a>。</p>
<p>如果 <strong>ReadFile</strong> 尝试从具有太小缓冲区的邮件图中读取，则函数返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_INSUFFICIENT_BUFFER</strong>。</p>
<p>使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志成功使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 打开的文件有严格的要求。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</p>
<p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong> 打开 <em>hFile</em>，则以下条件有效：</p>
<ul>
<li></li>
<li><p><em>lpOverlapped</em> 参数必须指向有效且唯一的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构，否则该函数可以错误地报告读取操作已完成。</p>
</li>
<li><em>lpNumberOfBytesRead</em> 参数应设置为 <strong>NULL</strong>。 使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> 函数获取读取的实际字节数。 如果 <em>hFile</em> 参数与 I/O 完成端口相关联，则还可以通过调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> 函数获取读取的字节数。</li>
</ul>
<h4 id="同步和文件位置"><a href="#同步和文件位置" class="headerlink" title="同步和文件位置"></a>同步和文件位置</h4><p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong>打开 <em>hFile</em>，则它是异步文件句柄;否则为同步。 使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的规则对每个结构略有不同，如前所述。</p>
<p><strong>注意</strong> 如果为异步 I/O 打开文件或设备，则使用该句柄对 <strong>ReadFile</strong> 等函数的后续调用通常会立即返回，但对于被阻止的执行，也可以同步执行。 有关更多信息，请参见<a target="_blank" rel="noopener" href="https://support.microsoft.com/kb/156932">http://support.microsoft.com/kb/156932</a>。</p>
<p>使用异步文件句柄的注意事项：</p>
<ul>
<li><p><strong>ReadFile</strong> 可能会在读取操作完成之前返回。 在此方案中， <strong>ReadFile</strong> 返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数返回 <strong>ERROR_IO_PENDING</strong>，这允许调用进程在系统完成读取操作时继续。</p>
</li>
<li><p>lpOverlapped</p>
</li>
</ul>
<p>  参数不得为</p>
<p>  NULL</p>
<p>  ，应与以下事实一起使用：</p>
<ul>
<li>尽管 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件由系统自动设置和重置，但 <strong>在 OVERLAPPED</strong> 结构中指定的偏移量不会自动更新。</li>
<li><strong>ReadFile</strong> 在开始 I/O 操作时将事件重置为非对齐状态。</li>
<li>在 READ 操作完成时， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件设置为信号状态;直到该时间，读取操作被视为挂起。</li>
<li>由于读取操作从 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的偏移量开始，并且 <strong>ReadFile</strong> 可能会在系统级读取操作完成 (读取挂起) 之前返回，因此，应用程序不应修改、释放或重用结构的任何其他部分，直到向事件发出信号 (（即） 读取完成) 。</li>
<li>如果在异步操作期间检测到文件结束 (EOF) ，则对该操作的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> 的调用将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_HANDLE_EOF</strong>。</li>
</ul>
<p>使用同步文件句柄的注意事项：</p>
<ul>
<li>如果 <em>lpOverlapped</em> 为 <strong>NULL</strong>，则读取操作从当前文件位置开始， <strong>ReadFile</strong> 在操作完成之前不会返回，并且系统会在 <strong>ReadFile</strong> 返回之前更新文件指针。</li>
<li>如果 <em>lpOverlapped</em> 不是 <strong>NULL</strong>，则读取操作从 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的偏移量开始， <strong>ReadFile</strong> 在读取操作完成之前不会返回。 系统在 <strong>ReadFile</strong> 返回之前更新 <strong>OVERLAPPED</strong> 偏移量和文件指针。</li>
<li>如果 <em>lpOverlapped</em> 为 <strong>NULL</strong>，则当同步读取操作到达文件末尾时， <strong>ReadFile</strong> 将返回 <strong>TRUE</strong> 并将设置为 <code>*lpNumberOfBytesRead</code> 零。</li>
<li>如果 <em>lpOverlapped</em> 不是 <strong>NULL</strong>，则当同步读取操作到达文件末尾时， <strong>ReadFile</strong> 将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_HANDLE_EOF</strong>。</li>
</ul>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">同步和异步 I/O</a>。</p>
<h4 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a>管道</h4><p>如果使用匿名管道并且写入句柄已关闭，则 <strong>当 ReadFile</strong> 尝试使用管道的相应读取句柄进行读取时，函数将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_BROKEN_PIPE</strong>。</p>
<p>如果在消息模式下读取命名管道，并且下一条消息的长度超过 <em>nNumberOfBytesToRead</em> 参数指定， <strong>ReadFile</strong> 将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_MORE_DATA</strong>。 后续调用 <strong>ReadFile</strong> 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe">PeekNamedPipe</a> 函数可以读取消息的其余部分。</p>
<p>如果 <strong>ReadFile</strong> 在管道上返回 <strong>TRUE</strong> 时<em>，lpNumberOfBytesRead</em> 参数为零，则管道的另一端称为 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> 函数，<em>nNumberOfBytesToWrite</em> 设置为零。</p>
<p>有关管道的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/pipes">管道</a>。</p>
<h4 id="事务处理的操作"><a href="#事务处理的操作" class="headerlink" title="事务处理的操作"></a>事务处理的操作</h4><p>如果存在绑定到文件句柄的事务，则该函数将从文件的事务处理视图中返回数据。 保证事务处理读取句柄在句柄期间显示文件的相同视图。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/about-transactional-ntfs">关于事务 NTFS</a>。</p>
<p>在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/05/16/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89/">http://charliechen114514.github.io/2023/05/16/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Windows-32API/">Windows 32API</a><a class="post-meta__tags" href="/tags/%E6%91%B8%E9%B1%BCing/">摸鱼ing</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/19/More-Effective-C-1/" title="More Effective C++(1)"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">More Effective C++(1)</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/16/%E6%91%B8%E9%B1%BCing%EF%BC%881%EF%BC%89-Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%9D%E6%8E%A2%EF%BC%882%EF%BC%89/" title="摸鱼ing（1）-Windows-API-程序设计初探（2）"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">摸鱼ing（1）-Windows-API-程序设计初探（2）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/04/%E6%91%B8%E9%B1%BCing%EF%BC%881%EF%BC%89-Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%9D%E6%8E%A2%EF%BC%881%EF%BC%89/" title="摸鱼ing（1） Windows API 程序设计初探（1）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-04</div><div class="title">摸鱼ing（1） Windows API 程序设计初探（1）</div></div></a></div><div><a href="/2023/05/16/%E6%91%B8%E9%B1%BCing%EF%BC%881%EF%BC%89-Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%9D%E6%8E%A2%EF%BC%882%EF%BC%89/" title="摸鱼ing（1）-Windows-API-程序设计初探（2）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">摸鱼ing（1）-Windows-API-程序设计初探（2）</div></div></a></div><div><a href="/2023/05/19/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89/" title="Windows-API-程序设计（2）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-19</div><div class="title">Windows-API-程序设计（2）</div></div></a></div><div><a href="/2023/05/27/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3/" title="Windows-API-程序设计(3)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-27</div><div class="title">Windows-API-程序设计(3)</div></div></a></div><div><a href="/2023/05/27/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4/" title="Windows-API-程序设计(4)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-27</div><div class="title">Windows-API-程序设计(4)</div></div></a></div><div><a href="/2023/05/28/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%885%EF%BC%89/" title="Windows-API-程序设计（5）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-28</div><div class="title">Windows-API-程序设计（5）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">84</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">大更新！这下上了简单的数据结构的C实现，如果只对思路感兴趣看思路即可，如果想查看API实现就取看详解</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Windows-API"><span class="toc-number">1.</span> <span class="toc-text">系统学习Windows API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%80%E7%9C%8B"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型一看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">API基础函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6demo"><span class="toc-number">1.3.</span> <span class="toc-text">读取文件demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read-file"><span class="toc-number">1.4.</span> <span class="toc-text">read file</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#createFileW-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.4.1.</span> <span class="toc-text">createFileW 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">符号链接行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">缓存行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5-I-O-%E5%8F%A5%E6%9F%84"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">同步和异步 I&#x2F;O 句柄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">1.4.1.7.</span> <span class="toc-text">文件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.4.1.8.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%A3%81%E7%9B%98%E5%92%8C%E5%8D%B7"><span class="toc-number">1.4.1.9.</span> <span class="toc-text">物理磁盘和卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%99%A8%E8%AE%BE%E5%A4%87"><span class="toc-number">1.4.1.10.</span> <span class="toc-text">更改器设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E5%B8%A6%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="toc-number">1.4.1.11.</span> <span class="toc-text">磁带驱动器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E8%B5%84%E6%BA%90"><span class="toc-number">1.4.1.12.</span> <span class="toc-text">通信资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA"><span class="toc-number">1.4.1.13.</span> <span class="toc-text">机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mailslots"><span class="toc-number">1.4.1.14.</span> <span class="toc-text">Mailslots</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">1.4.1.15.</span> <span class="toc-text">管道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadFile-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.4.2.</span> <span class="toc-text">ReadFile 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-1"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">同步和文件位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-1"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">事务处理的操作</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/01/Qt-Opencv-Config/" title="Qt &amp;&amp; Opencv Config"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt &amp;&amp; Opencv Config"/></a><div class="content"><a class="title" href="/2023/06/01/Qt-Opencv-Config/" title="Qt &amp;&amp; Opencv Config">Qt &amp;&amp; Opencv Config</a><time datetime="2023-06-01T13:31:25.000Z" title="发表于 2023-06-01 21:31:25">2023-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/31/Ros%E5%B0%8F%E8%BD%A6%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%EF%BC%88%E6%B0%B4%EF%BC%81%EF%BC%89/" title="Ros小车简单操作（水！）"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ros小车简单操作（水！）"/></a><div class="content"><a class="title" href="/2023/05/31/Ros%E5%B0%8F%E8%BD%A6%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%EF%BC%88%E6%B0%B4%EF%BC%81%EF%BC%89/" title="Ros小车简单操作（水！）">Ros小车简单操作（水！）</a><time datetime="2023-05-31T12:34:30.000Z" title="发表于 2023-05-31 20:34:30">2023-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/QT-new-14/" title="QT new 14"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QT new 14"/></a><div class="content"><a class="title" href="/2023/05/29/QT-new-14/" title="QT new 14">QT new 14</a><time datetime="2023-05-29T09:14:07.000Z" title="发表于 2023-05-29 17:14:07">2023-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%886%EF%BC%89/" title="Windows-API-程序设计（6）"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows-API-程序设计（6）"/></a><div class="content"><a class="title" href="/2023/05/29/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%886%EF%BC%89/" title="Windows-API-程序设计（6）">Windows-API-程序设计（6）</a><time datetime="2023-05-29T09:13:07.000Z" title="发表于 2023-05-29 17:13:07">2023-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/28/pytorch%E5%AD%A6%E4%B9%A05/" title="pytorch学习5"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pytorch学习5"/></a><div class="content"><a class="title" href="/2023/05/28/pytorch%E5%AD%A6%E4%B9%A05/" title="pytorch学习5">pytorch学习5</a><time datetime="2023-05-28T13:51:30.000Z" title="发表于 2023-05-28 21:51:30">2023-05-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>