<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>QT new 9-10-11 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="QT new 9一些经典容器的若干操作QListWidget​        下面的文段来自QT帮助助手！ Detailed Description  ​        QListWidget is a convenience class that provides a list view similar to the one supplied by QListView, but with a c">
<meta property="og:type" content="article">
<meta property="og:title" content="QT new 9-10-11">
<meta property="og:url" content="http://charliechen114514.github.io/2023/05/26/QT-new-9-10-11/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="QT new 9一些经典容器的若干操作QListWidget​        下面的文段来自QT帮助助手！ Detailed Description  ​        QListWidget is a convenience class that provides a list view similar to the one supplied by QListView, but with a c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-05-26T12:28:03.000Z">
<meta property="article:modified_time" content="2023-05-26T12:32:24.944Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="QT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/05/26/QT-new-9-10-11/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'QT new 9-10-11',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-26 20:32:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">QT new 9-10-11</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-26T12:28:03.000Z" title="发表于 2023-05-26 20:28:03">2023-05-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-26T12:32:24.944Z" title="更新于 2023-05-26 20:32:24">2023-05-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="QT new 9-10-11"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="QT-new-9"><a href="#QT-new-9" class="headerlink" title="QT new 9"></a>QT new 9</h1><h2 id="一些经典容器的若干操作"><a href="#一些经典容器的若干操作" class="headerlink" title="一些经典容器的若干操作"></a>一些经典容器的若干操作</h2><h3 id="QListWidget"><a href="#QListWidget" class="headerlink" title="QListWidget"></a>QListWidget</h3><p>​        下面的文段来自QT帮助助手！</p>
<pre><code>Detailed Description
</code></pre><p><img src="image-20230526191818350.png" alt="image-20230526191818350"></p>
<p>​        QListWidget is a convenience class that provides a list view similar to the one supplied by QListView, but with a classic item-based interface for adding and removing items. QListWidget uses an internal model to manage each QListWidgetItem in the list.<br>For a more flexible list view widget, use the QListView class with a standard model.<br>List widgets are constructed in the same way as other widgets:</p>
<pre class="line-numbers language-none"><code class="language-none">QListWidget *listWidget &#x3D; new QListWidget(this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        The selectionMode() of a list widget determines how many of the items in the list can be selected at the same time, and whether complex selections of items can be created. This can be set with the setSelectionMode() function.<br>There are two ways to add items to the list: they can be constructed with the list widget as their parent widget, or they can be constructed with no parent widget and added to the list later. If a list widget already exists when the items are constructed, the first method is easier to use:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">new QListWidgetItem(tr(&quot;Oak&quot;), listWidget);
new QListWidgetItem(tr(&quot;Fir&quot;), listWidget);
new QListWidgetItem(tr(&quot;Pine&quot;), listWidget);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        If you need to insert a new item into the list at a particular position, then it should be constructed without a parent widget. The insertItem() function should then be used to place it within the list. The list widget will take ownership of the item.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem *newItem &#x3D; new QListWidgetItem;
newItem-&gt;setText(itemText);
listWidget-&gt;insertItem(row, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        For multiple items, insertItems() can be used instead. The number of items in the list is found with the count() function. To remove items from the list, use takeItem().<br>​        The current item in the list can be found with currentItem(), and changed with setCurrentItem(). The user can also change the current item by navigating with the keyboard or clicking on a different item. When the current item changes, the currentItemChanged() signal is emitted with the new current item and the item that was previously current.</p>
<p>​        大致就是创建一个长得像那样链表似的一个控件！</p>
<p><img src="image-20230526192003545.png" alt="image-20230526192003545">        在QT 的 UI设计下，常常见这个控件于： List Widget下面。</p>
<p>​        我们这里不对对象名称做什么修改了！默认的情况下——</p>
<pre class="line-numbers language-none"><code class="language-none">ui -&gt; listWidget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        找到它来！</p>
<p>​        为了添加控件，我们有两种方式来进行：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 方式1
QListWidgetItem* item &#x3D; new QListWidgetItem(&quot;卢本伟牛逼&quot;);

ui-&gt;listWidget-&gt;addItem(item);

item-&gt;setTextAlignment(Qt::AlignHCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这就是一种方式——通过包装成 Item 送到Widget里去。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 方式2
QStringList list;
list &lt;&lt; &quot;卢&quot;&lt;&lt;&quot;本&quot;&lt;&lt;&quot;伪&quot;&lt;&lt;&quot;牛&quot;&lt;&lt;&quot;逼&quot;;
ui-&gt;listWidget-&gt;addItems(list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是通过传入String List 链表的方式送数据。</p>
<h3 id="1）添加条目的函数"><a href="#1）添加条目的函数" class="headerlink" title="1）添加条目的函数"></a>1）<strong>添加条目的函数</strong></h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">void</span> <span class="token class-name static-context">QListWidget</span><span class="token operator">::</span><span class="token function">addItem</span><span class="token punctuation">(</span>QListWidgetItem <span class="token operator">*</span> item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这个添加函数需要实现 new 一个 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 条目对象，然后添加到列表控件末尾，下面小节会专门讲 QListWidgetItem 类。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::addItem(const QString &amp; label)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这第二个添加函数其实更常用，因为更简便，功能是将字符串 label 添加到列表控件末尾显示，其实该函数内部会自动根据字符串 new 一个条目对象添加到列表控件。<br>如果有设置好的字符串列表，那么可以通过如下函数把多个字符串全部添加到列表控件：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::addItems(const QStringList &amp; labels)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>add<em> 函数是将条目添加到末尾，如果要将条目插入到指定行 row 位置，则使用 insert</em> 函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::insertItem(int row, QListWidgetItem * item) &#x2F;&#x2F;插入条目到第 row 行
void QListWidget::insertItem(int row, const QString &amp; label) &#x2F;&#x2F;插入字符串到第 row 行
void QListWidget::insertItems(int row, const QStringList &amp; labels) &#x2F;&#x2F;插入多个字符串到从 row 行开始的多个行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>获取列表控件里面的条目计数使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QListWidget::count() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（2）删除函数"><a href="#（2）删除函数" class="headerlink" title="（2）删除函数"></a>（2）<strong>删除函数</strong></h2><p>​        因为是基于条目的控件，所以列表控件的删除单个条目函数名字是 <strong>takeItem()</strong>：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::takeItem(int row)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        takeItem() 根据行号从列表控件移除一个条目，并返回该条目指针，如果行号不合法，返回 NULL 指针。<br>​        如果返回的是实际存在的条目，那么需要注意，返回的条目指针需要手动 delete 掉，因为列表控件不再拥有该条目，该条目<strong>不会由列表控件析构时自动删除。</strong><br>​        <strong>takeItem() 函数还有第二个用途，因为列表控件没有直接的调整条目前后顺序的函数，可以先将要调整顺序的条目移出来takeItem()，然后再调用 insertItem() 把这个条目插入到新的位置。</strong>（重点关注之）</p>
<p>​        如果要清空整个列表控件，删除之前添加的所有条目，可以调用槽函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（3）条目访问函数"><a href="#（3）条目访问函数" class="headerlink" title="（3）条目访问函数"></a>（3）<strong>条目访问函数</strong></h2><p>​        根据行号获取条目对象的指针，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::item(int row) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果已知列表控件含有的条目对象指针，反查当前行号，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QListWidget::row(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>在图形界面，如果希望根据列表控件在屏幕显示的相对坐标位置（以列表控件内部左上角为原点）来获取条目，使用如下函数：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::itemAt(const QPoint &amp; p) const

QListWidgetItem * QListWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>反过来，如果根据已知条目，获取这个条目占据的矩形区域，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QRect QListWidget::visualItemRect(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（4）当前选中条目的操作"><a href="#（4）当前选中条目的操作" class="headerlink" title="（4）当前选中条目的操作"></a>（4）<strong>当前选中条目的操作</strong></h2><p>获取列表控件当前选中条目的函数如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::currentItem() const &#x2F;&#x2F;当前选中 条目
int QListWidget::currentRow() const  &#x2F;&#x2F;当前选中的行号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果当前没有选中的条目，那么返回的指针为 NULL，返回的序号为 -1 ，代码里要注意判断返回值。</p>
<p>设置已存在的某个条目为选中状态，使用函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::setCurrentItem(QListWidgetItem * item)    &#x2F;&#x2F;设置当前选中条目为 item
void QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)
void QListWidget::setCurrentRow(int row, QItemSelectionModel::SelectionFlags command)&#x2F;&#x2F;设置当前选中行为 row
void QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        第二个和第四个设置函数有个 SelectionFlags 类型的参数 command，这个参数决定选中的方式，是要选中QItemSelectionModel::Select ，还是取消选中 QItemSelectionModel::Deselect，还有其他选中方式，等到表格控件一节再详细列出来。<br>如果当前选中的条目发生变化，会触发如下三个信号，可以根据实际用途选择合适的信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::currentItemChanged(QListWidgetItem * current, QListWidgetItem * previous)

void QListWidget::currentRowChanged(int currentRow)

void QListWidget::currentTextChanged(const QString &amp; currentText)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意参数里的指针有可能为空值，序号可能为 -1，字符串也可能是空串，一定要注意判断非法的参数值。</p>
<p>​        本章的三个控件都可以设置选中模式，比如单选模式，一次只能选中一个条目，多选模式，一次可以选中多个条目等等，详细的选中模式在放到表格控件一节讲解，因为表格 中涉及的选中模式较多，一块讲解。本节的列表控件默认情况下，选中模式为单选 。QAbstractItemView::SingleSelection，以上的 <em>current</em> 等函数都是基于默认的单选模式的。</p>
<p>​        如果需要用到多选模式，可以设置 selectionMode 属性为 QAbstractItemView::ExtendedSelection，这种扩展选中模式类似常见的文件资源管理器的选中模式，可以使用 Ctrl 或 Shift 加鼠标点击实现多选：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setSelectionMode(QAbstractItemView::SelectionMode mode)  &#x2F;&#x2F;设置选中模式
QAbstractItemView::SelectionMode    selectionMode() const     &#x2F;&#x2F;获取选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        QAbstractItemView 是本章所有控件的抽象基类，本章后面控件也有类似的选中模式设置，如果把列表控件设置成多选模式，那么可以用如下函数获取同 时选中的多个条目：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QListWidgetItem *&gt; QListWidget::selectedItems() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        不论单选还是多选模式，条目选中情况有任何变化时，会触发如下信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemSelectionChanged()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（5）条目查找和排序"><a href="#（5）条目查找和排序" class="headerlink" title="（5）条目查找和排序"></a>（5）<strong>条目查找和排序</strong></h2><p>​        如果需要根据文本查找匹配的条目，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QListWidgetItem *&gt; QListWidget::findItems(const QString &amp; text, Qt::MatchFlags flags) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        该函数第一个参数 text 是要查找的模板子串，第二个参数是匹配标志，Qt::MatchFlags 是非常通用的枚举类型，不仅可用于字符串匹配，还能用于其他类型变量的匹配，Qt::MatchFlags 包含关于查找匹配的多种方式的枚举值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Qt::MatchFlags 枚举常量</strong></th>
<th><strong>数值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::MatchExactly</td>
<td>0</td>
<td>精确匹配，执行基于 QVariant 的匹配。</td>
</tr>
<tr>
<td>Qt::MatchFixedString</td>
<td>8</td>
<td>执行基于字符串的匹配，如果不指定 MatchCaseSensitive，默认是大小写不敏感。</td>
</tr>
<tr>
<td>Qt::MatchContains</td>
<td>1</td>
<td>条目包含要查找的模板子串。</td>
</tr>
<tr>
<td>Qt::MatchStartsWith</td>
<td>2</td>
<td>条目以要查找的模板子串打头。</td>
</tr>
<tr>
<td>Qt::MatchEndsWith</td>
<td>3</td>
<td>条目以要查找的模板子串结尾。</td>
</tr>
<tr>
<td>Qt::MatchCaseSensitive</td>
<td>16</td>
<td>查找时大小写敏感。</td>
</tr>
<tr>
<td>Qt::MatchRegExp</td>
<td>4</td>
<td>根据正则表达式模板子串匹配字符串。</td>
</tr>
<tr>
<td>Qt::MatchWildcard</td>
<td>5</td>
<td>根据通配符模板子串（如 *.txt）匹配字符串。</td>
</tr>
<tr>
<td>Qt::MatchWrap</td>
<td>32</td>
<td>执行回绕查找，当查找到最后一个条目时返回到第一个的条目继续查找，直到所有的条目都检查一遍。</td>
</tr>
<tr>
<td>Qt::MatchRecursive</td>
<td>64</td>
<td>递归查找，遍历所有子条目。</td>
</tr>
</tbody>
</table>
</div>
<p>​        后面两节的表格控件和树形控件也有类似的查找函数 findItems() ，第二个匹配标志参数也是一样的类型。</p>
<p>​        列表控件的自动排序是通过 sortingEnabled 属性来控制，获取和设置函数如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool isSortingEnabled() const
void setSortingEnabled(bool enable)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        列表控件条目默认是不排序的，如果希望自动按照字典序排序，调用 setSortingEnabled(true) 即可。另外还可以手动对列表控件现有条目排序：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::sortItems(Qt::SortOrder order &#x3D; Qt::AscendingOrder)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Qt::AscendingOrder 是按升序排列，Qt::DescendingOrder 是按降序排列。</p>
<h2 id="（6）条目显示和运行时条目编辑"><a href="#（6）条目显示和运行时条目编辑" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）<strong>条目显示和运行时条目编辑</strong></h2><p>​        关于列表控件 QListWidget 和里面的条目 QListWidgetItem，需要注意条目 QListWidgetItem 仅仅是数据，不是控件或子控件，列表控件根据多个 QListWidgetItem 对象，来呈现条目里的数据，<strong>只有列表控件自己是控件实体。</strong><br>列表控件默认以自己的方式呈现条目数据，比如白底黑字的普通条目显示，如果要按照特殊的子控件来显示字符串，比如用 QLabel 对象显示条目数据，可以用如下函 数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::setItemWidget(QListWidgetItem * item, QWidget * widget)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        列表控件会同时拥有 item 数据条目和用于显示 item 的子控件 widget。注意这里的子控件 widget 只有静态显示功能，如果用按钮作为显示子控件，那么按钮是不可点击的。如果希望自己定制一个能交互操作的子条目显示控件，需要使用 QListView 并子类化 QItemDelegate 类，这些复杂的等到模型视图章节再讲。</p>
<p>​        对于本节列表控件，如果要获取 setItemWidget() 函数指定某个条目的显示子控件，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QWidget * QListWidget::itemWidget(QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果要删除上面 setItemWidget() 指定的特殊显示控件，使用函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::removeItemWidget(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        特殊的显示子控件移除后，该条目就还按照列表控件原来的普通条目显示。</p>
<p>​        <strong>如果希望在程序运行时编辑列表控件的条目，有两种方式，本小节先讲第一种（第二种是设置条目自身的特性标志），手动打开条目的文本编辑器（这个编辑器是列表控件自 带功能，与 setItemWidget 设置的显示子控件没关系）：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::openPersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>这个函数名是打开条目的持续编辑器，持续的意思是如果不调用关闭函数，该条目的编辑器会一直开启，关闭这个持续编辑器使用如下函数：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::closePersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>一般可以在检测到条目激活信号（itemActivated）时调用打开函数 openPersistentEditor() ，在当前条目变化（ currentItemChanged）时调用关闭函数 closePersistentEditor() 。</strong> 使用这一对开关持续编辑器函数涉及到编写多个信号的槽函数，使用比较麻烦，建议用后面第二小节介绍的条目标 志位和 QListWidget::editItem(QListWidgetItem * item) 实现条目的可编辑功能。</p>
<h2 id="（7）其他信号和槽函数"><a href="#（7）其他信号和槽函数" class="headerlink" title="（7）其他信号和槽函数"></a>（7）<strong>其他信号和槽函数</strong></h2><p>除了上面关于当前条目变化和选中条目变化的信号，条目还有激活、单击、双击等信号，罗列如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemActivated(QListWidgetItem * item)  &#x2F;&#x2F;激活信号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当用户点击或双击条目时，条目会被激活，具体哪些操作会激活条目，要根据操作系统设置来定，比如 Windows 一般是双击打开激活，KDE 桌面通常是单击打开激活。另外，系统的快捷键也可以激活条目，如 Windows 和 Linux X11 桌面是回车键激活，Mac OS X 是 Ctrl+0 ，一般激活信号用于开启编辑等操作。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemChanged(QListWidgetItem * item)   &#x2F;&#x2F;条目内容发生变化<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意这是条目内容变化的信号，不是选中状态变化，程序如果在运行时改变了条目文本内容，比如持续编辑器修改了文本，会触发这个信号。<br>剩下几个单击、双击、进入、按压等信号意义比较直白，不详细解释了：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemClicked(QListWidgetItem * item)   &#x2F;&#x2F;条目单击信号
void QListWidget::itemDoubleClicked(QListWidgetItem * item)  &#x2F;&#x2F;条目双击信号
void QListWidget::itemEntered(QListWidgetItem * item)  &#x2F;&#x2F;鼠标追踪时进入条目的信号，一般用不着
void QListWidget::itemPressed(QListWidgetItem * item)  &#x2F;&#x2F;鼠标按键在条目上处于按下状态时发的信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>列表控件的槽函数除了前面讲过的 clear() 槽函数用于清空所有条目，还有个比较实用的条目滚动函数，列表控件自带滚动条，当条目总数超出控件矩形能呈现的数目时，滚动条自动出现，通过滚动条支持更多的条目显示。使 用如下槽函数可 以让列表控件滚动到想显示的某个条目位置：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::scrollToItem(const QListWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第一个参数 item 就是想显示出来的条目，第二个参数是滚动显示方式，默认是 QAbstractItemView::EnsureVisible，即保证指定条目显示出来，还有其他的滚动显示方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>QAbstractItemView::ScrollHint 枚举常量</strong></th>
<th><strong>数值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>QAbstractItemView::EnsureVisible</td>
<td>0</td>
<td>滚动到指定条目能显示出来即可。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtTop</td>
<td>1</td>
<td>滚动直到将指定条目显示到可视区域的顶部。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtBottom</td>
<td>2</td>
<td>滚动直到将指定条目显示到可视区域的底部。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtCenter</td>
<td>3</td>
<td>滚动直到将指定条目显示到可视区域的中间。</td>
</tr>
</tbody>
</table>
</div>
<p>原博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kongcheng253/article/details/128615688">[QT_007]Qt学习之QListWidget控件详解_天空之城8020的博客-CSDN博客</a></p>
<h1 id="QT-NEW-10"><a href="#QT-NEW-10" class="headerlink" title="QT NEW 10"></a>QT NEW 10</h1><h2 id="主要控件"><a href="#主要控件" class="headerlink" title="主要控件"></a>主要控件</h2><h3 id="QTreeWidget"><a href="#QTreeWidget" class="headerlink" title="QTreeWidget"></a>QTreeWidget</h3><pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        The QTreeWidget class is a convenience class that provides a standard tree widget with a classic item-based interface similar to that used by the QListView class in Qt 3. This class is based on Qt’s Model/View architecture and uses a default model to hold items, each of which is a QTreeWidgetItem.<br>​        Developers who do not need the flexibility of the Model/View framework can use this class to create simple hierarchical lists very easily. A more flexible approach involves combining a QTreeView with a standard item model. This allows the storage of data to be separated from its representation.<br>​        In its simplest form, a tree widget can be constructed in the following way:</p>
<pre class="line-numbers language-none"><code class="language-none">QTreeWidget *treeWidget &#x3D; new QTreeWidget();
treeWidget-&gt;setColumnCount(1);
QList&lt;QTreeWidgetItem *&gt; items;
for (int i &#x3D; 0; i &lt; 10; ++i)
&#123; 
	items.append(new QTreeWidgetItem(static_cast&lt;QTreeWidget *&gt;\		(nullptr), 
	QStringList(QString(&quot;item: %1&quot;).arg(i))));
&#125;
 treeWidget-&gt;insertTopLevelItems(0, items);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        Before items can be added to the tree widget, the number of columns must be set with setColumnCount(). This allows each item to have one or more labels or other decorations. The number of columns in use can be found with the columnCount() function.<br>The tree can have a header that contains a section for each column in the widget. It is easiest to set up the labels for each section by supplying a list of strings with setHeaderLabels(), but a custom header can be constructed with a QTreeWidgetItem and inserted into the tree with the setHeaderItem() function.<br>​        The items in the tree can be sorted by column according to a predefined sort order. If sorting is enabled, the user can sort the items by clicking on a column header. Sorting can be enabled or disabled by calling setSortingEnabled(). The isSortingEnabled() function indicates whether sorting is enabled.</p>
<h2 id="一些详解："><a href="#一些详解：" class="headerlink" title="一些详解："></a>一些详解：</h2><p>原博客：</p>
<p>​        <a target="_blank" rel="noopener" href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p>
<p>​        树形控件的节点可以有多层、多个子节点， 如果将子节点全部展开，那么每一行都是一个数据条目。<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QTreeWidgetItem&amp;spm=1001.2101.3001.7020">QTreeWidgetItem</a> 比较特殊，一个条目内部可以有多列数据信息，相当于表格控件一整行的表格单元集成为一个条目，所以树形条目要比前面两节的列表条目和表格条目都复杂。树形控件每行的条目之间可以是兄弟关系或父子关系，含有子节点的条目可以折叠也可以展开，进行遍历时有专门的迭代器 QTreeWidgetItemIterator 实现，也可以自行编写<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=递归算法&amp;spm=1001.2101.3001.7020">递归算法</a>遍历所有条目。</p>
<h3 id="8-3-1-QTreeWidget"><a href="#8-3-1-QTreeWidget" class="headerlink" title="8.3.1 QTreeWidget"></a>8.3.1 QTreeWidget</h3><p>在 Qt 设计师界面可以直接拖动树形控件到窗口里，下图展示树形控件的外观和构成：</p>
<p><img src="1.png" alt="f1ce3ab52d8fb8ed2698fa14a9ddb2b0.png"></p>
<p> 默认情况下，树形控件<strong>最上面是一个树头条目</strong>，<strong><em>\</em>树头条目也是 QTreeWidgetItem 对象**</strong>，可以有<strong>多列内容</strong>。<br>树头下面是真正的树形控件所有条目，在折叠的情况下，如上图所示，每行一个顶级条目，顶级条目也是 QTreeWidgetItem 对象，<strong>顶级条目的父节点指针 QTreeWidgetItem::parent() 为 NULL</strong>。<br>将所有节点展开之后，可以看到每个节点可以有多个子节点：</p>
<p><img src="2d11f9ba73fbaed337db73e2e141f4e7.png" alt="2d11f9ba73fbaed337db73e2e141f4e7.png"></p>
<p>对于包含子节点的父节点，左边会有小的三角形指示器，用于控制折叠或展开父节点。子节点也可以拥有更低级别的子节点（孙节点），以此类推，树形控件没 有限定子节点 的层数。顶级节点和其子孙节点的数据结构一样，都可以有多列数据，只是添加的函数、父节点指针不一样。下面介绍树形控件的函数和功能。</p>
<h3 id="（0）树形控件的构造函数很简单："><a href="#（0）树形控件的构造函数很简单：" class="headerlink" title="（0）树形控件的构造函数很简单："></a>（0）树形控件的构造函数很简单：</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidget(QWidget * parent &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里只有指定父窗口或父控件的指针 parent 。树形控件在添加条目之前，必须要先设置列数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setColumnCount(int columns) &#x2F;&#x2F;设置列数
int columnCount() const &#x2F;&#x2F;获取列数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>默认的列数是 1 列</strong>，如果涉及到多列数据，比如文件浏览树，有文件名、文件类型、大小、修改时间等等，就需要设置为多列数据的树。<br>树形控件设置好列数就可以添加相应的顶级条目，添加顶级条目是由树形控件自身的函数实现，而子条目则由 QTreeWidgetItem 的函数实现。本小节主要围绕树形控件和其基类的函数来讲，<strong>树形控件也可以设置和表格控件类似的表头，这里称为树头条目</strong>。</p>
<h3 id="（1）添加和访问顶级条目"><a href="#（1）添加和访问顶级条目" class="headerlink" title="（1）添加和访问顶级条目"></a>（1）添加和访问顶级条目</h3><p>树形控件顶级条目的操作比较类似 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidget&amp;spm=1001.2101.3001.7020">QListWidget</a> 的列表条目操作函数。新建条目之后，可以用如下函数把条目添加到树形控件的顶级条目<strong>列表末尾</strong>：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::addTopLevelItem(QTreeWidgetItem * item) &#x2F;&#x2F;添加一个顶级条目到末尾
void QTreeWidget::addTopLevelItems(const QList&lt;QTreeWidgetItem *&gt; &amp; items) &#x2F;&#x2F;添加多个顶级条目到末尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        如果希望将条目插入到指定顶级条目列表的 index 序号位置，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::insertTopLevelItem(int index, QTreeWidgetItem * item)
void QTreeWidget::insertTopLevelItems(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; items)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>树形控件所有的顶级条目父节点指针都为 NULL</strong> （父节点是指树形层次中的节点关系，<strong>而条目的父控件依然是树形控件本身</strong>）。<br>​        添加了顶级条目之后，可以对顶级条目进行计数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::topLevelItemCount() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（2）移除顶级条目"><a href="#（2）移除顶级条目" class="headerlink" title="（2）移除顶级条目"></a>（2）移除顶级条目</h3><p>​        移除顶级条目的函数也是take*打头：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::takeTopLevelItem(int index)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        index是顶级条目的序号，<strong>该函数只是从树形控件卸下顶级条目，但不会删除条目的内存空间，如果希望彻底删除，那么手动 delete 该函数返回的条目。</strong><br>如果要清空所有的顶级条目和子条目，使用槽函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（3）条目访问函数-1"><a href="#（3）条目访问函数-1" class="headerlink" title="（3）条目访问函数"></a>（3）条目访问函数</h3><p>​        对于顶级条目，如果知道顶级条目的序号获取对应的条目：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::topLevelItem(int index) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        反过来，对于已知顶级条目对象，查看其顶级序号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::indexOfTopLevelItem(QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果条目不是顶级条目或者条目不属于该控件，那么会返回 -1。<br>​        树形控件实际运行时，可能既有顶级条目，也有展开后的子孙条目同时显示，<strong>所以某个条目上面或下面的相邻条目不一定是同级别的兄弟条目，有可能是叔辈祖 辈的条目，也 可能是子辈孙辈条目。</strong>获取某个条目的相邻条目函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::itemAbove(const QTreeWidgetItem * item) const &#x2F;&#x2F;上面相邻条目
QTreeWidgetItem * QTreeWidget::itemBelow(const QTreeWidgetItem * item) const &#x2F;&#x2F;下面相邻条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        从屏幕控件显示角度，如果根据树形控件<strong>内部相对坐标</strong>获取条目（树形控件显示区域的左上角为原点），使用下面函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::itemAt(const QPoint &amp; p) const
QTreeWidgetItem * QTreeWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这两个函数是一个意思，一<strong>个用 QPoint 对象表示相对坐标，另一个直接用 x 和 y 数值表示坐标，如果对应坐标没有条目，会返回</strong> <strong>NULL</strong>，注意判断 返回值。<br>​        树形控件也是自带滚动条的，如果条目特别多，自动显示滚动条，对于树形控件在屏幕可见的条目，可以根据条目对象获取它的<strong>可视矩形</strong>（树形控件显示区域的 左上角为原 点）：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QRect QTreeWidget::visualItemRect(const QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（4）当前条目的操作"><a href="#（4）当前条目的操作" class="headerlink" title="（4）当前条目的操作"></a>（4）当前条目的操作</h3><p>​        树形控件的选中操作默认比较像 QListWidget，如果不手动设置，<strong>只能选中一个高亮条目</strong>。<br>获取当前高亮选中条目的函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::currentItem() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        树形控件可以有多列，当前条目被点击选中的列号为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::currentColumn() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        树形控件内的条目一般都没有固定行号，<strong>因为条目可以展开也可以折叠，行号是变化的，所以没有基于行号的操作函数。</strong></p>
<p>​        如果要设置某个条目为当前选中的状态：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setCurrentItem(QTreeWidgetItem * item)
void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column)
void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        第一个 setCurrentItem() 函数相当<strong>于设置该条目整行高亮选中</strong>，第二个是设置该条目行的 column <strong>列高亮选中</strong>，第三个函数是<strong>单次选中命令</strong>，参考“8.2.4 选中区域和选中行为”的单次选中命令内容，<strong>只是树形控件是一整行为一个条目，定位到条目的某列数据，就 类似指定表格控件的单元格。</strong><br>如果当前高亮选中的状态发生变化，会触发如下信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::currentItemChanged(QTreeWidgetItem * current, QTreeWidgetItem * previous)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里分别是当前高亮选中的条目，和之前高亮选中的条目，注意指针可能是 NULL，使用指针前一定要判断指针非空</p>
<h3 id="（5）条目查找和排序-1"><a href="#（5）条目查找和排序-1" class="headerlink" title="（5）条目查找和排序"></a>（5）条目查找和排序</h3><p>​        如果要根据模板子串查找某列文本匹配的条目，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QTreeWidgetItem *&gt; QTreeWidget::findItems(const QString &amp; text, Qt::MatchFlags flags, int column &#x3D; 0) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里text是模板子串，flags是匹配标志（参看“8.1.1 QListWidget”中的字符串匹配标志表格），第三个参数是指定查找的列。<strong>该函数只查找一列的文本，其他列的文本是不查找的</strong>。如果需要查找所有列数据，那么要根据不同列号逐列查询。</p>
<p>​        类似表格控件，树形控件也可以按照列的文本进行自动排序，自动排序的设置函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool    isSortingEnabled() const          &#x2F;&#x2F;设置是否自动排序
void    setSortingEnabled(bool enable)   &#x2F;&#x2F;查看是否开启自动排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        指定排序的列号和升序降序，使用从基类继承的函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeView::sortByColumn(int column, Qt::SortOrder order)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>在没有开启自动排序的情况下，也可以调用该函数进行一次性的条目排序。</strong></p>
<h3 id="（6）条目显示和运行时条目编辑-1"><a href="#（6）条目显示和运行时条目编辑-1" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）条目显示和运行时条目编辑</h3><p>​        可以为条目的某列“单元格”设置单独的控件来静态显示（控件不具有编辑功能）：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setItemWidget(QTreeWidgetItem * item, int column, QWidget * widget) &#x2F;&#x2F;设置条目列控件
QWidget * QTreeWidget::itemWidget(QTreeWidgetItem * item, int column) const &#x2F;&#x2F;获取条目列控件，不设置就是NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        注意该函数只能在条目添加到树形控件之后*<em>才能调用，否则无效，\并且条目列控件只能用于显示，无法编辑，如果要定制可编辑的“单元格”控件，必须用基类 QTreeView 并继承 QItemDelegate 做代理，这些内容到后面模型视图章节讲解<br>​        再次强调：itemWidget 条目控件，在默认情况下是与条目本身数据完全无关的，是条目数据的替换品，而不是协作模式。<strong>只有手动设置信号与槽，它们才可能关联上。</strong><br>QListWidget 和 QTreeWidget 的条目控件<strong>都是静态显示，不能编辑。</strong><br>​        QTreeWidget 控件的条目列控件 widget 还必须把默认是透明背景<em>*，</em></em>这样控件的内容和内部模型数据（就是条目的列数据）同时显示，文本会重影，效果就糟糕了。<br>删除条目的列控件使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::removeItemWidget(QTreeWidgetItem * item, int column)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>这个函数没有返回值，会自动地彻底删除条目列控件。</strong></p>
<p>​        在大多数情况下都用不到 itemWidget ，因为能够为条目设置可编辑标志位，然后调用如下函数开启树形控件自带的文本编辑器：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::editItem(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数 item 是指定的条目，column 是条目的列（类似“单元格”）。在没有为条目设置可编辑标志位的情况下，可以调用下面一对函数进行持续编辑器的开启和关闭：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::openPersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)
void QTreeWidget::closePersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>注意这对函数一开一关，要成对调用，否则编辑完了不会自动关闭持续编辑器。</strong></p>
<h3 id="（7）信号"><a href="#（7）信号" class="headerlink" title="（7）信号"></a>（7）信号</h3><p>​        关于当前高亮选中变化的信号 currentItemChanged() 前面讲过了，这里先列几个常规的信号，然后再将树形控件独有的信号。常规信号就是下面这 几个：（条目列就类似表格控件的单元格）</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void itemActivated(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被激活
void itemChanged(QTreeWidgetItem * item, int column)   &#x2F;&#x2F;条目列的数据发生变化，比如文本或图标修改了
void itemClicked(QTreeWidgetItem * item, int column)  &#x2F;&#x2F;条目列被单击
void itemDoubleClicked(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被双击
void itemEntered(QTreeWidgetItem * item, int column) &#x2F;&#x2F;进入条目列
void itemPressed(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被点 击按下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>树形控件最独特的就是展开和折叠信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::itemExpanded(QTreeWidgetItem * item)  &#x2F;&#x2F;条目展开时发送信号
void QTreeWidget::itemCollapsed(QTreeWidgetItem * item) &#x2F;&#x2F;条目折叠时发送信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        如果调用槽函数 expandAll() 展开所有子孙条目，那么不会触发 itemExpanded() 信号，因为触发太多会非常影响性能。<br>​        类似地，如果用槽函数 collapseAll() 折叠所有子孙条目，也不会触发 itemCollapsed() 信号，以免影响性能。<br>举例来说，在文件夹浏览的时候，因为操作系统里的文件太多，没法一次性构建完整的文件树，那么就可以用展开和折叠信号实时枚举某一层次文件夹的内容， 而不是一次性 枚举文件系统所有文件，因为一次性枚举所有文件的性能太糟糕。<br>树形控件还有一个 <strong>itemSelectionChanged</strong>() 信号，一般在多选模式才会用到，稍后讲解。</p>
<h3 id="（8）槽函数"><a href="#（8）槽函数" class="headerlink" title="（8）槽函数"></a>（8）槽函数</h3><p>​        树形控件的槽函数包括四个（基类的另算）：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void clear() &#x2F;&#x2F;清空整个树形控件
void collapseItem(const QTreeWidgetItem * item) &#x2F;&#x2F;折叠指定的条目
void expandItem(const QTreeWidgetItem * item)  &#x2F;&#x2F;展开指定 条目
void scrollToItem(const QTreeWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible) &#x2F;&#x2F;滚动到指定条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        滚动函数 scrollToItem() 第二个参数是<strong><em>\</em>滚到到该条目的显示方式**</strong>，参考“8.1.1 QListWidget”QAbstractItemView::  ScrollHint 枚举常量的表格。</p>
<h3 id="（9）基类-QTreeView-的函数"><a href="#（9）基类-QTreeView-的函数" class="headerlink" title="（9）基类 QTreeView 的函数"></a>（9）基类 QTreeView 的函数</h3><p>QTreeView 的功能函数也很多，这里列举几个可能常用的，详细的内容等到模型视图章节讲解。关于列隐藏或显示、设置列宽的函数如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeView::setColumnHidden(int column, bool hide) &#x2F;&#x2F;设置列隐藏或显示
bool QTreeView::isColumnHidden(int column) const &#x2F;&#x2F;判断列是否隐藏
void QTreeView::hideColumn(int column) &#x2F;&#x2F;槽函数，隐藏指定列
void QTreeView::showColumn(int column) &#x2F;&#x2F;槽函数，显示指定列
void QTreeView::setColumnWidth(int column, int width) &#x2F;&#x2F;设置列宽
int QTreeView::columnWidth(int column) const &#x2F;&#x2F;获取指定列的宽度
void QTreeView::resizeColumnToContents(int column) &#x2F;&#x2F;槽函数，自动调整 指定列的宽度属性 
 &#x2F;&#x2F;indentation 控制显示父子节点的缩进宽度：
int indentation() const    &#x2F;&#x2F;获取父子节点的缩进宽度
void setIndentation(int i) &#x2F;&#x2F;设置缩进宽度
void resetIndentation()    &#x2F;&#x2F;重置缩进宽度为默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基类还有几个常用的折叠和展开槽函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void collapseAll() &#x2F;&#x2F;折叠所有子孙节点，这样只能看到顶级节点
void expandAll() &#x2F;&#x2F;展开所有子孙节点，完全展开的树
void expandToDepth(int depth) &#x2F;&#x2F;展开 depth 层级的子节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        expandToDepth() 函数是指一直展开，直到将第 depth 层级的子节点都展开为止。以顶级条目为第 0 层级，顶级条目的直接子节点为第 1 层级，孙子节点为第 2 层级，依次类推。<br>​        例如 expandToDepth(0) 的效果如下：</p>
<p><img src="c1f8eac3f9ec327ea98347e5abab1354.png" alt="c1f8eac3f9ec327ea98347e5abab1354.png"></p>
<p>​        如果调用 expandToDepth(1) 展开第1级的节点：</p>
<p><img src="590d3ad8a2fcae012d2240bdbe9a012c.png" alt="590d3ad8a2fcae012d2240bdbe9a012c.png"></p>
<p>​        如果把 expandToDepth() <strong>参数设置成负数，那么相当于展开无穷大级别，就是展开所有的子孙节点。</strong></p>
<h3 id="（10）树头条目"><a href="#（10）树头条目" class="headerlink" title="（10）树头条目"></a>（10）树头条目</h3><p>​        树形控件只有一个表头，就是<strong>显示在上面的水平表头，本节也叫树头条目</strong>。设置树头条目的函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setHeaderItem(QTreeWidgetItem * item) &#x2F;&#x2F;设置树头条目，树头条目可以有多列数据，相当于多列的表头一次性设置了。
void QTreeWidget::setHeaderLabel(const QString &amp; label) &#x2F;&#x2F;只设置第 0 列的表头
void QTreeWidget::setHeaderLabels(const QStringList &amp; labels) &#x2F;&#x2F;设置多列的表头
QTreeWidgetItem * QTreeWidget::headerItem() const &#x2F;&#x2F;获取树头条目
树头条目本质其实也是由 QHeaderView 子控件来显示的，可以在基类找到相关函数：
QHeaderView * QTreeView::header() const &#x2F;&#x2F;获取表头视图控件
void QTreeView::setHeader(QHeaderView * header) &#x2F;&#x2F;设置表头视图， 一般树形控件不需要用这个函数
void QTreeView::setHeaderHidden(bool hide) &#x2F;&#x2F;设置表头是否隐藏
bool QTreeView::isHeaderHidden() const &#x2F;&#x2F;判断是否隐藏了表头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        无论是 QTableWidget 还是 QTreeWidget 的表头，都是 QHeaderView 子控件显示，QHeaderView 参考“8.2.3 表头设置”的内容。</p>
<h3 id="（11）选中行为和选中模式"><a href="#（11）选中行为和选中模式" class="headerlink" title="（11）选中行为和选中模式"></a>（11）选中行为和选中模式</h3><p>​        与 QTableWidget 类似，QTreeWidget也从祖类 QAbstractItemView 继承了选中行为和选中模式的属性：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QAbstractItemView::SelectionBehavior  selectionBehavior() const &#x2F;&#x2F;获取选中行为，按条目选中、整行或整列选中
void setSelectionBehavior(QAbstractItemView::SelectionBehavior behavior) &#x2F;&#x2F;设置选中行为
QAbstractItemView::SelectionMode  selectionMode() const &#x2F;&#x2F;获取选中模式，比如单选、多选、扩展选择
void setSelectionMode(QAbstractItemView::SelectionMode mode) &#x2F;&#x2F;设置选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        关于选中模式和选中行为的枚举常量参看“8.2.4 选中区域和选中行为”小节中的枚举常量表格，单次选中命令的函数和枚举常量也参考该小节。</p>
<p>​        默认情况下，树形控件是按照整行选中，并且是单选模式，如果把选中模式改成多选的 QAbstractItemView::ExtendedSelection，那么树形控件也可以使多选的，这时候信号 itemSelectionChanged() 就能派上用场：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">void</span> <span class="token class-name static-context">QTreeWidget</span><span class="token operator">::</span><span class="token function">itemSelectionChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        多选状态变化时会触发该信号（单选模式也触发，只是不需要用这个信号），可以关联该信号，监视当前所有选中的条目：</p>
<pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">QList<span class="token operator">&lt;</span>QTreeWidgetItem <span class="token comment">*> QTreeWidget::selectedItems() const</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        注意，<strong>这里的选中条目仅仅是指实际显示的直接选中的条目，不包括折叠隐藏的子孙条目计数</strong>，因为选中父节点与选中其子孙节点没关系，不会递归选中所有子 孙：</p>
<p><img src="c216490e8c65baf4903b5093b2deddcc.png" alt="c216490e8c65baf4903b5093b2deddcc.png"></p>
<p>​        树形控件及其基类没有递归选中子条目的属性或函数，<strong>如果希望递归选中某个节点的所有子孙节点，那么需要自行编写递归函数。</strong>关于树形控件类本身的内容介 绍到这，因为 涉及到父子节点隶属关系、节点展开和折叠，树形控件还有很大一部分功能都是由其条目类 QTreeWidgetItem 的函数实现的.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QListWidgetItem&gt;
#include&lt;QStringList&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
&#123;   
    ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt;&quot;卢本伟&quot;&lt;&lt;&quot;牛逼&quot;);
	QTreeWidgetItem* item &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐&quot;);
    QTreeWidgetItem* item2 &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐2&quot;);
    ui-&gt;treeWidget-&gt;addTopLevelItem(item);
    ui-&gt;treeWidget-&gt;addTopLevelItem(item2);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230526200623971.png" alt="image-20230526200623971"></p>
<h1 id="QT-NEW-11"><a href="#QT-NEW-11" class="headerlink" title="QT NEW 11"></a>QT NEW 11</h1><h2 id="主要控件-1"><a href="#主要控件-1" class="headerlink" title="主要控件"></a>主要控件</h2><h3 id="QTableWidget"><a href="#QTableWidget" class="headerlink" title="QTableWidget"></a>QTableWidget</h3><p><img src="image-20230526200740443.png" alt="image-20230526200740443"></p>
<pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Table widgets provide standard table display facilities for applications. The items in a QTableWidget are provided by QTableWidgetItem.<br>​        If you want a table that uses your own data model you should use QTableView rather than this class.<br>​        Table widgets can be constructed with the required numbers of rows and columns:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">tableWidget &#x3D; new QTableWidget(12, 3, this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Alternatively, tables can be constructed without a given size and resized later:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">tableWidget &#x3D; new QTableWidget(this);
tableWidget-&gt;setRowCount(10);
tableWidget-&gt;setColumnCount(5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        Items are created outside the table (with no parent widget) and inserted into the table with setItem():</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem *newItem &#x3D; new QTableWidgetItem(tr(&quot;%1&quot;).arg(\
        								 (row+1)*(column+1)));
tableWidget-&gt;setItem(row, column, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        If you want to enable sorting in your table widget, do so after you have populated it with items, otherwise sorting may interfere with the insertion order (see setItem() for details).<br>Tables can be given both horizontal and vertical headers. The simplest way to create the headers is to supply a list of strings to the setHorizontalHeaderLabels() and setVerticalHeaderLabels() functions. These will provide simple textual headers for the table’s columns and rows. More sophisticated headers can be created from existing table items that are usually constructed outside the table. For example, we can construct a table item with an icon and aligned text, and use it as the header for a particular column:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem *cubesHeaderItem &#x3D; new QTableWidgetItem(tr(&quot;Cubes&quot;));
cubesHeaderItem-&gt;setIcon(QIcon(QPixmap(&quot;:&#x2F;Images&#x2F;cubed.png&quot;)));
cubesHeaderItem-&gt;setTextAlignment(Qt::AlignVCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        The number of rows in the table can be found with rowCount(), and the number of columns with columnCount(). The table can be cleared with the clear() function.</p>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>​        原博客：</p>
<p>​        <a target="_blank" rel="noopener" href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p>
<h2 id="QTableWidgetItem"><a href="#QTableWidgetItem" class="headerlink" title="QTableWidgetItem"></a>QTableWidgetItem</h2><p>​        表格控件条目 QTableWidgetItem 与 8.1.2 节 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 有很多相似的地方，<br>QTableWidgetItem 也是一个纯数据类，不是控件，没有基类，也就没有信号和槽函数。QTableWidgetItem 可以直接用数据流 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QDataStream&amp;spm=1001.2101.3001.7020">QDataStream</a> 读写，表格条目不单单有文本，还可以有自己的图标、复选框等特性，表格控件会根据条目对象的丰富特性来呈现数据并进行交互操作。</p>
<h3 id="（1）首先来看看条目的构造函数："><a href="#（1）首先来看看条目的构造函数：" class="headerlink" title="（1）首先来看看条目的构造函数："></a>（1）<strong>首先来看看条目的构造函数：</strong></h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem(int type &#x3D; Type)
QTableWidgetItem(const QString &amp; text, int type &#x3D; Type)
QTableWidgetItem(const QIcon &amp; icon, const QString &amp; text, int type &#x3D; Type)
QTableWidgetItem(const QTableWidgetItem &amp; other) &#x2F;&#x2F;复制构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        参数里的 type 一般用于派生类，指定条目独特的分类，对于普通的表格控件条目，通常用默认的数值即可。第二个构造函数是指定了条目的文本，第三个构造函数同 时指定了条目图标和文本。<br>​        在构造函数里不能直接指定所属的表格控件，因为表格控件有行号、列号所以不能简单追加到表格里，而只能用表格控件的 QTableWidget::setItem() 函数把条目设置到指定单元格里。注意一个条目只能设置给表格控件唯一的一个单元格，不能把一个条目设置给多个单元格。如果希望为多个单元格设置相似的条目数据内容，那么可 以用后面介绍的 clone() 函数制造大量新的复制体条目。<br>​        复制构造函数不会复制旧条目的 type() 类型值和tableWidget() 所属表格控件指针，条目其他的内部数据和条目标志都会复制。</p>
<h3 id="（2）复制函数和运算符函数"><a href="#（2）复制函数和运算符函数" class="headerlink" title="（2）复制函数和运算符函数"></a>（2）<strong>复制函数和运算符函数</strong></h3><p>​        除了复制构造函数，还有专门的克隆函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem * QTableWidgetItem::clone() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        克隆函数会新建一个当前条目的复制体，然后返回新复制体条目的指针，如果要构造并添加大量重复内容的条目，这个函数就比较实用。clone() 函数内部会调用复制构造函数创建新条目并返回。<br>​        条目复制还可以用等于号函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        等于号函数复制的内容与复制构造函数差不多，type() 类型值和 tableWidget() 所属表格控件指针也不复制。<br>​        还有个小于号函数，可以比较条目文本的字典序：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果希望使用更多的比较函数，可以直接用 QString 的比较函数。</p>
<h3 id="（3）QTableWidgetItem-的功能函数与内部数据"><a href="#（3）QTableWidgetItem-的功能函数与内部数据" class="headerlink" title="（3）QTableWidgetItem 的功能函数与内部数据"></a>（3）<strong>QTableWidgetItem 的功能函数与内部数据</strong></h3><p>​        QTableWidgetItem 内部的数据也大致分为两类：第一类是以数据角色形式管理的通用数据，这些数据自动参与 QDataStream 数据流的读写；第二类是非通用数据，不参与数据流读写，与 QListWidgetItem 和 QListWidget 自身特性有关。QTableWidgetItem 主要的功能函数也是围绕这两类内部数据展开的。</p>
<p>​        ● <strong>第一类：通用数据及其处理函数</strong><br>​        通用数据是以数据角色与数据变量一一对应的形式存储管理，比如设置文本 setText()、设置图标 setIcon() 等函数，其本质都是根据各自的角色调用通用设置数据的函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">virtual void setData(int role, const QVariant &amp; value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        也可以根据角色来获取各个数据变量：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">virtual QVariant data(int role) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        查看表格控件的源代码文件可以看到关于图标操作函数的源码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> QIcon <span class="token function">icon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span> 
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">qvariant_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QIcon<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DecorationRole<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">QTableWidgetItem</span><span class="token double-colon punctuation">::</span><span class="token function">setIcon</span><span class="token punctuation">(</span><span class="token keyword">const</span> QIcon <span class="token operator">&amp;</span>aicon<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">setData</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DecorationRole<span class="token punctuation">,</span> aicon<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        QTableWidgetItem 的通用数据与 QListWidgetItem 的通用数据一模一样，函数名也一样，列表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>获取函数</strong></th>
<th><strong>设置函数</strong></th>
<th><strong>数据角色</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>text()</td>
<td>setText(const QString &amp;text)</td>
<td>Qt::DisplayRole</td>
<td>条目显示的文本。</td>
</tr>
<tr>
<td>icon()</td>
<td>setIcon(const QIcon &amp;icon)</td>
<td>Qt::DecorationRole</td>
<td>条目显示的图标。</td>
</tr>
<tr>
<td>statusTip()</td>
<td>setStatusTip(const QString &amp;statusTip)</td>
<td>Qt::StatusTipRole</td>
<td>如果主界面有状态栏，鼠标悬停在该条目上时显示该状态信息到状态栏。</td>
</tr>
<tr>
<td>toolTip()</td>
<td>setToolTip(const QString &amp;toolTip)</td>
<td>Qt::ToolTipRole</td>
<td>鼠标悬停在该条目上时显示的工具提示信息。</td>
</tr>
<tr>
<td>whatsThis()</td>
<td>setWhatsThis(const QString &amp;whatsThis)</td>
<td>Qt::WhatsThisRole</td>
<td>如果主界面窗口标题栏有？帮助按钮，点击帮助按钮再点击该条目会显示该帮助信息。</td>
</tr>
<tr>
<td>font()</td>
<td>setFont(const QFont &amp;font)</td>
<td>Qt::FontRole</td>
<td>显示条目文本用的字体。</td>
</tr>
<tr>
<td>textAlignment()</td>
<td>setTextAlignment(int alignment)</td>
<td>Qt::TextAlignmentRole</td>
<td>文本的对齐方式。</td>
</tr>
<tr>
<td>backgroundColor()</td>
<td>setBackgroundColor(const QColor &amp;color)</td>
<td>Qt::BackgroundColorRole</td>
<td>文本背景色。</td>
</tr>
<tr>
<td>textColor()</td>
<td>setTextColor(const QColor &amp;color)</td>
<td>Qt::TextColorRole</td>
<td>文字颜色。</td>
</tr>
<tr>
<td>background()</td>
<td>setBackground(const QBrush &amp;brush)</td>
<td>Qt::BackgroundRole</td>
<td>条目的背景画刷。</td>
</tr>
<tr>
<td>foreground()</td>
<td>setForeground(const QBrush &amp;brush)</td>
<td>Qt::ForegroundRole</td>
<td>条目的前景画刷。</td>
</tr>
<tr>
<td>checkState()</td>
<td>setCheckState(Qt::CheckState state)</td>
<td>Qt::CheckStateRole</td>
<td>条目自带的复选框选中状态，可以是三态复选框。</td>
</tr>
<tr>
<td>sizeHint()</td>
<td>setSizeHint(const QSize &amp;size)</td>
<td>Qt::SizeHintRole</td>
<td>条目显示的建议尺寸。</td>
</tr>
</tbody>
</table>
</div>
<p>​        表格条目 QTableWidgetItem 可以直接用数据流 QDataStream 读写，是通过下面运算符重载函数实现的：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QDataStream &amp;    operator&lt;&lt;(QDataStream &amp; out, const QTableWidgetItem &amp; item)
QDataStream &amp;    operator&gt;&gt;(QDataStream &amp; in, QTableWidgetItem &amp; item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        使用 &gt;&gt; 和 &lt;&lt; 运算符进行流输入输出比较常见，当然也可以用 QTableWidgetItem 类内部的读写函数进行输入输出：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTableWidgetItem::read(QDataStream &amp; in)
void QTableWidgetItem::write(QDataStream &amp; out) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​         <strong>第二类：非通用数据及其操作函数</strong><br>表格控件的条目也是在构造函数一次性指定条目类型，然后这个类型是只读的：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTableWidgetItem::type() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        类型值一般用于派生类区分不同的条目类型，自定义的条目类型值需要大于等于 QTableWidgetItem::UserType 。<br>​        新条目通过表格控件 QTableWidget::setItem() 函数设置给表格控件之后，条<strong>目会自动保存所属的表格控件指针，</strong>可以用如下函数获取：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidget * QTableWidgetItem::tableWidget() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        程序运行时，除了可以通过表格控件的 QTableWidget::selectedItems() 获取用户选中的条目列表，每个单元格条目自身也会记录是否 被用户选中，并且能设置自身是否被选中：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool QTableWidgetItem::isSelected() const &#x2F;&#x2F;判断条目自身是否高亮选中
void QTableWidgetItem::setSelected(bool select) &#x2F;&#x2F;设置条目自身是 否被选中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>表格控件条目初始化时也有默认的标志位，并且运行时可以修改条目的特性标志：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Qt::ItemFlags QTableWidgetItem::flags() const &#x2F;&#x2F;获取特性标志位
void QTableWidgetItem::setFlags(Qt::ItemFlags flags) &#x2F;&#x2F;设置特性标志位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        QTableWidgetItem 构造<strong>时默认的标志位为</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>QT宏</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::ItemIsSelectable</td>
</tr>
<tr>
<td>Qt::ItemIsUserCheckable</td>
</tr>
<tr>
<td>Qt::ItemIsEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsDragEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsDropEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsEditable</td>
</tr>
</tbody>
</table>
</div>
<p>​        因此程序代码生成的所有表格条目默认都是可编辑的，程序运行时用户双击空的单元格时，表格控件会自动创建新条目保存用户编辑内容，这些自动创建的条目也都是可编辑的。如果希望条目是只读的，那么把标志位设置不带Qt::ItemIsEditable 的新标志位即可。</p>
<p>​        Qt::ItemFlags 所有的枚举常量在 8.1.2 节末尾有详细的表格描述，这里不重复贴了。表格条目默认就是支持复选状态的，只是默认没有显示出来，要让表格控件显示条目对应的复选框，可以用下面一句代码实现：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">item-&gt;setCheckState( Qt::Unchecked );  &#x2F;&#x2F;显示复选框<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        对于表格控件和表格条目，自带单行编辑器和复选框功能，因此不需要为单元格添加自定义的单行编辑器或复选框，如果要用到其他更多的输入控件，那才需要定制单元格。<br>​        表格控件条目与 QListWidgetItem 最大的一个区别就是表格条目既有行号，也有列号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTableWidgetItem::row() const &#x2F;&#x2F;获取行号
int QTableWidgetItem::column() const &#x2F;&#x2F;获取列号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        行号和列号也是在 QTableWidget::setItem() 函数里指定的，条目自身并不能修改行号或列号。表格控件条目与 QListWidgetItem 另一个区别是，<strong>表格控件条目没有隐藏函数，所有表格条目都是显示的（只要不被单元格控件QTableWidget::cellWidget() 遮挡）。</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;设函数列数
    ui-&gt;tableWidget-&gt;setColumnCount(3);

    &#x2F;&#x2F;设置表头
    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;&quot;姓名&quot;&lt;&lt;&quot;性别&quot;&lt;&lt;&quot;年龄&quot;);

    ui-&gt;tableWidget-&gt;setRowCount(10);
    ui-&gt;tableWidget-&gt;setItem(0,0,new QTableWidgetItem(&quot;泰勒&quot;));


&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230526202457563.png" alt="image-20230526202457563"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/05/26/QT-new-9-10-11/">http://charliechen114514.github.io/2023/05/26/QT-new-9-10-11/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/QT/">QT</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/27/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3/" title="Windows-API-程序设计(3)"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Windows-API-程序设计(3)</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/26/QT-new-7-8/" title="QT new 7-8"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">QT new 7-8</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/28/QT-1/" title="QT 1"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-28</div><div class="title">QT 1</div></div></a></div><div><a href="/2023/04/18/QT-NEW-3/" title="QT NEW (3)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-18</div><div class="title">QT NEW (3)</div></div></a></div><div><a href="/2023/04/18/QT-NEW-2/" title="QT NEW (2)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-18</div><div class="title">QT NEW (2)</div></div></a></div><div><a href="/2023/04/19/QT-NEW-4/" title="QT NEW 4"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-19</div><div class="title">QT NEW 4</div></div></a></div><div><a href="/2023/05/14/QT-new-6/" title="QT-new-6"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-14</div><div class="title">QT-new-6</div></div></a></div><div><a href="/2023/05/26/QT-new-7-8/" title="QT new 7-8"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-26</div><div class="title">QT new 7-8</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">大更新！这下上了简单的数据结构的C实现，如果只对思路感兴趣看思路即可，如果想查看API实现就取看详解</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#QT-new-9"><span class="toc-number">1.</span> <span class="toc-text">QT new 9</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E5%AE%B9%E5%99%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.</span> <span class="toc-text">一些经典容器的若干操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QListWidget"><span class="toc-number">1.1.1.</span> <span class="toc-text">QListWidget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%9D%A1%E7%9B%AE%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">1）添加条目的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">（2）删除函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9D%A1%E7%9B%AE%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">（3）条目访问函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%BD%93%E5%89%8D%E9%80%89%E4%B8%AD%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.</span> <span class="toc-text">（4）当前选中条目的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">（5）条目查找和排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%98%BE%E7%A4%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%A1%E7%9B%AE%E7%BC%96%E8%BE%91"><span class="toc-number">1.6.</span> <span class="toc-text">（6）条目显示和运行时条目编辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%85%B6%E4%BB%96%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">（7）其他信号和槽函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT-NEW-10"><span class="toc-number">2.</span> <span class="toc-text">QT NEW 10</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%8E%A7%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">主要控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QTreeWidget"><span class="toc-number">2.1.1.</span> <span class="toc-text">QTreeWidget</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="toc-number">2.2.</span> <span class="toc-text">一些详解：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-QTreeWidget"><span class="toc-number">2.2.1.</span> <span class="toc-text">8.3.1 QTreeWidget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%880%EF%BC%89%E6%A0%91%E5%BD%A2%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%9A"><span class="toc-number">2.2.2.</span> <span class="toc-text">（0）树形控件的构造函数很简单：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B7%BB%E5%8A%A0%E5%92%8C%E8%AE%BF%E9%97%AE%E9%A1%B6%E7%BA%A7%E6%9D%A1%E7%9B%AE"><span class="toc-number">2.2.3.</span> <span class="toc-text">（1）添加和访问顶级条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A7%BB%E9%99%A4%E9%A1%B6%E7%BA%A7%E6%9D%A1%E7%9B%AE"><span class="toc-number">2.2.4.</span> <span class="toc-text">（2）移除顶级条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9D%A1%E7%9B%AE%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0-1"><span class="toc-number">2.2.5.</span> <span class="toc-text">（3）条目访问函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%BD%93%E5%89%8D%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.6.</span> <span class="toc-text">（4）当前条目的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F-1"><span class="toc-number">2.2.7.</span> <span class="toc-text">（5）条目查找和排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%98%BE%E7%A4%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%A1%E7%9B%AE%E7%BC%96%E8%BE%91-1"><span class="toc-number">2.2.8.</span> <span class="toc-text">（6）条目显示和运行时条目编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.2.9.</span> <span class="toc-text">（7）信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E6%A7%BD%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.10.</span> <span class="toc-text">（8）槽函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%889%EF%BC%89%E5%9F%BA%E7%B1%BB-QTreeView-%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.11.</span> <span class="toc-text">（9）基类 QTreeView 的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89%E6%A0%91%E5%A4%B4%E6%9D%A1%E7%9B%AE"><span class="toc-number">2.2.12.</span> <span class="toc-text">（10）树头条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89%E9%80%89%E4%B8%AD%E8%A1%8C%E4%B8%BA%E5%92%8C%E9%80%89%E4%B8%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.13.</span> <span class="toc-text">（11）选中行为和选中模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT-NEW-11"><span class="toc-number">3.</span> <span class="toc-text">QT NEW 11</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%8E%A7%E4%BB%B6-1"><span class="toc-number">3.1.</span> <span class="toc-text">主要控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QTableWidget"><span class="toc-number">3.1.1.</span> <span class="toc-text">QTableWidget</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QTableWidgetItem"><span class="toc-number">3.3.</span> <span class="toc-text">QTableWidgetItem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A6%96%E5%85%88%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">3.3.1.</span> <span class="toc-text">（1）首先来看看条目的构造函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A4%8D%E5%88%B6%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text">（2）复制函数和运算符函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89QTableWidgetItem-%E7%9A%84%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">3.3.3.</span> <span class="toc-text">（3）QTableWidgetItem 的功能函数与内部数据</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/05/Semester1-updateOfWholeNotes/" title="Semester1 updateOfWholeNotes"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Semester1 updateOfWholeNotes"/></a><div class="content"><a class="title" href="/2023/06/05/Semester1-updateOfWholeNotes/" title="Semester1 updateOfWholeNotes">Semester1 updateOfWholeNotes</a><time datetime="2023-06-05T03:50:36.000Z" title="发表于 2023-06-05 11:50:36">2023-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/03/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%887-8%EF%BC%89/" title="Windows-API-程序设计（7,8）"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows-API-程序设计（7,8）"/></a><div class="content"><a class="title" href="/2023/06/03/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%887-8%EF%BC%89/" title="Windows-API-程序设计（7,8）">Windows-API-程序设计（7,8）</a><time datetime="2023-06-03T02:23:40.000Z" title="发表于 2023-06-03 10:23:40">2023-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/01/Qt-Opencv-Config/" title="Qt &amp;&amp; Opencv Config"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Qt &amp;&amp; Opencv Config"/></a><div class="content"><a class="title" href="/2023/06/01/Qt-Opencv-Config/" title="Qt &amp;&amp; Opencv Config">Qt &amp;&amp; Opencv Config</a><time datetime="2023-06-01T13:31:25.000Z" title="发表于 2023-06-01 21:31:25">2023-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/31/Ros%E5%B0%8F%E8%BD%A6%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%EF%BC%88%E6%B0%B4%EF%BC%81%EF%BC%89/" title="Ros小车简单操作（水！）"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ros小车简单操作（水！）"/></a><div class="content"><a class="title" href="/2023/05/31/Ros%E5%B0%8F%E8%BD%A6%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C%EF%BC%88%E6%B0%B4%EF%BC%81%EF%BC%89/" title="Ros小车简单操作（水！）">Ros小车简单操作（水！）</a><time datetime="2023-05-31T12:34:30.000Z" title="发表于 2023-05-31 20:34:30">2023-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/QT-new-14/" title="QT new 14"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QT new 14"/></a><div class="content"><a class="title" href="/2023/05/29/QT-new-14/" title="QT new 14">QT new 14</a><time datetime="2023-05-29T09:14:07.000Z" title="发表于 2023-05-29 17:14:07">2023-05-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>