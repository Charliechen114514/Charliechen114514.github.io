<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Deep Qt Learn-1 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Deep Qt写在前面​        这个文档是为了正儿八经的学习Qt开开设的，本次Qt文档将会严肃的基于Qt5开发实例这本书，展开对Qt的学习。值得注意到是，当你阅读此文档时，我们将默认您有一定的Qt基础 Start all​        让我们先从写一个对话框——其可以返回圆的大小开始！我们首先构建一个基于QDialog的项目，在Ui编辑窗口处拖一个LineEdit，拖一个QTextBro">
<meta property="og:type" content="article">
<meta property="og:title" content="Deep Qt Learn-1">
<meta property="og:url" content="http://charliechen114514.github.io/2023/09/05/Deep-Qt-Learn-1/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="Deep Qt写在前面​        这个文档是为了正儿八经的学习Qt开开设的，本次Qt文档将会严肃的基于Qt5开发实例这本书，展开对Qt的学习。值得注意到是，当你阅读此文档时，我们将默认您有一定的Qt基础 Start all​        让我们先从写一个对话框——其可以返回圆的大小开始！我们首先构建一个基于QDialog的项目，在Ui编辑窗口处拖一个LineEdit，拖一个QTextBro">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-09-05T12:24:22.000Z">
<meta property="article:modified_time" content="2023-09-05T12:25:08.279Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Qt">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/09/05/Deep-Qt-Learn-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Deep Qt Learn-1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-05 20:25:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Deep Qt Learn-1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-05T12:24:22.000Z" title="发表于 2023-09-05 20:24:22">2023-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-05T12:25:08.279Z" title="更新于 2023-09-05 20:25:08">2023-09-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>22分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Deep Qt Learn-1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Deep-Qt"><a href="#Deep-Qt" class="headerlink" title="Deep Qt"></a><code>Deep Qt</code></h1><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>​        这个文档是为了正儿八经的学习Qt开开设的，本次Qt文档将会严肃的基于Qt5开发实例这本书，展开对Qt的学习。值得注意到是，当你阅读此文档时，我们将默认您有一定的Qt基础</p>
<h1 id="Start-all"><a href="#Start-all" class="headerlink" title="Start all"></a><code>Start all</code></h1><p>​        让我们先从写一个对话框——其可以返回圆的大小开始！我们首先构建一个基于QDialog的项目，在Ui编辑窗口处拖一个LineEdit，拖一个QTextBrowser，拖一个QPushButton出来，嗯，对了，为了让他美观一些，我们整一个QGridLayout上去。以及，限制一下FixedSize，至少，我们并不需要他托的太离谱</p>
<p><img src="image-20230827210357007.png" alt="image-20230827210357007"></p>
<p>​        我想这不能再简单了。现在，我们的目光就聚集在这三个控件上，围绕他们完成我们的功能，在下面</p>
<h2 id="计算圆的大小"><a href="#计算圆的大小" class="headerlink" title="计算圆的大小"></a>计算圆的大小</h2><p>​        我们老规矩，程序经过预处理和符号加载后，从main处开始运行代码：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; main.cpp

#include &quot;dialog.h&quot;
#include &lt;QApplication&gt;

int main(int argc, char *argv[])
&#123;
    QApplication a(argc, argv);
    Dialog w;
    w.show();

    return a.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们逐行分析</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;dialog.h&quot;
#include &lt;QApplication&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这个dialog.h，可能你的不是，是什么别的名字，但是你摁住Ctrl + 鼠标进去一看，果然，正是你自己的头文件。在这里，我们对我们的窗口完成的功能实现预定义</p>
<p>​        第二行的QApplication则是引入了QApllication类，我们的各式各样的GUI广泛资源，基本设置和事件处理都由他负责</p>
<pre class="line-numbers language-none"><code class="language-none">int main(int argc, char *argv[])
&#123;
	 QApplication a(argc, argv);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        命令行程序，我们的程序接受了一个命令行，同时值得注意是，创建了一个QApplication，处理我们的命令行。</p>
<pre class="line-numbers language-none"><code class="language-none">Dialog w;
w.show();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        创建了一个Dialog，并且显示它——我们的工作结束！</p>
<pre class="line-numbers language-none"><code class="language-none">	return a.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        程序进入消息循环，等待可能的输入响应</p>
<p>​        好了，扯完了，我们下面来写代码：</p>
<p>​        这是我们的头文件</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef DIALOG_H
#define DIALOG_H

#include &lt;QDialog&gt;
#include &lt;QKeyEvent&gt;

namespace Ui &#123;
class Dialog;
&#125;

class Dialog : public QDialog
&#123;
    Q_OBJECT

public:
    explicit Dialog(QWidget *parent &#x3D; nullptr);
    void caculateArea();			&#x2F;&#x2F; 核心处理函数
    ~Dialog();

private slots:
    void on_pushButton_clicked();     &#x2F;&#x2F; 摁下摁扭的响应
    void on_lineEdit_returnPressed(); &#x2F;&#x2F; 摁Enter键的响应

private:
    Ui::Dialog *ui;

&#125;;
#endif &#x2F;&#x2F; DIALOG_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        按照逻辑顺序，我们先写核心代码：</p>
<pre class="line-numbers language-none"><code class="language-none">void caculateArea();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们先拿出两个宏，第一个是衡量PI的精度</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">const double PI &#x3D; 3.1415926; &#x2F;&#x2F; #define PI 3.1415926<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        第二个是衡量面积大小</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define Area(X) ( X*X*PI )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        好，现在，我们写核心：很简单，我们触发了这个函数表示开始算，拿到LineEdit的结果，然后投射到TextBrowser上</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; dialog.cpp
void Dialog::caculateArea()
&#123;
    bool isAbleTransform;
    double radius &#x3D; static_cast&lt;double&gt;(ui-&gt;lineEdit-&gt;text().toFloat(&amp;isAbleTransform));
    if(!isAbleTransform)&#123;
        QMessageBox::critical(this,&quot;错误！&quot;, &quot;输入不是数字！&quot;);
        return;
    &#125;

    ui-&gt;textBrowser-&gt;setText(&quot;面积大小：&quot; + QString::number(Area(radius)));
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们使用的是GUI的revelant API，啥呢，</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Dialog::on_pushButton_clicked()
&#123;
    caculateArea();
&#125;


void Dialog::on_lineEdit_returnPressed()
&#123;
    caculateArea();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        出乎意料的简单——这是因为本质上我们的响应的目的就只有一个——调用函数，显示在桌面上！</p>
<h1 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h1><p>​        这个，可是Qt的一大特色，我们使用了这个东西，来化简了窗口的通信！在比较早期的Qt中，我们总是这样书写信号与曹的代码：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">connect(Object1, SIGNAL(signal1), Object2, SLOT(slot1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        现在，我们则是抛弃掉了SIGNAL和SLOT宏，转向了传递函数的地址（或者说函数指针），我们现在这样写代码：</p>
<pre class="line-numbers language-none"><code class="language-none">connect(ui-&gt;pushbutton, &amp;QPushButton::pressed, this, &amp;MainWindow::doSomething);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这句话的意思是：绑定摁扭点击和主窗口某个方法。只要点击他，就会调用doSomething.</p>
<h2 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h2><h3 id="一、桌面程序的结构"><a href="#一、桌面程序的结构" class="headerlink" title="一、桌面程序的结构"></a>一、桌面程序的结构</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ifeng12358/article/details/120880153">Qt 信号和槽的机制（逻辑清晰的来说清楚信号和槽，呕心沥血之作）_qt的信号与槽机制原理_冯一川的博客-CSDN博客</a></p>
<p>​        Qt的使用场景，主要是应用于桌面程序来使用，不管你使用的操作系统平台是什么。对于桌面程序来说，最重要的就是交互了。既然有交互，就需要一个窗口系统了。</p>
<p>​        窗口系统实现了桌面程序的主要逻辑，并提供了一套基于事件驱动的编程框架。Qt同样也提供了这样的一套逻辑。</p>
<p>​        我们常见的桌面程序的结构，如下图所示：</p>
<p><img src="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yav5LiA5bed,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yav5LiA5bed,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p> 所以，我们可以看到，在桌面程序中我们需要对窗口系统的一些操作作出相应，也就是事件。</p>
<h3 id="二、事件"><a href="#二、事件" class="headerlink" title="二、事件"></a>二、事件</h3><p>实现事件的机制通常有两种。</p>
<p>一种是事件处理类，是用回调函数来实现。</p>
<p>另一种叫委托，就是事件的处理不是收到事件的人自己来做，而是把它委托给了别人来做。Qt就提供了这样的一种机制：信号和槽。</p>
<h3 id="三、信号和槽"><a href="#三、信号和槽" class="headerlink" title="三、信号和槽"></a>三、信号和槽</h3><p>信号与槽是Qt特有的的消息传输机制，在Qt中信号与槽用得十分广泛。在编程的过程中，我们都会遇到消息传递的事情，本质上就是发出命令（信号、消息），执行命令（相应的执行）。</p>
<p>比如单击窗口上一个按钮然后弹出一个对话框，那么就可以将这个按钮的单击信号和自定义的槽关联起来，信号是按钮的单击信号，槽实现了创建一个对话框并显示的功能。</p>
<p>信号与槽就是实现对象之间通信的一种机制，在其他编程语言中也有通过回调机制来实现对象之间的通信。</p>
<ul>
<li>信号：当对象改变其状态时，信号就由该对象发射 (emit) 出去，而且对象只负责发送信号，它不知道另一端是谁在接收这个信号。</li>
<li>槽：用于接收信号，而且槽只是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。</li>
</ul>
<p>信号槽是设计模式<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=观察者模式&amp;spm=1001.2101.3001.7020">观察者模式</a>的一种实现：</p>
<p>A、一个信号就是一个能够被观察的事件，或者至少是事件已经发生的一种通知；<br>B、一个槽就是一个观察者，通常就是在被观察的对象发生改变的时候——也可以说是信号发出的时候——被调用的函数；<br>C、信号与槽的连接，形成一种观察者-被观察者的关系；<br>D、当事件或者状态发生改变的时候，信号就会被发出；同时，信号发出者有义务调用所有注册的对这个事件（信号）感兴趣的函数（槽）。</p>
<p>信号和槽是多对多的关系。一个信号可以连接多个槽，而一个槽也可以监听多个信号。</p>
<p>然后，实现信号和槽，就要说一下Qt的元对象系统。</p>
<h3 id="四、Qt元对象系统"><a href="#四、Qt元对象系统" class="headerlink" title="四、Qt元对象系统"></a>四、Qt元对象系统</h3><p>Qt 的元对象系统叫 Mate-Object-System，提供了对象之间通信的信号与槽机制、运行时类型信息和动态属性系统。</p>
<p>但是，元对象是基于三个条件的：</p>
<p> 1、该类必须继承自Qobject类</p>
<p> 2、必须在类的私有声明区声明<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Q_OBJECT&amp;spm=1001.2101.3001.7020">Q_OBJECT</a>宏（在类定义的时候，如果没有指定public，<br>则默认为private，用来启用元对象功能，比如动态属性、信号和槽）。 </p>
<p> 3、 元对象编译器Meta-Object Compiler（moc）为 QObject的子类实现元对象<br>特性提供必要的代码。</p>
<p>有了元对象系统后，我们就可以使用Qt的信号和槽了。</p>
<h3 id="五、信号和槽的格式"><a href="#五、信号和槽的格式" class="headerlink" title="五、信号和槽的格式"></a>五、信号和槽的格式</h3><p>信号与槽关联是用 QObject::connect() 函数实现的，其基本格式是：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">QObject</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">connect</span><span class="token punctuation">(</span>sender<span class="token punctuation">,</span> <span class="token function">SIGNAL</span><span class="token punctuation">(</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> receiver<span class="token punctuation">,</span> <span class="token function">SLOT</span><span class="token punctuation">(</span><span class="token function">slot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在Qt 5中提供了一种新的格式：</p>
<pre class="line-numbers language-lisp" data-language="lisp"><code class="language-lisp">connect<span class="token punctuation">(</span><span class="token car">sender</span>, &amp;Sender:<span class="token lisp-property property">:valueChanged</span><span class="token splice symbol variable">,receiver</span>, &amp;Receiver:<span class="token lisp-property property">:updateValue</span><span class="token punctuation">)</span><span class="token comment">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>具体的使用哪种格式，就看个人的喜好了。</p>
<p>注：在日常的项目编程中，如果第一种的connect方式出现报错，你可以尝试使用第二种connect方式。</p>
<h3 id="六、connect的第五个参数"><a href="#六、connect的第五个参数" class="headerlink" title="六、connect的第五个参数"></a>六、connect的第五个参数</h3><p>在connect函数中除了上面介绍的四个参数外，还有第五个参数，是缺省的参数。我们打开qobject.h文件可以看到它的定义，如下所示：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">static QMetaObject::Connection connect(const QObject *sender, const char *signal,
            const QObject *receiver, const char *member, Qt::ConnectionType &#x3D; Qt::AutoConnection);
 
static QMetaObject::Connection connect(const QObject *sender, const QMetaMethod &amp;signal,
            const QObject *receiver, const QMetaMethod &amp;method,
            Qt::ConnectionType type &#x3D; Qt::AutoConnection);
 
inline QMetaObject::Connection connect(const QObject *sender, const char *signal,
            const char *member, Qt::ConnectionType type &#x3D; Qt::AutoConnection) const;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后一个参数所表示的意思：</p>
<p>Qt::AutoConnection：信号的发送者与信号的接收者在同一线程，则默认使用Qt::DirectConnection：如果不在同一线程，则默认  使用Qt::QueuedConnection。<br>Qt::DirectConnection：信号的发送者与信号的接收者在同一线程中执行，当发出信号后，会马上进入槽函数，看上去就像在信号  发送位置调用了槽函数，在多线程下会比较危险，容易造成崩溃。<br>Qt::QueuedConnection：信号的发送者与信号的接收者不在同一线程中执行，槽函数运行于信号的接收者线程，当发送信号后，  槽函数不会马上被调用，等待信号的接收者把当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。<br>Qt::BlockingQueuedConnection：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。<br>Qt::UniqueConnection：可以通过按位或（|）与以上四个结合在一起使用。当设置此参数时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是避免了重复连接。</p>
<p>介绍到这里，信号和槽的基本内容就写完了。但是，还是得说下Qt事件（你可以结合着上面第2节一起看）。</p>
<h3 id="七、Qt事件"><a href="#七、Qt事件" class="headerlink" title="七、Qt事件"></a>七、Qt事件</h3><p>无论是什么桌面操作系统，每个进程都有一个全局的事件队列（Event Queue）。当我们在键盘上按了一个键、移动或者点击鼠标、触摸屏幕等等，都会产生一个事件（Event），并由操作系统负责将它扔到进程的事件队列。</p>
<p>扔到事件队列后，它会等待以后的某一个时刻发送。分配器（dispatcher ）会遍历事件队列，并且将入栈的事件发送到它们的目标对象当中，因此它们被称为<strong>事件循环（Event loop</strong>）。</p>
<p>Qt中是通过运行QCoreApplication::exec()来进入Qt的主体事件循环的；这会引发阻塞，直至QCoreApplication::exit() 或者 QCoreApplication::quit() 被调用，进而结束循环。</p>
<h1 id="Qt5模板库，工具类和基本控件"><a href="#Qt5模板库，工具类和基本控件" class="headerlink" title="Qt5模板库，工具类和基本控件"></a>Qt5模板库，工具类和基本控件</h1><h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>​        我们很难逃过字符串这个东西，为什么？无论是做什么，我们都要使用字符串来传递信息。无论是网络编程还是GUI显示，很多地方都需要字符串可以灵活的正确的按照我们的想法表达。</p>
<p>​        QString提供了一个非常完善的方法来供我们使用字符串。我们先来看一个简单的操作：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QCoreApplication&gt;
#include &lt;QString&gt;
#include &lt;QDebug&gt;
int main(int argc, char *argv[])
&#123;
    QCoreApplication a(argc, argv);

    QString str1 &#x3D; &quot;Welcome &quot;;
    QString str2 &#x3D; &quot;Qt!&quot;;

    qDebug() &lt;&lt; str1 + str2;

    return a.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们很自然的想到+号使得字符串自然的拼接。我们毫不意外的看到输出是：</p>
<p><img src="image-20230829180312755.png" alt="image-20230829180312755"></p>
<p>​        我们为什么可以直接这样写：</p>
<pre class="line-numbers language-none"><code class="language-none">QString str1 &#x3D; &quot;Welcome &quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        而不是</p>
<pre class="line-numbers language-none"><code class="language-none">QString str1(&quot;Welcome &quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        呢，答案是，我们调用了这个构造函数</p>
<pre class="line-numbers language-none"><code class="language-none">inline QT_ASCII_CAST_WARN QString(const char *ch)
   : d(fromAscii_helper(ch, ch ? int(strlen(ch)) : -1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        实际上，我们还可以到—他不是QString直接跟const char*对接，而是用一个fromAscii对象处理：这是为了方便程序员更加高级的处理字符串的（翻译成Unicode字符串还是其他？）</p>
<p>​        如果不喜欢用 + （我没见过），可以使用等价的接口<code>append</code>，</p>
<pre class="line-numbers language-none"><code class="language-none">QString str;
str.append(str1);
str.append(str2);

qDebug() &lt;&lt; str;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230829181923523.png" alt="image-20230829181923523"></p>
<p>​        我们甚至可以使用一个sprintf来生成我们的字符串，这跟我们的C++字符串库一样</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString Str;
   Str.sprintf(&quot;%s&quot;,&quot;str1&quot;);

   qDebug() &lt;&lt; Str;

   Str.sprintf(&quot;%s&quot;,&quot;str2&quot;);

   qDebug() &lt;&lt; Str;

   Str.sprintf(&quot;%s %s&quot;,&quot;str1&quot;, &quot;str2&quot;);

   qDebug() &lt;&lt; Str;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230829182354324.png" alt="image-20230829182354324"></p>
<p>​        熟悉格式化输出的话，还可以使用arg函数。相较于sprintf，她更有类型安全，且支持处理的类型更多</p>
<pre class="line-numbers language-none"><code class="language-none">QString argtest;
argtest &#x3D; QString(&quot;%1 was in %2&quot;).arg(&quot;Charlie&quot;).arg(&quot;cc&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="image-20230829183053685.png" alt="image-20230829183053685"></p>
<p>​        还有其他的接口，如insert等，可以看后面翻译的文档：</p>
<p>​        更加值得一提的是：QString还有一些方法如：trimmed（移除两端的空白字符）和simplified方法（用空格代表空白字符）</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>​        startsWith方法判定的是某一个字符串是不是以另一个指定的字符串开头</p>
<pre class="line-numbers language-none"><code class="language-none">if(argtest.startsWith(&quot;charlie&quot;,Qt::CaseInsensitive))
    qDebug() &lt;&lt; &quot; yep &quot;;

if(argtest.startsWith(&quot;Charlie&quot;,Qt::CaseInsensitive))
    qDebug() &lt;&lt; &quot; yep &quot;;

qDebug() &lt;&lt; &quot;We see that in Qt::CaseInsensitive mode, both judgement can be true&quot;;

if(!argtest.startsWith(&quot;charlie&quot;,Qt::CaseSensitive))
    qDebug() &lt;&lt; &quot; nope &quot;;

if(argtest.startsWith(&quot;Charlie&quot;,Qt::CaseSensitive))
    qDebug() &lt;&lt; &quot; yep &quot;;

qDebug() &lt;&lt; &quot;but CaseSensitive don&#39;t&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230829183957089.png" alt="image-20230829183957089"></p>
<p>​        可以一瞥，对了，CaseSensitive是QT下的一个Enumeration，一个枚举值，可以看到当我们指定大小写敏感的时候，charlie就找不到了，默认的讲，我们不指定的话，自然是CaseSensitive，这一点可以在默认参数看到：</p>
<pre class="line-numbers language-none"><code class="language-none">#if QT_STRINGVIEW_LEVEL &lt; 2
    bool startsWith(const QString &amp;s, Qt::CaseSensitivity cs &#x3D; Qt::CaseSensitive) const;
    bool startsWith(const QStringRef &amp;s, Qt::CaseSensitivity cs &#x3D; Qt::CaseSensitive) const;
#endif
    Q_REQUIRED_RESULT bool startsWith(QStringView s, Qt::CaseSensitivity cs &#x3D; Qt::CaseSensitive) const Q_DECL_NOTHROW
    &#123; return QtPrivate::startsWith(*this, s, cs); &#125;
    bool startsWith(QLatin1String s, Qt::CaseSensitivity cs &#x3D; Qt::CaseSensitive) const;
    bool startsWith(QChar c, Qt::CaseSensitivity cs &#x3D; Qt::CaseSensitive) const;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        还有个类似的是endsWith，这里不在讲述了！</p>
<p>​        contains方法则是上述两个的通用算法，查询的是子字符串在不在我们的字符串内，返回的是boolean类型</p>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>​        比较函数用于比较两个 QString，并返回整数值 0、小于 0 或大于 0，具体取决于两个 QString 分别相等、小于或大于彼此。</p>
<p>示例 1：比较两个 QStrings</p>
<pre class="line-numbers language-none"><code class="language-none">QString str1 &#x3D; “Hello”;
QString str2 &#x3D; “World”;
int result &#x3D; str1.compare（str2）&#x2F;&#x2F; 结果将小于 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        在这个例子中，我们比较两个QStrings“Hello”和“World”。由于“Hello”按字母顺序排在“World”之前，因此结果将小于 0。</p>
<p>示例 2：使用区分大小写</p>
<pre class="line-numbers language-none"><code class="language-none">QString str1 &#x3D; “Hello”;
QString str2 &#x3D; “HELLO”;
int result &#x3D; str1.compare（str2， Qt：：CaseInsensitive ）&#x2F;&#x2F; 结果将为 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        在这里，我们使用比较函数的可选第二个参数来指定比较应该不区分大小写。</p>
<p>​        由于“Hello”和“HELLO”仅在大小写上有所不同，因此结果将为0，表示两个QString相等。</p>
<p>​        我们最建议使用的是Compare函数，他速度很快。</p>
<h3 id="字符串向其他类型转化"><a href="#字符串向其他类型转化" class="headerlink" title="字符串向其他类型转化"></a>字符串向其他类型转化</h3><p>​        我们可以把字符串在可以的情况下转化为其他类型：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QString str &#x3D; &quot;125&quot;;
bool ok;
int dec &#x3D; str.toInt(&amp;ok);
if(!ok)
	qDebug() &lt;&lt; &quot;Failed to translate&quot;;
else
    qDebug() &lt;&lt; dec;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230829191643468.png" alt="image-20230829191643468"></p>
<p>​        也可以转化为其他格式的字符串：</p>
<ol>
<li>toAscii转化为一个八位字符串</li>
<li>toLatin1转化为一个Latin-1(ISO8859-1)编码的8位字符串</li>
<li>toUtf8转化为utf8字符串</li>
<li>toLocal8Bit字符串</li>
</ol>
<h1 id="Related-Docs"><a href="#Related-Docs" class="headerlink" title="Related Docs"></a>Related Docs</h1><p><a target="_blank" rel="noopener" href="http://qt5.digitser.top/5.15/zh-CN/classes.html">所有类 | Qt 5.15 - 中文文档编制,帮助,手册,教程 (digitser.top)</a></p>
<p>​        也可以查看我的github仓库：<a target="_blank" rel="noopener" href="https://github.com/Charliechen114514/MyTranslatedQtDocument-CN/tree/master/Basic C%2B%2B Class/S">MyTranslatedQtDocument-CN/Basic C++ Class/S at master · Charliechen114514/MyTranslatedQtDocument-CN (github.com)</a></p>
<h1 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h1><p>​        我们下面要谈到的是容器类！容器！我想大伙第一反应就是STL的容器。正确的！Qt的容器类是类似的。</p>
<p>​        他可以存储我们<strong>绝大部分</strong>的容器（意味深长），基本的数据类型，Qt的简单的数据类型，都可以存放在容器里，但是，<strong>类似于QWidget和QDialog</strong>一类的玩意不可以存储，更详细的讲：一切<strong>QObject和他的派生子类</strong>都不可以存在容器里：他们甚至没法通过编译：</p>
<pre class="line-numbers language-none"><code class="language-none">QList&lt;QToolBar&gt; list; &#x2F;&#x2F; compiling Fails!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        但是，这不是意味着存不了，而是转向存储他们的指针</p>
<pre class="line-numbers language-none"><code class="language-none">QList&lt;QToolBar*&gt; list; &#x2F;&#x2F; Accessible!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="QList-QLinkedList-QVector"><a href="#QList-QLinkedList-QVector" class="headerlink" title="QList, QLinkedList, QVector"></a><code>QList, QLinkedList, QVector</code></h1><h2 id="QList"><a href="#QList" class="headerlink" title="QList"></a><code>QList</code></h2><p>​        这是真的很常用，本人开发的一些小工具的首选容器！他们之间的对比如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>容器类</th>
<th>查找</th>
<th>插入</th>
<th>头插</th>
<th>尾插</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>QList</code></td>
<td><code>O(1)</code></td>
<td><code>O(n)</code></td>
<td><code>Amort O(1)</code></td>
<td><code>Amort O(1)</code></td>
</tr>
<tr>
<td><code>QLinkedList</code></td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td><code>QVector</code></td>
<td><code>O(1)</code></td>
<td><code>O(n)</code></td>
<td><code>O(n)</code></td>
<td><code>Amort O(1)</code></td>
</tr>
</tbody>
</table>
</div>
<p>​        我们来看一个demo:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QCoreApplication&gt;
#include &lt;QList&gt;
#include &lt;QDebug&gt;
int main(int argc, char *argv[])
&#123;
    QCoreApplication a(argc, argv);

    QList&lt;QString&gt; myList;
    for(int i &#x3D; 0; i &lt; 10; i++)
    &#123;
        QString tmp &#x3D; &quot;this is number: &quot; + QString::number(i);
        myList &lt;&lt; tmp;
    &#125;

    for (int i &#x3D; 0; i &lt; myList.size();i++) &#123;
        qDebug () &lt;&lt; myList[i];
    &#125;

    return a.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们使用了list 的 &lt;&lt; 方法， 他等价于<code>push_back</code>方法！</p>
<h2 id="QLinkedList"><a href="#QLinkedList" class="headerlink" title="QLinkedList"></a><code>QLinkedList</code></h2><p>​        如名称一致——链表，正儿八经的链表！我建议——当你的元素需要频繁的插取的时候，直接使用这个容器会好得多！</p>
<h2 id="QVector"><a href="#QVector" class="headerlink" title="QVector"></a><code>QVector</code></h2><p>​        STL 的vector，这里是一样的，我们还有QPolygon, QPolygonF, QStack等容器来自这个容器！</p>
<h2 id="一些迭代器"><a href="#一些迭代器" class="headerlink" title="一些迭代器"></a>一些迭代器</h2><p>​        这里不打算讲，但是可以注意的是，迭代器分为Java风格的和STL风格的，Java风格的迭代器可以参看Qt官网</p>
<h1 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h1><p>​        下面我们开始讲点新东西——也就是控件！</p>
<h2 id="摁扭类"><a href="#摁扭类" class="headerlink" title="摁扭类"></a>摁扭类</h2><p>​        我们常见的基础类摁扭有：</p>
<ul>
<li>PushButton 普通按钮</li>
<li>ToolButton 工具按钮</li>
<li>RadioButton 单选按钮</li>
<li>CheckBox 复选框</li>
<li>Command Link Button 命令链接摁扭</li>
<li>对话框按钮盒</li>
</ul>
<p>​        拖出来给大伙看一眼</p>
<p><img src="image-20230831165050603.png" alt="image-20230831165050603"></p>
<p>​        我们下面来设计一下，构建一个自定义的按钮，这一次我们构建的项目是QWidget(控件)， 我们构建一个叫做MyWidget的类，头文件记得添加这些头文件</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;QPushButton&gt;
#include&lt;QFont&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        头文件就可以不用动了</p>
<p>​        然后就是书写代码：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;myidget.h&quot;

Myidget::Myidget(QWidget *parent)
    : QWidget(parent)
&#123;
    setMinimumSize(200,120);
    setMaximumSize(200,120);

    QPushButton* quit &#x3D; new QPushButton(&quot;Quit&quot;, this);

    quit-&gt;setGeometry(60,40,75,30);

    quit-&gt;setFont(QFont(&quot;Times&quot;, 18, QFont::Bold));

    connect(quit, &amp;QPushButton::clicked, this, &amp;QWidget::close);
&#125;

Myidget::~Myidget()
&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        以及为了显示窗口不让他失踪，我们在main.cpp中有必要指定一下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;myidget.h&quot;
#include &lt;QApplication&gt;

int main(int argc, char *argv[])
&#123;
    QApplication a(argc, argv);
    Myidget w;
    w.setGeometry(100,100,200,120); &#x2F;&#x2F; 设置一下大小
    w.show();

    return a.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230831170310308.png" alt="image-20230831170310308"></p>
<p>​        点击它，程序就结束了。</p>
<h2 id="输入部件"><a href="#输入部件" class="headerlink" title="输入部件"></a>输入部件</h2><p>​        常见的输入部件在这里：</p>
<ol>
<li>Combo Box 组合框</li>
<li>Font Combo Box 字体编辑框 （可以获得用户选择的字体！）</li>
<li>Line Edit 行编辑框</li>
<li>Text Edit 文本编辑框</li>
<li>Plain Text Edit 纯文本编辑框</li>
<li>Spin Box 数字显示框</li>
<li>Double Spin Box 双自旋盒</li>
<li>Time Edit 时间编辑</li>
<li>Date Edit 日期编辑</li>
<li>Date/Time Edit 时间日期编辑</li>
<li>Dial 拨号</li>
<li>Horizontal Scroll Bar 横向滚动条</li>
<li>Vertical Scroll Bar 纵向滚动条</li>
<li>Horizontal Slider 横向滑块</li>
<li>Vertical Slider 纵向滑块</li>
<li>Key Sequence Edit 按键序编辑框</li>
</ol>
<p><img src="image-20230831171224388.png" alt="image-20230831171224388"></p>
<p>​        还是一样，相关的设计已经集成在我的Qt CN Document仓库了</p>
<h2 id="显示控件"><a href="#显示控件" class="headerlink" title="显示控件"></a>显示控件</h2><p>​        下面的这些控件主要是用来展示内容的（Display）</p>
<ul>
<li>Label: 标签</li>
<li>TextBrowser 文本浏览器</li>
<li>Graphic View 图形视图</li>
<li>Calendar Widget 日历</li>
<li>LCD Number 液晶数字</li>
<li>Process Bar 进度条</li>
<li>Horizontal Line水平线</li>
<li>Vertical Line 铅垂线</li>
<li>OpenGL Widget OpenGL控件</li>
<li>QQuick Widget QML模块</li>
</ul>
<h2 id="容器组"><a href="#容器组" class="headerlink" title="容器组"></a>容器组</h2><ul>
<li>GroupBox</li>
<li>Scroll Area</li>
<li>Tool Box</li>
<li>Tab Widget</li>
<li>Stacked Widget</li>
<li>Frame</li>
<li>Widget</li>
<li>MDI Area</li>
<li>Dock Widget</li>
<li>QAxWidget</li>
</ul>
<h1 id="Qt5-布局"><a href="#Qt5-布局" class="headerlink" title="Qt5 布局"></a>Qt5 布局</h1><p>我们下面来看看布局问题：</p>
<h2 id="分割类QSpitter"><a href="#分割类QSpitter" class="headerlink" title="分割类QSpitter"></a>分割类QSpitter</h2><p><img src="image-20230904222839497.png" alt="image-20230904222839497"></p>
<p>​        我们可以这样应用QSplitter类帮助我们做这样的事情：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &lt;QApplication&gt;
#include &lt;QSplitter&gt;
#include &lt;QTextEdit&gt;
int main(int argc, char *argv[])
&#123;
    QApplication a(argc, argv);
    QFont font(&quot;ZYSong18030&quot;, 12);
    a.setFont(font);
    QSplitter *splitMainWindow &#x3D; new QSplitter(Qt::Horizontal, 0);

    &#x2F;&#x2F; 主分割
    QTextEdit* textLeft &#x3D; new QTextEdit(QObject::tr(&quot;Left Widget&quot;), splitMainWindow);
    textLeft-&gt;setAlignment(Qt::AlignCenter);

    &#x2F;&#x2F; right 分割
    QSplitter* rightSplit &#x3D; new QSplitter(Qt::Vertical, splitMainWindow);
    rightSplit-&gt;setOpaqueResize(false);
    QTextEdit* textUp &#x3D;new QTextEdit(QObject::tr(&quot;Top Widget&quot;), rightSplit);
    textUp-&gt;setAlignment(Qt::AlignCenter);

    QTextEdit* textDown &#x3D;new QTextEdit(QObject::tr(&quot;bottom Widget&quot;), rightSplit);
    textDown-&gt;setAlignment(Qt::AlignCenter);
    splitMainWindow-&gt;setStretchFactor(1,1);
    splitMainWindow-&gt;setWindowTitle(QObject::tr(&quot;Splitter&quot;));
    splitMainWindow-&gt;show();

&#x2F;&#x2F;    MainWindow w;
&#x2F;&#x2F;    w.show();

    return a.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，我们仔细瞧瞧代码：</p>
<pre class="line-numbers language-none"><code class="language-none">QSplitter *splitMainWindow &#x3D; new QSplitter(Qt::Horizontal, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        主分割窗口，我们并且还对窗口呈现主水平分割：人话如下：</p>
<p><img src="image-20230904223113085.png" alt="image-20230904223113085"></p>
<p>​        然后，在主窗口左侧插入一个TextEdit类，至于文本的对齐方式是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Qt::AlignLeft</code></td>
<td>左对齐</td>
</tr>
<tr>
<td><code>Qt::AlignRight</code></td>
<td>右对齐</td>
</tr>
<tr>
<td><code>Qt::AlignCenter</code></td>
<td>居中对齐</td>
</tr>
<tr>
<td><code>Qt::AlignUp</code></td>
<td>顶对齐</td>
</tr>
<tr>
<td><code>Qt::AlignBottom</code></td>
<td>底对齐</td>
</tr>
</tbody>
</table>
</div>
<p>​        而<code>rightSplit-&gt;setOpaqueResize(false);</code>这句话的意思是：拖拽时不会实时更新显示，直接一条灰线。</p>
<h2 id="QDockWidget类"><a href="#QDockWidget类" class="headerlink" title="QDockWidget类"></a>QDockWidget类</h2><p>​        我们下面来看一个QDockWidget类的例子：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
    setWindowTitle(tr(&quot;DockWindows&quot;));
    QTextEdit* text &#x3D; new QTextEdit(this);
    text-&gt;setText(tr(&quot;Main Windows&quot;));
    text-&gt;setAlignment(Qt::AlignCenter);
    setCentralWidget(text);
    &#x2F;&#x2F; Dock1
    QDockWidget* dock &#x3D; new QDockWidget(tr(&quot;Dock1&quot;), this);

    dock-&gt;setFeatures(QDockWidget::DockWidgetMovable);
    dock-&gt;setAllowedAreas(Qt::LeftDockWidgetArea| Qt::RightDockWidgetArea);

    QTextEdit* text1 &#x3D; new QTextEdit();
    text1-&gt;setText(tr(&quot;Window1, the dock widget can be moved between docks by the user&quot;));
    dock-&gt;setWidget(text1);
    addDockWidget(Qt::RightDockWidgetArea, dock);

    QDockWidget* dock1 &#x3D; new QDockWidget(tr(&quot;DockWindow2&quot;),this);\
    dock1-&gt;setFeatures(QDockWidget::DockWidgetFloatable | QDockWidget::DockWidgetClosable);
    QTextEdit* text2 &#x3D; new QTextEdit();
    text2-&gt;setText(tr(&quot;Windows2, the dock widget can be detached from the mainWindow, and floated as an independent window&quot;));
    dock1-&gt;setWidget(text2);
    addDockWidget(Qt::RightDockWidgetArea, dock1);

    QDockWidget* dock2 &#x3D; new QDockWidget(tr(&quot;DockWindow2&quot;),this);
    dock2-&gt;setFeatures(QDockWidget::AllDockWidgetFeatures);
    QTextEdit* text3 &#x3D; new QTextEdit();
    text2-&gt;setText(tr(&quot;Windows2, the dock widget can be detached from the mainWindow, and floated as an independent window&quot;));
    dock1-&gt;setWidget(text3);
    addDockWidget(Qt::RightDockWidgetArea, dock2);

&#125;

MainWindow::~MainWindow()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230905200515557.png" alt="image-20230905200515557"></p>
<p>​        看起来不错！</p>
<h2 id="QStackedWidget类"><a href="#QStackedWidget类" class="headerlink" title="QStackedWidget类"></a>QStackedWidget类</h2><p><img src="image-20230905201906477.png" alt="image-20230905201906477"></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; mainWindow.h
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;
#include &lt;QListWidget&gt;
#include &lt;QLabel&gt;
#include &lt;QStackedWidget&gt;
#include &lt;QHBoxLayout&gt;
class MainWindow : public QMainWindow
&#123;
    Q_OBJECT

public:
    MainWindow(QWidget *parent &#x3D; 0);
    ~MainWindow();
private:
    QListWidget* list;
    QStackedWidget* stack;
    QList&lt;QLabel*&gt; labelList;
&#125;;

#endif &#x2F;&#x2F; MAINWINDOW_H


#include &quot;mainwindow.h&quot;

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
    QWidget* widget &#x3D; new QWidget(this);
    setCentralWidget(widget);
    this-&gt;setWindowTitle(&quot;Stacked Test&quot;);
    list &#x3D; new QListWidget(widget);

    list-&gt;insertItem(0, tr(&quot;window1&quot;));
    list-&gt;insertItem(1, tr(&quot;window2&quot;));
    list-&gt;insertItem(2, tr(&quot;window3&quot;));

    labelList.push_back(new QLabel(tr(&quot;WindowTest1&quot;)));
    labelList.push_back(new QLabel(tr(&quot;WindowTest2&quot;)));
    labelList.push_back(new QLabel(tr(&quot;WindowTest3&quot;)));

    stack &#x3D; new QStackedWidget(widget);

    for(int i &#x3D; 0; i &lt; 3; i++)
       stack-&gt;addWidget(labelList[i]);
    QHBoxLayout *mainLay &#x3D; new QHBoxLayout(widget);

    mainLay-&gt;setMargin(5); &#x2F;&#x2F; 设置边距
    mainLay-&gt;setSpacing(5);
    mainLay-&gt;addWidget(list);
    mainLay-&gt;addWidget(stack,0,Qt::AlignCenter);
    mainLay-&gt;setStretchFactor(list, 1);
    mainLay-&gt;setStretchFactor(stack, 3);
    connect(list, &amp;QListWidget::currentRowChanged, stack, &amp;QStackedWidget::setCurrentIndex);

&#125;

MainWindow::~MainWindow()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Qt基本布局"><a href="#Qt基本布局" class="headerlink" title="Qt基本布局"></a>Qt基本布局</h2><p>​        简单的讲，我们的QT布局如下：</p>
<p><img src="image-20230905202309121.png" alt="image-20230905202309121"></p>
<p>​        好了，常见的基本控件和其他的定西都说完了</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/09/05/Deep-Qt-Learn-1/">http://charliechen114514.github.io/2023/09/05/Deep-Qt-Learn-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Qt/">Qt</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%98%E5%8E%9F%E7%9C%9F%E7%9B%B8%EF%BC%88%E8%B6%85%E9%95%BF%E8%AE%B0%E5%BD%95%E7%89%88%EF%BC%89/" title="操作系统还原真相（超长记录版）"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统还原真相（超长记录版）</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/23/TCP-IP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941%EF%BC%8C2%EF%BC%8C3/" title="TCP/IP 网络编程笔记——1，2，3"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">TCP/IP 网络编程笔记——1，2，3</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/07/DeepLearningQt-ReadingDocuments1/" title="DeepLearningQt-ReadingDocuments1"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="title">DeepLearningQt-ReadingDocuments1</div></div></a></div><div><a href="/2023/06/06/Learn-Qt-I/" title="Learn_Qt-I"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Learn_Qt-I</div></div></a></div><div><a href="/2024/01/19/OCR%E5%BC%80%E5%8F%91%E5%BA%93%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/" title="OCR开发库日志记录"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-19</div><div class="title">OCR开发库日志记录</div></div></a></div><div><a href="/2023/06/06/Algorithm-RecursionSpecial/" title="Algorithm_RecursionSpecial"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_RecursionSpecial</div></div></a></div><div><a href="/2023/06/06/Algorithm-in-C-1/" title="Algorithm_in_C(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_in_C(1)</div></div></a></div><div><a href="/2024/01/09/2024%E5%AF%92%E5%81%87%E6%95%B4%E6%B4%BB-C-Cppb%E9%AB%98%E7%BA%A7%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/" title="2024寒假整活_C_Cppb高级编译技术"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-09</div><div class="title">2024寒假整活_C_Cppb高级编译技术</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Deep-Qt"><span class="toc-number">1.</span> <span class="toc-text">Deep Qt</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">2.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Start-all"><span class="toc-number">3.</span> <span class="toc-text">Start all</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%9C%86%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.1.</span> <span class="toc-text">计算圆的大小</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD"><span class="toc-number">4.</span> <span class="toc-text">信号与槽</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%E7%BC%BA%E7%82%B9"><span class="toc-number">4.1.</span> <span class="toc-text">优点缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.1.</span> <span class="toc-text">一、桌面程序的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.1.2.</span> <span class="toc-text">二、事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD"><span class="toc-number">4.1.3.</span> <span class="toc-text">三、信号和槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Qt%E5%85%83%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.1.4.</span> <span class="toc-text">四、Qt元对象系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.5.</span> <span class="toc-text">五、信号和槽的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81connect%E7%9A%84%E7%AC%AC%E4%BA%94%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.6.</span> <span class="toc-text">六、connect的第五个参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81Qt%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.1.7.</span> <span class="toc-text">七、Qt事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Qt5%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%8C%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%8E%A7%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">Qt5模板库，工具类和基本控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">字符串类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.1.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.1.2.</span> <span class="toc-text">查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">5.1.3.</span> <span class="toc-text">字符串比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%90%91%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-number">5.1.4.</span> <span class="toc-text">字符串向其他类型转化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Related-Docs"><span class="toc-number">6.</span> <span class="toc-text">Related Docs</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">容器类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QList-QLinkedList-QVector"><span class="toc-number">8.</span> <span class="toc-text">QList, QLinkedList, QVector</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QList"><span class="toc-number">8.1.</span> <span class="toc-text">QList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QLinkedList"><span class="toc-number">8.2.</span> <span class="toc-text">QLinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QVector"><span class="toc-number">8.3.</span> <span class="toc-text">QVector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">8.4.</span> <span class="toc-text">一些迭代器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E4%BB%B6"><span class="toc-number">9.</span> <span class="toc-text">控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%81%E6%89%AD%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">摁扭类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E9%83%A8%E4%BB%B6"><span class="toc-number">9.2.</span> <span class="toc-text">输入部件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%8E%A7%E4%BB%B6"><span class="toc-number">9.3.</span> <span class="toc-text">显示控件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%BB%84"><span class="toc-number">9.4.</span> <span class="toc-text">容器组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Qt5-%E5%B8%83%E5%B1%80"><span class="toc-number">10.</span> <span class="toc-text">Qt5 布局</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%B1%BBQSpitter"><span class="toc-number">10.1.</span> <span class="toc-text">分割类QSpitter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QDockWidget%E7%B1%BB"><span class="toc-number">10.2.</span> <span class="toc-text">QDockWidget类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QStackedWidget%E7%B1%BB"><span class="toc-number">10.3.</span> <span class="toc-text">QStackedWidget类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80"><span class="toc-number">10.4.</span> <span class="toc-text">Qt基本布局</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/08/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%B5%85%E8%AE%BA/" title="C++智能指针浅论"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++智能指针浅论"/></a><div class="content"><a class="title" href="/2024/03/08/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%B5%85%E8%AE%BA/" title="C++智能指针浅论">C++智能指针浅论</a><time datetime="2024-03-08T14:09:12.000Z" title="发表于 2024-03-08 22:09:12">2024-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/05/Linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="Linux内核深度学习"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux内核深度学习"/></a><div class="content"><a class="title" href="/2024/03/05/Linux%E5%86%85%E6%A0%B8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="Linux内核深度学习">Linux内核深度学习</a><time datetime="2024-03-05T01:04:41.000Z" title="发表于 2024-03-05 09:04:41">2024-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/29/Opencv490-MSVC-Mingw-WITHQT-OpencvContrib4-x%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/" title="Opencv490+MSVC_Mingw+WITHQT+OpencvContrib4_x编译教程"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Opencv490+MSVC_Mingw+WITHQT+OpencvContrib4_x编译教程"/></a><div class="content"><a class="title" href="/2024/01/29/Opencv490-MSVC-Mingw-WITHQT-OpencvContrib4-x%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/" title="Opencv490+MSVC_Mingw+WITHQT+OpencvContrib4_x编译教程">Opencv490+MSVC_Mingw+WITHQT+OpencvContrib4_x编译教程</a><time datetime="2024-01-29T10:03:05.000Z" title="发表于 2024-01-29 18:03:05">2024-01-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%E9%80%9F%E9%80%9A%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%B0%A2%E5%B8%8C%E4%BB%81%E7%89%88%E6%9C%AC%EF%BC%89/" title="计算机网络概念速通（基于谢希仁版本）"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络概念速通（基于谢希仁版本）"/></a><div class="content"><a class="title" href="/2024/01/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%E9%80%9F%E9%80%9A%EF%BC%88%E5%9F%BA%E4%BA%8E%E8%B0%A2%E5%B8%8C%E4%BB%81%E7%89%88%E6%9C%AC%EF%BC%89/" title="计算机网络概念速通（基于谢希仁版本）">计算机网络概念速通（基于谢希仁版本）</a><time datetime="2024-01-24T03:45:11.000Z" title="发表于 2024-01-24 11:45:11">2024-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/22/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="重新学习Linux操作系统"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="重新学习Linux操作系统"/></a><div class="content"><a class="title" href="/2024/01/22/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="重新学习Linux操作系统">重新学习Linux操作系统</a><time datetime="2024-01-22T04:24:05.000Z" title="发表于 2024-01-22 12:24:05">2024-01-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>