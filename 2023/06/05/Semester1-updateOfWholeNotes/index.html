<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Semester1 updateOfWholeNotes | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Magazine of Programming I(对以往笔记的总和以及部分模块的更新) Sections includes:&gt; C++阅读笔记 简单的算法入门 Linux入门 Cmake入门 基于VS的Opencv教程 qt开发1 Windows API初步1  C++笔记阅读C++基础编程​        下面，我们开始正式的入门Ｃ++这个语言，通过一些简单的分析来了解一些简单的概念！我">
<meta property="og:type" content="article">
<meta property="og:title" content="Semester1 updateOfWholeNotes">
<meta property="og:url" content="http://charliechen114514.github.io/2023/06/05/Semester1-updateOfWholeNotes/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="Magazine of Programming I(对以往笔记的总和以及部分模块的更新) Sections includes:&gt; C++阅读笔记 简单的算法入门 Linux入门 Cmake入门 基于VS的Opencv教程 qt开发1 Windows API初步1  C++笔记阅读C++基础编程​        下面，我们开始正式的入门Ｃ++这个语言，通过一些简单的分析来了解一些简单的概念！我">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-06-05T03:50:36.000Z">
<meta property="article:modified_time" content="2023-06-05T03:53:46.512Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Semester_overall">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/06/05/Semester1-updateOfWholeNotes/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Semester1 updateOfWholeNotes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-05 11:53:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Semester1 updateOfWholeNotes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-05T03:50:36.000Z" title="发表于 2023-06-05 11:50:36">2023-06-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-05T03:53:46.512Z" title="更新于 2023-06-05 11:53:46">2023-06-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">73k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>291分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Semester1 updateOfWholeNotes"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Magazine-of-Programming-I"><a href="#Magazine-of-Programming-I" class="headerlink" title="Magazine of Programming I"></a>Magazine of Programming I</h1><p>(对以往笔记的总和以及部分模块的更新)</p>
<h2 id="Sections-includes-gt"><a href="#Sections-includes-gt" class="headerlink" title="Sections includes:&gt;"></a>Sections includes:&gt;</h2><ol>
<li>C++阅读笔记</li>
<li>简单的算法入门</li>
<li>Linux入门</li>
<li>Cmake入门</li>
<li>基于VS的Opencv教程</li>
<li>qt开发1</li>
<li>Windows API初步1</li>
</ol>
<h1 id="C-笔记阅读"><a href="#C-笔记阅读" class="headerlink" title="C++笔记阅读"></a>C++笔记阅读</h1><h1 id="C-基础编程"><a href="#C-基础编程" class="headerlink" title="C++基础编程"></a>C++基础编程</h1><p>​        下面，我们开始正式的入门Ｃ++这个语言，通过一些简单的分析来了解一些简单的概念！我们将会在这些sections中认识</p>
<p>​        基本的数据类型：布尔值，字符，整形，浮点数等概念</p>
<p>​        还要认识算术运算符，关系运算符和逻辑运算符，用在操作上树基础数据类型。这些运算符包括诸如+ ,==, &lt;=等，还会有赋值，也包括Ｃ/Ｃ++的++自增运算，条件运算（？：）和复合赋值运算（+=）</p>
<p>​        一些基本结构语句，比如说ifwhile等来改变程序的流程</p>
<p>​        一些复合类型、比如说指针和数组。</p>
<p>​        一套标准而又通用的抽象化库，比如字符串（string）和向量(vector)</p>
<h2 id="1-1简单程序的书写"><a href="#1-1简单程序的书写" class="headerlink" title="1.1简单程序的书写"></a>1.1简单程序的书写</h2><p>下面开始书写简单的程序，我们的要求是将一小段信息发送到用户的终端，是请求用户输入一小段自己的姓名，程序读取后用这个姓名来跟用户打招呼。</p>
<p>在Ｃ/C++中，程序是从一个叫做main()的地方开始入手执行程序的，格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">int main()

&#123;

 

   &#x2F;&#x2F; this is he place you input the code

 

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        int是Ｃ++程序的一个关键字，什么是关键字呢？就是程序语言预先定义好了的具有特殊含义的名称。言之：int是用来表示内置的数据类型的，它表明这一个整形。</p>
<p>​        如图的：这是一个函数，它是一块独立的程序代码序列，<code>main</code>函数返回一个整形，事实上，它的逻辑含义正式说明程序是否正确允许运行，原则上正确运行返回0，否则返回其他值。这表达出程序产生了其他错误需要处理！</p>
<p>​        当然，其他函数的名称可以由程序员自己选择，当然，最好名称是让人一下子就明白这是要干什么的！比如对于一个实现了排序的函数，你给他起名字叫<code>sort()</code>也比叫他<code>q()</code>强的多</p>
<p>​        函数的参数列表，是函数执行时候可能用到的参数，我们把它放在（）里面，比如：<code>void sort(int* arr, unsigned int arrLen)</code>，而当你直接书写（）表明函数不接受参数！</p>
<p>​        随后，当我们制定完函数的返回类型，参数列表函数名称之后，就用一个大括号将实现代码阔起来{}</p>
<p>​        // 是C/C++的注释符号！</p>
<p>​        下面我们开始完成任务：第一个工作就是向用户给出提示输入！事实上，在Ｃ++中，我们是调用面对对象的类层次体系来完成这个工作的</p>
<p>​        <strong>所谓的类就是用户自己定义的数据类型，</strong>在Ｃ++中这个关键字就是class。我们使用基本的数据类型将他们组合起来构成新的自定义的对象！比如说：我们选择三个浮点型来表现一个点的空间坐标！等等。</p>
<p>class给我们了抽象事物的能力！虽然说还是没到该使用class的时候，但还是先要声明一下，我妈实现一个class类即要声明又要实现！它们要被放在不同的文件下。想要使用这些类呢，就要引用他们的声明文件，也就是头文件！标准格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里，有标准库已经封装好了的控制台输出对象：cout，这样的使用，就可以把我们想要输入的东西输出到控制台上：</p>
<pre class="line-numbers language-none"><code class="language-none">cout&lt;&lt; “offer me your name please!”;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这就是一条单独的语句。如果我们书写这样的代码，用户就会看见一条信息了！但是先别急，还没讲完，这个时候运行会报错的。</p>
<p>我们要找一个东西来储存用户的输入，不错，选取标准库的string 是一个汗不错的主意。声明的方式可以类比：</p>
<pre class="line-numbers language-none"><code class="language-none">string usr_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但是止步于此系统不认识你的string是什么，于是声明一下头文件就好了：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;string&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>以后运用cin来输入东西读入进程序就好了！</p>
<pre class="line-numbers language-none"><code class="language-none">cin &gt;&gt; usr_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>而在我们读取成功之后，我们利用收集到的信息，来完成打招呼：</p>
<pre class="line-numbers language-none"><code class="language-none">cout&lt;&lt;“hello,” 
&lt;&lt;usr_name
&lt;&lt;“ nice to meet you!”
&lt;&lt;“\n”;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        是的，我们的Cout可以这样使用来达到连续输出的效果！</p>
<p>​        下面我们组合起来，完成我们第一个大程序：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;

#include&lt;string&gt;

 

using namespace std; &#x2F;&#x2F; using in declaring the functions that belongs to which!

 

int main()

&#123;

string usr_namel;

cout &lt;&lt; “sbmit your first name”;

 

cin &gt;&gt; usr_name;

 

cout &lt;&lt; “ hello !”

&lt;&lt; usr_name

&lt;&lt; “nice to meet you\n”; ,&#x2F;&#x2F; 表示换行

return 0;

&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们的程序会在后面很成功的完成我们的任务。</p>
<p>程序中间的有一行，是我们需要留心的，那就是</p>
<pre class="line-numbers language-none"><code class="language-none">using namespace std;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这一行程序将标准库里的函数所在的空间暴露给我们的程序，意味着我们不再需要指明这是哪里的某函数便可以直接使用之！</p>
<h2 id="对象的定义和初始化问题"><a href="#对象的定义和初始化问题" class="headerlink" title="对象的定义和初始化问题"></a>对象的定义和初始化问题</h2><p>​        下面想要集中说明的是关于对象初始化和定义的问题！</p>
<p>​        这是一块内存地址对于我们程序员的抽象！换而言之，我们给这块内存地址取一个名字，映射这块内存地址，赋予它数据类型。注意的是名称是任何字母，数字和下划线____的若干组合！大小写是区分的！！！对象名称也不可以由名字打头！比如说1_User是一个不合法的名称。</p>
<p>​        每个对象都有自己的数据类型，他们决定了这个对象有多大，范围如何。一个标准的声明对象的格式是：</p>
<pre class="line-numbers language-none"><code class="language-none">int usr_val &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        也就是</p>
<pre class="line-numbers language-none"><code class="language-none">typename varName &#x3D; Val;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在这行语句里，我们实际上做了两件事情：对象的定义和初始化，我们都做了！定义只是声明了这个变量是什么，赋值，也就是初始化的具体行为，是用assignment这个行为，使用= 这个运算符完成的。</p>
<p>​        简单的对象只需要一次复制就可以有效的完成。但是对于复杂的对象，也就是比如说复数：学过几本数学的都知道，复数是由实数和虚数构成的。那么，这样的行为大多数情况下就是未定义的！</p>
<pre class="line-numbers language-none"><code class="language-none">complex anError &#x3D; 1; &#x2F;&#x2F; Error ,this is a compound variable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>那，我们就需要使用这样的方式，比如说：</p>
<pre class="line-numbers language-none"><code class="language-none">Complex ok(10,20); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>标准库是怎么说的呢？标准库是使用了模版来进行编程的：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;complex&gt;
Complex&lt;double&gt; aComplex(10,29);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        好，那这个<code>&lt;double&gt;</code>又是几个意思呢？事实上这涉及到另一个高级的概念叫做模版编程。对于一类大对象，我们需要知道具体的（用户和用户程序员给出才能完全确定的）数据结构才能进行完全的初始化。这个是模版</p>
<p>​        当然，对于一些常量，我们使用const修饰符来让编译器知道这个变量是不允许修改的！</p>
<pre class="line-numbers language-none"><code class="language-none">const typeName varName &#x3D; initialVal;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="书写表达式"><a href="#书写表达式" class="headerlink" title="书写表达式"></a>书写表达式</h2><p>​        下面我们来开始另一个Ｃ++编程的主要活动，也就是书写表达式指挥编译器，从而间接的指挥CPU等各个硬件来完成我们希望完成的工作。事实上，我们刚刚阐述的赋值就是一种赋值表达式。</p>
<p>​        表达式可以是简单的：</p>
<pre class="line-numbers language-none"><code class="language-none">i +&#x3D; 2；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        也可以是复杂的，比如说下面的式子实现了自动检测行数来实现自动换行的语句</p>
<pre class="line-numbers language-none"><code class="language-none">cout &lt;&lt; textInLine &lt;&lt; (cnt % 8 ? ‘’ : ‘\n’ );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        %这个运算符是取余操作符，同时，还有一个崭新的三目操作符</p>
<pre class="line-numbers language-none"><code class="language-none">EXPR1 ? EXPR2 : EXPR3;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这是什么意思呢？我换一下：</p>
<p>​        你吃饭了吗？ 吃了：没吃</p>
<p>​        也就是说，只有对着EXPR1 求值返回的是真，才会执行EXPR2 ，否则就是执行3</p>
<p>​        表达式的核心是运算符，对于赋值行为我们常常会遇到自己操作自己的情况。Ｃ++使用+=，++ 等行为来简化我们的自增行为。</p>
<pre class="line-numbers language-none"><code class="language-none">cnt +&#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        特别的 ++ 和 —  是递增递减运算符，专门的，有前置的与后置的运算符。</p>
<p>​        前置是先加后用，也就是说</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; demo 
int val &#x3D; 10;
cout &lt;&lt; ++val;
&#x2F;&#x2F; On console , we see the res is 11
cout &lt;&lt; val++;
&#x2F;&#x2F; On console , we see the res is 11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        除了赋值运算符，我们还有关系运算符。这里有== != &lt; &gt; &lt;= &gt;= 这个关系式返回的是布尔值。</p>
<p>​        这样的特性使之可以用在if 等结构语句: </p>
<pre class="line-numbers language-none"><code class="language-none">if( BOOL_EXPR)&#123;

&#x2F;&#x2F; the statements that executing only when EXPR is true.

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        一个经典的应用我想就是用户反馈判断的代码了！</p>
<pre class="line-numbers language-none"><code class="language-none">if(usr_choice &#x3D;&#x3D; ‘Y’)&#123;

usr_more &#x3D; false;

&#125;

else&#123;

usr_more &#x3D; true;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        值的我们反复警示的是！很多人上手就会写好玩的</p>
<pre class="line-numbers language-none"><code class="language-none">if(choice &#x3D; ‘Y’)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>这样就是一个赋值行为，表达式返回赋值的结果，也就是说，除非是赋值0，否则这个if判断将会是永远成立的！而且choice的值将会被赋值‘Y’，灾难！</strong></p>
<p>​        <strong>在if中的表达式可以使用&amp;&amp; || !等运算符来避免不必要的嵌套if从句，后者对于阅读代码的人来讲是一个灾难。</strong></p>
<pre class="line-numbers language-none"><code class="language-none">if(password 
   &amp;&amp; 
   validate( password) 
   &amp;&amp; 
   (get_account &#x3D; retrieve_account_info(password)  
   ) 
  )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上，我们首先看password是不是false，是的话，后面的表达式不执行直接跳过！</p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>我们运算符也有优先级的，运算符从上到下运算符优先级逐步降低：</p>
<p><strong>NOT ！</strong></p>
<p><strong>算术运算符 * / %</strong></p>
<p><strong>算术运算符 + -</strong></p>
<p><strong>关系运算符 &lt; &gt; &lt;= &gt;=</strong></p>
<p><strong>关系运算符 == !=</strong></p>
<p><strong>逻辑运算符AND</strong></p>
<p><strong>逻辑运算符 OR</strong></p>
<p><strong>赋值运算符 =</strong></p>
<p>因此，当我们试图判断 i可不可以被2惩整除的时候，不可以写作：</p>
<pre class="line-numbers language-none"><code class="language-none">if(!i %2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>因为！i会被先计算，所以，这样才是合适的：</p>
<pre class="line-numbers language-none"><code class="language-none">if（!(i%2)）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="条件语句和循环语句"><a href="#条件语句和循环语句" class="headerlink" title="条件语句和循环语句"></a>条件语句和循环语句</h2><p>下面要讲述简单的循环语句和条件语句。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>​        很简单，就是if ,else ,else if三件套，这个我们不再多说，没有新鲜的东西！</p>
<p>​        但是值得一提的是switch语句！我们如果发现可以使用一系列的整数来代替选择的话就不妨使用switch语句，其格式是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">switch(num)&#123;

case 1:

cout &lt;&lt; “this is the case 1”;break; &#x2F;&#x2F; break is using to jump out the structure .

case 2:

cout &lt;&lt; “this is the case 2”;break;

default:

break;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>我们如果希望程序在某一个条件之下一直做一些什么事情，那while for do{}while什么的最合适了。</p>
<pre class="line-numbers language-none"><code class="language-none">while(get_Correct)
&#123;

	get_Correct &#x3D; usrInput();

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        while循环表达式会在开始执行循环体的时候先计算（）内部的表达式是不是真，若果是真循环体执行一直到表达式循环为假，这就强迫我们提供循环的出口！</p>
<p>​        当然，有的时候可以用break 直接干掉循环，或者是使用 continue结束当前循环。</p>
<p>比如说</p>
<pre class="line-numbers language-none"><code class="language-none">while(cin &gt;&gt; word)
&#123; 
	if(word.size() &lt; min_size)&#123;

		continue; &#x2F;&#x2F; 只是不再收录小于 min 长度的字符串

	&#125;
	if(word.size() &gt;&#x3D; max_size)&#123;
		break; &#x2F;&#x2F; 则是遇到大于最大长度的直接跳出循环继续执行其他的程序
	&#125;
	Proceed_text(word)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用标准库的array-和vector"><a href="#使用标准库的array-和vector" class="headerlink" title="使用标准库的array 和vector"></a>使用标准库的array 和vector</h2><p>​        我们的程序经常需要存储一系列的元素，这需要我们使用数组来完成这个工作，在Ｃ++中，前辈们已经帮我们封装好了 array 和 vector使用。</p>
<p>​    想要使用之，就必须首先引用头文件</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;array&gt;
#include&lt;vector&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        在初始化的时候，就需要注意到我们首先要指明存什么</p>
<pre class="line-numbers language-none"><code class="language-none">int sq_size &#x3D; 10;

vector&lt;int&gt; pell_seq(sq_size);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        你瞧，这样就好了，int指明了我们的动态数组（vector是动态数组）存储整形的，而pell_seq 是这个动态数组的名字，（）里面提供的是初始化时提供的参数。</p>
<p>​        对于数组的赋值，我们使用[]，里头提供下标来作为在数组哪里赋值的依据。</p>
<p>​        这里为了方便使用for语句来赋值</p>
<pre class="line-numbers language-none"><code class="language-none">for(init-statement; condition_of_continueForLoop; expression)
&#123;

 

&#125;

&#x2F;&#x2F;Examples
for(int i &#x3D; 0; i &lt; 10; i++)
&#123;

pell_seq[i] &#x3D; i;

&#125;
 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        你看这样就好了。至于如何打印我们将在后面学习！</p>
<p>​        array是类似的，不过，array是静态的数组，不支持动态扩展，这是我们需要注意的。</p>
<h2 id="指针小论"><a href="#指针小论" class="headerlink" title="指针小论"></a>指针小论</h2><p>我们可以通过被告知元素在哪里而不是他叫什么来访问元素。这正是指针的用处！声明一个指针，赋予其地址，也就是他在计算机内存的何处。</p>
<pre class="line-numbers language-none"><code class="language-none">int* pVal &#x3D; &amp;Val;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 使用这个方法拿到一个元素的地址，这下，指针就像钥匙一般找到元素本身来对其本身进行操作了：</p>
<pre class="line-numbers language-none"><code class="language-none">if（*pVal !&#x3D; 1024）
&#123;

	*pVal &#x3D; 1024;	

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当我们不在声明中对指针变量使用*时，正是解引用的意思。</p>
<p>我们需要指出的是，在指针本身，也可以存在：指针不指向任何东西，在习惯上赋值为NULL，当然在后面的Ｃ++中又使用nullptr作为不指向任何东西的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt;* pVec &#x3D; nullptr;
pVec &#x3D; new vector&lt;int&gt;(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>同时，这也提醒我们，在我们通过指针来对对象进行若干操作的时候，就需要首先了解一下这个指针是不是空：</p>
<pre class="line-numbers language-none"><code class="language-none">if(pVec &amp;&amp; *pVec.empty()) &#x2F;&#x2F; pVec 有效吗 &amp;&amp; pVec指向的对象元素是不是空    <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="文件流操作"><a href="#文件流操作" class="headerlink" title="文件流操作"></a>文件流操作</h2><p>操纵文件，对文件输入输出东西在Ｃ++中十分常见！</p>
<p>来看一个DEMO。</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;fstream&gt;
int main()
&#123;

	ofstream outfile(“something.txt”);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这行代码的作用效果是：打开一个文件，它是something.txt 如果文件并不存在，那我们就创建一个叫something的文本文件。并且让他处于打开的状态，从而程序可以对之输入。</p>
<p>​        但是，如我们每次都这样书写，带来的作用是新的会覆盖旧的书写，如果我们不想这样，那就提供一个参数： ios_base::app表明我们现在对文件施以追加输入。现在，可以通过outfile这个对象来给文件重定向内容了！</p>
<pre class="line-numbers language-none"><code class="language-none">if( !outfile )&#123;

cerr &lt;&lt; “Sadly unable to open and write something int the file :(”;

&#125;

 

outfile &lt;&lt; usr_name &lt;&lt; “is ” &lt;&lt; someString &lt;&lt; endl;

 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件的输入到程序中至可读，我们使用的是ifstream, 定义个ifstream 类的对象</p>
<pre class="line-numbers language-none"><code class="language-none">ifstream infile(“seq.txt”);

if(!infile)

&#123;

cerr &lt;&lt; “Oops, seemingly you are new here…”;

&#x2F;&#x2F; do others

&#125;

&#x2F;&#x2F; ...

while(infile &gt;&gt; name)&#123;

cout &lt;&lt; name &lt;&lt; endl;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> C++ 基础编程2</p>
<h2 id="面向过程的函数编程"><a href="#面向过程的函数编程" class="headerlink" title="面向过程的函数编程"></a>面向过程的函数编程</h2><p>​        为了更好的开发更大的程序，我们往往采用函数来完成我们的编程任务，从而提高代码的复用性。</p>
<h2 id="如何编写一个函数"><a href="#如何编写一个函数" class="headerlink" title="如何编写一个函数"></a>如何编写一个函数</h2><p>​        每一个函数都必须由下面四个部分构成：</p>
<p>​        1）返回类型 returnType : 简单的讲就是函数返回啥的问题</p>
<p>​        2）函数名： 函数的命名也有讲究，如何给函数命名是一门艺术，简单的讲：使用名称来告诉用户程序员这个函数的功能！</p>
<p>​        3）参数列表： 函数需要什么？这就是参数列表的用处了，参数列表列出了函数需要什么！</p>
<p>​        4）函数体： 函数是怎么实现的？结构如何，从这里看</p>
<pre class="line-numbers language-none"><code class="language-none">returnType funcName(typePackage parameters)&#123;
    
    &#x2F;&#x2F; do things here
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        比如说，我们对一个vector里的元素寻求最大值</p>
<pre class="line-numbers language-none"><code class="language-none">long findMax(vector&lt;int&gt; vec)&#123;
	long curMax &#x3D; vec[0];
    
	for(auto i &#x3D; vec.begin(); i !&#x3D; vec.end(); i++)&#123;
        
        if(*i &gt; curMax)&#123;
            curMax &#x3D; *i;
        &#125;
        
    &#125;
	
    return curMax;&#x2F;&#x2F; return the val back in here.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们就这样把函数抽象做子程序了！在这些子程序中，一个重要的issue就是异常处理，这里是一个简单的demo</p>
<p>​        我们来看这个函数</p>
<pre class="line-numbers language-none"><code class="language-none">long getElemFromVector(vector&lt;int&gt; vector, int pos)
&#123;
	if(pos &lt; 0 || pos &gt; vector.size())&#123;
        
        exit( -1 );
        
    &#125;
    
    return vector[pos];
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        很显然这是一个返回第pos位置上的元素的函数。那哪里是异常处理被？就是</p>
<pre class="line-numbers language-none"><code class="language-none">if(pos &lt; 0 || pos &gt; vector.size())&#123;
        
        exit( -1 );&#x2F;&#x2F; should include the &lt;cstdlib&gt; to use the functions
        
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="传参方法：passByReference"><a href="#传参方法：passByReference" class="headerlink" title="传参方法：passByReference"></a>传参方法：passByReference</h2><p>​        先别说！看一个这个玩意：</p>
<pre class="line-numbers language-none"><code class="language-none">void swapInt(int a, int b)&#123;

	int temp &#x3D; b
    b &#x3D; a;
    a &#x3D; temp;
   	

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        函数可以成功交换两数嘛，答案是否定的：</p>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
   int a &#x3D; 10;
   int b &#x3D;20;
   swap(a,b); 
   
   cout &lt;&lt; a &lt;&lt;&quot; &quot; &lt;&lt; b;
    
&#125;
&gt;&gt; a.out
&gt;&gt; 10 20 &#x2F;&#x2F; sadly make no swap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是因为调用函数的时候，只是把a,b的拷贝传入到函数的内部而不是他们本身，这样就意味着非常坏的事情：做无用功，玩弄形参而已，现在我们使用 reference 这个C++概念 。实际上，当我们使用引用的时候就意味着我们是传入它的地址：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; new type of coding
void swap(int&amp; a, int&amp; b)&#123;
    
    int temp &#x3D; a;
    a &#x3D; b;
    b &#x3D; temp;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们为什么传参传引用呢？原因是简单的：对于值传递，编译器必须复制传入对象，有时，这样的工作被证明是复杂耗时的。并不利于我们的程序性能的提升。其次，使用引用传递使的函数的作用可以有效地反馈至程序！当然，那为什么不用指针呢？区别在于，可以简单的理解为引用是特殊的常指针。而且在写法上更为简便。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>​        我们下面要说的是作用域的问题。我们为什么函数结束后一些临时变量会被销毁？就是因为我们的变量到达了他们的生命周期而被释放。一个变量的生命周期正是从他被创造开始到他被释放的实践间隔。这就是为什么传回函数临时变量的地址是非法的。因为我们拿到的是已经还给操作系统的内存——换而言之，我们在非法访问！于是，如果我们真的想返回函数的什么东西，应当使用值返回（return by val），这是因为函数此时返回了变量的副本。抑或是选择在内存中开辟！也就是说：在堆上开辟数据，他们会存留到程序结束为止，抑或是选择程序员自动释放。</p>
<h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><p>​        一个big issue! 我们需要在堆上放置数据，就很有必要使用操作符 new.</p>
<pre class="line-numbers language-none"><code class="language-none">Type* pobj &#x3D; new Type(Initial Val)
int* pInt &#x3D; new int(1024);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        使用delete来删除我们在堆上开辟的内存！</p>
<pre class="line-numbers language-none"><code class="language-none">delete pobj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果我们开辟的是一个数组，那就记得：</p>
<pre class="line-numbers language-none"><code class="language-none">delete[] pArray<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="提供默认的参数值"><a href="#提供默认的参数值" class="headerlink" title="提供默认的参数值"></a>提供默认的参数值</h2><p>​        我们有时候一些函数的参数总是使用一个默认的值，只在另一个时候才会使用别的值，那我们可不可以使用默认的值来减轻我们的开发负担呢？答案是可以的。</p>
<p>​        现在我们来考虑使用冒泡排序，在默认的情况下我们是要向控制台输出。但是有时候还是会向其他地方输出。怎么办？如何有效的设计这个函数？</p>
<pre class="line-numbers language-none"><code class="language-none">void bubbleSort(vector&lt;int&gt; &amp;vec, ofstream *ofil &#x3D; 0)&#123;
    for(int i &#x3D; 0; i &lt; vec.size(); i++)&#123;
        
        for(int j &#x3D; i+1 ; j &lt; vec.size(); j++)&#123;
            if(vec[i] &gt; vec[j])&#123;
                
                if(ofil !&#x3D; 0)&#123;
                    (*ofil)&lt;&lt; &quot;About to call the debug&quot;;
                &#125;
                swap(vec[i],vec[j],ofil);
            &#125;
            
        &#125;
        
    &#125;
    
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意到我们为了提供默认使之给ofil对象使用的是指针传递。这是因为我们如果是使用的引用传递，就意味着我们无法置0. 不太好设置初始值！</p>
<p>​        关于默认值，值得注意的是有两个基本的注意点：首先是默认值必须放在最右边，不可以插入中间指定默认值而后面不指定</p>
<pre class="line-numbers language-none"><code class="language-none">int a(int a &#x3D; 5, int b);&#x2F;&#x2F; invalid!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        注意还有，必须只能指定一次默认值！不可以指定两次！</p>
<pre class="line-numbers language-none"><code class="language-none">int a(int a, int b &#x3D; 2);
int a(int a, int b &#x3D; 3);&#x2F;&#x2F;编译器不知道调用哪一个！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="使用局部静态变量"><a href="#使用局部静态变量" class="headerlink" title="使用局部静态变量"></a>使用局部静态变量</h2><p>​        一些常用的东西，可以存在静态区，我们使用的是static关键字完成这项工作的！</p>
<pre class="line-numbers language-none"><code class="language-none">int someFunc(...)&#123;

	static int a &#x3D; 10;&#x2F;&#x2F;当这里被定义了过后。。。下一次再次调用直接取先前被创造出的地方

	a++;&#x2F;&#x2F;第一次调11 第二次调用12.。。以此类推
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="可以考虑inline"><a href="#可以考虑inline" class="headerlink" title="可以考虑inline"></a>可以考虑inline</h2><p>​        对于一些频繁调用的函数，我们加上inline声明。编译器调用的时候选择在调用点处用一份函数代码副本代替。也就是说：</p>
<pre class="line-numbers language-none"><code class="language-none">int f1()&#123;
    
    ...
    
    f2();
    
    ...
        
    f3();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，本来是编译器要跳转三次到其他函数，现在加上inline声明，f2,f3的代码直接移动到f1内部，编译器之跳转到f1工作完毕再跳出！我们由此获得了性能提升。</p>
<p>​        但是这只是一种请求，编译器会根据自己运行的情况进行判断！一般而言，我们倾向于选择体积小，常被调用和从事工作不复杂的函数加上inline。</p>
<h2 id="提供重载函数"><a href="#提供重载函数" class="headerlink" title="提供重载函数"></a>提供重载函数</h2><p>​        有时候，我们的函数只是因为工作相同，但是参数不同而不得不命名不同的函数。这不方便我们的工作！于是我们选择使用重载函数来完成我们的操作</p>
<pre class="line-numbers language-none"><code class="language-none">void display(string a);
void display(int a);
&#x2F;&#x2F;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        注意到参数类型要不同！</p>
<h2 id="定义并使用模板"><a href="#定义并使用模板" class="headerlink" title="定义并使用模板"></a>定义并使用模板</h2><p>​        但是重载函数面对太多不同的类型，也不能写那么多重载函数，怎么办呢？使用模板就好了！</p>
<p>​        模板的格式定义是： template&lt; typename name&gt;</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename nameType&gt;
void display(nameType msg);
	当我们传一个string的时候，编译器把这里解释成string，如果传入一个int 就是int。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="使用头文件"><a href="#使用头文件" class="headerlink" title="使用头文件"></a>使用头文件</h2><p>​        我们可以分离 声明——实现这个抽象工作，只需要我们把声明放到头文件就可以了！</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#include&quot;MyFile.h&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        简单来讲，&lt;&gt; 和“”的区别在于。 尖括号包下的文件被认为是标准的或者是项目专属的文件，编译器回去默认磁盘项目里去找，而“”被认为是用户头文件，编译器从当下的文件目录开始找！</p>
<p>​        C++基础编程３</p>
<h2 id="泛型编程风格"><a href="#泛型编程风格" class="headerlink" title="泛型编程风格"></a>泛型编程风格</h2><p>​        STL,就是泛型编程的良好体现,它由两个基本组件组成.1是容器, 2是泛型算法.</p>
<h3 id="从指针运算讲起"><a href="#从指针运算讲起" class="headerlink" title="从指针运算讲起"></a>从指针运算讲起</h3><p>​        我们现在考虑从一个容器里找到一个元素,  比如说在一个vector容器中找到我们想要的整数: int. 算法是轻而易举就可以写出来的:</p>
<pre class="line-numbers language-none"><code class="language-none">int* find(const vector&lt;int&gt; &amp;r_vec,int&amp; val)&#123;

	for(int i &#x3D; 0 ; i &lt; r_vec.size();i++)&#123;
        
        if(vec[i] &#x3D;&#x3D; value)&#123;
            return &amp;vec[i];
        &#125;
        
    &#125;

	return nullptr;&#x2F;&#x2F; same as NULL in C 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        如果,我们的容器时任何什么东西又该怎么办呢?</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename elem&gt;&#x3D;
elem* find(const vector&lt;elem&gt;&amp; r_vec, elem&amp; val)
&#123;
	for(int i &#x3D; 0 ; i &lt; r_vec.size();i++)&#123;
        
        if(vec[i] &#x3D;&#x3D; value)&#123;&#x2F;&#x2F; 当然要求elem存在 equal 方法或者是重载了 &#x3D;&#x3D;
            return &amp;vec[i];
        &#125;
        
    &#125;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是,貌似若我们不是在vector里找,而是list里找,那又该怎么办呢. 我们没办法对list找下标的(list 是离散容器)</p>
<h2 id="采用纯指针访问"><a href="#采用纯指针访问" class="headerlink" title="采用纯指针访问"></a>采用纯指针访问</h2><p>​        anyway, 我们想一下啊: 本质上[]就是一个语法糖,对于一个连续容器的, 本质上讲:</p>
<pre class="line-numbers language-none"><code class="language-none">array[i]  &lt;----------&gt; (array+i)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这样就启发我们这样书写当传入类型是array类型的时候(经典数组)</p>
<pre class="line-numbers language-none"><code class="language-none">elem* find(elem* begin,int elemSize,elem&amp; befoundElem)&#123;

	if(begin &amp;&amp; elemSize &lt; 0)&#123;
        return nullptr;
    &#125;
    
    for(int i &#x3D; 0; i &lt; size; i++,begin++)&#123;
        if(*begin &#x3D;&#x3D; beFoundElem)&#123;
            
            return begin;
            
        &#125;
    &#125;

	return nullptr;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        嗯,但是传入要访问多少个,不如试试全部传入指针?</p>
<pre class="line-numbers language-none"><code class="language-none">elem* find(elem* begin,elem* end,elem&amp; befoundElem)&#123;

	if(begin &amp;&amp; elemSize &lt; 0)&#123;
        return nullptr;
    &#125;
    
    for(; begin !- end; i++,begin++)&#123;
        if(*begin &#x3D;&#x3D; beFoundElem)&#123;
            
            return begin;
            
        &#125;
    &#125;

	return nullptr;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在我们发现,我们无意的抽象出来一个对象, 什么意思?我们抽象出来一个指针类型,使之可以有 ++ — * -&gt;等若干行为,我们的容器只需要提供begin 和 end就可以使用最广泛的泛型算法!这就是 iterator迭代器的来源!</p>
<h2 id="泛型指针-迭代器"><a href="#泛型指针-迭代器" class="headerlink" title="泛型指针:迭代器"></a>泛型指针:迭代器</h2><pre class="line-numbers language-none"><code class="language-none">vector&lt;string&gt; :: iterator IT &#x3D; svec.begin()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        就是一个指针指向了begin!如果我们希望是一个常指针帮助我们做事情,那使用const_iterator会好很多!</p>
<p>​        为了可以让iterator正常工作,有必要指出与实现:</p>
<pre class="line-numbers language-none"><code class="language-none">1 -&gt; equlity( &#x3D;&#x3D; ) and inequlity ( !&#x3D; )
2 -&gt; assignment(&#x3D; 赋值)
3. empty(空)
4. size(衡量元素大小)
5.clear()删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="初始化一个容器的基本五大接口"><a href="#初始化一个容器的基本五大接口" class="headerlink" title="初始化一个容器的基本五大接口"></a>初始化一个容器的基本五大接口</h2><ol>
<li>初始化默认的空容器</li>
<li>产生特定的容器,并且所有的成员都要有默认的初始值</li>
<li>产生特定大小的容器,并为之赋初始值</li>
<li>通过iterator给与值</li>
<li>复制构造</li>
</ol>
<h1 id="C-基础编程4"><a href="#C-基础编程4" class="headerlink" title="C++ 基础编程4"></a>C++ 基础编程4</h1><h2 id="基于对象的编程风格"><a href="#基于对象的编程风格" class="headerlink" title="基于对象的编程风格"></a>基于对象的编程风格</h2><p>​        我们在先前已经体验过class了，就像vector一样。</p>
<p>​        首先，我们知道：类必须要声明！</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;string&gt;
string pooh[4] &#x3D;&#123;

	&quot;winnie&quot;,
    &quot;robin&quot;,
    &quot;eeyole&quot;,
    &quot;piglet&quot;

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        class 名称将会被视作类型（type）名称，就像内置类型int, double一样。 class object的初始化做法有很多种！</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;vector&gt;

string path(&quot;dummy&quot;);
vector&lt;string&gt; svc1(4);
vector&lt;string&gt; svc2(4,&quot;dummy&quot;);
vector&lt;string&gt; svc3(pooh,pooh+4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        每个class都会提供一组操作数，让我们可以作用之在object.比如说，我们提供函数func(), </p>
<pre class="line-numbers language-none"><code class="language-none">class sth;
sth Sth;
Sth.func(obj object)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        一般的, class有三个部分组成，我更愿意说：class里的成员是分为三个类别的：private的，protected的，和 public 的。Public区域下的成员和对象都是对外开放。Private则只能在类内访问！举个例子：</p>
<pre class="line-numbers language-none"><code class="language-none">class aClass
&#123;
public:
	int pub_Val; &#x2F;&#x2F; can be used in public space
    int* returnAIntVal();&#123;
        return new int(10); &#x2F;&#x2F; can be used in public space
    &#125;
	int returnPri_Val()&#123;
        return pri_Val; &#x2F;&#x2F; valid
    &#125;;
private:
    int pri_Val; 
    int* returnSomethong();&#123;
        return new int(11);
    &#125;
&#125;

int main()&#123;
    
    aClass sth;
    int a &#x3D; sth.pub_Val; &#x2F;&#x2F; valid 
    int* pa &#x3D; sth.returnPri_Val();&#x2F;&#x2F; valid 
    int priAVal &#x3D; sth.rereturnPri_Val();
        &#x2F;&#x2F; Also valid! This is the Interface of private. 
        
    &#x2F;&#x2F; followings are invalid
    
    int wrongA &#x3D; sth.pri_Val; &#x2F;&#x2F; Invalid!!! cannot visit private
    int* wrongB &#x3D; sth.returnSomethong();&#x2F;&#x2F; Invalid!!! cannot visit private 
&#125;
		<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实现一个Class"><a href="#实现一个Class" class="headerlink" title="实现一个Class"></a>实现一个Class</h3><p>​        我们的main topic 在使用C++手写一个stack！关键在于怎么写</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506140519165.png?lastModify=1685936981" alt="image-20230506140557771"></p>
<p>​        这是一个声明！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506140557771.png?lastModify=1685936981" alt="image-20230506140519165"></p>
<p>​        这是一个Stack的标准声明与定义。</p>
<p>​        下面，编写接口：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
class Stack 
&#123;

public:
	bool push(const string&amp; pString);
	bool pop(string&amp; pString);
	bool peek(string&amp; pString);

	bool isEmpty();
	bool isFull();

	int size() &#123; return _stack.size(); &#125;;
private:

	vector&lt;string&gt; _stack;

&#125;;

void fill_stack(Stack&amp; stack, istream&amp; is &#x3D; cin) &#123;
	string str;

	while (is &gt;&gt; str &amp;&amp; !stack.isFull()) &#123;

		stack.push(str);

	&#125;

	cout &lt;&lt; &quot;Read in&quot; &lt;&lt; stack.size() &lt;&lt; &quot;elements\n&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是接口没有实现！那怎么办！</p>
<p>​        我们是这样书写类内的成员函数的：只需要声明这是哪个类的函数。。。</p>
<pre class="line-numbers language-none"><code class="language-none">bool Stack::pop(string&amp; elem) &#123;

	if (empty()) &#123;

		return false;

	&#125;

	elem &#x3D; _stack.back();
	_stack.pop_back();
	return true;
&#125;

inline bool Stack::empty() &#123;

	return this-&gt;_stack.empty();

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        类和其成员函数的定义和实现是，应当放在头文件里去。</p>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>​        我们先不说的这样抽象！转向直接阐述：构造函数是一种初始化函数，同</p>
<pre class="line-numbers language-none"><code class="language-none">int a &#x3D; new int;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        是一回事。但是由于我们的类是若干基础变量组合产生。有必要使用函数来包装！比如说：</p>
<pre class="line-numbers language-none"><code class="language-none">class Tri&#123;

private:
	m_Val1;
	m_Val2;
    
&#125;
Tri::Tri()&#123;
    
    m_Val1 &#x3D; 10;
    m_Val2 &#x3D; 20;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        上面的函数就是一个构造函数，我们初始化了类内的变量！</p>
<p>​        构造函数是可以重载的！我们可以重载构造函数，使之给用户提供不同的初始化方式。</p>
<pre class="line-numbers language-none"><code class="language-none">Tri::Tri(int mVal1, int mVal2)&#123;
    
    m_Val1 &#x3D; mVal1;
    m_Val2 &#x3D; mVal2;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>​        我们对于一些变量可以使之直接在表内初始化</p>
<pre class="line-numbers language-none"><code class="language-none">Tri::Tri(int mVal1, int mVal2): m_Val1(mVal1),m_Val2(mVal2)&#123;
    &#x2F;&#x2F; ... other things
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们会在程序的结尾调用析构器。事实上，在上面的函数中没有必须调用析构器！因为对象都是简单对象，直接释放即可。这就说明一件事情：对于简单的类和简单的尚未在堆上开辟内存的类，可以直接调用析构器从而实现内存释放</p>
<h2 id="逐一初始化的"><a href="#逐一初始化的" class="headerlink" title="逐一初始化的"></a>逐一初始化的</h2><p>​        下面想要说的是浅拷贝的知识点：这是在我们使用等号赋值的一种较为常见的错误</p>
<p>​        对于一些简单的类，那些成员不在堆上的类，我们当然可以选择浅拷贝来解决问题：</p>
<pre class="line-numbers language-none"><code class="language-none">class Easy&#123;
    
    public:
 		anSample(int val1, int val2);   
    	int m_Val1;
    	int m_Val2;
    
    &#x2F;&#x2F;...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样的行为被称为浅拷贝：</p>
<pre class="line-numbers language-none"><code class="language-none">Easy anSample(1, 2);&#x2F;&#x2F; call the anSample(int,int)
Easy aCopy &#x3D; anSample;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        本质上，我们实际上调用了这样一个被编译器隐藏起来的函数：</p>
<pre class="line-numbers language-none"><code class="language-none">Easy&amp; operator&#x3D;(Easy&amp; beCopied)&#123;
    
    this-&gt;m_Val1 &#x3D; beCopied-&gt;m_Val1;
    this-&gt;m_Val2 &#x3D; beCopied-&gt;m_Val2;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        那也就意味着，假使我们这样操作：</p>
<pre class="line-numbers language-none"><code class="language-none">class Diff&#123;
    
public:
    
	diff(int val)&#123;
        
        this-&gt;m_Val1 &#x3D; val;
        
        this-&gt;m_inHeapArray &#x3D; new int[10];
    &#125;    
    
    
    int m_Val1;
    
    int* m_inHeapArray;
    
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        而这样的话，就意味着我们在赋值的时候</p>
<pre class="line-numbers language-none"><code class="language-none">Diff dif(10);
Diff copy &#x3D; dif;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        调用的是：</p>
<pre class="line-numbers language-none"><code class="language-none">Easy&amp; operator&#x3D;(Easy&amp; beCopied)&#123;
    
    this-&gt;m_Val1 &#x3D; beCopied-&gt;m_Val1;
    this-&gt;m_inHeapArray &#x3D; beCopied-&gt;m_inHeapArray;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这分明是开了两个指针指向同一块内存，这就意味着，只需要我们的被拷贝对象或者是拷贝对象被调用了正确的（就是说我们的程序员正确的释放了内存）析构函数，那么，当程序结束或者是准备析构另一个对象的时候，我们就会拿起来它，释放（危险行为），但是先前这块地方已经被释放过了！坏了，这下寄了，程序就会崩溃！</p>
<p>​        解决办法是：自己老老实实重写，比如说：</p>
<pre class="line-numbers language-none"><code class="language-none">Diff&amp; operator&#x3D;(Diff&amp; beCopied)&#123;
    
    this-&gt;m_Val1 &#x3D; beCopied-&gt;m_Val1;
    
    this-&gt;m_inHeapArray &#x3D; new int[10];
    
    memcpy(this-&gt;m_inHeapArray,beCopied-&gt;m_inHeapArray,10*sizeof(int));
    
    return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="TIPS：小心坑"><a href="#TIPS：小心坑" class="headerlink" title="TIPS：小心坑"></a>TIPS：小心坑</h2><p>​        由于引用的出现，我们赋值方式很多，但是这样的等号赋值，编译器调用哪一个呢？</p>
<pre class="line-numbers language-none"><code class="language-none">Diff copy &#x3D; sample; &#x2F;&#x2F; 调用了默认的还是自己重载的？
&#x2F;&#x2F;

Diff copy2;
copy2 &#x3D; sample; &#x2F;&#x2F; sample is already inited<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        答案是，上面的调用的是默认的拷贝构造函数（构！造！），下面调用的是自己手动重载的函数。这是等号赋值函数。这是我们需要注意的！！！</p>
<p>​        下面供一个小小的DEMO给大伙看看：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cstdlib&gt;

class Diff &#123;

public:
	Diff();
	Diff(int val);
	~Diff();
	Diff&amp; operator&#x3D;(Diff&amp; dif);
	void showDetail()const;
private:
	int m_Val;
	int* m_inHeap;
&#125;;

Diff::Diff() &#123;

	this-&gt;m_Val &#x3D; 0;
	this-&gt;m_inHeap &#x3D; NULL;
&#125;


Diff::Diff(int val) &#123;

	this-&gt;m_Val &#x3D; val;
	this-&gt;m_inHeap &#x3D; new int[10];

&#125;

Diff::~Diff() &#123;
	delete[] this-&gt;m_inHeap;

	std::cout &lt;&lt; &quot;Finished calling the destructor!&quot; &lt;&lt; &#39;\n&#39;;
&#125;

Diff&amp; Diff::operator&#x3D;(Diff&amp; dif) &#123;

	this-&gt;m_Val &#x3D; dif.m_Val;

	this-&gt;m_inHeap &#x3D; new int[10];

	memcpy(this-&gt;m_inHeap, dif.m_inHeap, 10 * sizeof(int));

	return *this;
&#125;

void Diff::showDetail()const &#123;

	std::cout &lt;&lt; &quot;the Val &gt;&quot; &lt;&lt; this-&gt;m_Val &lt;&lt; &quot;   &quot; \
		&lt;&lt; &quot; the addr name :&gt;&quot; &lt;&lt; this-&gt;m_inHeap &lt;&lt; &quot;   &quot; &lt;&lt; std::endl;

&#125;

int main() &#123;

	Diff sample(10);

	Diff copy;
	copy &#x3D; sample;
	copy.showDetail();
	sample.showDetail();
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="mutable-和-const"><a href="#mutable-和-const" class="headerlink" title="mutable 和 const"></a>mutable 和 const</h2><p>​        查阅你的英文字典，哈哈一笑，一个是可变的，一个不是可变。</p>
<p>​        我们来看一个Demo函数：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;

class wrapArray &#123;

public:
	wrapArray();
	wrapArray(size_t size);
	inline size_t getSize() const &#123; return this-&gt;arrSize; &#125;;
	inline int* getAddr(int* emptySpace &#x3D; nullptr)const &#123; int* space &#x3D; new int[arrSize]; memcpy(space, this-&gt;arr, sizeof(int) * arrSize); return space; &#125;;
	void simpleInitArr();
	long addSum()const;
private:
	int* arr;
	size_t arrSize;
&#125;;

wrapArray::wrapArray() &#123;

	this-&gt;arrSize &#x3D; 0;
	this-&gt;arr &#x3D; nullptr;
&#125;

wrapArray::wrapArray(size_t size) &#123;

	this-&gt;arrSize &#x3D; size;
	this-&gt;arr &#x3D; new int[size];

&#125;

void wrapArray::simpleInitArr() &#123;


	for (int i &#x3D; 0; i &lt; this-&gt;arrSize; i++) &#123;
		this-&gt;arr[i] &#x3D; i;
	&#125;

	return;
&#125;

long wrapArray::addSum()const &#123;

	long sum &#x3D; 0;
	int* arr &#x3D; getAddr();
	for (auto i &#x3D; 0; i &lt; getSize(); i++) &#123;
		sum +&#x3D; arr[i];
	&#125;
	return sum;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <strong>类</strong>的成员函数后面加 const，表明这个函数不会对这个类对象的 数据成员（准确地说是非静态数据成员）作任何改变 。 在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加 const，而对于改变数据成员的成员函数不能加 const。</p>
<p>​        可以看到上面的函数就是这样做的！</p>
<p>​        但是注意到！一些函数虽然是 const 的，向编译器承诺不会改变成员的值的。但是他们有可能返回一个 non-const接口，对于那些拿起这些接口的对象，他们是<strong>可以</strong>改变对象的值的！这是十分不好的！最好的办法是设计一个non-const类型从而分别处理比较好</p>
<p>​        那mutable呢？他们用在这样希望其他不变而就这个改变的变量上，比如说：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;

class Person &#123;
public:
    Person();
    ~Person();

    int getAge() const; &#x2F;*调用方法*&#x2F;
    int getCallingTimes() const; &#x2F;*获取上面的getAge()方法被调用了多少次*&#x2F;
private:
    int age;
    char* name;
    float score;
    mutable int m_nums;            &#x2F;*用于统计次数*&#x2F;
&#125;;

Person::Person()
&#123;
    m_nums &#x3D; 0;
&#125;

Person::~Person() &#123;&#125;

int Person::getAge() const
&#123;
    std::cout &lt;&lt; &quot;Calling the method&quot; &lt;&lt; std::endl;
    m_nums++; &#x2F;&#x2F; 你看这个就突破了const 的修饰
    &#x2F;&#x2F;age &#x3D; 4; 仍然无法修改该成员变量
    return age;
&#125;

int Person::getCallingTimes()const
&#123;
    return m_nums;
&#125;

int main()
&#123;
    Person* person &#x3D; new Person();
    for (int i &#x3D; 0; i &lt; 10; i++) &#123;
        person-&gt;getAge();
    &#125;
    std::cout &lt;&lt; &quot;getAge()方法被调用了&quot; &lt;&lt; person-&gt;getCallingTimes() &lt;&lt; &quot;次&quot; &lt;&lt; std::endl;
    delete person;

    getchar();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>​        什么是this指针？其实，它就相当于一个self!也就是说指向他自己的一个指针！</p>
<p>​        by the way, 针对拷贝构造函数的时候注意一定要查看这两个对象是不是一致的。这是一个好习惯。</p>
<h2 id="静态类成员与函数"><a href="#静态类成员与函数" class="headerlink" title="静态类成员与函数"></a>静态类成员与函数</h2><p>​        什么是静态类的呢?我们回想一下静态类变量：</p>
<pre class="line-numbers language-none"><code class="language-none">static int times &#x3D; 2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        一回事情！而且，static变量可以定义在类的外面：</p>
<pre class="line-numbers language-none"><code class="language-none">class isSomeThing&#123;
    &#x2F;&#x2F;...
    inline static getAStaticVal()&#123;return aStaticVal;&#125;
&#125;

int isSomeThing:: aStaticVal &#x3D; 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        值得注意的是：静态成员函数是只可以访问静态变量成员的，为什么呢？</p>
<p>​        在类中，static 除了可以声明静态成员变量，还可以声明静态成员函数。普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。</p>
<p>​        编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。</p>
<p>​        普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。</p>
<p>​        普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。</p>
<p>​        静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</p>
<h1 id="C-基础编程5"><a href="#C-基础编程5" class="headerlink" title="C++基础编程5"></a>C++基础编程5</h1><h2 id="面对对象的编程风格"><a href="#面对对象的编程风格" class="headerlink" title="面对对象的编程风格"></a>面对对象的编程风格</h2><p>​        我们面对对象的程序语言风格的主要两大特质是：继承和多态。前者让一群相关的类组织起来，使之可以共享共同的数据和操作行为，后者让我们在这些类上进行编程时，像是在操纵一个单一的个体，赋予我们更多的弹性加入或者移除任何特定的类。</p>
<p>​        继承产生了父类和子类的说法，父类定义了子类的共同之处和私有实现，而每一个子类都可以增加或者覆盖继承而来的东西，从而实现自身独特的行为。举个例子： AudioBook 从更大的父类 BOOK 继承了作者和标题之外，还有脸属于自己的播讲者和其他东西。</p>
<p>​        父类在C++中还有基类之称， 而子类则是作为派生类出现的。我们可以绘制一幅图来展示类之间的层级关系，如图所示：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/1.jpg?lastModify=1685936981" alt="1"></p>
<p>​        那啥是多态呢：来看一个程序：</p>
<pre class="line-numbers language-none"><code class="language-none">void general_check_in(LibMat&amp; mat)
&#123;
    &#x2F;&#x2F; 但是我们不会传入一个基类 libmat，而是传入一个具体的派生类，如Magazines,AudioBook, Book这类的
    mat.check_in();
    
    if(mat.is_late())&#123;
        mat.assess_fine();
    &#125;
    if(mat.waitinglist())&#123;
        mat.notify_available();
    &#125;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        demo:&gt;</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
class LibMat &#123;

public:
	
	virtual void isCheckIn() &#123; cout &lt;&lt; &quot;is a LibMat\n&quot;; &#125;;

&#125;;

class Book : public LibMat &#123;

public:

	void isCheckIn() &#123; cout &lt;&lt; &quot;is a Book\n&quot;; &#125;


&#125;;

class Magazine :public LibMat &#123;
public:
	void isCheckIn() &#123; cout &lt;&lt; &quot;is a magazine\n&quot;; &#125;

&#125;;

void isChecked(LibMat&amp; Mat) &#123;


	Mat.isCheckIn();


&#125;



int main() &#123;

	&#x2F;&#x2F; 继承

	LibMat libmat;

	libmat.isCheckIn();

	Book book;

	book.isCheckIn();

	Magazine mag;

	mag.isCheckIn();

	&#x2F;&#x2F; 多态
	
	isChecked(book);

	isChecked(mag);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        上面的程序很有意思，我们的Interface分明要求的是LibMat，但是我们传入的是它的若干子类，程序却能正确的运行！只是因为编译器在运行时候确定具体应该调啥函数，而不是在编写程序时才指定！</p>
<h2 id="面向对象的编程运作流程"><a href="#面向对象的编程运作流程" class="headerlink" title="面向对象的编程运作流程"></a>面向对象的编程运作流程</h2><p>​        上面的例子太过简单，我们复杂一点：为了持续的跟踪个对象的构造，调用和析构，我们给个行为塞上向控制台打印Debug信息的语句</p>
<p>​        virtual这个关键字表明当下的被修饰函数时虚函数，可以被子类改写：</p>
<pre class="line-numbers language-none"><code class="language-none">class LibMat:
&#123;
public:
    
    LibMat()&#123;cout&lt;&lt;&quot; calling for the libmat constructor&quot;;&#125;
	
    virtual ~LibMat()&#123;cout&lt;&lt;&quot; calling for the LibMat destructor&quot;;&#125;
    
    virtual void printInfo const&#123; cout &lt;&lt;&quot;LibMat!&quot;;&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是一个类，我们跟踪一下这个对象的流程：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
class LibMat
&#123;
public:

    LibMat() &#123; cout &lt;&lt; &quot; calling for the libmat constructor\n&quot;; &#125;

    virtual ~LibMat() &#123; cout &lt;&lt; &quot; calling for the LibMat destructor\n&quot;; &#125;

    virtual void printInfo() const&#123; cout &lt;&lt; &quot;[printInfo] LibMat!\n&quot;; &#125;
&#125;;

void callPrint(LibMat&amp; aLib) &#123;

    cout &lt;&lt; &quot;Call relevant functions\n&quot;;

    aLib.printInfo();
&#125;

int main()
&#123;

    LibMat lib;

    callPrint(lib);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230510091108469.png?lastModify=1685936981" alt="image-20230510091108469"></p>
<p>​        下面呢，我们派生一个类。叫Book（先前似乎用过，但是这里改变层级关系）。</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

&#x2F;&#x2F; 这是基类
class LibMat
&#123;
public:

    LibMat() &#123; cout &lt;&lt; &quot; calling for the libmat constructor\n&quot;; &#125;

    virtual ~LibMat() &#123; cout &lt;&lt; &quot; calling for the LibMat destructor\n&quot;; &#125;

    virtual void printInfo() const&#123; cout &lt;&lt; &quot;[printInfo] LibMat!\n&quot;; &#125;
&#125;;

&#x2F;&#x2F; 这是派生类
class Book : public LibMat &#123;
public:
    Book() &#123; cout &lt;&lt; &quot; calling for the book constructor&quot;; &#125;
    Book(string bookName, string authorWho) &#123;
        cout &lt;&lt; &quot; calling for the book constructor&quot;; 
        this-&gt;authorWho &#x3D; authorWho;
        this-&gt;bookName &#x3D; bookName;
    &#125;
    virtual ~Book() &#123; cout &lt;&lt; &quot; calling for book destructor&quot;; &#125;;
    virtual void printInfo()const &#123; cout &lt;&lt; &quot;[printInfo] Book: Author  &quot;&lt;&lt;authorWho\
        &lt;&lt;&quot;  and the title is:&quot;&lt;&lt;bookName&lt;&lt;endl; &#125;
private:
    string bookName;
    string authorWho;
&#125;;

void callPrint(LibMat&amp; aLib) &#123;

    cout &lt;&lt; &quot;Call relevant functions\n&quot;;

    aLib.printInfo();
&#125;

int main()
&#123;

    Book book(&quot;A note for Essential C++&quot;, &quot;CharlieChen&quot;);

    callPrint(book);
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230511093009133.png?lastModify=1685936981" alt="image-20230511093009133"></p>
<p>​        这就是我们的调用结果！</p>
<p>​        首先我们高兴的发现：编译器自动识别了我们传入的是LibMat的一个子类 Book。从而在调用时调用了Book的Print Info。也就是说，我们在一个需要父类接口的函数处传入一个子类时，往往会调用子类重写父类的方法而隐藏其父类的方法！</p>
<p>​        其二，我们留意到，程序中我们并没有显示的构造父类，或者说是基类，但是运行程序的时候依旧调用了父类的构造函数！</p>
<p>​        我们不止步于此，继续派生Book类！我们的书本种类繁多，不如整一个AudioBook,他派生于Book，但是还多出来narrator！也就是播讲者。那就是说：我们的私有成员在其自己的直接父类中又多了narrator!</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
&#x2F;&#x2F; 基类
class LibMat
&#123;
public:

    LibMat() &#123; cout &lt;&lt; &quot; calling for the libmat constructor\n&quot;; &#125;

    virtual ~LibMat() &#123; cout &lt;&lt; &quot; calling for the LibMat destructor\n&quot;; &#125;

    virtual void printInfo() const&#123; cout &lt;&lt; &quot;[printInfo] LibMat!\n&quot;; &#125;
&#125;;

&#x2F;&#x2F; 直接父类
class Book : public LibMat &#123;
public:
    Book() &#123; cout &lt;&lt; &quot; calling for the book constructor&quot;; &#125;
    Book(string bookName, string authorWho) &#123;
        cout &lt;&lt; &quot; calling for the book constructor\n&quot;; 
        this-&gt;authorWho &#x3D; authorWho;
        this-&gt;bookName &#x3D; bookName;
    &#125;
    virtual ~Book() &#123; cout &lt;&lt; &quot; calling for book destructor\n&quot;; &#125;;
    virtual void printInfo()const &#123; cout &lt;&lt; &quot;[printInfo] Book: Author  &quot;&lt;&lt;authorWho\
        &lt;&lt;&quot;  and the title is:&quot;&lt;&lt;bookName&lt;&lt;endl; &#125;
protected:
    string bookName;
    string authorWho;
&#125;;

&#x2F;&#x2F;子类
class AudioBook : public Book &#123;
public:
    AudioBook(const string&amp; title, const string&amp; author, \
        const string&amp; narrator) :Book(title, author), narrator(narrator) &#123;

        cout &lt;&lt; &quot;calling for the audiobook construtor:\n&quot;;

    &#125;

    virtual void printInfo()const &#123;
        cout &lt;&lt; &quot;[printInfo] AudioBook: Author &quot; &lt;&lt; authorWho &lt;&lt; \
            &quot; bookName  &quot; &lt;&lt; bookName &lt;&lt; &quot;  narrator :&quot; &lt;&lt; narrator &lt;&lt; endl;
    &#125;

protected:
    string narrator;

&#125;;


void callPrint(LibMat&amp; aLib) &#123;

    cout &lt;&lt; &quot;Call relevant functions\n&quot;;

    aLib.printInfo();
&#125;

int main()
&#123;

    AudioBook audioBook(&quot;A note for Essential C++&quot;, &quot;CharlieChen&quot;,&quot;Charliechen&quot;);

    callPrint(audioBook);
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​            对于那些希望可以直接访问继承来的父类私有成员，有必要声明之为protected 的。而那些希望自己独有而不被其他甚至是自己子类访问，则声明之private！正如上面所示的那样！</p>
<h2 id="定义一个抽象的基类"><a href="#定义一个抽象的基类" class="headerlink" title="定义一个抽象的基类"></a>定义一个抽象的基类</h2><p>​        对于我们想要设计的若干类，不如找出他们的共同点，设计出来一个只有共同的成员和行为的——基类！现在，我们拿一个——叫做num  sequence 的基类来抽象出所有的数列的共同点！</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
class num_sequence &#123;

public:
	&#x2F;*
		getElembyPos( pos ) offering a returned value by giving pos
		generate_elem( pos ) create a subSequence that locates [0, pos]
		arrayType() return type of the array
		print( os ) written all elements into ostream
		check_integrity( pos ) whether the pos is valid
		max_pos() return the max position
	*&#x2F;
	int 		getElembyPos(int pos);
	void 		generate_elem(int pos);
	string 		arrayType();
	void 		print(ostream&amp; os);
	bool 		check_integrity(int pos);
	static int 	 max_pos();
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        随后，指定哪些行为，是子类可能需要重写的！我们把它抽象成virtual的虚函数！表明他们可以被子类重写！</p>
<p>​        下一步，指定哪些成员我们希望子类继承并直接可以访问！</p>
<p>​        我们把两步整合一下，再次修理：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
class num_sequence &#123;

public:
	&#x2F;*
		getElembyPos( pos ) offering a returned value by giving pos
		generate_elem( pos ) create a subSequence that locates [0, pos]
		arrayType() return type of the array
		print( os ) written all elements into ostream
		check_integrity( pos ) whether the pos is valid
		max_pos() return the max position
	*&#x2F;
	virtual ~num_sequence() &#123;&#125;; &#x2F;&#x2F; diffrent type of sequence has different ways

	virtual int getElembyPos(int pos) &#x3D; 0; &#x2F;&#x2F; absolute virtual, contemporily need to overwrite!
	
	virtual string arrayType() const &#x3D; 0;

	virtual ostream&amp; print(ostream&amp; os) &#x3D; 0;

	static int max_pos() &#123; return _max_elems; &#125;;
    
protected:
	
	virtual void generate_elem(int pos) const &#x3D; 0;
	
	bool check_integrity(int pos) const;

	const static int _max_elems &#x3D; 1024;
	
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意到，如果想要程序员强制重写虚函数，可以指定之为纯虚函数：</p>
<pre class="line-numbers language-none"><code class="language-none">virtual type funcName(funcList) &#x3D; 0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        由于基类的接口不完整，编译器不允许为之产生对象！只能作为派生类的子对象使用！于是，一个拥有纯虚函数的基类<strong>没有必要，也不应该拥有构造函数</strong>，同时，不同的子类析构方式可能不一样，由此指定析构函数为virtual 的！</p>
<p>​        带上实现看看：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
class num_sequence &#123;

public:
	&#x2F;*
		getElembyPos( pos ) offering a returned value by giving pos
		generate_elem( pos ) create a subSequence that locates [0, pos]
		arrayType() return type of the array
		print( os ) written all elements into ostream
		check_integrity( pos ) whether the pos is valid
		max_pos() return the max position
	*&#x2F;
	virtual ~num_sequence() &#123;&#125;; &#x2F;&#x2F; diffrent type of sequence has different ways

	virtual int getElembyPos(int pos) &#x3D; 0; &#x2F;&#x2F; absolute virtual, contemporily need to overwrite!
	
	virtual string arrayType()const &#x3D; 0;

	virtual ostream&amp; print(ostream&amp; os &#x3D; cout)&#x3D; 0;

	static int max_pos() &#123; return _max_elems; &#125;;
protected:
	
	virtual void generate_elem(int pos) &#x3D; 0;
	
	bool check_integrity(int pos, int size);

	const static int _max_elems &#x3D; 1024;
	
&#125;;

 

bool num_sequence::check_integrity(int pos,int size) &#123;

	if (pos &lt; 0 || pos &gt; _max_elems) &#123;

		cerr &lt;&lt; &quot; invalid position! request rejected!&quot;;
		return false;
	&#125;
	return true;
&#125;

ostream&amp; operator&lt;&lt; (ostream &amp; os, num_sequence&amp; ns) &#123;
	return ns.print(os);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="定义一个派生类"><a href="#定义一个派生类" class="headerlink" title="定义一个派生类"></a>定义一个派生类</h2><p>​        下面开始使用num_sequence干活！</p>
<pre class="line-numbers language-none"><code class="language-none">class Fib :public num_sequence &#123;

public:
	Fib(int len &#x3D; 1, int begin_pos &#x3D; 1) :length(len), begin_pos(begin_pos) &#123;&#125;;
	virtual int getElembyPos(int pos);
	virtual ostream&amp; print(ostream&amp; os &#x3D; cout;
	int getlength() const&#123; return length; &#125;;
	int getBeginPos() const &#123; return begin_pos; &#125;;

protected:
	virtual void generate_elem(int pos) ;
	int length;
	int begin_pos;
	vector&lt;int&gt; _elems;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下面继续实现！</p>
<p>​        我们先实现一个返回指定位置的值的函数，大致看起来这样！值得注意的是我们在写实现的时候不用带上virtual！</p>
<pre class="line-numbers language-none"><code class="language-none">int Fib::getElembyPos(int pos) &#123;

	if (!check_integrity(pos)) &#123;
		return 0;
	&#125;

	if (pos &gt; _elems.size()) &#123;
		Fib::generate_elem(pos);
	&#125;

	return _elems[pos - 1];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意到：1. 我们使用public 继承下来的<code>check_integrity(pos)</code>可以直接使用！因为这正是protected的成员！其二，建议载函数前指定这是哪个类的！</p>
<pre class="line-numbers language-none"><code class="language-none">void Fib::generate_elem(int pos) &#123;

	if (_elems.empty()) &#123;

		_elems.push_back(1);
		_elems.push_back(1);&#x2F;&#x2F; the first two should be 1,1
	&#125;

	if (_elems.size() &lt;&#x3D; pos) &#123;

		int i &#x3D; _elems.size();
		int n2 &#x3D; _elems[i - 2];
		int n1 &#x3D; _elems[i - 1];

		for (; i &lt; pos; i++) &#123;

			int elem &#x3D; n1 + n2;
			_elems.push_back(elem);
			n2 &#x3D; n1;
			n1 &#x3D; elem;

		&#125;

	&#125;

&#125;

ostream&amp; Fib::print(ostream&amp; os) &#123;

	int elem_pos &#x3D; begin_pos - 1;
	int end_pos &#x3D; elem_pos + length;

	if (end_pos &gt; _elems.size()) &#123;
		Fib::generate_elem(end_pos);
	&#125;

	while (elem_pos &lt; end_pos)
		os &lt;&lt; _elems[elem_pos++] &lt;&lt; &quot; &quot;;
	return os;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​            下面综合一下实现+小小的调整</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
class num_sequence &#123;

public:
	&#x2F;*
		getElembyPos( pos ) offering a returned value by giving pos
		generate_elem( pos ) create a subSequence that locates [0, pos]
		arrayType() return type of the array
		print( os ) written all elements into ostream
		check_integrity( pos ) whether the pos is valid
		max_pos() return the max position
	*&#x2F;
	virtual ~num_sequence() &#123;&#125;; &#x2F;&#x2F; diffrent type of sequence has different ways

	virtual int getElembyPos(int pos) &#x3D; 0; &#x2F;&#x2F; absolute virtual, contemporily need to overwrite!
	
	virtual string arrayType()const &#x3D; 0;

	virtual ostream&amp; print(ostream&amp; os &#x3D; cout)&#x3D; 0;

	static int max_pos() &#123; return _max_elems; &#125;;
protected:
	
	virtual void generate_elem(int pos) &#x3D; 0;
	
	bool check_integrity(int pos, int size);

	const static int _max_elems &#x3D; 1024;
	
&#125;;

 

bool num_sequence::check_integrity(int pos,int size) &#123;

	if (pos &lt; 0 || pos &gt; _max_elems) &#123;

		cerr &lt;&lt; &quot; invalid position! request rejected!&quot;;
		return false;
	&#125;
	return true;
&#125;

ostream&amp; operator&lt;&lt; (ostream &amp; os, num_sequence&amp; ns) &#123;
	return ns.print(os);
&#125;

class Fib :public num_sequence &#123;

public:
	Fib(int len &#x3D; 1, int begin_pos &#x3D; 1) :length(len), begin_pos(begin_pos) &#123;&#125;;
	virtual int getElembyPos(int pos);
	virtual ostream&amp; print(ostream&amp; os &#x3D; cout);
	int getlength() const&#123; return length; &#125;;
	int getBeginPos() const &#123; return begin_pos; &#125;;
	string arrayType()const;
protected:
	virtual void generate_elem(int pos) ;
	int length;
	int begin_pos;
	vector&lt;int&gt; _elems;
	bool check_integrity(int pos, int size);
&#125;;

string Fib::arrayType() const&#123;
	return &quot;Fib&quot;;
&#125;

int Fib::getElembyPos(int pos) &#123;

	if (!check_integrity(pos,_elems.size())) &#123;
		return 0;
	&#125;

	if (pos &gt; _elems.size()) &#123;
		Fib::generate_elem(pos);
	&#125;

	return _elems[pos - 1];
&#125;

void Fib::generate_elem(int pos) &#123;

	if (_elems.empty()) &#123;

		_elems.push_back(1);
		_elems.push_back(1);&#x2F;&#x2F; the first two should be 1,1
	&#125;

	if (_elems.size() &lt;&#x3D; pos) &#123;

		int i &#x3D; _elems.size();
		int n2 &#x3D; _elems[i - 2];
		int n1 &#x3D; _elems[i - 1];

		for (; i &lt; pos; i++) &#123;

			int elem &#x3D; n1 + n2;
			_elems.push_back(elem);
			n2 &#x3D; n1;
			n1 &#x3D; elem;

		&#125;

	&#125;

&#125;

ostream&amp; Fib::print(ostream&amp; os) &#123;

	int elem_pos &#x3D; begin_pos - 1;
	int end_pos &#x3D; elem_pos + length;

	if (end_pos &gt; _elems.size()) &#123;
		Fib::generate_elem(end_pos);
	&#125;

	while (elem_pos &lt; end_pos)
		os &lt;&lt; _elems[elem_pos++] &lt;&lt; &quot; &quot;;
	return os;
&#125;

bool Fib::check_integrity(int pos, int size) &#123;

	if (pos &lt;&#x3D; 0 || pos &gt; _max_elems) &#123;
		cerr &lt;&lt; &quot; invalid position! request rejected!&quot;;
		return false;
	&#125;
	if (pos &gt; size) &#123;
		generate_elem(pos);
	&#125;

	return true;
&#125;

int main()
&#123;
	Fib fib;

	cout &lt;&lt; fib&lt;&lt;endl;

	Fib fib2(16);

	cout &lt;&lt; fib2;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="初始化，析构和复制"><a href="#初始化，析构和复制" class="headerlink" title="初始化，析构和复制"></a>初始化，析构和复制</h2><p>​        我再重复一遍：对于一个派生类的构造，他总是先递归的调用父类的构造函数！最后调用自己的构造函数！如果没有指定，则父类构造调用默认构造！对于复制，也是一样的，可以重写 operator = 来实现有效的深拷贝</p>
<h2 id="覆盖，定义虚函数"><a href="#覆盖，定义虚函数" class="headerlink" title="覆盖，定义虚函数"></a>覆盖，定义虚函数</h2><p>​        注意到，假使我们重写虚函数，特别是纯虚函数，必须在：参数列表，返回类型，常量性等<strong>完全</strong>跟父类一致！！！</p>
<p>​        对于虚函数的静态解析，当（1）基类的constructor和destructor （2）调用基类对象而不是对象的pointer 或者引用！</p>
<p>​        也就是说，如果我们的父类构造函数调用了一个虚函数，则会调用父类自己的而不是派生类的！！！（很好理解，先有鸡还是先有蛋的问题）</p>
<h2 id="运行时的类型鉴定机制"><a href="#运行时的类型鉴定机制" class="headerlink" title="运行时的类型鉴定机制"></a>运行时的类型鉴定机制</h2><p>​        C++中有一个接口函数叫typeid，可以在动态运行时查看类的类型是什么！需要引用头文件#include&lt; typeinfo &gt;</p>
<pre class="line-numbers language-none"><code class="language-none">if(typeid(*ps) &#x3D;&#x3D; typeid(Fib))
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        C++基础编程6</p>
<h2 id="基于template的编程"><a href="#基于template的编程" class="headerlink" title="基于template的编程"></a>基于template的编程</h2><p>​        template， 翻译作模板，听起来有一些奇怪：事实上，他叫：运行时才确定的参数更好！也就说，我们的这样的一个关键字是定义在动态编译上的，传入的类型唯有在运行时才会知道！为了方便，我们不妨使用二叉树来说明之！</p>
<h2 id="被参数化的类型"><a href="#被参数化的类型" class="headerlink" title="被参数化的类型"></a>被参数化的类型</h2><p>​        这是一个string的二叉树定义，我们会在稍后给出这个类具体的行为：</p>
<pre class="line-numbers language-none"><code class="language-none">class string_BTnode&#123;
  public:
    &#x2F;&#x2F;...
  private:
    string _val;
    int _cnt;
    string_BTnode* _lchild;
    string_BTnode* _rchild;
    
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        相仿的，我们还可以给出：</p>
<pre class="line-numbers language-none"><code class="language-none">class int_BTnode&#123;
  public:
    &#x2F;&#x2F;...
  private:
    int _val;
    int _cnt;
    int_BTnode* _lchild;
    int_BTnode* _rchild;
    
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        template的作用就出来了！我们可以合并之：采用模板声明：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename valType&gt;
class BTnode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这样就使得我们有机会直接使用：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename valType&gt;
class BTnode&#123;
    
    valType _val;
    int _cnt;
    BTnode* _lchild;
    BTnode* _rchild;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        使用的办法，就是将之实例化：</p>
<pre class="line-numbers language-none"><code class="language-none">BTnode&lt;int&gt; aIntBtNode;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        而对于二叉树本身，也声明之一个类就可以了：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename elemType&gt;
class BTtree&#123;
    public:
    	&#x2F;&#x2F;...
    private:
    	BTnode&lt;elemType&gt;* _root;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        尔后，所有的实现函数都是以BTtree&lt; elemType &gt; :: funcName;来实现的。</p>
<h2 id="template类型参数的处理"><a href="#template类型参数的处理" class="headerlink" title="template类型参数的处理"></a>template类型参数的处理</h2><p>​        注意到：为我们往往喜欢传递引用方式来传递数据！这样效率最快，也就是说：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename valType&gt;
inline BTNode&lt;valType&gt;::BTnode(const valType&amp; val):_val(val)&#123;
    &#x2F;&#x2F;...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        而不是：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename valType&gt;
inline BTNode&lt;valType&gt;::BTnode(const valType val)&#123;
    &#x2F;&#x2F;...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        同时推介初始化列表初始化成员，不然若是传递类， 采用 = 赋值不方便，且效率低下（复制）</p>
<h2 id="常量表达式和默认参数值"><a href="#常量表达式和默认参数值" class="headerlink" title="常量表达式和默认参数值"></a>常量表达式和默认参数值</h2><p>我们可以用一个常量来template初始化。举个例子：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;int len&gt;
class num_sequence&#123;
    
    public:
    	num_sequence(int begin_pos &#x3D; 1);
&#125;
template&lt;int len&gt;
class Fib:public num_sequence&lt;len&gt;&#123;
    public:
    	Fib(int begin_pos &#x3D; 1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样初始化的时候：</p>
<pre class="line-numbers language-none"><code class="language-none">Fib&lt;16&gt; fib1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>异常处理机制分为：异常的鉴定和发出，以及异常的处理方式。在我们设计程序的时候，常常会出现异常。我们抛出异常的方式是throw!</p>
<pre class="line-numbers language-none"><code class="language-none">throw 42;
throw &quot;panic!&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>抛出的对象将是我们接受的：</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>是由catch，或者一连串的catch组成，小括号——对象，大括号处理异常！</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;

	bool staturs &#x3D; false;
    
	catch(int errir)&#123;
        log_msg(...);
    &#125;
    
    catch(const char* str)&#123;
        log_msg(...);
    &#125;
	&#x2F;&#x2F;...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>于是，他们可以：上面的语句接受</p>
<pre class="line-numbers language-none"><code class="language-none">throw 42;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个语句</p>
<pre class="line-numbers language-none"><code class="language-none">throw &quot;Panic&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>去到了：</p>
<pre class="line-numbers language-none"><code class="language-none">catch(const char* str)&#123;
       log_msg(...);
   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>对于那些没办法完整处理一次异常的，再次扔出就好了</p>
<pre class="line-numbers language-none"><code class="language-none">catch(...)&#123;
    
    log_msg(&quot;exceptions&quot;);
    
    throw;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>他将会在下一个接受一个错误类型的catch再次进入</p>
<h2 id="提炼异常"><a href="#提炼异常" class="headerlink" title="提炼异常"></a>提炼异常</h2><p>注意到： try和catch是半生的</p>
<pre class="line-numbers language-none"><code class="language-none">try&#123;
    
    &#x2F;&#x2F;...
    
    
&#125;
catch(st1)&#123;
    &#x2F;&#x2F;...
&#125;
catch(st2)&#123;
    &#x2F;&#x2F;...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那些没有找到catch的，会逐步回溯到main找对应的catch。（异常处理机制托管）找不到？就调用std::abort()退出去。</p>
<h1 id="More-Effective-C-1"><a href="#More-Effective-C-1" class="headerlink" title="More Effective C++ 1"></a>More Effective C++ 1</h1><h2 id="Basic-Issues"><a href="#Basic-Issues" class="headerlink" title="Basic Issues"></a>Basic Issues</h2><p>我们现在开始C++的一大名著阅读.在这个sections，更多关注的是基础的C++议题。</p>
<h3 id="条款1-区分pointers-和-reference"><a href="#条款1-区分pointers-和-reference" class="headerlink" title="条款1 区分pointers 和 reference"></a>条款1 区分pointers 和 reference</h3><p>​        Pointers和reference确实不一样。在使用方式上，我们对Pointers是*（解引用）和<code>-&gt;</code>的方式来访问Reference确跟对象本身一样，访问成员使用 . </p>
<p>​        作为Reference，不存在空引用！也就是说，不存在一个引用不指向任何对象。这点上，真是跟指针不大一样！</p>
<pre class="line-numbers language-none"><code class="language-none">char* pc &#x3D; 0;
char* pc1 &#x3D; &amp;aCh; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        当然，那这样如何呢？</p>
<pre class="line-numbers language-none"><code class="language-none">char *pc &#x3D; 0;
char&amp; rc &#x3D; *pc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        答案是未定义行为！千万别显示的，或者是隐式的做这样的事情！</p>
<p>​        其二，基于上面的阐述，被引用的对象——必须——在引用之前就被初始化！</p>
<pre class="line-numbers language-none"><code class="language-none">string&amp; rs; &#x2F;&#x2F; 不存在这样的代码！这是非法的
string s(&quot;xxyyzz&quot;);
string&amp; rs &#x3D; s;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        相对应的——</p>
<pre class="line-numbers language-none"><code class="language-none">string* ps;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        通过编译！但是，比如说我的编译器会警告你没有初始化。于是，有必要对指针的合法性进行判断，而引用从来没有必要关注这件事情。</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;

void checkPointersValid(double* pt) &#123;

	if (pt &#x3D;&#x3D; nullptr) &#123;
		throw &quot;trying to use empty double pointer! that&#39;s really bad :(&quot;;
		return;
	&#125;
	std::cout &lt;&lt; &quot;Got value:&gt; &quot; &lt;&lt; *pt &lt;&lt; std::endl;
	return;
&#125;

void Processing(double* pt) &#123;

	try &#123;

		checkPointersValid(pt);

	&#125;
	catch (const char* errorStr) &#123;

		std::cout &lt;&lt; errorStr &lt;&lt; std::endl;

		exit(-1);

	&#125;

	return;
&#125;

int main() &#123;
	double val &#x3D; 10;

	double* p1 &#x3D; &amp;val;

	double* null &#x3D; nullptr;

	Processing(p1);

	Processing(null);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        很是复杂。。。</p>
<p>​        另一个重要的区别在于：pointers是可变的，它可以从指向一个内存，原生的话，不加以说明的——指向另一块内存，而不会告诉你这件事情——这是很危险的（对于指向堆内存的话，容易造成泄漏）。但是reference就相当于常指针，总是指向那个对象不会改变。</p>
<p>​        总结来看：当你——需要考虑到“不指向任何对象”的可能性时，或者考虑：在不同时间需要指向不同对象的可能性时，有必要使用指针来完成你的工作，其余的情况下可以使用reference。</p>
<h3 id="条款2：最好使用C-转型操作符"><a href="#条款2：最好使用C-转型操作符" class="headerlink" title="条款2：最好使用C++转型操作符"></a>条款2：最好使用C++转型操作符</h3><p>​        在旧时的C语言，我们如下转换类型</p>
<pre class="line-numbers language-none"><code class="language-none">(target_type)expression<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        然而，这样的作法没有经过检查且辨识度太低了：为了解决这个问题，C++引入了：</p>
<pre class="line-numbers language-none"><code class="language-none">static_cast&lt;target_type&gt;(expression)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        来个例子：</p>
<pre class="line-numbers language-none"><code class="language-none">int res1 &#x3D; 10, res2 &#x3D; 20;
double do_res &#x3D; static_cast&lt;double&gt;(res1)&#x2F;res2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        static_cast跟旧时的C一样有威力，也拥有一样的限制。甚至不可以移除const修饰符，于是const_cast来干这个事情了。</p>
<p>​        const_cast只可以改变变量的常量性和变易性。其余的都改变不了！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230514123125051.png?lastModify=1685936981" alt="image-20230514123125051"></p>
<pre class="line-numbers language-none"><code class="language-none">class widget &#123;
public:
	int a;
&#125;;

class specialWidget :public widget &#123;
public:
	int b;
&#125;;
void update(specialWidget* psw) &#123;

&#125;
int main() &#123;

	specialWidget sw;
	const specialWidget&amp; csw &#x3D; sw;

	update(&amp;csw); &#x2F;&#x2F; invalid

	update(const_cast&lt;specialWidget*&gt;(&amp;csw)); &#x2F;&#x2F; finish work properly!

	update((specialWidget*)&amp;csw);

	widget* pw &#x3D; new specialWidget;
	update(pw);&#x2F;&#x2F;error ： 类型错误，不可以需要孩子传父亲！

	update(const_cast&lt;specialWidget*&gt;(pw)); &#x2F;&#x2F; error
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        还有个dynamic_cast，特别用在了安全的向下转性或者跨系转型的动作。也就是说，可以将指向基类的指针或引用转向指向派生或者是兄弟类的类的指针或者是引用。他没有办法用在缺乏虚函数的类型，也不可改变常量性！</p>
<h3 id="条款3：不要以多态的方式处理数组"><a href="#条款3：不要以多态的方式处理数组" class="headerlink" title="条款3：不要以多态的方式处理数组"></a>条款3：不要以多态的方式处理数组</h3><p>​        继承的最重要的性质之一就是可以通过指向基类的指针或者是引用来操纵派生类。比如说</p>
<pre class="line-numbers language-none"><code class="language-none">class BST&#123;...&#125;
class BalancedBST: public BST&#123;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        打印这些东西，我们涉及到：</p>
<pre class="line-numbers language-none"><code class="language-none">void PrintBSTArray(ostream&amp; os,const BSTarray[],int numElems)&#123;
    &#x2F;&#x2F; omit some basic check
    for(int i &#x3D; 0; i &lt; int numElems; i++)&#123;
        os&lt;&lt;array[i]; &#x2F;&#x2F; pretended that it has already been designed for using &lt;&lt;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是下一次传入：BalancedBST的时候，我们却依然实际上生成的是：</p>
<pre class="line-numbers language-none"><code class="language-none">os &lt;&lt; array + sizeof(BST)*i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        而不是</p>
<pre class="line-numbers language-none"><code class="language-none">os &lt;&lt; array + sizeof(BalancedBST)*i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这很麻烦了！倘若这个函数是删除元素的话，就意味着删除是不完全的！因为基类总是不会比派生类小的！而且行为未定义！极易造成程序的崩溃！所以不要一多态的方式来处理数组，是啥就是啥的处理！</p>
<h3 id="条款四：非必要不提供默认构造函数"><a href="#条款四：非必要不提供默认构造函数" class="headerlink" title="条款四：非必要不提供默认构造函数"></a>条款四：非必要不提供默认构造函数</h3><p>​        Default constructors是C++从无到有的生成一个对象的办法。这个东西你不指定初始化方法，其成员也会拥有一些值——对于数值者是０或者是其他些什么无意义的随机值，对于指针者是nullptr。一些内置的数据结构被初始化作空容器。</p>
<p>​        但是有一些类，倘若我们不提供任何其他信息，是不应该存在的！也就是说：一些可以从无到有的类才适合default constructor.反之不需要。比如说：</p>
<pre class="line-numbers language-none"><code class="language-none">class EquipmentPieces&#123;
    
  public:
    EquipmentPieces(int ID);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        于是不难意料到：这样的初始化不可能合法：</p>
<pre class="line-numbers language-none"><code class="language-none">EquipmentPieces EqVec[10];&#x2F;&#x2F; no Default constructors<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        哪有该怎么办嘞，要不我们：</p>
<pre class="line-numbers language-none"><code class="language-none">int IDArray[]&#x3D;&#123;1,2,3,...&#125;;&#x2F;&#x2F; make the Id valid previously
EquipmentPiece eqVec[10] &#x3D; &#123;
    
    EquipmentPiece(IDArray[0]),
    EquipmentPiece(IDArray[1]),
    ...
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是这没办法解决我们在堆上完成类似的行为。于是，我们不妨先声明指针数组</p>
<pre class="line-numbers language-none"><code class="language-none">typedef EquipmentPieces* PEP;
PEP aPointerArray[10];&#x2F;&#x2F; in stack
PEP aPointerArrayInHeap[10] &#x3D; new PEP[10];
for(int i &#x3D; 0; i &lt; 10; i++)&#123;
    
    aPointerArrayInHeap[i] &#x3D; new EquipmentPieces(ID[i]);
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        麻烦在于，我们必须记住我们在这里开辟了内存，是需要我们手动释放的。其次，可能指针本身还要占据内存，这是不好的。</p>
<p>​        于是还有第三种方法，那就是类似于C式的——先分配空数据，让数组指针指向之！</p>
<pre class="line-numbers language-none"><code class="language-none">void* rawMem &#x3D; operator new[](10*sizeof(EquipmentPiece));

EquipmentPiece* EPArray &#x3D; static_cast&lt;EquipmentPiece*&gt; (rawMem);

for(int i &#x3D; 0; i &lt; 10; i++)&#123;
    new(&amp;bestPieces[i]) EquipmentPieces(ID[i]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        就算如此，你会发现还得是要手动初始化！况且，释放掉他需要很麻烦的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">for(int i &#x3D; 0 i &gt;&#x3D; 0; i--)&#123;
	epVec[i].~EquipmentPieces();
&#125;

operator delete[](rawMem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        一个没有默认构造器的类很快还会有第二个麻烦，那就是没办法直接调用大部分的模板！你当然可以谨慎的设计之来回避这个问题。但是大部分人只有会在出现问题的时候想起来这回事情。</p>
<p>​        所以要不要它呢？注意到如果一切类都给了默认构造器，我们就必须手动的检查它，否则会产生大量的问题！</p>
<p>​        于是，还是回到这里：倘若我们不提供任何其他信息，是不应该存在的！也就是说：一些可以从无到有的类才适合default constructor.反之不需要！</p>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h3 id="条款5：对定制的类型转换符保持警觉"><a href="#条款5：对定制的类型转换符保持警觉" class="headerlink" title="条款5：对定制的类型转换符保持警觉"></a>条款5：对定制的类型转换符保持警觉</h3><p>​        C++自然允许不同类型之间的隐式转换，我是说，比如说</p>
<pre class="line-numbers language-none"><code class="language-none">short a &#x3D; 10;
double b &#x3D; a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        居然是可行的！这还好，C++甚至可以：</p>
<pre class="line-numbers language-none"><code class="language-none">double b &#x3D; 10.00；
char a &#x3D; b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这样会造成信息丢失的转换都是可以正常运行的！ 这是因为C++编译器会想尽办法的找到</p>
<p>​        于是，在C++的类设计上，有必要专门提供一个转换函数来促使之客户程序员调用，</p>
<pre class="line-numbers language-none"><code class="language-none">class Rational&#123;
public:    
	Rational(double a, double b); &#x2F;&#x2F; make a&#x2F;b 
&#125;;

Rational r(1,2);
cout &lt;&lt; r;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这居然是可以输出的：0.5！</p>
<p>​        这是因为C++编译器会想尽办法的找到转化方式。这就很容易造成自己不期望你被调用的函数被调用了！</p>
<pre class="line-numbers language-none"><code class="language-none">class Rational&#123;
public:    
	Rational(double a, double b); &#x2F;&#x2F; make a&#x2F;b 、
    double asDouble() const;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样，显示的调用即可：</p>
<pre class="line-numbers language-none"><code class="language-none">cout &lt;&lt; r.asDouble()&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        或者，采用关键字explict来防止隐式转换！</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;
class Array&#123;
    
public:
    ...
        explicit Array(int num);
    ...
&#125;;

Array&lt;int&gt; a(10);
Array&lt;int&gt; b(10);

if(a &#x3D;&#x3D; b[i])&#x2F;&#x2F; invalid!!! as it is expicited, you can not transform it underconciously!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="条款6区分前置操作符和后置操作符"><a href="#条款6区分前置操作符和后置操作符" class="headerlink" title="条款6区分前置操作符和后置操作符"></a>条款6区分前置操作符和后置操作符</h3><p>​        在很久以前的C++，没办法区分前置＋＋和后置＋＋（或者－－）。于是，我们这样设计类来防止语法混淆：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;

class UpInt &#123;

public:
	UpInt(int i) :_val(i) &#123;&#125;;
	UpInt&amp; operator++() &#123; this-&gt;_val++; return *this; &#125;;
	const UpInt operator++(int) &#123; UpInt old &#x3D; *this; ++(*this); return old; &#125;;
	UpInt&amp; operator--()&#123; this-&gt;_val--; return *this; &#125;
	const UpInt operator--(int) &#123; UpInt old &#x3D; *this; --(*this); return old; &#125;;

	int getVal()const &#123; return _val; &#125;
private:
	int _val;
&#125;;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const UpInt&amp; my_data) &#123; os &lt;&lt; my_data.getVal() &lt;&lt; endl; return os; &#125;;

int main() &#123;

	UpInt val(10);
	++val;
	cout &lt;&lt; val;
	--val;
	cout &lt;&lt; val;
	val++;
	cout &lt;&lt; val;
	val--;
	cout &lt;&lt; val;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        为什么:</p>
<pre class="line-numbers language-none"><code class="language-none">const UpInt operator++(int) &#123; UpInt old &#x3D; *this; ++(*this); return old; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        因为我们是为了防止:</p>
<pre class="line-numbers language-none"><code class="language-none">int i &#x3D; 0;
i++++; &#x2F;&#x2F; invalid! C++ abandon this behaviors<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        所以就是直接禁止!只需要加个const将返回的对象常量化!就好了</p>
<h3 id="条款7：千万不要重载-amp-amp-和-操作符"><a href="#条款7：千万不要重载-amp-amp-和-操作符" class="headerlink" title="条款7：千万不要重载&amp;&amp;,|| 和 , 操作符"></a>条款7：千万不要重载&amp;&amp;,|| 和 , 操作符</h3><p>​        继承于C的，C++对真假值的逻辑表达式也是采用“骤死式”的判别表达式。也就是说，针对这样的表达式：</p>
<pre class="line-numbers language-none"><code class="language-none">char* p;
...&#x2F;&#x2F; probably init the string or not

if((p !&#x3D; NULL) &amp;&amp; (strlen(p) &gt; 10))&#123;
    ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        不需要担心strlen(p)会使用空指针，事实上，一旦判定 p == NULL，那就意味着这个表达式一定为假，就不需要我们去计算第二个式子。于是第二条甚至不会执行。</p>
<p>​        但是，一旦我们重载了，就无法预期编译器的行为。</p>
<p>​        于是在C++中，一些运算符是不可以重载的：</p>
<pre class="line-numbers language-none"><code class="language-none">.	.*		::		?:		 new 	 delete		sizeof		typeid		static_cast		
dynamic_cast		const_cast		reinterpret_cast<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="条款8：了解不同含义的new和delete"><a href="#条款8：了解不同含义的new和delete" class="headerlink" title="条款8：了解不同含义的new和delete"></a>条款8：了解不同含义的new和delete</h3><p>​        我们必须指出，C++的语言有时候确实令人感到难绷，比如说我们会说new operator和operator new 不是一件事情！</p>
<pre class="line-numbers language-none"><code class="language-none">string* phs &#x3D; new string(&quot;Memory Managements&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        首先，这个new式语言内建的，就是说：首先他分配足够多的内存，放置一个东西。然后调用编译器找到的最合适的初始constructor来完成初始化工作！这样的行为不可以我们改变。</p>
<p>​        我们可以改变什么啥呢？改变operator new。什么意思？我们发现，new在一些适合调用一个函数执行必要的内存分配空间。这个函数我们可以重写！</p>
<pre class="line-numbers language-none"><code class="language-none">void* operator new(size_t size);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        也就是说，这是一个操作符函数，该函数返回一个空的内存！嘿，就像malloc函数一样！</p>
<pre class="line-numbers language-none"><code class="language-none">void* rawMem &#x3D; operator new(sizeof(string));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        于是，new operator实际上就是operator new + 内存初始化了</p>
<pre class="line-numbers language-none"><code class="language-none">string* phs &#x3D; new string(&quot;Memory Managements&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        等价于</p>
<pre class="line-numbers language-none"><code class="language-none">void* tempName &#x3D; operator new(sizeof(string));
call the func &gt;&gt; string::string(&quot;Memory Managements&quot;); on tempmemory
string* ps &#x3D; static_cast&lt;string*&gt;(memory);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        还有一种有趣的new ，叫placement new. 啥意思？就是我们已经知道了指定了一个地方就要放摸一个类的对象，那就可以用之</p>
<pre class="line-numbers language-none"><code class="language-none">class Widget&#123;
    public:
    	Widget(size_t size);
    ...
&#125;;

Widget* constructWidgetInBuffer(void* buffer,size_t size)&#123;
 	return new(buffer) Widget(size);   
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        欸我的嘛，抽象！其实这是在隐式的调用operator new</p>
<pre class="line-numbers language-none"><code class="language-none">void* operator new(size_t size,void* locations)&#123;
    
    return locations;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Deletion-amp-amp-Deallocation"><a href="#Deletion-amp-amp-Deallocation" class="headerlink" title="Deletion &amp;&amp; Deallocation"></a>Deletion &amp;&amp; Deallocation</h4><p>​        为了避免 resource leak （资源泄露），每一个动态分配行为都必须分配一个。函数operator delete 对于内建的delete operator 对于内建的 delete operator ，好像operator new 对于 new operator 一样。</p>
<pre class="line-numbers language-none"><code class="language-none">string* ps;
&#x2F;&#x2F;...
delete ps;
	你的编译器必须产生怎样的代码？它必须可以析构ps所指对象。又可以释放该对象占用的内存。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        内存释放动作由于函数operator delete 执行。通常声明如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void operator delete(void* memoryToBeDeallocated);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        由此delete ps;</p>
<p>​        造成编译器产生这样的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">ps-&gt;~string();
operator delete(ps);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这里呈现的一个暗示就是，如果你只打算处理原始的，未设置初值的内存，应该完全回避new operator 和 delete operators。改用operator new取得内存并以 operator delete 归还给系统。</p>
<pre class="line-numbers language-none"><code class="language-none">void* buffer &#x3D; operator new(50*sizeof(char));
&#x2F;&#x2F;...
operator delete(buffer);    
	这组行为在C++相当于malloc和free.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        如果你使用placement new, 在某内存块中产生的对象，你应该避免对那块内存使用 delete operator. 因为delete operator调用operator delete释放内存，但是该内存含有的对象最初并非是由operator new 分配得来的。毕竟placement new只是返回它所接受的指针而已，谁知道那个指针从哪里来呢？所以为了抵消该对象的构建器的影响，我们选择直接调用对象的destructor。</p>
<pre class="line-numbers language-none"><code class="language-none">void* mallocShared(size_t size);
void freeShared(void *memory);
void *sharedMemory &#x3D; mallocShared(sizeof(Widget));

Widget* pW &#x3D; constructWidgetInBuffer(sharedMemory,10);
...
&#x2F;&#x2F; delete pW; 不要这样做！没有意义，因为sharedMemory来自mallocShared函数而不是new 出来的！
pW-&gt;~Widget();&#x2F;&#x2F;可以的！手动调用析构器是允许的
freeShared(pW);&#x2F;&#x2F; 可以的！释放pW所指向的内存，不调用任何destructor!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Arrays数组"><a href="#Arrays数组" class="headerlink" title="Arrays数组"></a>Arrays数组</h4><p>​        下面，我们考虑一些更远的事情，我是说：</p>
<pre class="line-numbers language-none"><code class="language-none">string* ps &#x3D; new string[10];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        用的还是new operator，但是这次是数组！于是，我们实际上调用的是它的兄弟oprator new[ ]!当然这也就意味着我们可以重写之，但是往往重写全局的new函数是不明智的，因为其他的new operator也会发生行为的改变而使得程序发生剧烈的变化！</p>
<p>​        类似的，删除使用了new operator</p>
<h2 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h2><p>​        C++增加了Exceptions 之后，改变了太多的事情。比如说原始指针的使用成为了一个高风险事件，资源泄露的风险也是大增。</p>
<p>​        但是为了使程序可以在触发异常后安全的退出程序，就必须使用它来处理推出前的工作！</p>
<h3 id="条款9：使用destructor来防止内存泄漏"><a href="#条款9：使用destructor来防止内存泄漏" class="headerlink" title="条款9：使用destructor来防止内存泄漏"></a>条款9：使用destructor来防止内存泄漏</h3><p>​        假设我们现在正在书写一个类（Adorable Little Animal）ALA，我们在之后派生出来了小猫和小狗两个类</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519100041781.png?lastModify=1685936981" alt="image-20230519100041781"></p>
<p>​        为了实现领养工作，我们在抽象类下书写虚函数：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
class ALA &#123;

public:
	virtual void processAdoption() &#x3D; 0;&#x2F;&#x2F; 强迫重写

protected:

	string name;
&#125;;

class Puppy : public ALA&#123;
public:
	virtual void processAdoption();
&#125;;

class Kitten :public ALA &#123;
public:
	virtual void processAdoption();
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        大致如此</p>
<p>​        现在我们需要读取星系返回一个ALA指针</p>
<pre class="line-numbers language-none"><code class="language-none">ALA* readALA(istream&amp; s);&#x2F;&#x2F; 不在谈论怎么实现<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        于是，我们的收养问题实际上可以这样书写：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 框架
void processAdoption(istream&amp; dataSource)&#123;
	while(dataSource)&#123;
        ALA *pa &#x3D; readALA(dataSource);
        pa-&gt;processAdoption();
        delete pa;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这要求我们函数走遍dataSource，处理所有的信息，显然的——我们调用一次，就必须释放一次！</p>
<p>​        现在出现问题了：假如说我们的 <code>pa-&gt;processAdoption()</code>抛出了一个异常！麻烦大了，这个异常会追溯到调用端，导致<code>delete pa;</code>被跳过了，也就是说，只要触发一次异常，资源泄露一次！</p>
<p>​        这个时候，C++的Exception就可以出马了：</p>
<pre class="line-numbers language-none"><code class="language-none">void processAdoption(istream&amp; dataSource)&#123;
	while(dataSource)&#123;
        ALA *pa &#x3D; readALA(dataSource);
       try&#123;
           pa-&gt;processAdoption();
       &#125;
        catch(...)&#123;
            delete pa;
            throw;&#x2F;&#x2F;再把异常传递出去
        &#125;
        delete pa;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        嘿！实在是太麻烦了！为什么不让delete代码剧中于一处呢？这就是智能指针的来源！我们只需要使用智能指针指向之，当发现需要被析构的时候就直接析构就好了。</p>
<pre class="line-numbers language-none"><code class="language-none">void processAdoption(istream&amp; dataSource)&#123;
    while(dataSource)&#123;
        unique_ptr&lt;ALA&gt; pa(readALA(dataSource));
        pa-&gt;processAdoption();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        隐藏在智能指针背后的理念是——以一个对象存放“必须自动释放的资源”，并且是依赖他自己的destructor来干这样的事情。</p>
<p>​        下面来看窗口设计，比如说我们来看使用窗口显示信息</p>
<pre class="line-numbers language-none"><code class="language-none">void displayInfo(const Information&amp; info)&#123;
    WINDOW_HANDLE w(createWindow());
    
    &#x2F;&#x2F;displayInfo here
    
    destroyWindow(w);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        还是先前的问题，如果允许时发生了exception，我们怎么办？</p>
<p>​        我们设计一个class：</p>
<pre class="line-numbers language-none"><code class="language-none">class WindowHandle&#123;
    public:
    	WindowHnadle(WINDOW_HANDLE handle):w(handle)&#123;&#125;;
    	~WindowHandle()&#123;destroyWindow(w)&#125;;
    	operator WINDOW_HANDLE()&#123;return w;&#125;;
    
    private:
    	WINDOW_HANDLE w;
    	WindowHandle(const WindowHandle&amp;);
    	WindowHandle&amp; operator&#x3D;(const WindowHandle);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们把复制和赋值行为给静止了，同时还给予了一个隐式操作符！，于是，这个函数的设计变得十分的简单：</p>
<pre class="line-numbers language-none"><code class="language-none">void displayInfo(const Information&amp; info)&#123;
   	WindowHandle w(createWindow());
    &#x2F;&#x2F;displayInfo here
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在我们把它作为临时对象可以销毁了！</p>
<h3 id="条款10：在constructor内部阻止内存泄漏"><a href="#条款10：在constructor内部阻止内存泄漏" class="headerlink" title="条款10：在constructor内部阻止内存泄漏"></a>条款10：在constructor内部阻止内存泄漏</h3><p>​        我们再说一遍，Exception的出现不太好，比如说我们正在写通讯录：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;list&gt;
using namespace std;
class Image &#123;
public:
	Image(const string&amp; imageDataFileName);
&#125;;

class AudioClip &#123;
public:
	AudioClip(const string&amp; audioDataFileName);
&#125;;

class PhoneNumber &#123;

&#125;;

class BookEntry &#123;
public:
	BookEntry(
		const string&amp; name,
		const string&amp; addr &#x3D; &quot;&quot;,
		const string&amp; imageFile &#x3D; &quot;&quot;,
		const string&amp; audioClipFile &#x3D; &quot;&quot;
	);
	~BookEntry();

	void addPhoneNumber(const PhoneNumber&amp; phoneNumber);

private:
	string theName;
	string theAddr;
	list&lt;PhoneNumber&gt; thePhone;
	Image* theImage;
	AudioClip* theAudioClip;
&#125;;

BookEntry::BookEntry(
	const string&amp; name,
	const string&amp; addr &#x3D; &quot;&quot;,
	const string&amp; imageFile &#x3D; &quot;&quot;,
	const string&amp; audioClipFile &#x3D; &quot;&quot;
) :theName(name), theAddr(addr), theImage(0), theAudioClip(0) &#123;
	if (imageFile !&#x3D; &quot;&quot;) &#123;
		theImage &#x3D; new Image(imageFile);
	&#125;

	if (audioClipFile !&#x3D; &quot;&quot;) &#123;
		theAudioClip &#x3D; new AudioClip(audioClipFile);
	&#125;
&#125;

BookEntry::~BookEntry() &#123;
	delete theImage;
	delete theAudioClip;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是当现在有了异常之后，假使我们正在初始化的对象抛出异常，就还会发生资源泄漏，即使使用智能指针也不行，因为其调用的destructor要求对象必须已经构建完整！</p>
<p>​        解决的办法是，在constructor内部就完成异常处理！</p>
<p>​        </p>
<pre class="line-numbers language-none"><code class="language-none">BookEntry::BookEntry(
	const string&amp; name,
	const string&amp; addr &#x3D; &quot;&quot;,
	const string&amp; imageFile &#x3D; &quot;&quot;,
	const string&amp; audioClipFile &#x3D; &quot;&quot;
) :theName(name), theAddr(addr), theImage(0), theAudioClip(0) &#123;
	try
	&#123;
		if (imageFile !&#x3D; &quot;&quot;) &#123;
			theImage &#x3D; new Image(imageFile);
		&#125;

		if (audioClipFile !&#x3D; &quot;&quot;) &#123;
			theAudioClip &#x3D; new AudioClip(audioClipFile);
		&#125;
	&#125;
	catch (...) &#123;
		delete theImage;
		delete theAudioClip;
		throw;&#x2F;&#x2F; 
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        清除这个过程还是可以抽象成一个私有函数！把他放到类里去：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;list&gt;
using namespace std;
class Image &#123;
public:
	Image(const string&amp; imageDataFileName);
&#125;;

class AudioClip &#123;
public:
	AudioClip(const string&amp; audioDataFileName);
&#125;;

class PhoneNumber &#123;

&#125;;

class BookEntry &#123;
public:
	BookEntry(
		const string&amp; name,
		const string&amp; addr &#x3D; &quot;&quot;,
		const string&amp; imageFile &#x3D; &quot;&quot;,
		const string&amp; audioClipFile &#x3D; &quot;&quot;
	);
	~BookEntry();

	void addPhoneNumber(const PhoneNumber&amp; phoneNumber);

private:
	string theName;
	string theAddr;
	list&lt;PhoneNumber&gt; thePhone;
	Image* theImage;
	AudioClip* theAudioClip;
	void cleanUp();
&#125;;

void BookEntry::cleanUp() &#123;
	delete theImage;
	delete theAudioClip;
&#125;

BookEntry::BookEntry(
	const string&amp; name,
	const string&amp; addr &#x3D; &quot;&quot;,
	const string&amp; imageFile &#x3D; &quot;&quot;,
	const string&amp; audioClipFile &#x3D; &quot;&quot;
) :theName(name), theAddr(addr), theImage(0), theAudioClip(0) &#123;
	try
	&#123;
		if (imageFile !&#x3D; &quot;&quot;) &#123;
			theImage &#x3D; new Image(imageFile);
		&#125;

		if (audioClipFile !&#x3D; &quot;&quot;) &#123;
			theAudioClip &#x3D; new AudioClip(audioClipFile);
		&#125;
	&#125;
	catch (...) &#123;
		cleanUp();
		throw;&#x2F;&#x2F; 
	&#125;
&#125;

BookEntry::~BookEntry() &#123;
	cleanUp();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们再次改进：</p>
<pre class="line-numbers language-none"><code class="language-none">class BookEntry &#123;
public:
	BookEntry(
		const string&amp; name,
		const string&amp; addr &#x3D; &quot;&quot;,
		const string&amp; imageFile &#x3D; &quot;&quot;,
		const string&amp; audioClipFile &#x3D; &quot;&quot;
	);
	~BookEntry();

	void addPhoneNumber(const PhoneNumber&amp; phoneNumber);

private:
	string theName;
	string theAddr;
	list&lt;PhoneNumber&gt; thePhone;
	Image* const theImage;
	AudioClip* const theAudioClip;
	void cleanUp();
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在外面就必须通过初值链表的方式才会给予之赋值。这样就可以这样给予一个安全的初始化方式</p>
<pre class="line-numbers language-none"><code class="language-none">BookEntry::BookEntry(
	const string&amp; name,
	const string&amp; addr &#x3D; &quot;&quot;,
	const string&amp; imageFile &#x3D; &quot;&quot;,
	const string&amp; audioClipFile &#x3D; &quot;&quot;
) :
theName(name), 
theAddr(addr), 
theImage(imageFile !&#x3D; &quot;&quot;?new Image(ImageFile):0), 
theAudioClip(audioClipFile !&#x3D; &quot;&quot;? new AudioClip(audioClipFile):0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是这又把问题绕回去了！</p>
<p>​        于是，为了使异常不流到外面，外面直接使用组合的方式完成任务：其构造函数放到类私有的地方：</p>
<pre class="line-numbers language-none"><code class="language-none">class BookEntry&#123;
    public:
	BookEntry(
		const string&amp; name,
		const string&amp; addr &#x3D; &quot;&quot;,
		const string&amp; imageFile &#x3D; &quot;&quot;,
		const string&amp; audioClipFile &#x3D; &quot;&quot;
	);
	~BookEntry();

	void addPhoneNumber(const PhoneNumber&amp; phoneNumber);

private:
	string theName;
	string theAddr;
	list&lt;PhoneNumber&gt; thePhone;
	Image* const theImage;
	AudioClip* const theAudioClip;
	void cleanUp();
    Image* initImage(const string&amp; imageFile);
    AudioClip* initAudioClipFile(const string&amp; audioClipFile);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        于是可以改写了：</p>
<pre class="line-numbers language-none"><code class="language-none">BookEntry::BookEntry(
	const string&amp; name,
	const string&amp; addr &#x3D; &quot;&quot;,
	const string&amp; imageFile &#x3D; &quot;&quot;,
	const string&amp; audioClipFile &#x3D; &quot;&quot;
) :
theName(name), 
theAddr(addr), 
theImage(initImage(imageFile)), 
theAudioClip(initAudioClipFile(audioClipFile))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        把异常处理转换到函数的内部：</p>
<pre class="line-numbers language-none"><code class="language-none">Image* BookEntry::initImage(const string&amp; imageFile)&#123;
    if(imageFile !&#x3D; &quot;&quot;)
        return new ImageFile(imageFile);
    else return 0;
&#125;&#x2F;&#x2F;这里不用，因为他是第一个被初始化，出现了其他问题会直接被释放
AudioClip* BookEntry::initAudioClipFile(const string&amp; audioClipFile)&#123;
	try&#123;
        if(audioClipFile !&#x3D; &quot;&quot;)&#123;
            return new AudioClip(audioClipFile);
        &#125;
       	else return 0;
    &#125;
    catch(...)&#123;
        delete theImage;
        throw;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        好吧，维护有些困难！那就是用<code>unique_ptr</code>!</p>
<pre class="line-numbers language-none"><code class="language-none">class BookEntry&#123;
    public:
	BookEntry(
		const string&amp; name,
		const string&amp; addr &#x3D; &quot;&quot;,
		const string&amp; imageFile &#x3D; &quot;&quot;,
		const string&amp; audioClipFile &#x3D; &quot;&quot;
	);
	~BookEntry();

	void addPhoneNumber(const PhoneNumber&amp; phoneNumber);

private:
	string theName;
	string theAddr;
	list&lt;PhoneNumber&gt; thePhone;
	const unique_ptr&lt;Image&gt; theImage;
	const unique_ptr&lt;AudioClip&gt; theAudioClip;
	void cleanUp();
    Image* initImage(const string&amp; imageFile);
    AudioClip* initAudioClipFile(const string&amp; audioClipFile);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样，就可以回到上一个设计了：</p>
<pre class="line-numbers language-none"><code class="language-none">BookEntry::BookEntry(
	const string&amp; name,
	const string&amp; addr &#x3D; &quot;&quot;,
	const string&amp; imageFile &#x3D; &quot;&quot;,
	const string&amp; audioClipFile &#x3D; &quot;&quot;
) :
theName(name), 
theAddr(addr), 
theImage(imageFile !&#x3D; &quot;&quot;?new Image(ImageFile):0), 
theAudioClip(audioClipFile !&#x3D; &quot;&quot;? new AudioClip(audioClipFile):0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        同时，不在需要构建手写destructor了，直接放：</p>
<pre class="line-numbers language-none"><code class="language-none">BookEntry::~BookEntry()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="条款11-禁止异常流出destructor"><a href="#条款11-禁止异常流出destructor" class="headerlink" title="条款11 禁止异常流出destructor"></a>条款11 禁止异常流出destructor</h3><p>​        假设现在外面的析构爆发问题了，我们的办法是：在里头使用try_catch语句接受处理之，甚至是这样：</p>
<pre class="line-numbers language-none"><code class="language-none">Session::~Session()&#123;
    try&#123;
        logDestruction(this);
    &#125;
    catch(...)&#123;&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这使得异常直接被吸收，防止程序调用std::abort()造成释放不完全！</p>
<h3 id="条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”"><a href="#条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”" class="headerlink" title="条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”"></a>条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”</h3><p>​        首先声明：我们调用函数返回到的是函数的调用端（除非失败了），而异常抛出一定不会回到抛出端！</p>
<p>​        如：</p>
<pre class="line-numbers language-none"><code class="language-none">istream operator&lt;&lt;(istream&amp; s,Widget&amp; w);
void passAndThrowWidget()&#123;
    Widget localWidget;
    cin &gt;&gt; localWidget;
    throw localWidget;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们把localWidget交到operator&gt;&gt;手里的时候，没有发生复制行为，而是绑定到reference上操作！（passByReference）,但是Exception不一样！无论是值传递还是引用传递，他都会发生复制行为！这是容易理解的：我们一旦调用了<code>throw localWidget</code>，程序离开函数，造成了<code>localWidget</code>析构，我们的catch如果是reference传递，那传的是一具尸体！好吧，我们就不得不复制了！这造成了throw是很慢的（特别是对象很大的时候）</p>
<p>​        现在事情复杂起来了！假使我们：</p>
<pre class="line-numbers language-none"><code class="language-none">class Widget&#123;&#125;;
class SpecialWidget:public Widget&#123;&#125;;
void passAndThrowWidget()&#123;
    SpecialWidget localSpecialWidget;
    ...
    Widget&amp; rw &#x3D; localSpecialWidget;
    throw rw;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        不是SpeicalWidget类型！因为这里抛出的是静态类型！复制的永远会是对象的静态类型！这是我们需要注意的：</p>
<pre class="line-numbers language-none"><code class="language-none">catch(Widget&amp; w)&#123;
    ...
    throw;
&#125;
&#x2F;&#x2F; and
catch(Widget&amp; w)&#123;
    ...
    throw w;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        不是一回事情，前者传入的啥抛出的就是啥！不会发生复制行为。但是第二种就会！于是，有必要对那些就是想要处理的一场样本的对象直接使用</p>
<pre class="line-numbers language-none"><code class="language-none">throw;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        即可！</p>
<p>​        对于继承体制的异常处理：必须指出：一个接受基类的catch会接受基类和其派生类！而接受派生类的catch只管派生类：</p>
<pre class="line-numbers language-none"><code class="language-none">try&#123;
    ...
&#125;
catch(base_error)&#123;&#125;
catch(derived_error)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        上面的这个设计不合适！因为derived_error catch不到任何异常！这跟虚函数：”最吻合调用机制“不同，catch是最先吻合的调用机制。</p>
<p>​        总结一下我们的长篇大论：</p>
<p>​        首先：exception object总是会被复制，使用pass by val会被复制两次！而传递函数的参数则不会</p>
<p>​        其次：跑出去成为exception的对象允许类转换的动作，比被传递到函数去的对象少。</p>
<p>​        最后，catch字句是源码顺序调用优先而不是吻合度调用优先！</p>
<h3 id="条款13-以引用传递捕捉异常"><a href="#条款13-以引用传递捕捉异常" class="headerlink" title="条款13 以引用传递捕捉异常"></a>条款13 以引用传递捕捉异常</h3><p>​        我们有三种方式传递异常：值传递，引用传递，指针传递。</p>
<p>​        先考虑指针传递：不得不说因为不复制对象而显得十分搞笑，但是不大好，程序员们往往会忘记：</p>
<pre class="line-numbers language-none"><code class="language-none">void someFunc&#123;
    exception ex;
    
    &#x2F;&#x2F;...
    
    throw &amp;ex;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对象早就被析构了！传递了一个非法指针！</p>
<p>​        好吧，开堆上：</p>
<pre class="line-numbers language-none"><code class="language-none">void someFunc&#123;
    exception ex;
    
    &#x2F;&#x2F;...
    
    throw new ex;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        那问题更大了，用户程序员没有办法知道：他们什么时候需要释放，什么时候不需要释放！这下麻烦了！还是不要用之为妙。</p>
<p>​        值传递呢？除了低效以外，如果我们传递了派生类指针，那意味着后续的处理下，对象都是基类，调用的虚函数是基类虚函数！程序爆炸了！</p>
<p>​        于是还是引用传递好！避免了上述的问题！</p>
<h3 id="条款14：明智使用exception-specification"><a href="#条款14：明智使用exception-specification" class="headerlink" title="条款14：明智使用exception specification"></a>条款14：明智使用exception specification</h3><p>​        谨慎使用他！</p>
<p>​        如：</p>
<pre class="line-numbers language-none"><code class="language-none">void f1();&#x2F;&#x2F; throw anything
void f2()throw(int)&#123;
    ...
    f1();
    ...
&#125;    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这下麻烦了，我们承诺了f2只会抛出int的意外，但是是事实f1会抛出一堆其他的意外！编译器不会帮助你检查这个事情，他默许了这样非法的行为。</p>
<p>​        同时，不要将template和 特殊异常一起使用！因为我们无法知道template会抛出什么异常，导致未定义行为的发生！</p>
<p>​        其二，如果A函数调用了B函数，若B没有特殊异常，A也不要有！但是很容易出错的：就是回调函数的问题：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef void(*CallBackPtr)(int X,int Y,void* dataToPassBack);

class CallBack&#123;
    public:
    	CallBack(CallBackPtr fPtr,void* dataToPassBack):
    		func(fPtr),data(dataToPassBack);
    void makeCallBack(int X,int Y)const throw();
    private:
    	CallBackPtr func;
    	void* data;
&#125;;

void CallBack::makeCallBack(int X,int Y)const throw()&#123;
    func(X,Y,data);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <code>makeCallBack</code>函数内部就违反了特殊异常，谁知道func里面抛出了什么异常呢？但是这就可以：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef void(*CallBackPtr)(int X,int Y,void* dataToPassBack) throw();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这样就强迫函数必须书写<code>throw()</code>后缀保证函数不会跑出任何异常！</p>
<p>​        还有其三：可以使用转化异常的方式防止出事情：</p>
<pre class="line-numbers language-none"><code class="language-none">class UnexpectedExeception&#123;&#125;;
void convertException()&#123;
    throw UnexpectedExeception();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样就好了！</p>
<h3 id="条款15：了解异常处理的代价"><a href="#条款15：了解异常处理的代价" class="headerlink" title="条款15：了解异常处理的代价"></a>条款15：了解异常处理的代价</h3><p>​        我的评价是简单的：一坨大便，下一个（）</p>
<p>​        好吧，异常处理是能少用就少用的：首先是程序开销巨大，其次：跳转使得程序逻辑结构不再清晰。完事！</p>
<h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="条款16：谨记-80-20-法则"><a href="#条款16：谨记-80-20-法则" class="headerlink" title="条款16：谨记 80 - 20 法则"></a>条款16：谨记 80 - 20 法则</h3><p>​        一个程序80%的资源用在20%的代码上。是的，80%的代码执行时间都花在那20%的代码上，80%的内存都被那20%的代码占去。。。当然，这就给我们的代码优化工作给出了重要的提示！也就是说，我们有必要把精力放在那20%的重要代码上去！</p>
<h3 id="条款17：考虑使用缓式评估"><a href="#条款17：考虑使用缓式评估" class="headerlink" title="条款17：考虑使用缓式评估"></a>条款17：考虑使用缓式评估</h3><p>​        啥意思，就是拖延战术！</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>​        考虑</p>
<pre class="line-numbers language-none"><code class="language-none">class String&#123;&#125;;
String s1 &#x3D; &quot;Hello&quot;;
String s2 &#x3D; s1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        急式评估，犹如我们大部分人干的那样，在运行时执行代码</p>
<pre class="line-numbers language-none"><code class="language-none">String s2 &#x3D; s1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        时，就立即去调用拷贝构造函数！快速的跑去复制成员和做其他的相关的操作。但事实上，我们也有可能就不会用到他——或者说，不必现在立刻马上的用到他，那为什么不做薄记工作，也就是等到什么时候用到了再说呢？这就是所谓的缓式评估。</p>
<p>​        当然，这里再强调一遍——缓式评估要求数据共享！也就是说——任何需要数据更改的操作，都必须做拷贝备份处理</p>
<h4 id="读还是写？"><a href="#读还是写？" class="headerlink" title="读还是写？"></a>读还是写？</h4><p>​        嘛，make a assumption that 我们要对一个字符串处理：</p>
<pre class="line-numbers language-none"><code class="language-none">std::string a &#x3D; &quot;111&quot;;
char a &#x3D; a[1]; &#x2F;&#x2F; just read the string
a[1] &#x3D; &#39;2&#39; &#x2F;&#x2F; probably make a copy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        显然成本不太一样——如果我们希望做一个备忘录的话，明眼人都知道第一个的工作量远小于第二个。</p>
<p>​        于是，有必要采取相关的行动——直到万不得已的时候，采取决定是怎样操作</p>
<h4 id="缓式读取"><a href="#缓式读取" class="headerlink" title="缓式读取"></a>缓式读取</h4><p>​        现在，我们需要从一个数据库读取一些非常大的东西——显然，直接把整个库扔过来（返回拷贝这件事情，嗯，开销太大了）是不合适的。于是，我们有必要先让程序带着空壳跑到需要数据的地方，再通过指针逐步返回完成工作！</p>
<h4 id="缓式表达式的评估"><a href="#缓式表达式的评估" class="headerlink" title="缓式表达式的评估"></a>缓式表达式的评估</h4><p>​        假设我们想要整一个——对，矩阵！两个1000 x 1000的矩阵相加！甚至相乘！</p>
<pre class="line-numbers language-none"><code class="language-none">class Mat&#123;
    Mat(int col, int row); &#x2F;&#x2F; init a matrix;
&#125;;

int main()&#123;
    
    Mat a(1000,1000);
    Mat b(1000,1000);
    c &#x3D; a + b;
    ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们要做1000 x 1000次加法！太疯狂了！但事实上，我们更多需要的可能只是里面的某一项，何不直接记录下，等到需要取的时候，根据需求来取呢？是这样的。</p>
<h3 id="条款18：分期摊还预期的计算成本"><a href="#条款18：分期摊还预期的计算成本" class="headerlink" title="条款18：分期摊还预期的计算成本"></a>条款18：分期摊还预期的计算成本</h3><p>​        辩证的——如果我们遵循机器式的——把一切程序的行为都设计成为缓式运算的话，有时也并不恰当。还有一些时候，急式评估是更好的！</p>
<p>​        这样的情况往往出现在程序的某一个Section下需要频繁的调用，可以先讲一些内容使用一些数据结果存储之。到时候就不必再去重新计算。</p>
<p>​        比如说，在一些程序中，我们应用DynamicArray 来存储数据，当发生存入比存储空间小的时候，不妨一次扩展更多的空间而不是一次就扩展一个，毕竟，大概率下你要存储的东西会比较大的多出原来的空间，不妨开辟更多的元素，防止扩展函数被频繁的调用。</p>
<p>​        可以预见的是——这样的策略往往会要求更多的内存！于是，将条款17和18都好好应用于结合是必要的！</p>
<h3 id="条款19：了解临时对象的产生"><a href="#条款19：了解临时对象的产生" class="headerlink" title="条款19：了解临时对象的产生"></a>条款19：了解临时对象的产生</h3><p>​        下面来看一个通用的Swap函数：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;
void swap(T&amp; object1, T&amp; object2)&#123;
    T temp &#x3D; object1;
    object1 &#x3D; object2;
    object2 &#x3D; temp;
&#125;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们习惯上称呼temp是一个临时对象，但事实上它是函数的一个局部对象.而运作产生一个临时对象可能并不会提升程序性能。于是我们在程序运转上，可以考虑“返回值优化”。</p>
<h3 id="条款20：完成返回值优化工作"><a href="#条款20：完成返回值优化工作" class="headerlink" title="条款20：完成返回值优化工作"></a>条款20：完成返回值优化工作</h3><p>​        函数如果返回对象的话，往往会对程序的性能造成巨大的损伤。下面我们来看一个例子，和程序设计时常见的误区：</p>
<pre class="line-numbers language-none"><code class="language-none">class Rational&#123;
    public:
    	Rational(int numerator &#x3D; 0, int denominator &#x3D; 1);
    ...
        int numerator() const;
    	int denominator() const;
&#125;

const Rational operator*(const Rational&amp; lhs,const Rational&amp; rhs);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        好吧，我们大部分真是竭力的不让他返回值：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; sometime we are trying to return a pointer to the value in heap
const Rational* operator*(const Rational&amp; lhs,const Rational&amp; rhs);
Rational a &#x3D; 10;
Rational b(1, 2);
Rational c &#x3D; *(a * b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        看起来不错，但是有一个问题——用户程序员会记得删除它嘛？不删除则是会导致内存泄漏的！</p>
<p>​        于是还有人写出了更加危险的写法：</p>
<pre class="line-numbers language-none"><code class="language-none">const Rational&amp; operator*(const Rational&amp; lhs,const Rational&amp; rhs)&#123;
    Ratioanl result &#x3D; (lhs.numerator()*rhs.numerator().lhs.denominator()*rhs.denominator());
    
    return result;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        恭喜你返回了一具尸体，让程序在未定义的路上一路狂奔。好吧，有一些程序，我们是不得不返回对象的。所以——</p>
<pre class="line-numbers language-none"><code class="language-none">const Rational operator*(const Rational&amp; lhs,const Rational&amp; rhs)&#123;
    return Rational(lhs.numerator()*rhs.numerator().lhs.denominator()*rhs.denominator());
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        这样，你就不必担心释放的问题了！</p>
<h1 id="More-effective-C-2"><a href="#More-effective-C-2" class="headerlink" title="More effective C++2"></a>More effective C++2</h1><h2 id="条款22-考虑以操作符复合形式（op-）来取代独身形式"><a href="#条款22-考虑以操作符复合形式（op-）来取代独身形式" class="headerlink" title="条款22 考虑以操作符复合形式（op=）来取代独身形式"></a>条款22 考虑以操作符复合形式（op=）来取代独身形式</h2><p>​        对于大部分的程序员，他们希望——</p>
<pre class="line-numbers language-none"><code class="language-none">x &#x3D; x + y;
x &#x3D; x - y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        的同时</p>
<pre class="line-numbers language-none"><code class="language-none">x +&#x3D; y;
x -&#x3D; y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        的形式也可以被接受。</p>
<p>​        为了让复合形式和独身形式都可以很好的运作——我们选则：让前者作为基础来实现</p>
<pre class="line-numbers language-none"><code class="language-none">class Rational&#123;
    public:
    	Rational&amp; operator+&#x3D;(const Rational&amp; rhs);
    	Rational&amp; operator-&#x3D;(const Rational&amp; rhs);
&#125;

const Rational operator+(const Rational&amp; lhs,const Rational&amp; rhs)&#123;
    return Rational(lhs) +&#x3D; rhs;
&#125;

const Rational operator-(const Rational&amp; lhs,const Rational&amp; rhs)&#123;
    return Rational(lhs) -&#x3D; rhs;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样的话，我们就只需要维护符合操作符就好了。</p>
<p>​        事实上，为了扩展性更强一些，我们一般的使用模板来完成通用化的工作：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;
const T operator+(const T&amp; lhs,const T&amp; rhs)&#123;
    return T(lhs) +&#x3D; rhs;
&#125; 
template&lt;class T&gt;
const T operator-(const T&amp; lhs,const T&amp; rhs)&#123;
    return T(lhs) -&#x3D; rhs;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是现在为止我们都没有考虑效率的问题。</p>
<p>​        注意到复合操作类型不会花费时间构造一个巨大的对象返回。于是我们这样的设计可以让客户程序员选择效率与方便维护中二选一：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 易于维护的
Rational a,b,c,d,result;
result &#x3D; a + b + c + d;

&#x2F;&#x2F; 追求效率的
result &#x3D; a;
result +&#x3D; b;
result +&#x3D; c;
result +&#x3D; d;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        程序的灵活性更好了！</p>
<h2 id="条款23：考虑使用其他库"><a href="#条款23：考虑使用其他库" class="headerlink" title="条款23：考虑使用其他库"></a>条款23：考虑使用其他库</h2><h2 id="条款24：了解virtual-functions-multiple-functions-virtual-base-classes-runtime-type-identification的成本"><a href="#条款24：了解virtual-functions-multiple-functions-virtual-base-classes-runtime-type-identification的成本" class="headerlink" title="条款24：了解virtual functions, multiple functions, virtual base classes runtime type identification的成本"></a>条款24：了解virtual functions, multiple functions, virtual base classes runtime type identification的成本</h2><p>​        当一个虚函数被调用，执行的代码必须对应于调用者的动态类型。我们的编译器可以做到虚函数的处理得益于 virtual table 或 virtual table pointers</p>
<p>​        我们的vtbl 通常是函数指针架构产生的数组。</p>
<p>比如：</p>
<pre class="line-numbers language-none"><code class="language-none">class C1&#123;
    public:
    	C1();
    	virtual ~C1();
    	virtual void f1();
    	void f4() const;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230527133400105.png?lastModify=1685936981" alt="image-20230527133400105"></p>
<p>​        现在，一旦我们的子类继承了父类，并且自己重新实现了一些虚函数，那么——C2（假使它继承了C1）这张虚函数表的新改写函数就会换成子类自己的！</p>
<p>​        避免将虚函数声明为内联的inline,编译器也会自动忽视之。下面我会提到为什么</p>
<p>​        当然，只有虚函数表是不够的——我们的类中往往会增加一个函数数组指针，指向这个表！一旦发生继承，这个表就会被一大堆成员包围。</p>
<p>​        下面来看对于体系类的虚函数调用。还是回到C1，C2类的表</p>
<pre class="line-numbers language-none"><code class="language-none">void makeACall(C1* pC1)&#123;
	pC1()-&gt;f1();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        如果我们只看这点代码，完全不知道程序运行时会调用哪一段代码。编译器是这样处理的：</p>
<ol>
<li><p>根据对象的vptr 找到 vtbl</p>
</li>
<li><p>找到被调用的函数在vtbl的指针，然后调用之。</p>
<pre class="line-numbers language-none"><code class="language-none">(*pC1-&gt;vptr[i])(pC1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p> 你瞧！只有在运行的时候我们才会直到究竟是哪个！而inline跟virtual的设计理念完全冲突！这就是为什么不要给虚函数添加inline!</p>
</li>
</ol>
<p>​        下面考虑多重继承（相当恐怖的）</p>
<p>​        这是一个菱形继承：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230527134602652.png?lastModify=1685936981" alt="image-20230527134602652"></p>
<p>​        现在，我们视A作为最基本的类：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230527134822239.png?lastModify=1685936981" alt="image-20230527134822239"></p>
<p>​        当A内有任何一点虚函数</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230527134941853.png?lastModify=1685936981" alt="image-20230527134941853"></p>
<p>​        我们看到了虚函数是如何使得对象变大的了</p>
<p>​        RTTI作为运行时获取对象类型，一个class只需要一个就可以了。我们在vtbl的开头加上一个 type_info对象就可以帮助识别。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>性质</th>
<th>对象大小</th>
<th>Class数据量增加</th>
<th>内联几率降低</th>
</tr>
</thead>
<tbody>
<tr>
<td>虚函数</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>多重继承</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>虚拟基类</td>
<td>往往如此</td>
<td>有时候</td>
<td>否</td>
</tr>
<tr>
<td>RTTI</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
</tbody>
</table>
</div>
<h2 id="条款25：将构造函数和非成员函数虚化"><a href="#条款25：将构造函数和非成员函数虚化" class="headerlink" title="条款25：将构造函数和非成员函数虚化"></a>条款25：将构造函数和非成员函数虚化</h2><p>​        我们有必要将构造函数和非成员函数虚化——这是因为我们之间有关系的类可以做到一个构造函数完成更多的事情。而且更加的省精力。</p>
<p>​        构造函数的虚化有助于我们在实际调用的时候返回期望对象的构造函数！</p>
<h2 id="条款26-限制某个class所能产生的对象数量"><a href="#条款26-限制某个class所能产生的对象数量" class="headerlink" title="条款26 限制某个class所能产生的对象数量"></a>条款26 限制某个class所能产生的对象数量</h2><h3 id="允许0个或者1-个对象产出"><a href="#允许0个或者1-个对象产出" class="headerlink" title="允许0个或者1 个对象产出"></a>允许0个或者1 个对象产出</h3><p>​        阻止一个类的产生的最简单的方法就是把构造器放private里面。</p>
<p>​        那一个呢？配合static和接口函数！</p>
<pre class="line-numbers language-none"><code class="language-none">class PrinterJob;
class Printer&#123;
    public:
    	void submitJob(const PrinterJob&amp; job);
    	void reset();
    	void performSelfTest();
    	friend Printer&amp; thePrinter();
    private:
    	Printer();
    	Printer(const Printer&amp; rhs);
    	...
&#125;

Printer&amp; thePrinter()
&#123;
    static Printer p;
    return p;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样一调用，我们就总是调用那个在静态区的变量。</p>
<p>​        我们也可以把这一大堆东西放到namespace里去，防止冲突！</p>
<p>​        有一个细节：我们为什么不把这个函数：</p>
<pre class="line-numbers language-none"><code class="language-none">Printer&amp; thePrinter()
&#123;
    static Printer p;
    return p;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        设置成inline呢？答案是，防止被复制——因为我们把调用函数这个动作直接改成执行代码，这就意味着——这个对象可能会被复制！不要在带有locale static对象的函数中内联！</p>
<p>​        注意，<strong>一个构造函数是private 的类是不允许被继承的！</strong>（没办法显著的调用构造器）于是，<strong>避免一个具体类继承另一个具体类！</strong></p>
<h3 id="允许对象生生灭灭"><a href="#允许对象生生灭灭" class="headerlink" title="允许对象生生灭灭"></a>允许对象生生灭灭</h3><p>​        注意到：</p>
<pre class="line-numbers language-none"><code class="language-none">create Printer object p1;
use p1;
delete p1;
create Printer object p2;
use p2;
delete p2;
create Printer object p3;
use p3;
delete p3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样的事情不违反只允许一个对象！但是却不被允许，那么我们有必要整一个新办法</p>
<p>​        我们加上一个计数器就好了：</p>
<pre class="line-numbers language-none"><code class="language-none">class Printer&#123;
	public:
    	class TooManyObj&#123;&#125;;
    	static Printer* makePrinter();
    	~Printer();
    	void submitJob(const PrinterJob&amp; job);
    	void reset();
    	void performSelfTest();
    
    private:
    	static size_t numObjects;
    	static size_t numObjects &#x3D; 10;
    	Printer();
    	Printer(const Printer&amp; rhs);
&#125;

	size_t Printer::numObjects &#x3D; 0;
	Printer::Printer()&#123;
        if(numObjects &gt;&#x3D; max_obj)&#123;
            throw TooManyObj();
        &#125;
        ...
        ++numObjects;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        也有程序员使用专门计数的类！但这里就不再展开了。</p>
<h3 id="判断对象在哪里（在不在heap-）"><a href="#判断对象在哪里（在不在heap-）" class="headerlink" title="判断对象在哪里（在不在heap?）"></a>判断对象在哪里（在不在heap?）</h3><p>​        不应当直接在class里声明一个bool变量，然后塞到operator new这个函数下，因为：</p>
<pre class="line-numbers language-none"><code class="language-none">UPNumber* numArr &#x3D; new UPNumber[100];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这下坏了，编译器可能是：先调用operator new在调用构建器！（先开空间，在初始化，我们上面的办法就失效了！）</p>
<p>​        于是，不妨使用计组学的特性?</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230527142543682.png?lastModify=1685936981" alt="image-20230527142543682"></p>
<p>​        可以给出这样的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">bool onHeap(const void* addr)&#123;
	char onStack;
    return address &lt; &amp;onTheStack
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是别忘了，我们还有静态区！它无法区分和heap对象和static对象！</p>
<p>​        事实上，没有通用的办法！</p>
<h3 id="静止对象产生在heap上"><a href="#静止对象产生在heap上" class="headerlink" title="静止对象产生在heap上"></a>静止对象产生在heap上</h3><p>​        很简单了：直接把operator new 和operator delete直接扔到私有区！</p>
<h2 id="条款27：auto-ptr"><a href="#条款27：auto-ptr" class="headerlink" title="条款27：auto_ptr"></a>条款27：auto_ptr</h2><p>​        <strong>智能指针主要用于动态内存的管理,同时提供给用户与内置指针一样的使用方法,本条款主要涉及智能指针在构造与析构,复制和赋值,解引等方面的注意点,而非智能指针的实现细节.</strong></p>
<h3 id="智能指针的构造-赋值-析构"><a href="#智能指针的构造-赋值-析构" class="headerlink" title="智能指针的构造,赋值,析构"></a>智能指针的构造,赋值,析构</h3><pre class="line-numbers language-none"><code class="language-none">智能指针的copy constructor,assignment operator,destructor对应于不同的观念而有不同的实现,主要有三种选择:

不允许对象的共享,在调用copy constructor和assignment时转移对象所有权,这样在调用destructor时就可以直接delete智能指针内含的内置指针,如标准库的auto_ptr,其实现可能像这样:
template&lt;class T&gt;
class auto_ptr &#123;
public:
    ...
    auto_ptr(auto_ptr&lt;T&gt;&amp; rhs); 
    auto_ptr&lt;T&gt;&amp;  operator&#x3D;(auto_ptr&lt;T&gt;&amp; rhs); 
    ...
&#125;;
template&lt;class T&gt;
auto_ptr&lt;T&gt;::auto_ptr(auto_ptr&lt;T&gt;&amp; rhs)
&#123;
    pointee &#x3D; rhs.pointee; 
    rhs.pointee &#x3D; 0; &#x2F;&#x2F; 转移对象所有权
&#125; 
template&lt;class T&gt;
auto_ptr&lt;T&gt;&amp; auto_ptr&lt;T&gt;::operator&#x3D;(auto_ptr&lt;T&gt;&amp; rhs)
&#123;
    if (this &#x3D;&#x3D; &amp;rhs) &#x2F;&#x2F; 自我赋值的情况
        return *this; 
    delete pointee; 
    pointee &#x3D; rhs.pointee; &#x2F;&#x2F; 转移对象所有权
    rhs.pointee &#x3D; 0; 
    return *this;
&#125;
	值得注意的是,由于auto_ptr的copy constructor被调用时,对象所有权便转移了,像这样:
void printTreeNode(ostream&amp; s, auto_ptr&lt;TreeNode&gt; p)
&#123; s &lt;&lt; *p; &#125;
int main()&#123;
    auto_ptr&lt;TreeNode&gt; ptn(new TreeNode);
    ...
    printTreeNode(cout, ptn); &#x2F;&#x2F;通过传值方式传递auto_ptr
    ...
&#125;
	调用printTreeNode后,ptn所指向的内存便被释放,内含的内置指针也被置为0,但这并不符合用户的预期.这说明不能使用pass-by-value的方式传递auto_ptr给函数,只能使用pass-by-reference.

	使用这种策略实现的智能指针的destructor可能像这样:
template&lt;class T&gt;
SmartPtr&lt;T&gt;::~SmartPtr()
&#123;
    if (*this owns *pointee) &#123;
        delete pointee;
    &#125;
&#125;
2). 不允许对象的共享,调用copy constructor和assignment operator时进行深度拷贝——产生新对象.这种设计思想较简单,缺点也较明显:新对象的产生需要消耗资源.这里不再讨论

3). 允许对象的共享,使用引用计数,调用copy constructor和assignment operator增加引用计数的个数.当引用计数的个数为0时便析构对象并释放内存,如标准库的shared_ptr,关于引用计数的具体实现见[条款29](http:&#x2F;&#x2F;i.cnblogs.com&#x2F;PostDone.aspx?postid&#x3D;4857432&amp;actiontip&#x3D;存为草稿成功).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实现Dereference-Operators-解引操作符"><a href="#实现Dereference-Operators-解引操作符" class="headerlink" title="实现Dereference Operators(解引操作符)"></a>实现Dereference Operators(解引操作符)</h3><pre class="line-numbers language-none"><code class="language-none">主要讨论operator*和operator-&gt;的实现,前者放回所指对象的引用,像这样:
template&lt;class T&gt;
T&amp; SmartPtr&lt;T&gt;::operator*() const
&#123;
    perform &quot;smart pointer&quot; processing;
    return *pointee;
&#125;
如果程序采用了lazy fetching(见[条款17](http:&#x2F;&#x2F;www.cnblogs.com&#x2F;reasno&#x2F;p&#x2F;4830677.html))策略,就有可能需要为pointers变换出一个新对象.需要注意的是,operator*返回的是引用,如果返回对象,可能会产生由于SmartPtr指向的是T的派生类对象而非T类对象而造成的切割问题.

operator-&gt;和operator*类似,operator-&gt;返回指针.

对于使用引用计数的shared_ptr,问题还未停止,它允许多个智能指针共享相同对象,但前提是这些指针所指向的对象相同.由于operator*和operator-&gt;返回所指对象的引用和指针,这可能导致其所指对象被更改,但原则上共享同一块内存的其他智能指针却要求所指对象保持不变.因此有必要在调用operator*和operator-&gt;的时候开辟一块新内存,使调用operator*和operator-&gt;的智能指针指向这块新内存以防止共享内存被篡改,像这样:
template&lt;class T&gt;
T&amp; SmartPtr&lt;T&gt;::operator*() const&#123;
    if(number of reference!&#x3D;1)&#123;
        pointee&#x3D;new T(*pointee);
        --reference number of the old object;
        set the reference number of the new object to 1; 
    &#125;
    return *pointee;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="测试Smart-Pointers是否为Null"><a href="#测试Smart-Pointers是否为Null" class="headerlink" title="测试Smart Pointers是否为Null"></a>测试Smart Pointers是否为Null</h3><pre class="line-numbers language-none"><code class="language-none">直接的策略是定义隐式转换操作符operator void*,使得以下操作可以通过编译:
if (ptn &#x3D;&#x3D; 0) ... &#x2F;&#x2F; 正确
if (ptn) ... &#x2F;&#x2F; 正确
if (!ptn) ... &#x2F;&#x2F;正确
但隐式转换操作符很容易被滥用,它使得不同类型的指针可以相比较,以下代码可以通过编译:
SmartPtr&lt;Apple&gt; pa;
SmartPtr&lt;Orange&gt; po;
...
if (pa &#x3D;&#x3D; po) ...&#x2F;&#x2F;可以通过编译
尽管pa和po是不同类型的智能指针,但由于没有定义Smart&lt;Apple&gt;和Smart&lt;Orange&gt;为参数的operator&#x3D;&#x3D;,因此编译器默认调用operator void*,使得以上代码通过编译.

一种差强人意的方法是允许测试null,但使用!操作符,如果内置指针为null,便返回true,客户端要测试智能指针是否为null,就要像这样:
SmartPtr&lt;TreeNode&gt; ptn;
...
if (!ptn) &#123; 
    ...
&#125;
else &#123;
    ... 
&#125;
但以下做法却被禁止:
if (ptn &#x3D;&#x3D; 0) ... 
if (ptn) ...
&#96;iostream&#96;程序库不仅允许隐式类型转换&#96;void*&#96;,还提供&#96;operator!&#96; ,C++标准库中,&quot;隐式转换为void*&quot;已被&quot;隐式转换为bool&quot;取代,而operator bool总是返回operator!的反.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="将Smart-Pointers转换为Dumb-Pointers"><a href="#将Smart-Pointers转换为Dumb-Pointers" class="headerlink" title="将Smart Pointers转换为Dumb Pointers"></a>将Smart Pointers转换为Dumb Pointers</h3><pre class="line-numbers language-none"><code class="language-none">有时要兼容并未使用智能指针的程序库,就要允许智能指针到内置指针的转换,直接的思路还是隐式转换操作符:
template&lt;class T&gt;
class DBPtr &#123;
public:
    ...
    operator T*() &#123; return pointee; &#125;
    ...
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  但是正如多次强调的,隐式转换操作符很容易被滥用,它使得客户可以轻易获得内置指针,从而绕过智能指针的控制,像这样:</p>
<pre class="line-numbers language-none"><code class="language-none">class Tuple&#123;...&#125;;
void processTuple(DBPtr&lt;Tuple&gt;&amp; pt)
&#123;
    Tuple *rawTuplePtr &#x3D; pt; &#x2F;&#x2F; 得到内置指针
    use rawTuplePtr to modify the tuple
&#125;
	像这样的操作也会被通过:
DBPtr&lt;Tuple&gt; pt&#x3D;new Tuple;
delete pt;&#x2F;&#x2F;通过,执行隐式类型转换
	但这几乎肯定会造成错误,因为pt的析构函数执行时可能再次delete同一块内存.

	此外,对于采用引用计数的实现版本来说,&quot;允许clinets直接使用dumb pointers&quot;往往会导致导致簿记方面的错误,造成严重后果,

	即使实现了隐式转换操作符,但它还是不能做到提供和内置指针完全一样的行为,因为编译器禁止连续隐式调用自定义的隐式类型转换,像这样的使用会失败:
class TupleAccessors &#123;
public:
    TupleAccessors(const Tuple *pt); &#x2F;&#x2F; Tuple到TupleAccessor的转换
    ... 
&#125;;
TupleAccessors merge(const TupleAccessor&amp; ta1,const TupleAccessors&amp; ta2);
DBPtr&lt;Tuple&gt; pt1, pt2;
...
merge(pt1,pt2);&#x2F;&#x2F;调用会出错
	尽管&#96;DBPtr&lt;Tuple&gt;&#96;到&#96;Tuple*&#96;再到&#96;TupleAccessor&#96;的转换就可以匹配merge的参数,但编译器禁止这么做.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​          解决方法是使用普通成员函数进行显式转换以代替隐式转换操作符,像这样:</p>
<pre class="line-numbers language-none"><code class="language-none">class DBPtr &#123;
public:
    ...
    T* toPrimary() &#123; return pointee; &#125;
    ...
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Smart-Pointers和”与继承有关的”类型转换"><a href="#Smart-Pointers和”与继承有关的”类型转换" class="headerlink" title="Smart Pointers和”与继承有关的”类型转换"></a>Smart Pointers和”与继承有关的”类型转换</h3><pre class="line-numbers language-none"><code class="language-none">	两个类之间有继承关系,但以这两个类为参数具现化的类模板却没有继承关系,由于智能指针是类模板,因此智能指针的包装会屏蔽内置指针的继承关系,例如对于以下继承层次:
class MusicProduct &#123;
public:
    MusicProduct(const string&amp; title);
    virtual void play() const &#x3D; 0;
    virtual void displayTitle() const &#x3D; 0;
    ...
&#125;;
class Cassette: public MusicProduct &#123;
public:
    Cassette(const string&amp; title);
    virtual void play() const;
    virtual void displayTitle() const;
    ...
&#125;;
class CD: public MusicProduct &#123;
public:
    CD(const string&amp; title);
    virtual void play() const;
    virtual void displayTitle() const;
    ...
&#125;
void displayAndPlay(const MusicProduct* pmp, int numTimes)
&#123;
    for (int i &#x3D; 1; i &lt;&#x3D; numTimes; ++i) &#123;
    pmp-&gt;displayTitle();
    pmp-&gt;play();
&#125;
 整个继承体系像这样:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/699942-20151006212730503-151239962.png?lastModify=1685936981" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">由于各个类的继承关系,可以利用指针的多态实现面向对象编程,像这样:
Cassette *funMusic &#x3D; new Cassette(&quot;Alapalooza&quot;);
CD *nightmareMusic &#x3D; new CD(&quot;Disco Hits of the 70s&quot;);
displayAndPlay(funMusic, 10);
displayAndPlay(nightmareMusic, 0);
但当指针经过封装成为智能指针之后,正如开始所说,以下代码将无法通过编译：
void displayAndPlay(const SmartPtr&lt;MusicProduct&gt;&amp; pmp,int numTimes);
SmartPtr&lt;Cassette&gt; funMusic(new Cassette(&quot;Alapalooza&quot;));
SmartPtr&lt;CD&gt; nightmareMusic(new CD(&quot;Disco Hits of the 70s&quot;));
displayAndPlay(funMusic, 10); &#x2F;&#x2F; 错误!
displayAndPlay(nightmareMusic, 0); &#x2F;&#x2F; 错误!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是由于<code>MusicProduct,Cassette,CD</code>之间有继承关系,但智能指<code>SmartPtr&lt;MusicProduct&gt;,SmartPtr&lt;Cassette&gt;,SmartPtr&lt;CD&gt;</code>之间却没有内在的继承关系.</p>
<pre class="line-numbers language-none"><code class="language-none">	最直接的解决方法是为每一个智能指针类定义一个隐式类型转换操作符,像这样:
class SmartPtr&lt;Cassette&gt; &#123;
public:
    operator SmartPtr&lt;MusicProduct&gt;()
    &#123; return SmartPtr&lt;MusicProduct&gt;(pointee); &#125;
    ...
private:
    Cassette *pointee;
&#125;;
class SmartPtr&lt;CD&gt; &#123;
public:
    operator SmartPtr&lt;MusicProduct&gt;()
    &#123; return SmartPtr&lt;MusicProduct&gt;(pointee); &#125;
    ...
private:
    CD *pointee;
&#125;;
这种方法可以解决类型转换的问题,但是却治标不治本:一方面,必须为每一个智能指针实例定义隐式类型转换操作符,这无疑与模板的初衷背道相驰;另一方面,类的继承层次可能很庞大,采用以上方式,继承层次的最底层类的负担将会非常大——必须为对象直接或间接继承的每一个基类提供隐式类型转换操作符.

	&quot;将nonvirtual member function声明为templates&quot;是C++后来接入的一个性质,使用它可以从根本上解决饮食类型转换的问题,像这样:
template&lt;class T&gt; 
class SmartPtr &#123; 
public:
    SmartPtr(T* realPtr &#x3D; 0);
    T* operator-&gt;() const;
    T&amp; operator*() const;
    template&lt;class newType&gt; &#x2F;&#x2F; 模板成员函数
    operator SmartPtr&lt;newType&gt;() 
    &#123;
        return SmartPtr&lt;newType&gt;(pointee);
    &#125;
    ...
&#125;;
	这个成员函数模板将智能指针之间的隐式类型转换交由底层内置指针来完成,保证了指针转换的&quot;原生态&quot;:如果底层指针能够转换,那么包装后的智能指针也能够进行转换.唯一的缺点是它是通过指针之间的隐式类型转换来实现指针的多态,也就是说,它实际上并不能区分对象之间的继承层次,假如扩充MusicProduct的继承体系,加上一个新的CasSingle class,像这样:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/699942-20151006213007737-1835434124.png?lastModify=1685936981" alt="img"> </p>
<p>  那么对于以下代码:</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/ContractedBlock.gif?lastModify=1685936981" alt="img"> <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/ExpandedBlockStart.gif?lastModify=1685936981" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;
class SmartPtr &#123; ... &#125;; 
void displayAndPlay(const SmartPtr&lt;MusicProduct&gt;&amp; pmp,
int howMany);
void displayAndPlay(const SmartPtr&lt;Cassette&gt;&amp; pc,
int howMany);
SmartPtr&lt;CasSingle&gt; dumbMusic(new CasSingle(&quot;Achy Breaky Heart&quot;));
displayAndPlay(dumbMusic, 1);&#x2F;&#x2F;错误，隐式类型转换函数的调用具有二义性
正如之前所言,使用隐式类型转换操作符实现的指针多态并不能区分对象的继承层次,也就是说将SmartPtr&lt;CasSingle&gt;转为SmartPtr&lt;Cassette&gt;&amp;和转为SmartPtr&lt;MusicProduct&gt;&amp;具有同样的优先级,因此造成二义性.而内置指针却能做到这一点,它优先将CasSingle绑定到Cassette&amp;,因为CaSingle直接继承自Cassette.此外,以上策略还有移植性不高的缺点:有些编译器可能并不支持member templates.

对于内置指针,const修饰的含义因其位置而不同:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">CD goodCD(&quot;Flood&quot;);
const CD *p; &#x2F;&#x2F; p 是一个non-const 指针,指向 const CD 对象
CD * const p &#x3D; &amp;goodCD; &#x2F;&#x2F; p 是一个const 指针,指向non-const CD 对象;因为 p 是const,它必须在定义时就被初始化
const CD * const p &#x3D; &amp;goodCD; &#x2F;&#x2F; p 是一个const 指针,指向一个 const CD 对象
	但对于智能指针,只有一个地方可以放置const,因此cosnt只能施行于指针之上,而不能施行于指针所指对象之上:
const SmartPtr&lt;CD&gt; p&#x3D;&amp;goodCD;
	要是const修饰所值对象很简单,像这样:
SmartPtr&lt;const CD&gt; p&#x3D;&amp;goodCD;
	 由此方法可以实现和内置指针相同的四种指针:
SmartPtr&lt;CD&gt; p; &#x2F;&#x2F; non-const 对象, non-const 指针
SmartPtr&lt;const CD&gt; p; &#x2F;&#x2F; const 对象,non-const 指针
const SmartPtr&lt;CD&gt; p &#x3D; &amp;goodCD; &#x2F;&#x2F; non-const 对象,const 指针
const SmartPtr&lt;const CD&gt; p &#x3D; &amp;goodCD; &#x2F;&#x2F; const 对象,const 指针
	但这种方法仍有缺陷,正如经由模板包装之后,有继承关系的两个类完全没有关系一样,经由智能指针模板包装后的const和non-const对象完全不同,像这样看起来理所当然的代码通不过编译:
SmartPtr&lt;CD&gt; pCD &#x3D; new CD(&quot;Famous Movie Themes&quot;);
SmartPtr&lt;const CD&gt; pConstCD &#x3D; pCD;
	使用之前的隐式类型转换技术可以顺带解决这个问题,但又有所区别:const与non-const的转换是单向的,即可以对const指针做的事也可以对non-const指针进行,但可以对non-const指针做的事未必可以对const指针进行.这与public继承类似,利用这种性质,令每一个smart pointer-to-T-class public继承一个对应的smart pointer-to-const-T class:
template&lt;class T&gt; &#x2F;&#x2F; 指向const 对象的
class SmartPtrToConst &#123;
protected:
    union &#123;
        const T* constPointee; &#x2F;&#x2F; 提供给SmartPtrToConst 访问
        T* pointee; &#x2F;&#x2F; 提供给SmartPtr 访问
    &#125;;
&#125;;
template&lt;class T&gt; 
class SmartPtr: public SmartPtrToConst&lt;T&gt; &#123;
public:
    template&lt;class constType&gt;
    operator SmartPtrToConst&lt;constType&gt;();
    ... &#x2F;&#x2F;没有额外数据成员
&#125;;
	SmartPtrToConst使用了union,这样constPointee和pointee共享同一块内存SmartPtrToConst使用constPointee,SmartPtr使用pointee.

	 现在,使用SmartPtrToConst和SmartPtr分别代表指向const和non-const对象的智能指针,以下代码可以通过编译:
SmartPtr&lt;CD&gt; pCD &#x3D; new CD(&quot;Famous Movie Themes&quot;);
SmartPtrToConst&lt;CD&gt; pConstCD &#x3D; pCD;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>\8. 从2-7的讨论可以看出,智能指针功能强大,但索要付出的代价也很高,此外,智能指针无论如何也不能完全替代内置指针.当然,尽管内置指针在实现和维护方面需要大量技巧,但与其强大的功能相比在多数情况下还是值得的.</p>
<h2 id="条款28：引用计数"><a href="#条款28：引用计数" class="headerlink" title="条款28：引用计数"></a>条款28：引用计数</h2><p>​        引用计数是这样一个技巧，它允许多个有相同值的对象共享这个值的实现。这个技巧有两个常用动机。第一个是简化跟踪堆中的对象的过程。一旦一个对象通过调用new被分配出来，最要紧的就是记录谁拥有这个对象，因为其所有者－－并且只有其所有者－－负责对这个对象调用delete。但是，所有权可以被从一个对象传递到另外一个对象（例如通过传递指针型参数），所以跟踪一个对象的所有权是很困难的。象auto_ptr（见Item M9）这样的类可以帮助我们，但经验显示大部分程序还不能正确地得到这样的类。引用计数可以免除跟踪对象所有权的担子，因为当使用引用计数后，对象自己拥有自己。当没人再使用它时，它自己自动销毁自己。因此，引用计数是个简单的垃圾回收体系。</p>
<p>​        第二个动机是由于一个简单的常识。如果很多对象有相同的值，将这个值存储多次是很无聊的。更好的办法是让所有的对象共享这个值的实现。这么做不但节省内存，而且可以使得程序运行更快，因为不需要构造和析构这个值的拷贝。</p>
<p>​        和大部分看似简单的主意一样，这个动机也有一个曲折而有趣的细节。在其中必须有一个正确实现的引用计数体系。在开始钻研细节前，让我们掌握一些基础。一个好主意是先着眼于我们将可能如何遇到多个对象有相同的值。这儿有一个：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;                     &#x2F;&#x2F; the standard string type may

	public:                            &#x2F;&#x2F; employ the techniques in this Item, but that is not required
  		String(const char *value &#x3D; &quot;&quot;);
  		String&amp; operator&#x3D;(const String&amp; rhs);
		...

	private:
  		char *data;
&#125;;
String a, b, c, d, e;
a &#x3D; b &#x3D; c &#x3D; d &#x3D; e &#x3D; &quot;Hello&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        看起来，对象a到e都有相同的值“Hello”。其值的形态取决于String类是怎么实现的，但通常的实现是每个string对象有一个这个值的拷贝。例如，String的赋值操作可能实现为这样：</p>
<pre class="line-numbers language-none"><code class="language-none">String&amp; String::operator&#x3D;(const String&amp; rhs)
&#123;
  if (this &#x3D;&#x3D; &amp;rhs) return *this;         &#x2F;&#x2F; see Item E17

  delete [] data;

  data &#x3D;   new char[strlen(rhs.data) + 1];

  strcpy(data, rhs.data);

  return *this;                           &#x2F;&#x2F; see Item E15

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据这个实现，我们可以推测，这5个对象及其值如下：</p>
<p> <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/20191114165634252.png?lastModify=1685936981" alt="img"></p>
<p>其冗余是显然的。在一个理想的世界中，我们希望将上图改为这样：</p>
<p> <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/20191114165703168.png?lastModify=1685936981" alt="img"></p>
<p>​        这里，只存储了一个“Hello”的拷贝，所有具有此值的String对象共享其实现。</p>
<p>​        实际世界中，实现这个主意是不可能的，因为我们需要跟踪多少对象共享同一个值。如果上面的对象a被赋了“Hello”以外的另外一个值，我们不能摧毁值“Hello”，因为还有四个对象需要它。另一方面，如果只有一个对象有“Hello”这个值，当其超出生存空间时，没有对象具有这个值了，我们必须销毁这个值以避免资源泄漏。</p>
<p>​        保存当前共享/引用同一个值的对象数目的需求意味着我们的那张图必须增加一个计数值（引用计数）：</p>
<p> <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/2019111416593759.png?lastModify=1685936981" alt="img"></p>
<p>​        （有些人将其叫作use count，但我不是其中之一。C++有很多它自己的特性，最后需要的一个是专业名词的派别之争。）</p>
<p>​        创建一个带引用计数的String类并不困难，但需要注意一些细节，所以我们将略述这样一个类的大部分常用成员函数的实现。然而，在开始之前，认识到“我们需要一个地方来存储这个计数值”是很重要的。这个地方不能在String对象内部，因为需要的是每个String值一个引用计数值，而不是每个String对象一个引用计数。这意味着String值和引用计数间是一一对应的关系，所以我们将创建一个类来保存引用计数及其跟踪的值。我们叫这个类StringValue，又因为它唯一的用处就是帮助我们实现String类，所以我们将它嵌套在String类的私有区内。另外，为了便于Sting的所有成员函数读取其数据区，我们将StringValue申明为struct。需要知道的是：将一个struct内嵌在类的私有区内，能便于这个类的所有成员访问这个结构，但阻止了其它任何人对它的访问（当然，除了友元）。</p>
<p>​        基本设计是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;
public:

  ... &#x2F;&#x2F; the usual String member
&#x2F;&#x2F; functions go here

private:

  struct StringValue &#123; ... &#125;;        &#x2F;&#x2F; holds a reference count and a string value

  StringValue *value;                &#x2F;&#x2F; value of this String

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们可以给这个类起个其它名字（如RCString）以强调它使用了引用计数，但类的实现不该是类的用户必须关心的东西，用户只关心类的公有接口。而我们带引用计数的String版本与不带引用计数的版本，其接口完全相同，所以为什么要用类的名字来把问题搅混呢？真的需要吗？所以我们没有这么做。</p>
<p>​        这是StringValue的实现：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;
	private:
	struct StringValue &#123;
  		int refCount;
  		char *data;
  		StringValue(const char *initValue);
 		~StringValue();
		&#125;;

		...
&#125;;

String::StringValue::StringValue(const char *initValue): refCount(1)
&#123;
  	data &#x3D; new char[strlen(initValue) + 1];
  	strcpy(data, initValue);
&#125;
String::StringValue::~StringValue()
&#123;
  delete [] data;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是其所有的一切，很清楚，这不足以实现带引用计数的String类。一则，没有拷贝构造函数和赋值运算；</p>
<p>​        二则，没有提供对refCount的操作。别担心，少掉的功能将由String类提供。StringValue的主要目的是提供一个空间将一个特别的值和共享此值的对象的数目联系起来。StringValue给了我们这个，这就足够了。</p>
<p>​        我们现在开始处理String的成员函数。首先是构造函数：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;
public:

  String(const char *initValue &#x3D; &quot;&quot;);

  String(const String&amp; rhs);

  ...

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        第一个构造函数被实现得尽可能简单。我们用传入的char *字符串创建了一个新的StringValue对象，并将我们正在构造的string对象指向这个新生成的StringValue：</p>
<pre class="line-numbers language-none"><code class="language-none">String::String(const char *initValue): value(new StringValue(initValue))
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样的用户代码：</p>
<pre class="line-numbers language-none"><code class="language-none">String s(&quot;More Effective C++&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        生成的数据结构是这样的：</p>
<p> <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/20191114170009545.png?lastModify=1685936981" alt="img"></p>
<p>​        String对象是独立构造的，有同样初始化值的对象并不共享数据，所以，这样的用户代码：</p>
<pre class="line-numbers language-none"><code class="language-none">String s1(&quot;More Effective C++&quot;);

String s2(&quot;More Effective C++&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        产生这样的数据结构：</p>
<p> <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/2019111417004483.png?lastModify=1685936981" alt="img"></p>
<p>​        消除这样的副本是可能的：通过让String（或StringValue）对象跟踪已存在的StringValue对象，并只在是不同串时才创建新的对象。但这样的改进有些偏离目标。于是，我将它作为习题留给读者。</p>
<p>​        String的拷贝构造函数很高效：新生成的String对象与被拷贝的对象共享相同的StringValue对象：</p>
<pre class="line-numbers language-none"><code class="language-none">String::String(const String&amp; rhs): value(rhs.value)
&#123;
  ++value-&gt;refCount;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">String s1(&quot;More Effective C++&quot;);

String s2 &#x3D; s1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>产生这样的数据结构：</p>
<p> <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/2019111417004483-168517039708711.png?lastModify=1685936981" alt="img"></p>
<p>​        这肯定比通常的（不带引用计数的）string类高效，因为不需要为新生成的string值分配内存、释放内存以及将内容拷贝入这块内存。现在，我们只不过是拷贝了一个指针并增加了一次引用计数。</p>
<p>​        String类的析构函数同样容易实现，因为大部分情况下它不需要做任何事情。只要引用计数值不是0，也就是至少有一个String对象使用这个值，这个值就不可以被销毁。只有当唯一的使用者被析构了（也就是引用计数在进入函数前已经为1时），String的析构函数才摧毁StringValue对象：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;
	public:
  		~String();
  		...
&#125;;

String::~String()
&#123;
  	if (--value-&gt;refCount &#x3D;&#x3D; 0)
 	&#123;
     	 delete value;
  	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        和没有引用计数的版本比较一下效率。那样的函数总调用delete，当然会有一个相当程度的运行时间的代价。现在提供的String对象们实际上有时具有相同的值，上面的这个实现在此时只需要做一下减少引用计数并与0进行比较。</p>
<p>​        如果在这个问题上引用计数没有向外界表现出来，你就根本不需要花注意力。</p>
<p>​        这就是String的构造和析构，我们现在转到赋值操作：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;
	public:

 	 	String&amp; operator&#x3D;(const String&amp; rhs);

  		...

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        当用户写下这样的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">s1 &#x3D; s2;                              &#x2F;&#x2F; s1 and s2 are both String objects<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        其结果应该是s1和s2指向相同的StringValue对象。对象的引用计数应该在赋值时被增加。并且，s1原来指向的StringValue对象的引用计数应该减少，因为s1不再具有这个值了。如果s1是拥有原来的值的唯一对象，这个值应该被销毁。在C++中，其实现看起来是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">String&amp; String::operator&#x3D;(const String&amp; rhs)
&#123;
  	if (value &#x3D;&#x3D; rhs.value) 
    &#123;         				&#x2F;&#x2F; do nothing if the values
   	 	return *this;                    			&#x2F;&#x2F; are already the same; this
	&#125;                                  			   &#x2F;&#x2F; subsumes the usual test of
												&#x2F;&#x2F; this against &amp;rhs (see Item E17)

  	if (--value-&gt;refCount &#x3D;&#x3D; 0) 
    &#123;      &#x2F;&#x2F; destroy *this&#39;s value if
    	delete value;                    &#x2F;&#x2F; no one else is using it
	&#125;

  	value &#x3D; rhs.value;                 &#x2F;&#x2F; have *this share rhs&#39;s

  	++value-&gt;refCount;                 &#x2F;&#x2F; value

  	return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        围绕我们的带引用计数的String类，考虑一下数组下标操作（[]），它允许字符串中的单个字符被读或写：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;
	public:

  		const char&amp;

   	 	operator[](int index) const;       &#x2F;&#x2F; for const Strings

  		char&amp; operator[](int index);           &#x2F;&#x2F; for non-const Strings

		...

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个函数的const版本的实现很容易，因为它是一个只读操作，String对象的值不受影响：</p>
<pre class="line-numbers language-none"><code class="language-none">const char&amp; String::operator[](int index) const
&#123;
  return value-&gt;data[index];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    （这个函数实现了C++传统意义上的下标索引（根本不会说“不”）。如果你想加上参数检查，这是非常容易的。）</p>
<p>非const的operator[]版本就是一个完全不同的故事了。它可能是被调用了来读一个字符，也可能被调用了来写一个字符：</p>
<pre class="line-numbers language-none"><code class="language-none">String s;

...

cout &lt;&lt; s[3];                        &#x2F;&#x2F; this is a read

s[5] &#x3D; &#39;x&#39;;                          &#x2F;&#x2F; this is a write<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们希望以不同的方式处理读和写。简单的读操作，可以用与const的operator[]类似的方式实现，而写操作必须用完全不同的方式来实现。</p>
<p>​        当我们修改一个String对象的值时，必须小心防止修改了与它共享相同StringValue对象的其它String对象的值。不幸的是，C++编译器没有办法告诉我们一个特定的operator[]是用作读的还是写的，所以我们必须保守地假设“所有”调用非const operator[]的行为都是为了写操作。（Proxy类可以帮助我们区分读还是写，见Item M30。）</p>
<p>​        为了安全地实现非const的operator[]，我们必须确保没有其它String对象在共享这个可能被修改的StringValue对象。简而言之，当我们返回StringValue对象中的一个字符的引用时，必须确保这个StringValue的引用计数是1。这儿是我们的实现：</p>
<pre class="line-numbers language-none"><code class="language-none">char&amp; String::operator[](int index)

&#123;
  &#x2F;&#x2F; if we&#39;re sharing a value with other String objects,

  &#x2F;&#x2F; break off a separate copy of the value for ourselves

  if (value-&gt;refCount &gt; 1) &#123;
    --value-&gt;refCount;                    &#x2F;&#x2F; decrement current value&#39;srefCount, because we won&#39;t be using that value any more
    value &#x3D;                               &#x2F;&#x2F; make a copy of the
      new StringValue(value-&gt;data);       &#x2F;&#x2F; value for ourselves
  &#125;
  &#x2F;&#x2F; return a reference to a character inside our
  &#x2F;&#x2F; unshared StringValue object
  return value-&gt;data[index];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个“与其它对象共享一个值直到写操作时才拥有自己的拷贝”的想法在计算机科学中已经有了悠久而著名的历史了，尤其是在操作系统中：进程共享内存页直到它们想在自己的页拷贝中修改数据为止。这个技巧如此常用，以至于有一个名字：写时拷贝。它是提高效率的一个更通用方法－－缓式评估原则－－的特例。</p>
<p>​        大部分情况下，写时拷贝可以同时保证效率和正确性。只有一个挥之不去的问题。看一下这样的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">String s1 &#x3D; &quot;Hello&quot;;

char *p &#x3D; &amp;s1[1];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>数据结构是这样的：</p>
<p> <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/20191114170147593.png?lastModify=1685936981" alt="img"></p>
<p>​        现在看增加一条语句：</p>
<pre class="line-numbers language-none"><code class="language-none">String s2 &#x3D; s1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        String的拷贝构造函数使得s2共享s1的StringValue对象，所以数据结构将是：</p>
<p> <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/20191114170246431.png?lastModify=1685936981" alt="img"></p>
<p>​        下面这样的语句将有不受欢迎的结果：</p>
<pre class="line-numbers language-none"><code class="language-none">*p &#x3D; &#39;x&#39;;                     &#x2F;&#x2F; modifies both s1 and s2!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        String的拷贝构造函数没有办法检测这样的问题，因为它不知道指向s1拥有的StringValue对象的指针的存在。并且，这个问题不局限于指针：它同样存在于有人保存了一个String的非const operator[]的返回值的引用的情况下。</p>
<p>​        至少有三种方法来应付这个问题。第一个是忽略它，假装它不存在。这是实现带引用计数的String类的类库中令人痛苦的常见问题。如果你有带引用计数的String类，试一下上面的例子，看你是否很痛苦。即使你不能确定你操作的是否是带引用计数的String类，也无论如何应该试一下这个例子。由于封装，你可能使用了一个这样的类型而不自知。</p>
<p>​        不是所以的实现都忽略这个问题。稍微好些的方法是明确说明它的存在。通常是将它写入文档，或多或少地说明“别这么做。如果你这么做了，结果为未定义。”无论你以哪种方式这么做了（有意地或无意地），并抱怨其结果时，他们辩解道：“好了，我们告诉过你别这么做的。”这样的实现通常很方便，但它们在可用性方面留下了太多的期望。</p>
<p>​        第三个方法是排除这个问题。它不难实现，但它将降低一个值共享于对象间的次数。它的本质是这样的：在每个StringValue对象中增加一个标志以指出它是否为可共享的。在最初（对象可共享时）将标志打开，在非const的operator[]被调用时将它关闭。一旦标志被设为false，它将永远保持在这个状态（注10）。</p>
<p>​        这是增加了共享标志的修改版本：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;
private:
  struct StringValue &#123;
    	int refCount;

    	bool shareable;                &#x2F;&#x2F; add this
    
    	char *data;
    
    	StringValue(const char *initValue);
    
   		~StringValue();
  &#125;;
	...
&#125;;
String::StringValue::StringValue(const char *initValue)
:refCount(1),shareable(true)                &#x2F;&#x2F; add this
&#123;
  data &#x3D; new char[strlen(initValue) + 1];
  strcpy(data, initValue);
&#125;

String::StringValue::~StringValue()
&#123;
  delete [] data;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        如你所见，并不需要太多的改变；需要修改的两行都有注释。当然，String的成员函数也必须被修改以处理这个共享标志。这里是拷贝构造函数的实现：</p>
<pre class="line-numbers language-none"><code class="language-none">String::String(const String&amp; rhs)

&#123;
  if (rhs.value-&gt;shareable) &#123;
    value &#x3D; rhs.value;
    ++value-&gt;refCount;
  &#125;
  else &#123;
    value &#x3D; new StringValue(rhs.value-&gt;data);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        所有其它的成员函数也都必须以类似的方法检查这个共享标志。非const的operator[]版本是唯一将共享标志设为false的地方：</p>
<pre class="line-numbers language-none"><code class="language-none">char&amp; String::operator[](int index)
&#123;
  	if (value-&gt;refCount &gt; 1) &#123;
    	--value-&gt;refCount;
		value &#x3D; new StringValue(value-&gt;data);
  &#125;
  value-&gt;shareable &#x3D; false;           &#x2F;&#x2F; add this
  return value-&gt;data[index];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        如果使用Item M30中的proxy类的技巧以区分读写操作，你通常可以降低必须被设为不可共享的StringValue对象的数目。</p>
<p>​        引用计数不只用在字符串类上，只要是多个对象具有相同值的类都可以使用引用计数。改写一个类以获得引用计数需要大量的工作，而我们已经有太的工作需要做了。这样不好吗：如果我们将引用计数的代码写成与运行环境无关的，并能在需要时将它嫁接到其它类上？当然很好。很幸运，有一个方法可以实现它（至少完成了绝大部分必须的工作）。</p>
<p>​        第一步是构建一个基类RCObject，任何需要引用计数的类都必须从它继承。RCObject封装了引用计数功能，如增加和减少引用计数的函数。它还包含了当这个值不再被需要时摧毁值对象的代码（也就是引用计数为0时）。最后，它包含了一个字段以跟踪这个值对象是否可共享，并提供查询这个值和将它设为false的函数。不需将可共享标志设为true的函数，因为所有的值对象默认都是可共享的。如上面说过的，一旦一个对象变成了不可共享，将没有办法使它再次成为可共享。</p>
<p>​        RCObject的定义如下：</p>
<pre class="line-numbers language-none"><code class="language-none">class RCObject &#123;
public:

  	RCObject();

  	RCObject(const RCObject&amp; rhs);

  	RCObject&amp; operator&#x3D;(const RCObject&amp; rhs);

 	virtual ~RCObject() &#x3D; 0;

  	void addReference();

  	void removeReference();

	void markUnshareable();

	bool isShareable() const;

	bool isShared() const;

private:

	int refCount;

	bool shareable;

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        RCObjcet可以被构造（作为派生类的基类部分）和析构；可以有新的引用加在上面以及移除当前引用；其可共享性可以被查询以及被禁止；它们可以报告当前是否被共享了。这就是它所提供的功能。对于想有引用计数的类，这确实就是我们所期望它们完成的东西。注意虚析构函数，它明确表明这个类是被设计了作基类使用的（见Item E14）。同时要注意这个析构函数是纯虚的，它明确表明这个类只能作基类使用。</p>
<p>​        RCOject的实现代码：</p>
<pre class="line-numbers language-none"><code class="language-none">RCObject::RCObject(): refCount(0), shareable(true) &#123;&#125;
RCObject::RCObject(const RCObject&amp;): refCount(0), shareable(true) &#123;&#125;
RCObject&amp; RCObject::operator&#x3D;(const RCObject&amp;)
&#123; 
    return *this; 
&#125;
RCObject::~RCObject() &#123;&#125;               &#x2F;&#x2F; virtual dtors must always

                                       &#x2F;&#x2F; be implemented, even if
    
                                       &#x2F;&#x2F; they are pure virtual
    
                                       &#x2F;&#x2F; and do nothing (see also
    
                                       &#x2F;&#x2F; Item M33 and Item E14)

void RCObject::addReference() 
&#123;
    ++refCount; 
&#125;
void RCObject::removeReference()

&#123;   
    if (--refCount &#x3D;&#x3D; 0)
        delete this; 
&#125;

void RCObject::markUnshareable()
&#123; 
    shareable &#x3D; false; 
&#125;
bool RCObject::isShareable() const
&#123; 
    return shareable; 
&#125;
bool RCObject::isShared() const
&#123; 
    return refCount &gt; 1; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        可能很奇怪，我们在所有的构造函数中都将refCount设为了0。这看起来违反直觉。确实，最少，构造这个RCObject对象的对象引用它！在它构造后，只需构造它的对象简单地将refCount设为1就可以了，所以我们没有将这个工作放入RCObject内部。这使得最终的代码看起来很简短。</p>
<p>​        另一个奇怪之处是拷贝构造函数也将refCount设为0，而不管被拷贝的RCObject对象的refCount的值。这是因为我们正在构造新的值对象，而这个新的值对象总是未被共享的，只被它的构造者引用。再一次，构造者负责将refCount设为正确的值。</p>
<p>​        RCObject的赋值运算看起来完全出乎意料：它没有做任何事情。这个函数不太可能被调用的。RCObject是基于引用计数来共享的值对象的基类，它不该被从一个赋给另外一个，而应该是拥有这个值的对象被从一个赋给另外一个。在我们这个设计里，我们不期望StringValue对象被从一个赋给另外一个，我们期望在赋值过程中只有String对象被涉及。在String参与的赋值语句中，StringValue的值没有发生变化，只是它的引用计数被修改了。</p>
<p>​        不过，可以想象，一些还没有写出来的类在将来某天可能从RCObject派生出来，并希望允许被引用计数的值被赋值（见Item M23和Item E16）。如果这样的话，RCObject的赋值操作应该做正确的事情，而这个正确的事情就是什么都不做。想清楚了吗？假设我们希望允许在StringValue对象间赋值。对于给定的StringValue对象sv1和sv2，在赋值过程中，它们的引用计数值上发生什么？</p>
<pre class="line-numbers language-none"><code class="language-none">sv1 &#x3D; sv2;                    &#x2F;&#x2F; how are sv1&#39;s and sv2&#39;s reference counts affected?<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在赋值之前，已经有一定数目的String对象指向sv1。这个值在赋值过程中没有被改变，因为只是sv1的值被改变了。同样的，一定数目的String对象在赋值之前指向前v2，在赋值后，同样数目的对象指向sv2。sv2的引用计数同样没有改变。当RCObject在赋值过程中被涉及时，指向它的对象的数目没有受影响，因此RCObject::operator=不应该改变引用计数值。上面的实现是正确的。违反直觉？可能吧，但它是正确的。</p>
<p>​        RCObject::removeReference的代码不但负责减少对象的refCount值，还负责当refCount值降到0时析构对象。后者是通过delete this来实现的，如Item M27中解释的，这只当我们知道*this是一个堆对象时才安全。要让这个类正确，我们必须确保RCObject只能被构建在堆中。实现这一点的常用方法见Item M27，但我们这次采用一个特别的方法，这将在本条款最后讨论。</p>
<p>​        为了使用我们新写的引用计数基类，我们将StringValue修改为是从RCObject继承而得到引用计数功能的：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;
private:

  	struct StringValue: public RCObject &#123;
    	char *data;

    	StringValue(const char *initValue);
    
   	 	~StringValue();
	&#125;;

...
&#125;;
String::StringValue::StringValue(const char *initValue)
&#123;
  	data &#x3D; new char[strlen(initValue) + 1];

 	strcpy(data, initValue);
&#125;
String::StringValue::~StringValue()
&#123;
  delete [] data;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个版本的StringValue和前面的几乎一样，唯一改变的就是StringValue的成员函数不再处理refCount字段。RCObject现在接管了这个工作。</p>
<p>​        不用感觉不舒服，如果你注意到嵌套类（StringValue）从一个与包容类（String）无关的类（RCObject）继承而来的话。它第一眼看上去是有些古怪，但完全合理。嵌套类和其它类是完全相同的，所以它有自由从它喜欢的任何其它类继承。以后，你不用第二次思考这种继承关系了。   </p>
<p>​        RCObject类给了我们一个存储引用计数的地方，并提供了成员函数供我们操作引用计数，但调用这些函数的动作还必须被手工加入其它类中。仍然需要在String的拷贝构造函数和赋值运算函数中调用StringValue的addReference和 removeReference函数。这很笨拙。我们想将这些调用也移入一个可重用的类中，以使得String这样的类的作者不用再担心引用计数的任何细节。能实现吗？C++支持这样的重用吗？</p>
<p>​        能。没有一个简单的方法将所有引用计数方面的工作从所有的类中移出来；但有一个方法可以从大部分类中将大部分工作移出来。（在一些类中，你可以消除所有引用计数方面的代码，但我们的String类不是其中之一。有一个成员函数搞坏了这件事，我希望你别吃惊，它是我们的老对头：非const版本的operator[]。别放心上，我们最终制服了这家伙。）</p>
<p>​        每个String对象包含一个指针指向StringValue对象：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;
private:

  struct StringValue: public RCObject &#123; ... &#125;;

  StringValue *value;                &#x2F;&#x2F; value of this String

  ...

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们必须操作StringValue对象的refCount字段，只要任何时候任一个指向它的指针身上发生了任何有趣的事件。“有趣的事件”包括拷贝指针、给指针赋值和销毁指针。如果我们能够让指针自己检测这些事件并自动地执行对refCount字段的必须操作，那么我们就自由了。不幸的是，指针功能很弱，对任何事情作检测并作出反应都是不可能的。还好，有一个办法来增强它们：用行为类似指针的对象替代它们，但那样要多做很多工作了。</p>
<p>​        这样的对象叫灵巧指针，你可以在Item M28这看到它的更多细节。就我们这儿的用途，只要知道这些就足够了：灵巧指针对象支持成员选择（-&gt;）和反引用（*）这两个操作符，就象真的指针一样，并和内建指针一样是强类型的：你不能将一个指向T的灵巧指针指向一个非T类型的对象。</p>
<p>​        这儿是供引用计数对象使用的灵巧指针模板：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; template class for smart pointers-to-T objects. T must

&#x2F;&#x2F; support the RCObject interface, typically by inheriting

&#x2F;&#x2F; from RCObject

template&lt;class T&gt;

class RCPtr &#123;
public:

  RCPtr(T* realPtr &#x3D; 0);

  RCPtr(const RCPtr&amp; rhs);

  ~RCPtr();

  RCPtr&amp; operator&#x3D;(const RCPtr&amp; rhs);

  T* operator-&gt;() const;            &#x2F;&#x2F; see Item 28

  T&amp; operator*() const;             &#x2F;&#x2F; see Item 28

private:

  T *pointee;                       &#x2F;&#x2F; dumb pointer this

                                    &#x2F;&#x2F; object is emulating

  void init();                      &#x2F;&#x2F; common initialization

&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个模板让灵巧指针对象控制在构造、赋值、析构时作什么操作。当这些事件发生时，这些对象可以自动地执行正确的操作来处理它们指向的对象的refCount字段。</p>
<p>​        例如，当一个RCPtr构建时，它指向的对象需要增加引用计数值。现在不需要程序员手工处理这些细节了，因为RCPtr的构造函数自己处理它。两个构造函数几乎相同，除了初始化列表上的不同，为了不写两遍，我们将它放入一个名为init的私有成员函数中供二者调用：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;
RCPtr&lt;T&gt;::RCPtr(T* realPtr): pointee(realPtr)
&#123;
  init();
&#125;

template&lt;class T&gt;
RCPtr&lt;T&gt;::RCPtr(const RCPtr&amp; rhs): pointee(rhs.pointee)
&#123;
  init();
&#125;

template&lt;class T&gt;
void RCPtr&lt;T&gt;::init()
&#123;
  	if (pointee &#x3D;&#x3D; 0) &#123;                &#x2F;&#x2F; if the dumb pointer is
    	return;                          &#x2F;&#x2F; null, so is the smart one
  	&#125;
	if (pointee-&gt;isShareable() &#x3D;&#x3D; false) &#123;           &#x2F;&#x2F; if the value

    	pointee &#x3D; new T(*pointee);                   &#x2F;&#x2F; isn&#39;t shareable,

  	&#125;                                              &#x2F;&#x2F; copy it
	pointee-&gt;addReference();             &#x2F;&#x2F; note that there is now a
&#125;                                    &#x2F;&#x2F; new reference to the value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        将相同的代码移入诸如init这样的一个独立函数是很值得效仿的，但它现在暗淡无光，因为在此处，这个函数的行为不正确。</p>
<p>​        问题是这个：当init需要创建value的一个新拷贝时（因为已存在的拷贝处于不可共享状态），它执行下面的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">pointee &#x3D; new T(*pointee);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        pointee的类型是指向T的指针,所以这一语句构建了一个新的T对象，并用拷贝构造函数进行了初始化。由于RCPtr是在String类内部，T将是String::StringValue，所以上面的语句将调用String::StringValue的拷贝构造函数。我们没有为这个类申明拷贝构造函数，所以编译器将为我们生成一个。这个生成的拷贝构造函数遵守C++的自动生成拷贝构造函数的原则，只拷贝了StringValue的数据pointer，而没有拷贝所指向的char *字符串。这样的行为对几乎任何类（而不光是引用计数类）都是灾难，这就是为什么你应该养成为所有含有指针的类提供拷贝构造函数（和赋值运算）的习惯（见Item E11）。</p>
<p>​        RCPtr<T>模板的正确行为取决于T含有正确的值拷贝行为（如深拷贝）的拷贝构造函数。我们必须在StringValue中增加这样的一个构造函数：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;
private:
  struct StringValue: public RCObject &#123;
    StringValue(const StringValue&amp; rhs);
    ...
  &#125;;
  ...
&#125;;
String::StringValue::StringValue(const StringValue&amp; rhs)
&#123;
  	data &#x3D; new char[strlen(rhs.data) + 1];
  	strcpy(data, rhs.data);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        深拷贝的构造函数的存在不是RCPtr<T>的唯一假设。它还要求T从RCObject继承，或至少提供了RCObject的所提供的函数。事实上由于RCPtr对象只是被设计了指向引用计数对象的，这个假设并不过分。不过，这个假设必须被明确写入文档。</p>
<p>​        RCPtr<T>的最后一个假设是它所指向的对象类型为T。这似乎是显然的。毕竟，pointee的类型被申明为T*。但pointee可能实际上指向T的一个派生类。例如，如果我们有一个类SpecialStringValue是从String::StringValue继承的：</p>
<pre class="line-numbers language-none"><code class="language-none">class String &#123;
private:

  struct StringValue: public RCObject &#123; ... &#125;;

  struct SpecialStringValue: public StringValue &#123; ... &#125;;

  ...

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以生成一个String，包容的RCPtr<StringValue>指向一个SpecialStringValue对象。这时，我们希望init的这句：</p>
<pre class="line-numbers language-none"><code class="language-none">pointee &#x3D; new T(*pointee);                &#x2F;&#x2F; T is StringValue, but pointee really points to a SpecialStringValue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        调用的是SpecialStringValue的拷贝构造函数，而不是StringValue的拷贝构造函数。我们可以提供使用虚拷贝构造函数（见Item M25）来实现这一点。对于我们的String类，我们不期望从StringValue派生子类，所以我们忽略这个问题。</p>
<p>​        用这种方式实现了RCPtr的构造函数后，类的其它函数实现得很轻快。赋值运算很简洁明了，虽然“需要测试源对象的可共享状态”将问题稍微复杂化了。幸好，同样的问题已经在我们为构造函数写的init函数中处理了。我们可以爽快地再度使用它：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;
RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::operator&#x3D;(const RCPtr&amp; rhs)
&#123;
  	if (pointee !&#x3D; rhs.pointee)
    &#123;          
    	&#x2F;&#x2F; skip assignments， where the 		value doesn&#39;t change
		if (pointee) 
		&#123;
  			pointee-&gt;removeReference();        &#x2F;&#x2F; remove reference to
		&#125;                                    &#x2F;&#x2F; current value

		pointee &#x3D; rhs.pointee;               &#x2F;&#x2F; point to new value

		init();                              &#x2F;&#x2F; if possible, share it
  	&#125;                                      &#x2F;&#x2F; else make own copy

  	return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>析构函数很容易。当一个RCPtr被析构时，它只是简单地将它对引用计数对象的引用移除：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;
RCPtr&lt;T&gt;::~RCPtr()
&#123;
  	if (pointee)pointee-&gt;removeReference();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        如果这个RCPtr是最后一个引用它的对象，这个对象将在RCObject的成员函数removeReference中被析构。因此，RCPtr对象无需关心销毁它们指向的值的问题。</p>
<p>​        最后，RCPtr的模拟指针的操作就是你在Item M28中看到的灵巧指针的部分：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;

T* RCPtr&lt;T&gt;::operator-&gt;() const &#123; return pointee; &#125;

template&lt;class T&gt;

T&amp; RCPtr&lt;T&gt;::operator*() const &#123; return *pointee; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        够了！完结！最后，我们将各个部分放在一起，构造一个基于可重用的RCObject和RCPtr类的带引用计数的String类。或许，你还没有忘记这是我们的最初目标。</p>
<p>​        每个带引用计数的Sting对象被实现为这样的数据结构：</p>
<p>类的定义是：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;                       &#x2F;&#x2F; template class for smart
class RCPtr &#123;                           &#x2F;&#x2F; pointers-to-T objects; T

public:                                 &#x2F;&#x2F; must inherit from RCObject

  RCPtr(T* realPtr &#x3D; 0);

  RCPtr(const RCPtr&amp; rhs);

  ~RCPtr();

  RCPtr&amp; operator&#x3D;(const RCPtr&amp; rhs);

  T* operator-&gt;() const;

  T&amp; operator*() const;

private:

  T *pointee;

  void init();

&#125;;

class RCObject &#123;                       &#x2F;&#x2F; base class for reference-

public:                                &#x2F;&#x2F; counted objects

  void addReference();

  void removeReference();

  void markUnshareable();

  bool isShareable() const;

  bool isShared() const;

protected:

  RCObject();

  RCObject(const RCObject&amp; rhs);

  RCObject&amp; operator&#x3D;(const RCObject&amp; rhs);

  virtual ~RCObject() &#x3D; 0;

private:

  int refCount;

  bool shareable;

&#125;;

class String &#123;                           &#x2F;&#x2F; class to be used by

public:                                  &#x2F;&#x2F; application developers

  String(const char *value &#x3D; &quot;&quot;);

  const char&amp; operator[](int index) const;

  char&amp; operator[](int index);

private:

  &#x2F;&#x2F; class representing string values

  struct StringValue: public RCObject &#123;
    char *data;

StringValue(const char *initValue);

StringValue(const StringValue&amp; rhs);

void init(const char *initValue);

~StringValue();
  &#125;;

  RCPtr&lt;StringValue&gt; value;

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        绝大部分都是我们前面写的代码的翻新，没什么奇特之处。仔细检查后发现，我们在String::StringValue中增加了一个init函数，但，如我们下面将看到的，它的目的和RCPtr中的相同：消除构造函数中的重复代码。</p>
<p>​        这里有一个重大的不同：这个String类的公有接口和本条款开始处我们使用的版本不同。拷贝构造函数在哪里？赋值运算在哪里？析构函数在哪里？这儿明显有问题。</p>
<p>​        实际上，没问题。它工作得很好。如果你没看出为什么，需要重学C++了（prepare yourself for a C++ epiphany）。</p>
<p>​        我们不再需要那些函数了！确实，String对象的拷贝仍然被支持，并且，这个拷贝将正确处理藏在后面的被引用计数的StringValue对象，但String类不需要写下哪怕一行代码来让它发生。因为编译器为String自动生成的拷贝构造函数将自动调用其RCPtr成员的拷贝构造函数，而这个拷贝构造函数完成所有必须的对StringValue对象的操作，包括它的引用计数。RCPtr是一个灵巧指针，所以这是它将完成的工作。它同样处理赋值和析构，所以String类同样不需要写出这些函数。我们的最初目的是将不可重用的引用计数代码从我们自己写的String类中移到一个与运行环境无关的类中以供任何其它类使用。现在，我们完成了这一点（用RCObject和RCPtr两个类），所以当它突然开始工作时别惊奇。它本来就应该能工作的。</p>
<p>​        将所以东西放在一起，这儿是RCObject的实现：</p>
<pre class="line-numbers language-none"><code class="language-none">RCObject::RCObject(): refCount(0), shareable(true) &#123;
    
&#125;
RCObject::RCObject(const RCObject&amp;): refCount(0), shareable(true) &#123;
    
&#125;
RCObject&amp; RCObject::operator&#x3D;(const RCObject&amp;)
&#123; 
    return *this; 
&#125;
RCObject::~RCObject() &#123;&#125;
void RCObject::addReference() 
&#123; 
    ++refCount; 
&#125;
void RCObject::removeReference()
&#123; 
    if (--refCount &#x3D;&#x3D; 0) delete this; 
&#125;
void RCObject::markUnshareable()
&#123; 
    shareable &#x3D; false;
&#125;

bool RCObject::isShareable() const
&#123; 
    return shareable; 
&#125;

bool RCObject::isShared() const
&#123;
    return refCount &gt; 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是RCPtr的实现：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;
void RCPtr&lt;T&gt;::init()
&#123;
  if (pointee &#x3D;&#x3D; 0) 
      return;
  if (pointee-&gt;isShareable() &#x3D;&#x3D; false) 
  &#123;
    	pointee &#x3D; new T(*pointee);
  &#125;
  pointee-&gt;addReference();
&#125;

template&lt;class T&gt;
RCPtr&lt;T&gt;::RCPtr(T* realPtr): pointee(realPtr)
&#123; init(); &#125;

template&lt;class T&gt;
RCPtr&lt;T&gt;::RCPtr(const RCPtr&amp; rhs): pointee(rhs.pointee)
&#123; init(); &#125;

template&lt;class T&gt;
RCPtr&lt;T&gt;::~RCPtr()
&#123; if (pointee)pointee-&gt;removeReference(); &#125;

template&lt;class T&gt;
RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::operator&#x3D;(const RCPtr&amp; rhs)
&#123;
  	if (pointee !&#x3D; rhs.pointee) 
    &#123;
    	if (pointee) 
        &#123;
            pointee-&gt;removeReference();
        &#125;
		pointee &#x3D; rhs.pointee;

		init();
  	&#125;
	return *this;
&#125;

template&lt;class T&gt;
T* RCPtr&lt;T&gt;::operator-&gt;() const &#123; return pointee; &#125;

template&lt;class T&gt;
T&amp; RCPtr&lt;T&gt;::operator*() const &#123; return *pointee; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是String::StringValue的实现：</p>
<pre class="line-numbers language-none"><code class="language-none">void String::StringValue::init(const char *initValue)
&#123;
  data &#x3D; new char[strlen(initValue) + 1];
  strcpy(data, initValue);
&#125;
String::StringValue::StringValue(const char *initValue)
&#123; 
    init(initValue); 
&#125;
String::StringValue::StringValue(const StringValue&amp; rhs)
&#123; 
    init(rhs.data); 
&#125;
String::StringValue::~StringValue()
&#123; 
    delete [] data; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，归结到String，它的实现是：</p>
<pre class="line-numbers language-none"><code class="language-none">String::String(const char *initValue): value(new StringValue(initValue)) &#123;&#125;
const char&amp; String::operator[](int index) const
&#123; 
    return value-&gt;data[index]; 
&#125;

char&amp; String::operator[](int index)
&#123;
  	if (value-&gt;isShared()) &#123;
    	value &#x3D; new StringValue(value-&gt;data);

  	&#125;

 	value-&gt;markUnshareable();

  	return value-&gt;data[index];

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        如果你将它和我们用内建指针实现的版本相比较，你会受到两件事的打击。第一，代码有很多的减少。因为RCPtr完成了大量以前在String内部完成的处理引用计数的担子。第二，剩下的代码几乎没有变化：灵巧指针无缝替换了内建指针。实际上，唯一的变化是在operator[]里，我们用调用isShared函数代替了直接检查refCount的值，并用灵巧指针RCPtr对象消除了写时拷贝时手工维护引用计数值的工作。</p>
<p>​        这当然全都很漂亮。谁能反对减少代码？谁能反对成功的封装？然而，这个全新的String类本身对用户的冲击远胜过它的实现细节，这才是真正的闪光点。如果没有什么消息是好消息的话，这本身就是最好的消息。String的接口没有改变！我们增加了引用计数，我们增加了标记某个String的值为不可共享的能力，我们将引用计数功能移入一个新类，我们增加了灵巧指针来自动处理引用计数，但用户的一行代码都不需要修改。当然，我们改变了String类的定义，所以用户需要重新编译和链接，但他们在自己代码上的投资受到了完全的保护。你看到了吗？封装确实是个很好的东西。</p>
<p>​        到现在为止，我们所讨论的都假设我们能够访问有关类的源码。但如果我们想让一个位于支撑库中而无法修改的类获得引用计数的好处呢？不可能让它们从RCObject继承的，所以也不能对它们使用灵巧指针RCPtr。我们运气不好吗？</p>
<p>​        不是的。只要对我们的设计作小小的修改，我们就可以将引用计数加到任意类型上。</p>
<p>​        首先考虑如果从RCObject继承的话，我们的设计看起来将是什么样子。在这种情况下，我们需要增加一个类RCWidget以供用户使用，而所有的事情都和String/StringValue的例子一样，RCWidget和String相同，Widget和StringValue相同。设计看起来是这样的：</p>
<p>​        <strong>我们现在可以应用这句格言：计算机科学中的绝大部分问题都可以通过增加一个中间层次来解决。</strong>我们增加一个新类CountHolder以处理引用计数，它从RCObject继承。我们让CountHolder包含一个指针指向Widget。然后用等价的灵巧指针RCIPter模板替代RCPtr模板，它知道CountHolder类的存在。（名字中的“i”表示间接“indirect”。）修改后的设计为：</p>
<p>​        如同StringValue一样，CountHolder对用户而言，是RCWidget的实现细节。实际上，它是RCIPtr的实现细节，所以它嵌套在这个类中。RCIPtr的实现如下：</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;class T&gt;

class RCIPtr &#123;
public:

  RCIPtr(T* realPtr &#x3D; 0);

  RCIPtr(const RCIPtr&amp; rhs);

  ~RCIPtr();

  RCIPtr&amp; operator&#x3D;(const RCIPtr&amp; rhs);

  const T* operator-&gt;() const;               &#x2F;&#x2F; see below for an

  T* operator-&gt;();                           &#x2F;&#x2F; explanation of why

  const T&amp; operator*() const;                &#x2F;&#x2F; these functions are

  T&amp; operator*();                            &#x2F;&#x2F; declared this way

private:

  struct CountHolder: public RCObject 
  &#123;
    	~CountHolder() &#123; 
       		delete pointee; 
    	&#125;
    T *pointee;
  &#125;;
  CountHolder *counter;
  void init();
  void makeCopy();                                &#x2F;&#x2F; see below

&#125;;

template&lt;class T&gt;
void RCIPtr&lt;T&gt;::init()
&#123;
  	if (counter-&gt;isShareable() &#x3D;&#x3D; false)
  	&#123;
    	T *oldValue &#x3D; counter-&gt;pointee;	
		counter &#x3D; new CountHolder;

		counter-&gt;pointee &#x3D; new T(*oldValue);
 	&#125;

  	counter-&gt;addReference();
&#125;
template&lt;class T&gt;
RCIPtr&lt;T&gt;::RCIPtr(T* realPtr): counter(new CountHolder)
&#123;
  counter-&gt;pointee &#x3D; realPtr;
  init();
&#125;
template&lt;class T&gt;
RCIPtr&lt;T&gt;::RCIPtr(const RCIPtr&amp; rhs): counter(rhs.counter)
&#123; 
    init();
&#125;
template&lt;class T&gt;
RCIPtr&lt;T&gt;::~RCIPtr()
&#123; 
    counter-&gt;removeReference(); 
&#125;

template&lt;class T&gt;
RCIPtr&lt;T&gt;&amp; RCIPtr&lt;T&gt;::operator&#x3D;(const RCIPtr&amp; rhs)
&#123;
  	if (counter !&#x3D; rhs.counter) 
    &#123;
   		 counter-&gt;removeReference();
   	 	 counter &#x3D; rhs.counter;

		 init();
  	&#125;

  	return *this;

&#125;
template&lt;class T&gt;                          &#x2F;&#x2F; implement the copy
void RCIPtr&lt;T&gt;::makeCopy()                 &#x2F;&#x2F; part of copy-on-
&#123;                                          &#x2F;&#x2F; write (COW)

  	if (counter-&gt;isShared()) 
  	&#123;
    	T *oldValue &#x3D; counter-&gt;pointee;
		counter-&gt;removeReference();
	
		counter &#x3D; new CountHolder;

		counter-&gt;pointee &#x3D; new T(*oldValue);

		counter-&gt;addReference();  
  &#125;
    

&#125;
template&lt;class T&gt;                           &#x2F;&#x2F; const access;
const T* RCIPtr&lt;T&gt;::operator-&gt;() const      &#x2F;&#x2F; no COW needed
&#123;
    return counter-&gt;pointee; 
&#125;

template&lt;class T&gt;                           &#x2F;&#x2F; non-const
T* RCIPtr&lt;T&gt;::operator-&gt;()                  &#x2F;&#x2F; access; COW
&#123; 
    makeCopy(); 
    return counter-&gt;pointee; 
&#125;    &#x2F;&#x2F; needed

template&lt;class T&gt;                           &#x2F;&#x2F; const access;
const T&amp; RCIPtr&lt;T&gt;::operator*() const       &#x2F;&#x2F; no COW needed
&#123; 
    return *(counter-&gt;pointee);
&#125;

template&lt;class T&gt;                           &#x2F;&#x2F; non-const
T&amp; RCIPtr&lt;T&gt;::operator*()                   &#x2F;&#x2F; access; do the
&#123;
    makeCopy(); 
    return *(counter-&gt;pointee); 
&#125; &#x2F;&#x2F; COW thing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        RCIPtr与RCPtr只两处不同。第一，RCPtr对象直接指向值对象，而RCIptr对象通过中间层的CountHolder对象指向值对象。第二，RCIPtr重载了operator-&gt;和operator*，当有对被指向的对象的非const的操作时，写时拷贝自动被执行。</p>
<p>​        有了RCIPtr，很容易实现RCWidget，因为RCWidget的每个函数都是将调用传递给RCIPtr以操作Widget对象。举个例子，如果Widget是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">class Widget &#123;
public:

  Widget(int size);

  Widget(const Widget&amp; rhs);

  ~Widget();

  Widget&amp; operator&#x3D;(const Widget&amp; rhs);

  void doThis();

  int showThat() const;

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        那么RCWidget将被定义为这样：</p>
<pre class="line-numbers language-none"><code class="language-none">class RCWidget &#123;
public:

  RCWidget(int size): value(new Widget(size)) &#123;&#125;

  void doThis() &#123; value-&gt;doThis(); &#125;

  int showThat() const &#123; return value-&gt;showThat(); &#125;

private:

  RCIPtr&lt;Widget&gt; value;

&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意RCWidget的构造函数是怎么用它被传入的参数调用Widget的构造函数的（通过new操作符，见Item M8）；RCWidget的doThis怎么调用Widget的doThis函数的；以及RCWidget的showThat怎么返回Widget的showThat的返回值的。同样要注意RCWidget没有申明拷贝构造函数和赋值操作函数，也没有析构函数。如同String类一样，它不需要这些函数。感谢于RCIPtr的行为，RCWidget的默认版本将完成正确的事情。</p>
<p>​        如果认为生成RCWidget的行为很机械，它应该自动进行，那么你是对的。不难写个小程序接受如Widget这样的类而输出RCWidget这样的类。如果你写了一个这样的程序，请让我知道。</p>
<p>​        让我们从Widget、String、值、灵巧指针和引用计数基类中摆脱一下。给个机会回顾一下，在更广阔的环境下看一下引用计数。在更大的环境下，我们必须处理一个更高层次的问题，也就是什么时候使用引用计数？</p>
<p>​        实现引用计数不是没有代价的。每个被引用的值带一个引用计数，其大部分操作都需要以某种形式检查或操作引用计数。对象的值需要更多的内存，而我们在处理它们时需要执行更多的代码。此外，就内部的源代码而言，带引用计数的类的复杂度比不带的版本高。没有引用计数的String类只依赖于自己，而我们最终的String类如果没有三个辅助类（StringValue、RCObject和RCPtr）就无法使用。确实，我们这个更复杂的设计确保在值可共享时的更高的效率；免除了跟踪对象所有权的需要，提高了引用计数的想法和实现的可重用性。但，这四个类必须写出来、被测试、文档化、和被维护，比单个类要多做更多的工作。即使是管理人员也能看出这点。</p>
<p>​        引用计数是基于对象通常共享相同的值的假设的优化技巧（参见Item M18）。如果假设不成立的话，引用计数将比通常的方法使用更多的内存和执行更多的代码。另一方面，如果你的对象确实有具体相同值的趋势，那么引用计数将同时节省时间和空间。共享的值所占内存越大，同时共享的对象数目越多，节省的内存也就越大。创建和销毁这个值的代价越大，你节省的时间也越多。总之，引用计数在下列情况下对提高效率很有用：</p>
<p>​        少量的值被大量的对象共享。这样的共享通常通过调用赋值操作和拷贝构造而发生。对象/值的比例越高，越是适宜使用引用计数。</p>
<p>​        对象的值的创建和销毁代价很高昂，或它们占用大量的内存。即使这样，如果不是多个对象共享相同的值，引用计数仍然帮不了你任何东西。</p>
<p>​        只有一个方法来确认这些条件是否满足，而这个方法不是猜测或依赖直觉（见Item M16）。这个方法是使用profiler或其它工具来分析。使用这种方法，你可以发现是否创建和销毁值的行为是性能瓶颈，并能得出对象/值的比例。只有当你手里有了这些数据，你才能得出是否从引用计数上得到的好处超过其缺点。</p>
<p>​        即使上面的条件满足了，使用引用计数仍然可能是不合适的。有些数据结构（如有向图）将导致自我引用或环状结构。这样的数据结构可能导致孤立的自引用对象，它没有被别人使用，而其引用计数又绝不会降到零。因为这个无用的结构中的每个对象被同结构中的至少一个对象所引用。商用化的垃圾收集体系使用特别的技术来查找这样的结构并消除它们，但我们现在使用的这个简单的引用计数技术不是那么容易扩充出这个功能的。</p>
<p>​        即使效率不是主要问题，引用计数仍然很吸引人。如果你不放心谁应该去执行删除动作，那么引用计数正是这种让你放下担子的技巧。很多程序员只因为这个原因就使用引用计数。</p>
<p>​        让我们用最后一个问题结束讨论。当RCObject::removeReference减少对象的引用计数时，它检查新值是否为0。如果是，removeReference通过调用delete this销毁对象。这个操作只在对象是通过调用new生成时才安全，所以我们需要一些方法以确保RCObject只能用这种方法产生。</p>
<p>​        此处，我们用习惯方法来解决。RCObject被设计为只作被引用计数的值对象的基类使用，而这些值对象应该只通过灵巧指针RCPtr引用。此外，值对象应该只能由值会共享的对象来实例化；它们不能被按通常的方法使用。在我们的例子中，值对象的类是StringValue，我们通过将它申明为String的私有而限制其使用。只有String可以创建StringValue对象，所以String类的作者应该确保这些值对象都是通过new操作产成的。</p>
<p>​        于是，我们限制RCObject只能在堆上创建的方法就是指定一组满足这个要求的类，并确保只有这些类能创建RCObject对象。用户不可能无意地（或有意地）用一种不恰当的方法创建RCObject对象。我们限制了创建被引用计数对象的权力，当我们交出这个权力时，必须明确其附带条件是满足创建对象的限制条件。</p>
<h1 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h1><p>突发奇想，准备来点CPP狠活（）</p>
<h2 id="CPP智能指针类型"><a href="#CPP智能指针类型" class="headerlink" title="CPP智能指针类型"></a>CPP智能指针类型</h2><p>​    ·    就三个：</p>
<pre class="line-numbers language-none"><code class="language-none">std::unique_ptr
std::shared_ptr
std::weak_ptr
    
std::auto_ptr 已经被废弃！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下面就开始一些简单的讲述</p>
<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>​        在CPP智能指针诞生之后，CPP的指针就包括两类了： raw pointer裸指针和智能指针 smart_pointer。我们的cpp对指针进行了封装，优点就是可以自动分配内存，不需要你来干，不需要你来释放。</p>
<p>​        不过，需要知道的是：更多的时候裸指针会更加的方便而不是智能指针！在使用频率上，还是：原始指针 &gt; unique_ptr = shared_ptr &gt; weak_ptr的</p>
<p>​        对了，事实上我们的智能指针并没有完全解决内存安全！这是我们需要注意的。智能指针解决了所有权指针的释放和传输！因此，不是在开发中无脑的使用智能指针就完事了！否则还会造成内存安全隐患。</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>​        人话：在任何给定时刻只有一个指针管理这片内存！并且，当这个指针出了作用域之后自动释放内存。BTW，因为只能一个指针管，因此不能复制，智能移动。</p>
<p>​        我们有三种创建方式。</p>
<p>​        1）现有的裸指针来创建（建议设置为空nullptr）</p>
<p>​        2）new一个</p>
<p>​        3）std::make_unique整一个（推介）</p>
<p>​        by the way我们使用get（）方法来获取地址</p>
<p>​        其余的-&gt;和 . 都跟裸指针都是一样的，下面来看下demo</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; create a file of dog class::

.h:&gt;
#pragma once

#include&lt;string&gt;
#include&lt;iostream&gt;

class dog
&#123;
public:
	dog(std::string name, unsigned int age);
	dog() &#x3D; default; &#x2F;&#x2F; using in C++11, to avoid being mistaken while you just simply write &quot;dog a&quot;

	~dog();

	void showDogInfo() const &#123;
		std::cout &lt;&lt; &quot;the dog&#39;s name is: &quot; &lt;&lt; name &lt;&lt; &quot;and it&#39;s &quot; &lt;&lt; age &lt;&lt; &quot;years old&quot; &lt;&lt; &#39;\n&#39;;
	&#125;

	void setInfo(const std::string name,const unsigned int age)
	&#123;
		this-&gt;name &#x3D; name;
		this-&gt;age &#x3D; age;
		return;
	&#125;

	std::string getInfoofName() &#123;

		return this-&gt;name;

	&#125;

	unsigned int getAge() &#123;

		return this-&gt;age;

	&#125;
private:
	std::string name;
	unsigned int age;
&#125;;

.cpp:&gt;
   #include &quot;dog.h&quot;

dog::dog(std::string name, unsigned int age)
&#123;

	std::cout &lt;&lt; &quot;building a dog actually...&quot;;
	this-&gt;name &#x3D; name;
	this-&gt;age &#x3D; age;
	return;


&#125;


dog::~dog() &#123;
	

	std::cout &lt;&lt; &quot;is being erased of...  &quot; &lt;&lt;this-&gt;name&lt;&lt; &#39;\n&#39;;

	
&#125;

:&gt; in main.cpp
    #include&lt;iostream&gt;
#include&lt;memory&gt;
#include&quot;dog.h&quot;

using namespace std;

int main()
&#123;
	&#x2F;&#x2F; creating in stack

	dog c1(&quot;yes&quot;, 10);
	c1.showDogInfo();

	&#123;
		&#x2F;&#x2F; using in limited area

		dog c1(&quot;yep!!!&quot;, 200);
		c1.showDogInfo();
	&#125;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416205015394.png?lastModify=1685936981" alt="image-20230416205015394"></p>
<p>​        那在裸指针的接收吧！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416205243842.png?lastModify=1685936981" alt="image-20230416205243842"></p>
<p>​        出问题了，他没有调用析构，意味着内存泄漏</p>
<p>​        在CPP11之前，我们需要手动的delete！</p>
<p>​        但是就算如此还是会出现这样的问题！</p>
<pre class="line-numbers language-none"><code class="language-none">dog* c2 &#x3D; new dog(&quot;heap&quot;, 1000);
c2-&gt;showDogInfo();
&#123;
	c2 &#x3D; new dog(&quot;heap&quot;, 1000);
    c2-&gt;showDogInfo();
&#125;
	
delete c2;
&#x2F;&#x2F; FATAL ERROR!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们发现指针的转移造成了一个内存不被指针记住！</p>
<p>​        那这样呢？</p>
<pre class="line-numbers language-none"><code class="language-none">dog* c2 &#x3D; new dog(&quot;heap&quot;, 1000);
c2-&gt;showDogInfo();
&#123;
	c2 &#x3D; new dog(&quot;heap&quot;, 1000);
    c2-&gt;showDogInfo();
    delete c2;
&#125;
	
delete c2;
&#x2F;&#x2F; SO how???<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        还是错的！从这个变量已被改变开始，就找不回去了！所有，这个代码会崩溃。因此我们在这样的复杂场合下不应该使用裸指针。</p>
<h2 id="demo-of-智能指针创建"><a href="#demo-of-智能指针创建" class="headerlink" title="demo of 智能指针创建"></a>demo of 智能指针创建</h2><p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416210214902.png?lastModify=1685936981" alt="image-20230416210214902"></p>
<p>​        你看，现在我们使用智能指针。没有调用delete还是成功的删除了dog在堆上的内存</p>
<p>​        但是还有一个大问题：我们就这样跑路了对不对？不对，没有对原始的空指针进行销毁：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Correct one:...
dog* c2 &#x3D; new dog(&quot;heap&quot;, 1000);
c2-&gt;showDogInfo();
unique_ptr&lt;dog&gt; uni_dogPtr(c2);
c2 &#x3D; nullptr;
uni_dogPtr-&gt;showDogInfo();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我觉得不如这样写更加好：</p>
<pre class="line-numbers language-none"><code class="language-none">unique_ptr&lt;dog&gt; uni_dogPtr(new dog(&quot;smart&quot;,1000));
uni_dogPtr-&gt;showDogInfo();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        但官方推介的是这个：</p>
<pre class="line-numbers language-none"><code class="language-none">unique_ptr&lt;dog&gt; recommend &#x3D; make_unique&lt;dog&gt;(&quot;recommend&quot;,114514);	recommend-&gt;showDogInfo();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        显然这个更简洁。</p>
<p>​        下面是get()方法的应用：</p>
<pre class="line-numbers language-none"><code class="language-none">std::cout&lt;&lt;&quot;\nthe data&#39;s addr is :&gt; &quot;&lt;&lt;recommend.get() &lt;&lt; std::endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        也有可以对这个智能指针直接解引用的方式来处理问题：当然要预先定义解引用后怎么处置对象的问题。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416212757013.png?lastModify=1685936981" alt="image-20230416212757013"></p>
<h2 id="unique-ptr和函数调用"><a href="#unique-ptr和函数调用" class="headerlink" title="unique_ptr和函数调用"></a>unique_ptr和函数调用</h2><p>​        注意！这个玩意不可以copy，而且在做函数参数或者是的时候一定要留心所有权的问题！</p>
<p>​        1）值传递</p>
<p>​        需要使用std::move来转移内存的拥有权</p>
<p>​        若参数直接传入到std::make_unique语句，那就自动转化成move!</p>
<p>​        2）引用传递</p>
<p>​        若设置了const就不能改变指针的指向！这是需要我们注意的！</p>
<p>​        3）返回值</p>
<p>​        指向一个local object</p>
<p>​        当然用于链式函数！</p>
<p>​        下面来看一个Demo, 现在我们来看一下，我们现在设计一个如下的函数！</p>
<pre class="line-numbers language-none"><code class="language-none">void do_WithDog(std::unique_ptr&lt;dog&gt; pDog)&#123;

	pDog-&gt;showInfo();

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是很快，我们试图去传送的时候也，给你爆一个匪夷所思的错误：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230419210523714.png?lastModify=1685936981" alt="image-20230419210523714"></p>
<p>​        这个时候，其实就是ptr的权限不够，现在我们来用std::move来解决问题</p>
<pre class="line-numbers language-none"><code class="language-none">void do_WithDog(std::move(pDog))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        此后留意到，不可以再次使用这个指针来访问，因为以及被移动了！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3MxMXNob3dfMTYz,size_16,color_FFFFFF,t_70.png?lastModify=1685936981" alt="img"></p>
<p>（本质上讨论！就是把左值变为右值）</p>
<p>​        能不能简单点？可以，但是注意到，这里发生了隐式类型转换！</p>
<pre class="line-numbers language-none"><code class="language-none">void do_WithDog(std::make_unique&lt;dog&gt;());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        2)引用传递</p>
<p>​        现在我们重新设计一下！</p>
<pre class="line-numbers language-none"><code class="language-none">void doWithRefDof(std::unique_ptr&lt;dog&gt;&amp; pDog) &#123;
	pDog-&gt;setInfo(&quot;111&quot;, 100);
	pDog-&gt;showDogInfo();
	pDog.reset();&#x2F;&#x2F; 把pDog的指向转向0
&#125;
doWithRefDof(recommend);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        于是后面再次使用recommend的时候会发现代码会在运行的时候崩溃，因为</p>
<pre class="line-numbers language-none"><code class="language-none">recommend.get() --&gt; 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这是需要注意的！那这样呢？</p>
<pre class="line-numbers language-none"><code class="language-none">void doWithRefDof(const std::unique_ptr&lt;dog&gt;&amp; pDog) &#123;
	pDog-&gt;setInfo(&quot;111&quot;, 100);
	pDog-&gt;showDogInfo();
	pDog.reset();&#x2F;&#x2F; 把pDog的指向转向0
&#125;
doWithRefDof(recommend);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        然后发现爆了新错，不是因为setInfo不能使用，而是Reset 出了问题</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230419212829818.png?lastModify=1685936981" alt="image-20230419212829818"></p>
<p>​        就像常指针一样了！</p>
<p>​        下面，我们来设计一个返回unique_ptr 的函数 ，他正是：</p>
<pre class="line-numbers language-none"><code class="language-none">std::unique_ptr&lt;dog&gt; getUniDogPtr(const std::string name,const unsigned int age)&#123;

	std::unique_ptr&lt;dog&gt; p_Dog &#x3D; std::make_unique&lt;dog&gt;(name,age);
    
    return p_Dog;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        或者再简洁一点！</p>
<pre class="line-numbers language-none"><code class="language-none">std::unique_ptr&lt;dog&gt; getUniqueDogPtr(const std::string name,const unsigned int age) &#123;

	return std::make_unique&lt;dog&gt;(name, age);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="shared-ptr-与计数机制"><a href="#shared-ptr-与计数机制" class="headerlink" title="shared_ptr 与计数机制"></a>shared_ptr 与计数机制</h2><p>​        <code>shared_ptr</code>作为现代C++智能指针的一种，又被译作计数指针（按照原名是共享指针），于是，不同于<code>unique_ptr</code>那样， <code>shared_ptr</code>字如其名的——可以共享数据！我们可以复制这个指针，让多个指针都指向同一块内存！</p>
<p>​        但是让<code>shared_ptr</code>独特于裸指针的是：它引入了计数机制！也就是说，wrap了一个计数器与类对象所指向的内存相关联起来！</p>
<p>​        我们对其的copy行为在运行中发生一侧，计数器就+1，销毁一次就-1，对外界的接口就是调用方法：<code>use_count()</code>来查看</p>
<h3 id="常量类型的shared-ptr"><a href="#常量类型的shared-ptr" class="headerlink" title="常量类型的shared_ptr"></a>常量类型的shared_ptr</h3><p>​        下面呢：我们来搞一下shared_ptr来指向经典对象的demo:</p>
<pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int&gt; i_pInt1 &#x3D; make_shared&lt;int&gt;(10);

cout &lt;&lt; &quot;val:&gt;&quot; &lt;&lt; *i_pInt1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422212238727.png?lastModify=1685936981" alt="image-20230422212238727"></p>
<p>​        试试use_count:</p>
<pre class="line-numbers language-none"><code class="language-none">cout &lt;&lt;&quot;use_count:&gt;&quot;&lt;&lt;i_pInt1.use_count()&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422212438039.png?lastModify=1685936981" alt="image-20230422212438039"></p>
<p>​        那我们说的copy究竟是啥呢？正是类似于浅拷贝那样，announce 一个指针，直接将地址复制给这个新指针，只是将地址传递给了新指针而没有为这块数据本身做任何拷贝！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422212644498.png?lastModify=1685936981" alt="image-20230422212644498"></p>
<p>​        可以看到，这下<code>use_count</code>变成2了！</p>
<p>​        那就显然了！如果我们通过i_pInt1来改变值，当我们解析i_pInt2的时候，值一定也会变！    </p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;change the val by Path *pVal1 &#x3D; 20;

*i_pInt1 &#x3D; 1000;
cout &lt;&lt; &quot;val:&gt;&quot; &lt;&lt; *i_pInt2 &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422212859311.png?lastModify=1685936981" alt="image-20230422212859311"></p>
<p>​        那现在我们的指针的计数还是2，怎么让他减少呢？让其中一个不再指向这块内存就好了！</p>
<pre class="line-numbers language-none"><code class="language-none">i_pInt2 &#x3D; nullptr;
cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt1.use_count() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422213103231.png?lastModify=1685936981" alt="image-20230422213103231"></p>
<p>​        同时，我们注意，那个被指向nullptr的共享指针，他的计数就是0了！因为他这个时候不在指向任何东西！</p>
<pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;int&gt; i_pInt3 &#x3D; i_pInt1;
shared_ptr&lt;int&gt; i_pInt4 &#x3D; i_pInt1;
shared_ptr&lt;int&gt; i_pInt5 &#x3D; i_pInt1;
shared_ptr&lt;int&gt; i_pInt6 &#x3D; i_pInt1;
&#x2F;&#x2F; erase i_pInt2;
i_pInt2 &#x3D; nullptr;
cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt2.use_count() &lt;&lt; endl;
cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt1.use_count() &lt;&lt; endl;
cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt3.use_count() &lt;&lt; endl;
cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt4.use_count() &lt;&lt; endl;
cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt5.use_count() &lt;&lt; endl;
cout &lt;&lt; &quot;use_count:&gt;&quot; &lt;&lt; i_pInt6.use_count() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422213428144.png?lastModify=1685936981" alt="image-20230422213428144"></p>
<h3 id="自定义类型的shared-ptr"><a href="#自定义类型的shared-ptr" class="headerlink" title="自定义类型的shared_ptr"></a>自定义类型的shared_ptr</h3><pre class="line-numbers language-none"><code class="language-none">shared_ptr&lt;dog&gt; pDog1 &#x3D; make_shared&lt;dog&gt;(dog(&quot;111&quot;, 100));
*pDog1 &lt;&lt; *pDog1;

shared_ptr&lt;dog&gt; pDog2 &#x3D; pDog1;
shared_ptr&lt;dog&gt; pDog3 &#x3D; pDog1;
shared_ptr&lt;dog&gt; pDog4 &#x3D; pDog1;
cout &lt;&lt; pDog1.use_count() &lt;&lt; &quot; &quot; &lt;&lt; pDog2.use_count() &lt;&lt; &quot; &quot; &lt;&lt; pDog3.use_count() &lt;&lt; &quot; &quot; &lt;&lt; pDog4.use_count();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422214020516.png?lastModify=1685936981" alt="image-20230422214020516"></p>
<p>​        当shared_ptr 中没人指向内存的时候自动释放内存！可以使用reset方法来置空指针为 nullptr!</p>
<h2 id="shared-ptr与函数"><a href="#shared-ptr与函数" class="headerlink" title="shared_ptr与函数"></a>shared_ptr与函数</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>​        我们使用值传递的时候，我们是使用了copy的，这个时候在函数内部来use_count就会发现计数器+1了，但是当函数结束调用时，指针析构，计数器-1！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422214825448.png?lastModify=1685936981" alt="image-20230422214825448"></p>
<pre class="line-numbers language-none"><code class="language-none">#include&quot;dog.h&quot;
#include&lt;iostream&gt;

using namespace std;

void passByVal(shared_ptr&lt;dog&gt; pDog)
&#123;
	pDog-&gt;showDogInfo();
	cout &lt;&lt; pDog.use_count() &lt;&lt; endl;
	return;
&#125;

int main()
&#123;
	shared_ptr&lt;dog&gt; pDog1 &#x3D; make_shared&lt;dog&gt;(&quot;111&quot;, 100);
	cout &lt;&lt; pDog1.use_count() &lt;&lt; endl;
	passByVal(pDog1);
	cout &lt;&lt; pDog1.use_count() &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422215220588.png?lastModify=1685936981" alt="image-20230422215220588"></p>
<p>​        </p>
<pre class="line-numbers language-none"><code class="language-none">#include&quot;dog.h&quot;
#include&lt;iostream&gt;

using namespace std;

void passByVal(shared_ptr&lt;dog&gt; pDog)
&#123;
	pDog-&gt;showDogInfo();
	cout &lt;&lt; pDog.use_count() &lt;&lt; endl;
	return;
&#125;

void passByRef(shared_ptr&lt;dog&gt;&amp; pDog)
&#123;
	pDog-&gt;showDogInfo();
	pDog.reset(new dog(&quot;222&quot;,222));
	return;
&#125;


int main()
&#123;
	shared_ptr&lt;dog&gt; pDog1 &#x3D; make_shared&lt;dog&gt;(&quot;111&quot;, 100);
	cout &lt;&lt; pDog1.use_count() &lt;&lt; endl;
	passByVal(pDog1);
	cout &lt;&lt; pDog1.use_count() &lt;&lt; endl;
	passByRef(pDog1);
	pDog1-&gt;showDogInfo();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        显然，我们使用引用并更改之（reset方法）后，资源本身也被更改！因此，倘若我们不想让程序无意间更改资源本身，请在函数参数列表中做出如下的修改，那就是：</p>
<pre class="line-numbers language-none"><code class="language-none">void passByRef(const shared_ptr&lt;dog&gt;&amp; pDog)
&#123;
	pDog-&gt;showDogInfo();
	&#x2F;&#x2F; pDog.reset(new dog(&quot;222&quot;,222));
	return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422215456331.png?lastModify=1685936981" alt="image-20230422215456331"></p>
<p>​        这样就修改不了了！</p>
<h3 id="做返回值"><a href="#做返回值" class="headerlink" title="做返回值"></a>做返回值</h3><p>​        同普通指针类似，这里不做过多的讲解</p>
<h2 id="和unique-ptr的区别"><a href="#和unique-ptr的区别" class="headerlink" title="和unique_ptr的区别"></a>和unique_ptr的区别</h2><p>​        我们可以将unique_ptr转化为shared_ptr,只需使用std::move就好了！但是反之不能！就像只指向一个内存的一个指针可以用多个指针一同指向它！而反之不能！这里，当我们的函数需要返回一个开辟的地址时，强烈建议返回的指针时unique_ptr！这样方便我们使用！随时可以转化为shared_ptr或者给其他指针赋值，反之很困难！</p>
<pre class="line-numbers language-none"><code class="language-none">#include&quot;dog.h&quot;
#include&lt;iostream&gt;

using namespace std;

unique_ptr&lt;dog&gt; getUniPtr() &#123;

	return make_unique&lt;dog&gt;(&quot;111&quot;, 100);

&#125;

int main()
&#123;

	unique_ptr&lt;dog&gt; pUniDog &#x3D; getUniPtr();
	shared_ptr&lt;dog&gt; pSharedDog &#x3D; std::move(pUniDog);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        还是值得注意的是：unique_ptr向shared_ptr 转化的时候是隐式转化的！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422220750213.png?lastModify=1685936981" alt="image-20230422220750213"></p>
<pre class="line-numbers language-none"><code class="language-none">#include&quot;dog.h&quot;
#include&lt;iostream&gt;

using namespace std;

unique_ptr&lt;dog&gt; getUniPtr() &#123;

	return make_unique&lt;dog&gt;(&quot;111&quot;, 100);

&#125;

int main()
&#123;

	unique_ptr&lt;dog&gt; pUniDog &#x3D; getUniPtr();
	shared_ptr&lt;dog&gt; pSharedDog &#x3D; std::move(pUniDog);

	shared_ptr&lt;dog&gt; pTransform &#x3D; getUniPtr();
	if (!pTransform) &#123;
		return -1;
	&#125;

	pTransform-&gt;showDogInfo();
	cout &lt;&lt; pTransform.use_count() &lt;&lt; endl;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ ptr"></a>weak_ ptr</h2><p>​        这是弱指针！很有趣的是 weak_ptr不可以调用-&gt;和*，因为它压根就没有内存的所有权！那他为什么存在？</p>
<h3 id="一个循环引用的例子"><a href="#一个循环引用的例子" class="headerlink" title="一个循环引用的例子"></a>一个循环引用的例子</h3><p>​        下面我们修改dog.h</p>
<pre class="line-numbers language-none"><code class="language-none">void setFriend(std::shared_ptr&lt;dog&gt; dog) &#123;
		this-&gt;friends &#x3D; dog;
	&#125;
&#x2F;&#x2F;

private:
std::shared_ptr&lt;dog&gt; friends;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        </p>
<pre class="line-numbers language-none"><code class="language-none">#include&quot;dog.h&quot;
#include&lt;iostream&gt;
&#x2F;&#x2F;ERROR!!!!!!!!!!!!!!!!!!!!!
using namespace std;
int main()
&#123;
	shared_ptr&lt;dog&gt; pDog1 &#x3D; make_shared&lt;dog&gt;(&quot;111&quot;, 111);

	weak_ptr&lt;dog&gt; weak_one(pDog1);

	cout &lt;&lt; &quot;see:&gt;weak_ptr:&quot; &lt;&lt; weak_one.use_count() &lt;&lt; &quot; while:&gt; &quot; &lt;&lt; pDog1.use_count()&lt;&lt;endl;

	shared_ptr&lt;dog&gt; pDogLock &#x3D; weak_one.lock();

	cout &lt;&lt; pDog1.use_count() &lt;&lt; endl;
	cout &lt;&lt; weak_one.use_count() &lt;&lt; endl;
	cout &lt;&lt; pDogLock.use_count() &lt;&lt; endl;


	shared_ptr&lt;dog&gt; pDog3 &#x3D; make_shared&lt;dog&gt;(&quot;333&quot;, 3);
	shared_ptr&lt;dog&gt; pDog4 &#x3D; make_shared&lt;dog&gt;(&quot;444&quot;, 4);
	pDog3-&gt;setFriend(pDog4);
	pDog4-&gt;setFriend(pDog3);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422223254134.png?lastModify=1685936981" alt="image-20230422223254134"></p>
<p>​        马上发现问题了！好家伙，333和444没被析构！正确的，因为此时他们循环调用导致计数器失灵！</p>
<p>​        上述问题可以简化为：</p>
<p>​        当我们有一个类A，需要存储其他A类的对象的信息的时候，倘若我们使用shared_ptr，就会在销毁的时候遇到循环依赖的问题！比若说</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
class A &#123;
public:
	std::shared_ptr&lt;B&gt; bptr;
	~A() &#123;
		cout &lt;&lt; &quot;A is deleted&quot; &lt;&lt; endl;
	&#125;
&#125;;
class B &#123;
public:
	std::shared_ptr&lt;A&gt; aptr;
	~B() &#123;
		cout &lt;&lt; &quot;B is deleted&quot; &lt;&lt; endl;
	&#125;
&#125;;
int main()
&#123;
    
	&#123;
		std::shared_ptr&lt;A&gt; ap(new A);
		std::shared_ptr&lt;B&gt; bp(new B);
		ap-&gt;bptr &#x3D; bp;
		bp-&gt;aptr &#x3D; ap;
	&#125;
    
	cout&lt;&lt; &quot;Job unfinished,but sadly quit!&quot; endl; &#x2F;&#x2F; 循环引用导致ap bp退出了作用域都没有析构!
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        那怎么办？使用weak_ptr就好了</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422223544954.png?lastModify=1685936981" alt="image-20230422223544954"></p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;std::shared_ptr&lt;dog&gt; friends;
std::weak_ptr&lt;dog&gt; friends;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="构造一个weak-ptr"><a href="#构造一个weak-ptr" class="headerlink" title="构造一个weak_ptr"></a>构造一个weak_ptr</h3><p>​        我们注意到，weak_ptr作为shared_ptr的伴生物，其构造从shared_ptr来！</p>
<pre class="line-numbers language-none"><code class="language-none">using namespace std;
int main()
&#123;
	shared_ptr&lt;dog&gt; pDog1 &#x3D; make_shared&lt;dog&gt;(&quot;111&quot;, 111);

	weak_ptr&lt;dog&gt; weak_one(pDog1);

	cout &lt;&lt; &quot;see:&gt;weak_ptr:&quot; &lt;&lt; weak_one.use_count() &lt;&lt; &quot; while:&gt; &quot; &lt;&lt; pDog1.use_count()&lt;&lt;endl;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422222035184.png?lastModify=1685936981" alt="image-20230422222035184"></p>
<p>​        看到了嘛。我们的weak_ptr当被赋予了同样的地址之后，两者的计数器都不会+1！于是，想要解决上面的问题，只需要把其中一个指针改成weak_ptr就好了！</p>
<p>​        那么，weak_ptr可不可以转化成shared_ptr呢？可以！调用方法lock() 就OK了！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230422222447965.png?lastModify=1685936981" alt="image-20230422222447965"></p>
<h1 id="Section-1-简单的理解递归"><a href="#Section-1-简单的理解递归" class="headerlink" title="Section 1 简单的理解递归"></a>Section 1 简单的理解递归</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>​        我们在学习与工作中，常常看到这样递归。是的，递归让代码变得简洁，复用率更高。但是我们往往不会很好的使用递归（包括我，QAQ）。 一般来讲，这可能是不知道递归的本质是函数调用，不清晰函数调用的本质造成的，其次，我们很容易陷入递归里去出不来了，搞不清楚当前的状态，也即是：搞错了方向。宏观把控更为重要（后面会细说）</p>
<p>​        简单来讲，函数体内一次递归是对线性数据结构的遍历处理，二次递归是对二叉树数据结构的递归处理。多次递归是对多叉树进行处理。但这样讲还是抽象，我们先不从应用层面而是转向原理层面来了解递归！</p>
<h2 id="从栈讲起！"><a href="#从栈讲起！" class="headerlink" title="从栈讲起！"></a>从栈讲起！</h2><p>​        有点莫名奇妙，我们为什么要从栈讲起呢？这是为了后面的系统函数调用栈做准备，如果对栈比自己喜欢吃啥都熟悉，建议移步到系统调用栈下面去。</p>
<p>​        其实他不是什么新东西，只是一个受到了限制的数据结构（数组，单链表）等。什么意思呢》以数组为例，数组可以在结构的两端插入元素，链表同理。但是现在我们规定我们只能从一端来操作数据结构。举个例子。现在我们要往一个数组里扔东西。对于一个一般的数组，我爱怎么扔怎么扔。但是对于栈来讲，他只能如下图所示的这样的放入数组或者弹出数组。这样受限的数据结构正是栈。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409112854441.png?lastModify=1685936981" alt="image-20230409112854441"></p>
<p>​        可以看到，我们把插入和删除换成了 push back 和 pop out. 在栈里，这样的行为叫压栈和弹栈。</p>
<pre class="line-numbers language-none"><code class="language-none">往栈里放入元素的过程叫压栈
往栈里弹出元素的过程叫弹栈<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        而且，我们只可以对最上面的元素展开操作而不能对下面的元素操作。这样的特点从动态角度来看，不正是后进先出嘛！就是说，最后进入栈的必须第一个出栈</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409113920536.png?lastModify=1685936981" alt="image-20230409113920536"></p>
<p>​        至于栈的实现如何，这里不做说明，可以看我搞的其他博客或者自行查询怎样实现。</p>
<h2 id="系统函数调用栈"><a href="#系统函数调用栈" class="headerlink" title="系统函数调用栈"></a>系统函数调用栈</h2><p>​        可以说，栈的一个在操作系统级别的应用，就是系统函数的调用栈。话说的太抽象了，来看个例子！</p>
<p>​        今天我们需要书写一个程序，很简单，不难的：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt; &#x2F;&#x2F; 不熟悉这个的，理解为python 的 import 包就可以了！

int getModFrom2Int(int num1,int num2)
&#123;
    return a % b; &#x2F;&#x2F; 函数执行取余数的操作，并将其返回！
&#125;

int getAddOf2Int(int num1,int num2)
&#123;
    int resFromMod &#x3D; getModFrom2Int(num1,num2);
    return resFromMod + b;
&#125;

int main() &#x2F;&#x2F; 程序入口
&#123;
    int a &#x3D; 3;
    int b &#x3D; 2;
    int c &#x3D; getAddOf2Int(a,b); &#x2F;&#x2F; 
    printf(&quot;%d&quot;,c); &#x2F;&#x2F; print the num on console控制台的打印
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是一份简单的C语言代码。从程序运行的顺序来看：程序从 main 进入，经过初始化 a,b的时候，准备初始 c ，但是注意到，c的初始化是由<code>getAddOf2Int</code>这个函数的返回值赋值的，意味着程序必须要进入函数当中。 当程序执行到<code>getAddOf2Int</code>里，他马上又发现， 里头的另一个变量 res ，需要调用函数<code>getModFrom2Int</code>来解决。程序又跳转到<code>getModFrom2Int</code>里去，终于我们不折腾了，对 作为实参的 a, b 取完余数就直接扔回去（优雅的讲叫返回结果指调用处），res 得到了值 3 % 2 = 1，随后，<code>getAddOf2Int</code>又把res和 b 再次相加， 作为<code>getAddOf2Int</code>返回去了，显然这是 3。分析结束，是不是这样呢？我们在Linux下跑一下代码！</p>
<p>​        如果不知道怎么搞，就这样</p>
<pre class="line-numbers language-none"><code class="language-none"># 找到一个文件夹，进入到里面，打开终端 open in terminal
&gt;&gt;&gt; vim runCode1.c
#书写代码， 当然不熟悉的话，先摁i进入编辑模式随后输入代码

# 写完了退出去，方法是：摁esc，输入:wq退出

&gt;&gt;&gt; gcc runCode1 #没有就跟提示 sudo apt install gcc

# 没有指定可执行文件，会自动生成 a.out

&gt;&gt;&gt; .&#x2F;a.out

res: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409204340812.png?lastModify=1685936981" alt="image-20230409204340812"></p>
<p>​        找到你的可执行文件，不然就会出现如上图各种各样的报错。我们的分析没有大问题。</p>
<p>​        可是这跟我们的主题有什么关系呢？别着急，现在就来问你，怎么实现的？怎么让函数按部就班的调用，返回呢？答案就是系统调用函数栈。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409204833854.png?lastModify=1685936981" alt="image-20230409204833854"></p>
<p>​        很好，我们遇到一个函数就把函数地址（函数在哪）压到里面去！直到程序不在调用新的函数（最后一个入栈的不调函数了！）开始逐级返回，函数出栈！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409205354471.png?lastModify=1685936981" alt="image-20230409205354471"></p>
<p>​        这些函数在栈里，就用这里的属于说话吧！他们叫栈帧，如同视频一般，一帧一帧展示调用返回。</p>
<p>​        栈帧是一个复杂的复合体，一般而言他有三个部分构成！</p>
<p>​        1.函数参数，如 main 函数没有函数参数，而<code>getAddOf2Int</code>有两个参数 num1 ,num2</p>
<p>​        2.局部变量，如 main 函数里有 a, b ,c 三个在函数体内的变量，<code>getAddOf2Int</code>里有个res 来接受 Mod 函数的返回值。</p>
<p>​        3.(不好理解)返回地址。这是干嘛的呢？我们在文本编辑器里，可以直观的看到…</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409210330240.png?lastModify=1685936981" alt="image-20230409210330240"></p>
<p>但是对于CPU来讲，它进到getModFrom2Int里，再次出来的时候不知道下一条指令在哪里。于是，需要存储下一条指令（return resFromMod + num2）的指令地址，方便CPU从其他函数调用之后又再次回来时找到继续执行的地方.</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409210832275.png?lastModify=1685936981" alt="image-20230409210832275"></p>
<p>​        什么？口说无凭？上汇编！</p>
<pre class="line-numbers language-none"><code class="language-none">objdump -S a.out<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>A</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409211229724.png?lastModify=1685936981" alt="image-20230409211229724"></p>
<p>​        留心到 callq 指令，这是函数调用的指令。函数执行完毕，CPU直接读取栈帧的存储返回地址继续走。</p>
<h2 id="步入正题！函数调用自己！（就是递归）"><a href="#步入正题！函数调用自己！（就是递归）" class="headerlink" title="步入正题！函数调用自己！（就是递归）"></a>步入正题！函数调用自己！（就是递归）</h2><p>​        我们学习完基本的函数调用之后，有没有一个大胆的想法：函数可不可以调他自己呢？试试！</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;

int main()
&#123;
	cout &lt;&lt; &quot;Lol, I am calling myself again and again!&quot;;
	Sleep(500); &#x2F;&#x2F; 加个这个，防止程序栈炸了
	main();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409212333392.png?lastModify=1685936981" alt="image-20230409212333392"></p>
<p>​        是的，尝试自己调用自己！这个函数正在不停的调用他自己，直到函数调用栈溢出崩溃。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409213106889.png?lastModify=1685936981" alt="image-20230409213106889"></p>
<p>​        歪！不能这样啊，那咋办，简单，来个中止条件就可以了！简单加个出口。方法就是引入一个计数器，来控制调用次数</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409213315526.png?lastModify=1685936981" alt="image-20230409213315526"></p>
<p>​        就调用了十次，很好！</p>
<p>​        当然，没人，除非是真的需要，会对主函数干这种事情。事实上，以递归执行的函数的调用计时器往往放在参数列表里，通过检测参数来停止函数调用</p>
<p>​        比如说，打印函数3次：</p>
<pre class="line-numbers language-none"><code class="language-none">void PrintinLimits(int times)
&#123;
	if (times &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; if time is used up,process exited by returning val directly
		return;
	&#125;

	cout &lt;&lt; &quot;Calling for times:&gt;&quot; &lt;&lt; times &lt;&lt; &#39;\n&#39;;

	PrintinLimits(times - 1); &#x2F;&#x2F; 次数减1，趋向于停止（0就跳出去了）

	return;
&#125;


int main()
&#123;
	PrintinLimits(3);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409214645855.png?lastModify=1685936981" alt="image-20230409214645855"></p>
<p>所以，到底怎么回事，还是回到调用栈上</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409215339623.png?lastModify=1685936981" alt="image-20230409215339623"></p>
<p>​        比如说我们今天不好好写高斯求和函数：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;windows.h&gt;
using namespace std;

static int callLimits &#x3D; 10;

long GaussainSumInRecurssion(int curAdder)
&#123;
	if (curAdder &#x3D;&#x3D; 0) &#123;
		return 0;
	&#125;
	return curAdder + GaussainSumInRecurssion(curAdder-1);
&#125;


int main()
&#123;
	cout &lt;&lt; GaussainSumInRecurssion(10);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409214756137.png?lastModify=1685936981" alt="image-20230409214756137"></p>
<p>​        是跟上面同理的，但是这个是尾递归，不好理解，我们先不去分析。</p>
<p>​        仿照这一思路，打印数组也有花样！</p>
<pre class="line-numbers language-none"><code class="language-none">void printArrayInRecur(int* array, unsigned int arraySize)
&#123;
	if (arraySize &#x3D;&#x3D; 0) &#123;
		return;
	&#125;

	cout &lt;&lt; array[arraySize - 1] &lt;&lt; &quot; &quot; ; &#x2F;&#x2F; for correctly print
	&#x2F;&#x2F; 数组下标从0开始，减个一！

	printArrayInRecur(array, arraySize - 1);

	return;
&#125;


int main()
&#123;
	int array[4] &#x3D; &#123;1,2,3,4&#125;;

	printArrayInRecur(array, 4);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409215928720.png?lastModify=1685936981" alt="image-20230409215928720"></p>
<p>​        手动实现了倒序打印！</p>
<p>​        那正序呢？</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230409220243255.png?lastModify=1685936981" alt="image-20230409220243255"></p>
<p>​        递归的本质就是函数的调用，而且特别的，是调用他自己，为了防止根本停不下来的调用，我们必须提供一个函数的递归出口——这正是我们之前所阐述的！</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;
&#x2F;&#x2F; 如果你忘记了的话，看看这个复习一下吧！
void printRecur(const int* array, unsigned int start, unsigned int end)
&#123;
	if (array &#x3D;&#x3D; NULL) &#123;
		return;
	&#125;

	if (start &gt;&#x3D; end)
	&#123;
		return;
	&#125;
	cout &lt;&lt; array[start] &lt;&lt; &quot; &quot;;

	printRecur(array, start + 1, end);
&#125;


int main()
&#123;
	int arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;
	printRecur(arr, 0, 10);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们刚刚一直在说系统栈，可不可以书写一个函数来实现我们的系统栈功能呢？可以的：</p>
<p>​        改造上面的代码为如下，详细的解说请参看代码的注释！</p>
<pre class="line-numbers language-none"><code class="language-none">void imitateSysRecur(const int* array, unsigned int start, unsigned int end)
&#123;
	cout &lt;&lt; &#39;\n&#39;;
	stack&lt;int&gt;* sys &#x3D; new stack&lt;int&gt;();&#x2F;&#x2F; 创造一个空栈
	sys-&gt;push(array[start]);&#x2F;&#x2F; 这里等效做函数的第一次调用
	while (!sys-&gt;empty())&#x2F;&#x2F; 查看有没有弹出干净，没有继续弹出！
	&#123;
		int prt &#x3D; sys-&gt;top();&#x2F;&#x2F; 一下就弹出第一个任务
		
		if (start &gt;&#x3D; end)
			return;

		printf(&quot;%d &quot;, prt); &#x2F;&#x2F; 对之执行操作
		sys-&gt;push(array[++start]);&#x2F;&#x2F; 转向下一个
	&#125;

&#125;

int main()
&#123;
	int arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;
	imitateSysRecur(arr, 0, 10);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="虽说递归爽，但是注意到性能问题！"><a href="#虽说递归爽，但是注意到性能问题！" class="headerlink" title="虽说递归爽，但是注意到性能问题！"></a>虽说递归爽，但是注意到性能问题！</h2><p>​        递归也有代价：写的爽必然有代价。</p>
<p>​        首先函数调用就有时间的开销（注意到递归反复调用函数）</p>
<p>​        其次，这也存在空间上的开销！我们需要占一定的空间复杂度来运行我们的函数。</p>
<p>​        那么，什么时候使用递归呢？预告一下：正是那些非线性的数据结构我们使用递归来处理，这将会在树与图论中显的常见！</p>
<h2 id="练习1：递归求解线性表：如数组的和"><a href="#练习1：递归求解线性表：如数组的和" class="headerlink" title="练习1：递归求解线性表：如数组的和"></a>练习1：递归求解线性表：如数组的和</h2><p>​        首先，我们来看，对于一个线性表，我们若是想得知这些元素的和：</p>
<p>A=∑i=0n−1a[i]</p>
<p>​        然而马上发现，这个表达式可以写作：</p>
<p>A=∑i=0n−1a[i]=a[n−1]+∑i=0n−2a[i]</p>
<p>​        啊哈！这递归就出来了：终止条件就是当取到 arr[0]时停止！，这样就可以开始设计递归了。</p>
<p>​        我们的结果可以存放在函数的参数列表里，这样的话递归不用开辟新的空间存放局部变量！</p>
<pre class="line-numbers language-none"><code class="language-none">long getSumRecur(const int* arr, unsigned int arrSize,int curSum)&#x2F;&#x2F; 设计1
&#123;
	if (arr &#x3D;&#x3D; nullptr) &#x2F;&#x2F; 不合法的数组return
	&#123;
		return -1;&#x2F;&#x2F; 这个地方放错误处理，可以是cstdlib下的exit!
	&#125;

	if (arrSize &#x3D;&#x3D; -1) &#x2F;&#x2F; 即将越界
	&#123;
		return curSum; &#x2F;&#x2F; 求和结束，直接返回当下参数的curSum就好了
	&#125;

	getSumRecur(arr, arrSize - 1, curSum + arr[arrSize]);
    &#x2F;&#x2F; 递归！ 让arrSize减1， 表明arr[size-1]已经纳入和 curSum 了！
    &#x2F;&#x2F; 同时，在参数列表中做出 curSum + arr[arrSize]的修改就好了
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样的递归适合与有前缀初始值的求和！</p>
<p>​        有没有别的形式的？有。直接注意到：没有必要新增一个参数，而是直接return掉局部和！就是说：</p>
<pre class="line-numbers language-none"><code class="language-none">return arr[size] + getCur2(arr,size-1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        因为为了返回，必须要把getCur2的值求出来，一直递归到函数不需要调用自己为止！那就很是容易了，只要curSize == 0,返回 arr[curSize]就好了！（其实就是arr[0]）</p>
<pre class="line-numbers language-none"><code class="language-none">long getSumRecur2(const int* arr,int arrSize)
&#123;

	if (arr &#x3D;&#x3D; nullptr) &#123;
		return -1;
	&#125;

	if (arrSize &#x3D;&#x3D; 0)
	&#123;
		return arr[0];
	&#125;

	return arr[arrSize] + getSumRecur2(arr, arrSize - 1);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        run 一下代码！</p>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
	int arr[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;
	cout &lt;&lt; getSumRecur(arr, 9, 0)&lt;&lt; endl;
	cout &lt;&lt; getSumRecur2(arr, 9) &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230412214901272.png?lastModify=1685936981" alt="image-20230412214901272"></p>
<h1 id="Section-2-基于Java-的基础简单算法"><a href="#Section-2-基于Java-的基础简单算法" class="headerlink" title="Section 2 基于Java 的基础简单算法"></a>Section 2 基于Java 的基础简单算法</h1><h6 id="认识时间复杂度"><a href="#认识时间复杂度" class="headerlink" title="认识时间复杂度"></a>认识时间复杂度</h6><p>​        我们有一些操作是常数时间完成的：</p>
<pre class="line-numbers language-none"><code class="language-none">int a &#x3D;arr[i];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        因为我们直接计算偏移量直接取出的</p>
<p>​        但是这个不是</p>
<pre class="line-numbers language-none"><code class="language-none">int t&#x3D;list.get(i);&#x2F;&#x2F;链表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        因为链表必须遍历，才能找到元素</p>
<p>​        以及加减乘除的操作是常数操作。</p>
<p>​        总而言之：涉及到数据量的操作都是非常数操作</p>
<p>​        举个例子，选择排序：这个排序是一种选择某一个数与前面已经排好的数组开始对比。怎么保证前面的已经有序了呢？我们把算法作用在第一个元素上，这个时候那他与第二个元素排序，成功后就是一个有序小数组，这样就满足了递归的条件：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;Part I:C version without recurssion
#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;
#include&lt;windows.h&gt;
&#x2F;&#x2F;using Choose sort to sort the array
&#x2F;&#x2F;rand num getter
int getRandNum(int maxRange)
&#123;
    srand((unsigned int)clock());
    Sleep(10);
    return rand()% maxRange;
&#125;

void printCurrentArray(int* array,int arraySize)
&#123;
    printf(&quot;Current array is shown:\n&quot;);
    for(int i&#x3D;0; i&lt;arraySize; i++)
    &#123;
        printf(&quot;%d &quot;,array[i]);
    &#125;
    printf(&quot;\n&quot;);
&#125;

void swapInt(int* e1, int* e2)
&#123;
    int temp&#x3D;*e1;
    *e1&#x3D;*e2;
    *e2&#x3D;temp;
&#125;

int main()
&#123;
    &#x2F;&#x2F;get a rand array
    int arr[10]&#x3D;&#123;0&#125;;
    for(int i&#x3D;0; i&lt;10; i++)
    &#123;
        arr[i]&#x3D; getRandNum(100);
    &#125;
    &#x2F;&#x2F;Sort starts!
    for(int i&#x3D;1; i&lt;10; i++)
    &#123;
        &#x2F;&#x2F;from the second one
        &#x2F;&#x2F;Compared with the previous one and the front one
        for(int j&#x3D;i;j&gt;0;j--)
        &#123;
            &#x2F;&#x2F;If inverted,invert them back
            if(arr[j]&lt;arr[j-1])
            &#123;
                swapInt(&amp;arr[j], &amp;arr[j - 1]);
            &#125;
        &#125;
        &#x2F;&#x2F;Target the Current Key and show:
        printf(&quot;Current key is:%d\n&quot;,arr[i]);
        printCurrentArray(arr,10);
        printf(&quot;Enter the newline to go forward!&quot;);
        getchar();
    &#125;
    printf(&quot;Eventually...\n&quot;);
    printCurrentArray(arr,10);
&#125;
&#x2F;&#x2F;Or Recussion type
#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;
&#x2F;&#x2F;using Choose sort to sort the array
&#x2F;&#x2F;rand num getter
int getRandNum(int maxRange)
&#123;
    srand((unsigned int)clock());
    Sleep(10);
    return rand() % maxRange;
&#125;

void printCurrentArray(int* array, int arraySize)
&#123;
    printf(&quot;Current array is shown:\n&quot;);
    for (int i &#x3D; 0; i &lt; arraySize; i++)
    &#123;
        printf(&quot;%d &quot;, array[i]);
    &#125;
    printf(&quot;\n&quot;);
&#125;

void swapInt(int* e1, int* e2)
&#123;
    int temp &#x3D; *e1;
    *e1 &#x3D; *e2;
    *e2 &#x3D; temp;
&#125;

void insertSort(int* array, int arraySize, int cur_sort_place)
&#123;
    if (cur_sort_place &gt; arraySize-1)
        return;
    int j &#x3D; cur_sort_place;
    while (j &gt; 0)
    &#123;
        if (array[j] &lt; array[j - 1])
            swapInt(&amp;array[j], &amp;array[j - 1]);
        j--;
    &#125;
    choiceSort(array, arraySize, cur_sort_place + 1);
&#125;

int main()
&#123;
    int arr[10] &#x3D; &#123; 0 &#125;;
    for (int i &#x3D; 0; i &lt; 10; i++)
    &#123;
        arr[i] &#x3D; getRandNum(100);
    &#125;
    insertSort(arr, 10, 1);
    printCurrentArray(arr, 10);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个算法的时间复杂度就是O(N2)，这是因为操作表达式的最高阶是N2.</p>
<p>​        注意到O(N)表达的是表达式的最高此项，是衡量巨大数量下算法的优良度</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230126193633933.png?lastModify=1685936981" alt="image-20230126193633933"></p>
<p>​        当时间复杂度相同时，通过比较常数项作出判断是否可靠。更多的时候我们选择直接开跑看看怎么样：</p>
<pre class="line-numbers language-none"><code class="language-none">public static void Process1()
&#123;
    int N&#x3D;1000;
    int a&#x3D;1;
    for(int i&#x3D;0 ; i&lt;N; i++)
    &#123;
        a*&#x3D;10;
        a&#x3D;a+10;
        a&#x3D;6127*9876;
    &#125;
&#125;

public static void Process2()
&#123;
     int N&#x3D;1000;
    int a&#x3D;1;
    for(int i&#x3D;0 ; i&lt;N; i++)
    &#123;
        a&#x3D;10|1;
        a^&#x3D;10;
        a&#x3D;a&amp;9876;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对，就是这种。</p>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>​        回顾上面的实例代码：我们使用Java写出另一个版本：</p>
<pre class="line-numbers language-none"><code class="language-none">public static void seletionSort(int[] array)&#123;
    if(arr&#x3D;&#x3D;null&amp;&amp;arr.length&lt;2)
    &#123;
        return;
    &#125;
    for(int i&#x3D;0;i&lt;arr.length-1;i++)
    &#123;
        int minIndex&#x3D;i;
        for(int j&#x3D;i+1;j&lt;arr.length;j++)
        &#123;
            minIndex&#x3D;arr[j]&lt;arr[minIndex]?j:minIndex;&#x2F;&#x2F;直接找到最小的地方
        &#125;
        swap(arr,i,minIndex);&#x2F;&#x2F;Using in swap minindex with arr[i]
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><p>​        我们也可以使用冒泡排序排数，就像大的泡泡向下沉，小的泡泡向上浮。就好了。值得注意的是，我们换完产生的最值区已经换好了，没有必要再参与排序。</p>
<pre class="line-numbers language-none"><code class="language-none">for(int i&#x3D;0;i&lt;N-1;i++)
&#123;
    for(int j&#x3D;0;j&lt;N-i;j++)
    &#123;
        if(conditions)
            swap data;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="交换的离奇写法"><a href="#交换的离奇写法" class="headerlink" title="交换的离奇写法"></a>交换的离奇写法</h6><p>请看这个</p>
<pre class="line-numbers language-none"><code class="language-none">public static void swap(int[] arr, int i, int j)
&#123;
    arr[i]&#x3D;arr[i]^arr[j];
    arr[j]&#x3D;arr[i]^arr[j];
    arr[i]&#x3D;arr[i]^arr[j];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>异或：相同为0，不同为1：</p>
<p>例如：</p>
<p>A:1011110101001</p>
<p>B:1000101011001</p>
<p>  A^B: 0011011110000                        </p>
<p>也可以理解为无进位相加：</p>
<p>性质1：0^N=N,N^N=0</p>
<p>性质2：满足交换律和结合律</p>
<p>那这是怎么交换的？</p>
<p>a=a^b  1)</p>
<p>b=a^b</p>
<p>a=a^b</p>
<p>假设a= A,b=B;</p>
<p>1)a=A^B b=B</p>
<p>2)a=A^B,b=(A^B)^B =A^(B^B)=A</p>
<p>3)a=A^B^A=B b=A</p>
<p>交换完毕</p>
<p>但是注意：这样的方法不适用于同一块内存，否则会洗成0.</p>
<p>例题：1）现在有一个整型数组：里面有诺干出现了偶数次的数和一个出现奇数次的数，找出那个奇数次数的数：</p>
<p>EG：[2,1,3,1,3,1,3,2,1]——-&gt;3</p>
<p>Solutions：</p>
<pre class="line-numbers language-none"><code class="language-none">int ero&#x3D;0;
for(int i&#x3D;0;i&lt;arr.length;i++)
&#123;
ero^&#x3D;arr[i];
&#125;
printf(&quot;%d &quot;,ero);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是因为异或顺序无关，偶数次数的全消成了0.于是可以引用在奇偶相关次序无关的题目。</p>
<p>2）现在有一个整型数组：里面有诺干出现了偶数次的数和两个出现奇数次的数，找出那两个奇数次数的数：</p>
<p>Ok，当我们依旧沿袭上面的方法的时候，我们发现：eor=a^b,这是因为一切出现了偶数次的异或为0，a和b也最后削成一个a^b。下面怎么办？</p>
<p>注意到a≠b，这样的话：因为最右边的1是a,b作为二进制的特征数（用它来区分a,b），我们就可以提取出来：int rightOne=eor&amp;(~eor+1)，也就是源码与上补码，提取eor上的第右边的1，随后只与这个位置上是1的数，就得到a或者是b了</p>
<p>​        <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230127113335433.png?lastModify=1685936981" alt="image-20230127113335433"></p>
<pre class="line-numbers language-none"><code class="language-none">public static void printOddTimeNum2(int[] arr)
&#123;
    int eor&#x3D;0;
    for(int i&#x3D;0;i&lt;num)
    &#123;
        eor^arr[i];
    &#125;
    int rightOne&#x3D;eor&amp;(~eor+1);&#x2F;&#x2F;找出来最右边的数
    int onlyOne&#x3D;0;&#x2F;&#x2F;eor&#39;
    for(int cur:arr)
    &#123;
        if((cur&amp;rightOne)&#x3D;&#x3D;0)&#x2F;&#x2F;别写1，因为出来的只能是0或者是rightOne，如果想要另一个就!&#x3D;0;
            onlyOne^&#x3D;cur;
    &#125;
    System.out.printIn(onlyOne+&quot; &quot;+(ero^onlyOne));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h6><p>​        这个就是最上面的代码，就是相当于插牌。这个算法的表现是波动较大的：O(N)~O(N2)。</p>
<p>​        但是算法的复杂度是看最差情况的，所以是O(N2).</p>
<pre class="line-numbers language-none"><code class="language-none">public class Solution&#123;
    public static void insertSort(int[] arr)
    &#123;
        if(arr&#x3D;&#x3D;null&amp;&amp;arr.length&lt;2)
        &#123;
            return;
        &#125;
        for(int i&#x3D;1;i&lt;arr.length;i++)
        &#123;
            for(int j&#x3D;i-1; j&gt;&#x3D;0&amp;&amp;arr[j]&gt;arr[j+1];j--)
            &#123;
                swap(arr,j,j+1);
            &#125;
        &#125;
    &#125;
    public static void swap(...)
    &#123;
        &#x2F;&#x2F;...
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h6><p>​        注意，这个只使用于有序数组。这个数组使用二分查找是最快的。主要思想：找中间，比大小，挪边界，继续二分。这个算法的复杂度因此是O(log⁡n).</p>
<h6 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h6><p>​        假设我们要进行测试方法A，我们使用随机样本产生器，我们随机的产生数据放到多个方法，他们结果要是不一样，那要不就是A错，要不就是B错，要不就是都错了。这个时候人工干预的方式修改方法。</p>
<h5 id="递归行为下时间复杂度的计算"><a href="#递归行为下时间复杂度的计算" class="headerlink" title="递归行为下时间复杂度的计算"></a>递归行为下时间复杂度的计算</h5><h6 id="求取中点的方法"><a href="#求取中点的方法" class="headerlink" title="求取中点的方法"></a>求取中点的方法</h6><pre class="line-numbers language-none"><code class="language-none">int mid&#x3D;L+((R-L)&gt;&gt;1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    为什么这样书写：防止R+L溢出int上限、</p>
<h6 id="使用递归求解数组最大值："><a href="#使用递归求解数组最大值：" class="headerlink" title="使用递归求解数组最大值："></a>使用递归求解数组最大值：</h6><pre class="line-numbers language-none"><code class="language-none">public class Solution&#123;
	public static int getMax(int[] arr)
    &#123;
        return process(arr,0,arr.length-1);
    &#125;
    public static int process(int[] arr, int L ,int R)&#123;
        if(L&#x3D;&#x3D;R)
            return;
        int mid&#x3D;L+((R-L)&gt;&gt;1);
        int leftMax&#x3D;process(arr,L,mid);
        int rightMax&#x3D;process(arr,mid+1,R);
        return Math.max(leftMax,rightMax);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个写法我们是在二分类是常用的：先处理递归左边，再递归处理右边，最后从小到大的返回各层的最大值，最后得到整体的最大值。下面也有C++版本的</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;Windows.h&gt;
class Finder &#123;
public:
	int getMax(std::vector&lt;int&gt; s) &#123;
		return Dofindmax(s, 0, s.size()-1);
	&#125;
	int Dofindmax(std::vector&lt;int&gt; s, int left, int right)
	&#123;
		if (left &#x3D;&#x3D; right)
			return s[left];
		int mid &#x3D; left + ((right - left) &gt;&gt; 1);
		int leftMax &#x3D; Dofindmax(s, left, mid);
		int rightMax &#x3D; Dofindmax(s, mid + 1, right);
		return leftMax &gt; rightMax ? leftMax : rightMax;
	&#125;
&#125;;

void PrintVector(std::vector&lt;int&gt; s)
&#123;
	for (std::vector&lt;int&gt;::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++)
		std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
	std::cout&lt;&lt;std::endl;
&#125;

int getRandNum()
&#123;
	srand((unsigned int)clock());
	Sleep(10);
	return rand() % 100;
&#125;

int main()
&#123;
	std::vector&lt;int&gt; s;
	for (int i &#x3D; 0; i &lt; 10; i++)
		s.push_back(getRandNum());
	PrintVector(s);
	Finder f;
	int t &#x3D; f.getMax(s);
	std::cout &lt;&lt; t;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，别太常用，因为容易把栈搞炸</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230127160815732.png?lastModify=1685936981" alt="image-20230127160815732"></p>
<p>画个递归树</p>
<h6 id="Master公式"><a href="#Master公式" class="headerlink" title="Master公式"></a>Master公式</h6><p>if:T(N)=a∗T(Nb)+O(Nd)</p>
<p>then:1)logb⁡a&gt;d−&gt;T(Nlogb⁡a)</p>
<p>2)logb⁡a=d−&gt;T(NdlogN)</p>
<p>3)logb⁡a<d−>T(Nd)</p>
<p>有人话版本吗？有的：就是说我们的一次递归可以拆分一个问题为b个子问题，当然右额外开销Nd,这样，我们就有分层级讨论：比较logb⁡a与d的大小从而一步写出公式。</p>
<p>以上面为例：上面的问题把问题拆成两个子问题：b=2,并且在单个函数体内调用了两次：a=2,剩下的时间复杂度为O(1).这下，我们的公式就是：</p>
<p>T(N)=2∗T(N/2)+O(1)</p>
<p>这样就直接带入公式:T(N)=O(logn).</p>
<h6 id="补充Reading"><a href="#补充Reading" class="headerlink" title="补充Reading"></a>补充Reading</h6><p>​        平时设计或者阅读一个算法的时候，必然会提到算法的复杂度（包括时间复杂度和空间复杂度）。比如我们说一个二分查找算法的平均时间复杂度为 O(log n)，快速排序可能是 O(n log n)。那这里的 O 是什么意思？这样的表达是否准确呢？</p>
<p>​        今天来复习一下与算法复杂度相关的知识：函数渐进阶，记号 O、Ω、θ和 o；Master 定理。</p>
<p>​        先插一句，在算法复杂度分析中，log 通常表示以 2 为底的对数。</p>
<p>​        算法复杂度（算法复杂性）是用来衡量算法运行所需要的计算机资源（时间、空间）的量。通常我们利用渐进性态来描述算法的复杂度。</p>
<p>​        用 n 表示问题的规模，T(n) 表示某个给定算法的复杂度。所谓渐进性态就是令 n→∞ 时，T(n) 中增长最快的那部分。严格的定义是：如果存在 T′(n)，当 n→∞ 时，有:</p>
<p>T(n)−T′(n)T(n)→0</p>
<p>​        我们就说T′(n)是 T(n) 当 n→∞ 时的渐进性态。</p>
<p>​        比如 T(n) = 2 <em> n ^ 2 + n log n + 3，那么显然它的渐进性态是 2 </em> n ^ 2，因为当 n→∞ 时，后两项的增长速度要慢的多，可以忽略掉。引入渐进性态是为了简化算法复杂度的表达式，只考虑其中的主要因素。当比较两个算法复杂度的时候，如果他们的渐进复杂度的阶不相同，那只需要比较彼此的阶（忽略常数系数）就可以了。</p>
<p>​        总之，分析算法复杂度的时候，并不用严格演算出一个具体的公式，而是只需要分析当问题规模充分大的时候，复杂度在渐进意义下的阶。记号 O、Ω、θ和 o 可以帮助我们了解函数渐进阶的大小。</p>
<p>​        假设有两个函数 f(n) 和 g(n)，都是定义在正整数集上的正函数。上述四个记号的含义分别是：</p>
<ul>
<li>f(n) = O(g(n))：∃c&gt;0,n0∈N,∀n≥n0,f(n)≤cg(n)；f 的阶<strong>不高于</strong> g 的阶。</li>
<li>f(n) = Ω(g(n))：∃c&gt;0,n0∈N,∀n≥n0,f(n)≥cg(n)；f 的阶<strong>不低于</strong> g 的阶。</li>
<li>f(n) = θ(g(n))：⟺f(n)=O(g(n))&amp;&amp;f(n)=Ω(g(n))；f 的阶<strong>等于</strong> g 的阶。</li>
<li>f(n) = o(g(n))：∀ε&gt;0,∃n0∈N,∀n≥n0,f(n)/g(n)&lt;ε；f 的阶<strong>低于</strong> g 的阶。</li>
</ul>
<p>​        可见，记号 O 给出了函数 f(n) 在渐进意义下的上界（但不一定是最小的），相反，记号Ω给出的是下界（不一定是最大的）。如果上界与下界相同，表示 f(n) 和 g(n) 在渐进意义下是同阶的（θ），亦即复杂度一样。</p>
<p>​        列举一些常见的函数之间的渐进阶的关系：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230127163435272.png?lastModify=1685936981" alt="image-20230127163435272"></p>
<p>​        有些人可能会把这几个记号跟算法的最坏、最好、平均情况复杂度混淆，它们有区别，也有一定的联系。</p>
<p>​        即使问题的规模相同，随着输入数据本身属性的不同，算法的处理时间也可能会不同。于是就有了最坏情况、最好情况和平均情况下算法复杂度的区别。它们从不同的角度反映了算法的效率，各有用处，也各有局限。</p>
<p>​        有时候也可以利用最坏情况、最好情况下算法复杂度来粗略地估计算法的性能。比如某个算法在最坏情况下时间复杂度为θ(n ^ 2)，最好情况下为θ(n)，那这个算法的复杂度一定是 O(n ^ 2)、Ω(n) 的。也就是说 n ^ 2 是该算法复杂度的上界，n 是其下界。</p>
<p>​        接下来看看 Master 定理。</p>
<p>​        有些算法在处理一个较大规模的问题时，往往会把问题拆分成几个子问题，对其中的一个或多个问题递归地处理，并在分治之前或之后进行一些预处理、汇总处理。这时候我们可以得到关于这个算法复杂度的一个递推方程，求解此方程便能得到算法的复杂度。其中很常见的一种递推方程就是这样的：</p>
<p>​        设常数 a &gt;= 1，b &gt; 1，f(n) 为函数，T(n) 为非负整数，T(n) = a T(n / b) + f(n)，则有：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230127163457999.png?lastModify=1685936981" alt="image-20230127163457999"></p>
<p>​        比如常见的二分查找算法，时间复杂度的递推方程为 T(n) = T(n / 2) + θ(1)，显然有 nlogba⁡=n0=Θ(1)，满足 Master 定理第二条，可以得到其时间复杂度为 T(n) = θ(log n)。</p>
<p>​        再看一个例子，T(n) = 9 T(n / 3) + n，可知 nlogba=n2，令ε取 1，显然满足 Master 定理第一条，可以得到 T(n) = θ(n ^ 2)。</p>
<p>​        来一个稍微复杂一点儿例子，T(n) = 3 T(n / 4) + n log n。nlogba=O(n0.793)，取ε = 0.2，显然当 c = 3 / 4 时，对于充分大的 n 可以满足 a <em> f(n / b) = 3 </em> (n / 4) <em> log(n / 4) &lt;= (3 / 4) </em> n <em> log n = c </em> f(n)，符合 Master 定理第三条，因此求得 T(n) = θ(n log n)。</p>
<p>​        运用 Master 定理的时候，有一点一定要<strong>特别注意</strong>，就是第一条和第三条中的ε必须<strong>大于零</strong>。如果无法找到大于零的ε，就不能使用这两条规则。</p>
<p>​        举个例子，T(n) = 2 T(n / 2) + n log n。可知 nlogba=n，而 f(n) = n log n，显然不满足 Master 定理第二条。但对于第一条和第三条，也无法找到大于零的ε使得 nlog⁡n=O(n1−ε) 或者Ω(n1−ε)，因此不能用 Master 定理求解，只能寻求别的方式求解。比如可以利用递归树求出该算法的复杂度为 T(n)=O(nlog2⁡n)。简单的说一下计算过程：</p>
<p>​        递归树的建立过程，就像是模拟算法的递推过程。树根对应的是输入的规模为 n 的问题，在递归处理子问题之外，还需要 n log n 的处理时间。然后根据递推公式给根节点添加子节点，每个子节点对应一个子问题。这里需要两个子节点，每个节点处理规模为 n / 2 的问题，分别需要 (n / 2) <em> log(n / 2) 的时间。因此在第二层一共需要 n </em> (log n - 1) 的时间。第三层节点就是将第二层的两个节点继续分裂开，得到四个各需要 (n / 4) <em> log(n / 4) 时间的节点，总的时间消耗为 n </em> (log n - 2)。依此类推，第 k（设树根为 k = 0）层有 2 ^ k 的节点，总的时间为 n * (log n - k)。而且可以知道，这棵树总共有 log n 层（最后一层每个节点只处理规模为 1 的子问题，无须再分治）。最后将每一层消耗的时间累加起来，得到：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230127163854294.png?lastModify=1685936981" alt="image-20230127163854294"></p>
<h6 id="归并排序（MergeSort）"><a href="#归并排序（MergeSort）" class="headerlink" title="归并排序（MergeSort）"></a>归并排序（MergeSort）</h6><p>​        1）整体就很简单，就是一个简单的递归，左边排好序，右边排好序，然后整体就有序。</p>
<p>​        2）让其整体有序的方式用了排外序方法</p>
<p>​        3）继续使用master公式求解:O(Nlog⁡N)，空间复杂度O(N)</p>
<p>​        4）归并排序的实质</p>
<p>思路</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230127164408704.png?lastModify=1685936981" alt="image-20230127164408704"></p>
<p>​        对于一块区域，我们使用指针访问：左右双指针法。开辟一块小空间，如果左边的大于右边的，左边指针拷贝同时指针后移一个，右边大于左边的同理。</p>
<pre class="line-numbers language-none"><code class="language-none">public class Solution&#123;
    public static void mergeSort(int[] arr)
    &#123;
        if(arr&#x3D;&#x3D;null||arr.length&lt;2)
            return;
        process(arr,0,arr.length-1);
    &#125;
    public static void process(int[] arr,int L, int R)
    &#123;
        if(L&#x3D;&#x3D;R)
            return;
      	int mid &#x3D; left + ((right - left) &gt;&gt; 1);
        process(arr,L,mid);
        process(arr,mid+1,R);
        merge(arr,L,mid,R);
    &#125;
    public static void merge(int[] arr,int L,int M,int R)&#123;
        int[] helpSort&#x3D;new int[R-L+1];&#x2F;&#x2F;这是辅助空间
        int i&#x3D;0;
        int p1&#x3D;L;
        int p2&#x3D;M+1;&#x2F;&#x2F;划分区域
        while(p1&lt;&#x3D;M&amp;&amp;p2&lt;&#x3D;R)&#123;
            helpSort[i++]&#x3D;arr[p1]&lt;&#x3D;arr[p2]?arr[p1++]:arr[p2++];
            &#125;
        while(p1&lt;&#x3D;M)&#123;
           helpSort[i++]&#x3D;arr[p1++];
        	&#125;
        while(p2&lt;&#x3D;R)&#123;
            helpSort[i++]&#x3D;arr[p2++];
        &#125;
        for(i&#x3D;0;i&lt;helpSort.length;i++)&#123;
            arr[L+i]&#x3D;helpSort[i];
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>C++:</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
 
void Merge(int arr[],int low,int mid,int high)&#123;
    &#x2F;&#x2F;low为第1有序区的第1个元素，i指向第1个元素, mid为第1有序区的最后1个元素
    int i&#x3D;low,j&#x3D;mid+1,k&#x3D;0; &#x2F;&#x2F;mid+1为第2有序区第1个元素，j指向第1个元素
    int *temp&#x3D;new(nothrow) int[high-low+1]; &#x2F;&#x2F;temp数组暂存合并的有序序列
    if(!temp)&#123; &#x2F;&#x2F;内存分配失败
        cout&lt;&lt;&quot;error&quot;;
        return;
    &#125;
    while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;high)&#123;
        if(arr[i]&lt;&#x3D;arr[j]) &#x2F;&#x2F;较小的先存入temp中
            temp[k++]&#x3D;arr[i++];
        else
            temp[k++]&#x3D;arr[j++];
    &#125;
    while(i&lt;&#x3D;mid)&#x2F;&#x2F;若比较完之后，第一个有序区仍有剩余，则直接复制到t数组中
        temp[k++]&#x3D;arr[i++];
    while(j&lt;&#x3D;high)&#x2F;&#x2F;同上
        temp[k++]&#x3D;arr[j++];
    for(i&#x3D;low,k&#x3D;0;i&lt;&#x3D;high;i++,k++)&#x2F;&#x2F;将排好序的存回arr中low到high这区间
		arr[i]&#x3D;temp[k];
    delete []temp;&#x2F;&#x2F;删除指针，由于指向的是数组，必须用delete []
&#125;
 
&#x2F;&#x2F;用递归应用二路归并函数实现排序——分治法
void MergeSort(int arr[],int low,int high)&#123;
    if(low&lt;high)&#123;
        int mid&#x3D;(low+high)&#x2F;2;
        MergeSort(arr,low,mid);
        MergeSort(arr,mid+1,high);
        Merge(arr,low,mid,high);
    &#125;
&#125;
 
int main()&#123;
    int a[10]&#x3D;&#123;5,1,9,3,7,4,8,6,2,0&#125;;
    MergeSort(a,0,9);
    for(int i&#x3D;0;i&lt;10;i++)
        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
    return 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="扩展我们的归并排序问题"><a href="#扩展我们的归并排序问题" class="headerlink" title="扩展我们的归并排序问题"></a>扩展我们的归并排序问题</h6><p>​        小和问题：对一个数组中，每个数左边比当前数小的数累加起来，叫做这个数的小和：请写一个程序：求解一个数组的小和。</p>
<p>Example:[1,3,4,2,5]产生的单个小和是[0,1,4,1,10],故数组的小和是16.</p>
<p>​        逆序问题：在一个数组中，左边的数如果比右边的数大，则这连哥哥数构成一个逆序对，请打印所有的逆序对。</p>
<p>​        （1）暴力解法是很简单的：对于位置i直接暴力遍历，但是O(N2)</p>
<p>​        有没有更快的：有！</p>
<p>​        仔细思考一下：我们的小和可以这样产生！看一个数右边走，如果有别的数大于它就加一次这个数本身。如[1,3,4,2,5]：看1，右边四个数比他大，就加四次1，看3，右边两个数比他大，就加两个3，依次类推。。。</p>
<p>​        现在，我们对全数组进行二分。针对拆分后的数组一级一级使用我们新的求小和的过程，我们在比较的同时也排序：如：[1，3，4，2，5]下，拆分成2级[1,3,4]和[2,5]，然后又是:[1,3] [4]  和[2]  [5]最后是:[1] [3] [4] [2] [5]，现在返回去合并：[1,3]产生小和1，[1,3,4]产生1个1，1个3，（左侧小，左侧加小和，左侧移动指针到下一个，于是产生）[2,5]合并产生一个2，之后再次合并产生一个1，一个3，一个4，现在完事了：1+1+1+3+2+1+3+4=16</p>
<p>​        这个算法为什么是O(NlogN),就是因为排序的时候不需要在暴力遍历之后才知道有几个数比当前的数小。这才省略了新的遍历。</p>
<p>​        可能不一样的是：在这题里面，我们必须在左右数字相等的时候先拷贝右边的，再拷贝左边的.</p>
<p>​        （2）类似的，仍可以使用mergeSort，也就是说，只要产生小和操作就是说明产生了逆序。我们只要统计这个就好了</p>
<p>​        荷兰国旗问题：指定一个数，比他大的放右边，小的放左边，但是注意空间复杂度O(1)</p>
<p>​        思路：我们把使用两个指针。把小于num的放到左边，与小于区的下一个数字直接交换就好了。这样小于区右扩，否则指针直接右移。</p>
<p>​        荷兰国旗问题（2）：指定一个数，比他大的放右边，小的放左边，相等的放中间。但是注意空间复杂度O(1)</p>
<p>​        </p>
<p>​        还是类似，只不过有趣的是我们可以：</p>
<p>​        小于：[i]和小于区域的下一个交换，小于区东扩</p>
<p>​        相等：直接++</p>
<p>​        大于：[i]和大于区域的上一个交换，大于区西扩，但是i不动（我们还没排序那个交换过来的数嘞！）。</p>
<p>看看代码实现（看2就好了）</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void swap(int* e1, int* e2)
&#123;
	int temp &#x3D; *e1;
	*e1 &#x3D; *e2;
	*e2 &#x3D; temp;
&#125;

typedef struct Pair_ &#123;
	int pair1;
	int pair2;
&#125;Pair;

void arrangeArray(Pair* pair, int* arr, int arrsize,int sortnum)
&#123;
	if (!pair &amp;&amp; !arr)
		return;
	if (arrsize &lt; 0)
		return;
	int* smaller &#x3D; &amp;arr[-1];
	int* bigger &#x3D; &amp;arr[10];
	int* check &#x3D; arr;
	while (check &lt; bigger)
	&#123;
		if (*check &lt; sortnum)
		&#123;
			swap(check, smaller + 1);
			check++;
			smaller++;
		&#125;
		else if (*check &#x3D;&#x3D; sortnum)
		&#123;
			check++;
		&#125;
		else
		&#123;
			swap(check, bigger - 1);
			bigger--;
		&#125;
	&#125;
	pair-&gt;pair1 &#x3D; smaller - arr;
	pair-&gt;pair2 &#x3D; bigger - arr;

&#125;


void PrintArr(int* arr, int arr_size)
&#123;
	for (int i &#x3D; 0; i &lt; arr_size; i++)
	&#123;
		printf(&quot;%d &quot;, arr[i]);
	&#125;
	printf(&quot;\n&quot;);
&#125;
int main()
&#123;
	int arr[10] &#x3D; &#123; 3,5,6,3,4,5,2,6,9,0 &#125;;
	PrintArr(arr, 10);
	Pair* p&#x3D;(Pair*)malloc(sizeof(Pair));
	p-&gt;pair1 &#x3D; 0;
	p-&gt;pair2 &#x3D; 0;
	arrangeArray(p, arr, 10, 5);
	PrintArr(arr, 10);
	printf(&quot;%d\n&quot;, arr[p-&gt;pair1]);
	printf(&quot;%d\n&quot;, arr[p-&gt;pair2]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        C++:</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
class Array &#123;
public:
	void initVal(int* arr, int size) &#123;
		int* arrayData &#x3D; new int[size];
		for (int i &#x3D; 0; i &lt; size; i++)
		&#123;
			arrayData[i] &#x3D; arr[i];
		&#125;
		arraydata &#x3D; arrayData;
		arraysize &#x3D; size;
	&#125;
	void swapPartialData(int swap1,int swap2)
	&#123;
		int temp &#x3D; arraydata[swap1];
		arraydata[swap1] &#x3D; arraydata[swap2];
		arraydata[swap2] &#x3D; temp;
	&#125;
	void arrangeandSort(int sortnum)
	&#123;
		int smaller &#x3D; -1;
		int bigger &#x3D; arraysize;
		int check &#x3D; 0;
		while (check &lt; bigger)
		&#123;
			if (arraydata[check] &lt; sortnum)
			&#123;
				swapPartialData(check, smaller + 1);
				check++;
				smaller++;
			&#125;
			else if (arraydata[check] &#x3D;&#x3D; sortnum)
			&#123;
				check++;
			&#125;
			else
			&#123;
				swapPartialData(check, bigger - 1);
				bigger--;
			&#125;
		&#125;
	&#125;
	void PrintVal()
	&#123;
		for (int i &#x3D; 0; i &lt; arraysize; i++)
		&#123;
			std::cout &lt;&lt; arraydata[i] &lt;&lt; &quot; &quot;;
		&#125;
		std::cout &lt;&lt; std::endl;
	&#125;
private:
	int* arraydata;
	int arraysize;
&#125;;

int main()
&#123;
	int arr[10] &#x3D; &#123; 3,5,6,3,4,5,2,6,9,0 &#125;;
	Array a;
	a.initVal(arr, 10);
	a.PrintVal();
	a.arrangeandSort(5);
	a.PrintVal();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><p>​        快速排序请先把上面的代码琢磨明白：快速排序使得我们以一个数区分好了左右，排除掉标杆数我们只要对左右再次区分直到一个尽头结束。这次我们直接拿最后一个数当作标杆进行快排，这样我们就使得整个数组有序了。</p>
<p>​        这个思想还可以进一步优化：直接把标杆数（最后一个）直接放到中间，左右再递归。</p>
<p>​        当然，这个时间复杂度很不稳定：当划分值再中间的时候：</p>
<p>T(n)=2T(T2)+O(N)</p>
<p>​        但是如果划分值再最左边和最右边：则就是经典排序为O(N2)。</p>
<p>​        我们继续改进：如果我们在一个划分区域随机选一个数，是不是就更多的避免了总是遇到最差情况？是的，这就是随机快速排序。这下，我们就可以</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230130193038830.png?lastModify=1685936981" alt="image-20230130193038830"></p>
<p>​        对所有的情况求时间期望:O(Nlog⁡N)</p>
<h3 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h3><p>​        堆在逻辑结构上是一个完全二叉树。也就是说，每个非叶子节点必有左节点。怎么实现呢？我们可以将天然的一维数组视作一棵完全二叉树。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230131092857709.png?lastModify=1685936981" alt="image-20230131092857709"></p>
<p>我们可以使用这个公式快速找到左孩子的节点下标：(i是当前节点的下标)</p>
<p>Ileft=2i+1</p>
<p>类似的：</p>
<p>Iright=2i+2</p>
<p>父节点：</p>
<p>Ifather=i−12</p>
<p>完全二叉树的高度也可以求解：</p>
<p>H=logN+1</p>
<p>堆在这个概念上派生：他是一个特殊的完全二叉树。大根堆中其父节点总是大于子节点，比如说</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230131093338557.png?lastModify=1685936981" alt="image-20230131093338557"></p>
<p>类比的：小根堆就是父节点总是小于子节点。怎么创建一个堆呢？</p>
<p>​        假设：我们有一个干净的数组，现在往数组里放数。现在，标记一下一个heapsize:他描述我们现在已经成型的堆的大小。显然刚开始heapsize一定是0！因为压根数没来呢！随着数进来，如果一个数比父节点大，那就准备交换父节点！</p>
<pre class="line-numbers language-none"><code class="language-none">swap(arr[i],arr[(i-1)&#x2F;2]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果作为上一级的子节点还是比父节点大，那不就是又要交换？是的。这就是一个递归算法。但是如果相等呢？没关系，就停在那里就好了！</p>
<pre class="line-numbers language-none"><code class="language-none">public static void heapInsert(int[] arr,int index)&#123;
    &#x2F;&#x2F;不用担心0位置的问题，因为根节点的父节点还是他自己，取等依旧跳出循环
    while(arr[index]&gt;add[(index-1)&#x2F;2])&#123;
        swap(arr,index,(index-1)&#x2F;2);
        index&#x3D;(index-1)&#x2F;2;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        </p>
<p>​        这下很容易了：arr[0]就是我们的最大值，返回出去就好了。那如果我们要把它抹掉，然后还是一个大根堆。这又如何？很简单，与最后一个数交换，或者是被覆盖。然后heapsize—.然后，我们让父节点和子节点比较。</p>
<pre class="line-numbers language-none"><code class="language-none">public static void heapify(int[] arr, int index，int heapsize)&#123;
    &#x2F;&#x2F;得到左孩子下标
    int left &#x3D; index*2+1;
    &#x2F;&#x2F;一旦left&lt;heapsize那显然我们的当前节点就没有孩子节点了
    while(left&lt;heapsize)&#123;
        &#x2F;&#x2F;比较两个孩子节点谁大，把大的那个下标给largest
        int largest&#x3D;
            &#x2F;&#x2F;万一没右孩子嘞？判断一下！
            left+1&lt;heapsize
            &amp;&amp; arr[left+1]&gt;arr[left]
            ? left+1 : left ;
        &#x2F;&#x2F;父亲和孩子之间谁大？谁大把谁的下表交给largest
        largest &#x3D; arr[largest] &gt; arr[index] ? largest : index;
        &#x2F;&#x2F;如果到位了，退出循环！
        if(index&#x3D;&#x3D; largest)&#123;
            break;
        &#125;
        &#x2F;&#x2F;反之，交换，继续跑路
        swap(arr,largest,index);
        index&#x3D;largest;
        left &#x3D; index* 2+1;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        OK，现在我们的用户又抽风了，现在它随即指定一个节点变成?，那怎么怎么让他成为一个新的堆？很简单！如果变大了，只能往上走，就像上heapify,变小了那就是向下走。</p>
<p>​        算法复杂度如何？我们发现他就是遍历了树的高度：也就是说</p>
<p>T(N)=O(log⁡N)</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>​        现在我们拿到一个数组，想要进行堆排序，就首先需要构建堆。使用heapInsert就好了。然后怎么排序？我们想到，heap总是确定最大值，只需要：最大值和最后一个值交换，在heapsize—再堆排序。这是一个逐步弹出最大值的算法排序。</p>
<pre class="line-numbers language-none"><code class="language-none">import java.util.Array;
public class HeapSort&#123;
	public static void heapSort(int[] arr)&#123;
        if(arr&#x3D;&#x3D;null||arr.length&lt;2)&#123;
            return;
        &#125;
        for(int i&#x3D;0;i&lt;arr.length;i++)&#123;
            heapInsert(arr,i);
        &#125;
        int heapsize&#x3D;arr.length;
        swap(arr,0,--heapsize);
        while(heapSize&gt;0)&#123;
            heapify(arr,0,heapSize);
            swap(arr,0,--heapsize);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​            这个算法：空间复杂度:O(1) 时间复杂度: O(nlogn)</p>
<p>下面是C++版本：</p>
<pre class="line-numbers language-none"><code class="language-none">class Array &#123;
public:
	void Updatearray(int* arr, int size) &#123;
		int* trans &#x3D; new int[size];
		for (int i &#x3D; 0; i &lt; size; i++) &#123;
			trans[i] &#x3D; arr[i];
		&#125;
		this-&gt;array &#x3D; trans;
		this-&gt;arraysize &#x3D; size;
	&#125;
	void swap(int i1, int i2) &#123;
		int temp &#x3D; array[i1];
		array[i1] &#x3D; array[i2];
		array[i2] &#x3D; temp;
	&#125;
	int* getArrayDataPointer() &#123;
		return this-&gt;array;
	&#125;
	int getsize()
	&#123;
		return this-&gt;arraysize;
	&#125;
	void printArray() &#123;
		for (int i &#x3D; 0; i &lt; arraysize; i++)
		&#123;
			std::cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;
		&#125;
		std::cout &lt;&lt; std::endl;
	&#125;
private:
	int* array;
	int arraysize;
&#125;;


class heapSort &#123;
public:
	void heapInsert(Array a, int index) &#123;
		while (
            a.getArrayDataPointer()[index] 
            &gt; 
            a.getArrayDataPointer()[(index - 1) &#x2F; 2]
              ) 
        &#123;
			a.swap(index, (index - 1) &#x2F; 2);
			index &#x3D; (index - 1) &#x2F; 2;
		&#125;
	&#125;
	void heapify(Array a, int index, int heapsize) &#123;
		int left &#x3D; 2 * index + 1;
		while (left &lt; heapsize) &#123;
			int largest &#x3D;
				left + 1 &lt; heapsize
				&amp;&amp;
				a.getArrayDataPointer()[left + 1] &gt; a.getArrayDataPointer()[left]
				? left + 1 : left;
			largest &#x3D; a.getArrayDataPointer()[largest] &gt; a.getArrayDataPointer()[index] ? largest : index;
			if (index &#x3D;&#x3D; largest)
			&#123;
				break;
			&#125;
			a.swap(largest, index);
			index &#x3D; largest;
			left &#x3D; index * 2 + 1;
		&#125;
	&#125;
	void heapsort(Array a) &#123;
		if (a.getArrayDataPointer() &#x3D;&#x3D; NULL || a.getsize() &lt; 2)
		&#123;
			return;
		&#125;
		for (int i &#x3D; 0; i &lt; a.getsize(); i++)
			heapInsert(a, i);
		int heapsize &#x3D; a.getsize();
		a.swap(0, --heapsize);
		while (heapsize &gt; 0) &#123;
			heapify(a, 0, heapsize);
			a.swap(0, --heapsize);
		&#125;
	&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对于几乎排好序的（向我保证在-K~K内有序）数组，我们可以使用小根堆来排序，把小数往前弹就可以了。</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>​        这个算法跟之前的不一样，之前的算法都是基于比较的排序算法，现在介绍一个更逆天的算法：计数排序。这个算法的局限性极大：就是必须为整形，同时空间复杂度为O(N)，这样，我们得知了一个数据范围[K1,K2]，我们创造一个大小为[k2-k1+1]的数组，遇到一个数就在这个数对应的位置上+1，使用位置来衡量这个值的大小。随后，根据值来覆写数组。比如说统计到1的个数10，那就在数组里写10个1.但是，一旦数据量大起来就是寄！</p>
<p>​        现在，引入一个全新的算法：基数算法：我们首先确定数据的最大几位，对其他数字补齐0操作：如[72,100]-&gt;[072,100]就好了。然后基于个位数，创造10个桶。个位数是0的去0，1去1.。。以此类推，然后，从小到大导倒出来，随后比十位，再百位。。。以此类推</p>
<p>​        比如说：[17,13,25,100,72]-&gt;[ 017 , 013 , 025 , 100 , 072 ],然后个位入桶。再导出来</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230131115105002.png?lastModify=1685936981" alt="image-20230131115105002"></p>
<p>然后把这个数组再倒入桶，这次按十位数</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230131115241365.png?lastModify=1685936981" alt="image-20230131115241365"></p>
<p>然后把这个数组再倒入桶，这次按百位数</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230131115325430.png?lastModify=1685936981" alt="image-20230131115325430"></p>
<p>倒出来，排好序了</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230131115343881.png?lastModify=1685936981" alt="image-20230131115343881"></p>
<p>本质上，我们是按照位数排序</p>
<pre class="line-numbers language-none"><code class="language-none">public class _RadixSort&#123;
    public static void radixSort(int[] arr)&#123;
        if(arr&#x3D;&#x3D;null||arr.length&lt;2)&#123;
            return;
        &#125;
         radixsort(arr,0,arr.length-1,maxbits(arr));
    &#125;
   
    &#x2F;&#x2F;这个函数的本质是求解digit 表示最大的数有几个十进制位数
	public static int maxbits(int[] arr)&#123;
        int max&#x3D;Interger.MIN_VALUE;
        for(int i&#x3D;0;i&lt;arr.length;i++)&#123;
            max&#x3D;Math.max(max,arr[i]);
        &#125;
        int res&#x3D;0;
        while(max!&#x3D;0)&#123;
            res++;
            max&#x2F;&#x3D;10;
        &#125;
        return res;
    &#125;
    
    &#x2F;&#x2F;digit 表示最大的数有几个十进制位数
    public static void radixSort(int[] arr,int L ,int R,int digit)
    &#123;
        final int radix&#x3D;10;
        int i&#x3D;0,j&#x3D;0;
        &#x2F;&#x2F;准备空间
        int[] bucket&#x3D;new int[R-L+1];
        for(int d&#x3D;1;d&lt;&#x3D;digit;d++)
        &#x2F;&#x2F;有多少位就进出多少次，从个位起步
        &#123;
            int[] count &#x3D;new int[radix];
            &#x2F;&#x2F;这个代码统计数字频率，改进后则是统计小于等于该位置数的个数
             &#x2F;&#x2F;这个count[i]表示小于等于i有count[i]个，数组代替了队列使得我们保证了后进后出
            for(i&#x3D;L,i&lt;&#x3D;R;i++)
            &#123;
                j&#x3D;getDigit(arr[i],d);
                count[j]++;
            &#125;
        &#125;
        
        for(i&#x3D;1 ; i&lt;radix;i++)
        &#123;
            &#x2F;&#x2F;改进count
            count[i]&#x3D;count[i]+count[i-1];
        &#125;
        
        for(i&#x3D;R;i&gt;&#x3D;L;i--)
        &#123;
            &#x2F;&#x2F;取出位数
            j&#x3D;getDigit(arr[i],d);
            &#x2F;&#x2F;放到辅助数组
             bucket[count[j]-1]&#x3D;arr[i];
           &#x2F;&#x2F;我们放置一个,就在频数上减一
            count[j]--
        &#125;
        
        &#x2F;&#x2F;出桶
        for(int i&#x3D;L,j&#x3D;0;i&lt;&#x3D;R;i++,j++)
        &#123;
            arr[i]&#x3D;bucket[j];
        &#125;
        
    &#125;
    public static int getDigit(int x,int d)
    &#123;
        return ((x&#x2F;((int)Math.pow(10,d-1)))%10);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>​        哈希表在使用层面上可以理解为一个集合结构！在C++中使用</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;unordered_map&gt;
#include&lt;unordered_set&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        引入！</p>
<p>​        我们的哈希表就是由Key 和 Value构成。Set不带伴随数据Value,Map则带。</p>
<p>​        在Java中则是hashSet和HashMap结构：</p>
<pre class="line-numbers language-none"><code class="language-none">HashSet&lt;Integer&gt; hashSet &#x3D; new HashSet&lt;&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们来简单看看HashSet的基本API：</p>
<p>​        HashSet只有Key存在！</p>
<pre class="line-numbers language-none"><code class="language-none">HashSet&lt;Integer&gt; hashSet1&#x3D;new HashSet&lt;&gt;();
hashSet1.add(3);
System.out.printIn(hashSet1.contains(3));
hashSet1.remove(3);
System.out.printIn(hashSet1.contains(3));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        结构显然的是：</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt;true
&gt;&gt;&gt;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        可以用来查询</p>
<p>​        而对于HashMap,我们多了一个 value作为附加值：</p>
<pre class="line-numbers language-none"><code class="language-none">HashMap&lt;Integer,String&gt; mapTest &#x3D; new HashMap&lt;&gt;();
mapTest.put(1,&quot;1&quot;);
mapTest.put(1,&quot;2&quot;);&#x2F;&#x2F;注意是实际上覆盖掉了！Value就变成了“2”
mapTest.put(2,&quot;2V&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        于是我们可以使用key来查找：</p>
<pre class="line-numbers language-none"><code class="language-none">System.out.printIn(mapTest.containKey(1));
System.out.printIn(mapTest.get(1));
System.out.printIn(mapTest.get(4));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        看到我们的结果是：</p>
<pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt;true
&gt;&gt;&gt;&quot;2&quot;
&gt;&gt;&gt;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        查找一个数据是逆天的：可以认为查询数据的时间复杂度为：O(1)，只是常数项可能比较大</p>
<p>​        Hash表中Key如果是基本类型就是直接值传递，内存的占用是本身。如果不是基本类型就是引用传递（存放指针）</p>
<h3 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h3><p>​        有序表可以在使用层面上看作是一个集合结构：类似的，只有Key没有Value可以使用TreeSet结构，又有Key又有Value的是TreeMap结构（C++ 中又是Ordered Map 和 Ordered Set）.</p>
<p>​        我们的有序表和哈希表有一个区别就是Key按照一个方式排序。增删查改都可以！</p>
<p>​        但是由于有序：我们可以使用firstKey和lastKey查看Key中的极值，也就可以使用floorKey和ceilingKey来查看小于或者大于指定Key的界限！</p>
<p>​        还是一样：Key如果是基本类型就是直接值传递，内存的占用是本身。如果不是基本类型就是引用传递（存放指针），同时必须提供自己的比较器。</p>
<pre class="line-numbers language-none"><code class="language-none">功能一栏：
1.put:将键值对(key,value)放到表中，并将表中的value更新！
2.get:按照key返回value
3.remove 移除Key的记录
4.containsKey 是否存在Key的查询
5.firstKey 返回最左边的
6.lastKey 返回最右边的
7.floorKey 存过Key就返回Key，否则返回Key的前一个
8.ceilingKey 存过Key就返回Key，否则返回Key的后一个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        时间复杂度：O(log⁡n)</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>​        下面开始阐述单链表，将使用C，C++，Java浏览基本结构：对于具体的内容：比如说单链表，双链表，循环链表的特点可以看专门的数据结构的笔记：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct SigLinkNode_&#123;
    void* value;
    struct SigLinkNode_* next;
&#125;SigLinkNode,*SigLinkList
template &lt;class val&gt;
class SigLinkNode_&#123;
private:
    val value;
    class SigLinkNode* next;
public:
    &#x2F;&#x2F;Public API
&#125;
Class Node&lt;V&gt;&#123;
	V value;
	Node next;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        双链表：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct SigLinkNode_&#123;
    void* value;
    struct SigLinkNode_* next;
    struct SigLinkNode_* prior;
&#125;SigLinkNode,*SigLinkList
template &lt;class val&gt;
class SigLinkNode_&#123;
private:
    val value;
    class SigLinkNode* next;
    class SigLinkNode* prior;
public:
    &#x2F;&#x2F;Public API
&#125;
Class Node&lt;V&gt;&#123;
	V value;
	Node next;
    Node prior;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看几道题：</p>
<p>​        1.判断回文链表，使用O(log⁡n)的时间复杂度和O(1)的空间复杂度</p>
<p>​        很简单：我们只需要把链表里的内容放到栈里面：再将他依次弹出比对。</p>
<p>​        如果要省点空间呢》使用快慢指针：快指针一次走两步：满指针一次走一步。快指针走完了，慢指针压中中点即可：随后开始把后面的内容压入栈！</p>
<p>​        就原地呢？快慢指针走：快指针走到头了就开始将后半部分的指针反转，随后我们使用以一比对向中间靠拢。都相等就是回文！ </p>
<p>​        2.划分链表：小于左边，等于中间，大于右边：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230204200748834.png?lastModify=1685936981" alt="image-20230204200748834"></p>
<p>​        注意：小心边界：小于等于大于的条件是不能有空！</p>
<p>​        例题：两个单链表的相交问题：给定两个可能有环可能没有环的单链表，头节点是<code>head 1</code>和<code>head 2</code>.请实现这样一个函数，如果有相交就返回第一个相交节点，否则返回NULL！</p>
<p>​        法一：准备一个集合 Set。遇到一个链表的元素就把它放进去！但是有一个问题：如果一旦有环，我们怎么判断它结束了搜索呢？</p>
<p>​        法二：快慢指针法， 如果快指针遇到了NULL，那就说明没有环，反之，如果快慢指针相遇了，就说明有环（链表有环且是单链表，说明产生了封闭性）</p>
<p>​        下面，如果相遇了：那就马上快指针回到头节点，慢指针停留原地，快指针和慢指针改成一次一个走：他们最终一定在接口处相遇</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230210192103679.png?lastModify=1685936981" alt="image-20230210192103679"></p>
<p>（（5）处就是接口处）</p>
<p>​        </p>
<pre class="line-numbers language-none"><code class="language-none">public static class Node&#123;
    public int value;
    public Node next;
    
    public Node(int data)&#123;
        this.value &#x3D; data ;
    &#125;
&#125;
public static Node getInsertsectNode(Node head1, Node head2)&#123;
    if(head1 &#x3D;&#x3D; null || head2 &#x3D;&#x3D; null)&#123;
        return null;
    &#125;
    Node loop1 &#x3D; getLoopNode(head1);
    Node loop2 &#x3D; getLoopNode(head2);
    if(loop1 &#x3D;&#x3D; null &amp;&amp; loop2 &#x3D;&#x3D; null)&#123;
        return noLoop(head1 , head2);
    &#125;
    if(loop1 !&#x3D; null &amp;&amp; loop2 !&#x3D; null)&#123;
        return bothLoop(head1, loop1 , head2, loop2);
    &#125;
    return null;
&#125;

&#x2F;&#x2F;如果链表入环的节点，无环返回NULL
public static Node getLoopnode(Node head)&#123;
    if(head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null || head.next.next &#x3D;&#x3D; null)&#123;
        return null;
    &#125;
    Node n1 &#x3D; head.next;
    Node n2 &#x3D; head.next.next;
    while(n1 !&#x3D; n2)&#123;&#x2F;&#x2F;跳出来就说明有环
        
        if(n2.next &#x3D;&#x3D; null || n2.next.next &#x3D;&#x3D; null)&#123;
            return null; &#x2F;&#x2F;没有环
        &#125;
        n2 &#x3D; n2.next.next; &#x2F;&#x2F; 快指针移动
        n1 &#x3D; n1.next;
    &#125;
    while(n1 !&#x3D; n2)&#123;
        n1 &#x3D; n1.next;
        n2 &#x3D; n2.next;
    &#125;
    return n1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        首先，如果两个node都是NULL，说明两个链表都是无环！注意：如果其中有一个产生了交叉节点，那就两个表的最后一个节点必须是同一个！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230210202413774.png?lastModify=1685936981" alt="image-20230210202413774"></p>
<p>​        在判断上！我们直接判断最后的节点是不是同一个节点</p>
<pre class="line-numbers language-none"><code class="language-none">if(endNode1 !&#x3D; endNode2)
&#123;
	return null;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        那我们怎么找到第一个节点？现在为了方便统计，我们记录移动次数，好，现在我们统计两个指针的移动次数，举个例子：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230210204106539-16760328698641.png?lastModify=1685936981" alt="image-20230210204106539"></p>
<p>​        现在统计到第一条链表移动了6步，第二条4步，然后计算插值为2，于是再次回到开始，这次先让长链表指针走差值步，随后，让短表指针一起跟长指针走，他们就一定会在第一个共同节点处相遇！</p>
<pre class="line-numbers language-none"><code class="language-none">public static Node noLoop(Node head1,Node head2)&#123;
	if(head1 &#x3D;&#x3D; null || head2 &#x3D;&#x3D; null)&#123;
        return null;
    &#125;
    Node cur1 &#x3D; head1;
    Node cur2 &#x3D; head2;
    int n &#x3D; 0;
    &#x2F;&#x2F;统计一下移动了几步
    while( cur1.next !&#x3D; null)&#123;
        n++;
        cur1 &#x3D; cur1.next;
    &#125;
    &#x2F;&#x2F;统计一下差值
    while(cur2.next !&#x3D; null)&#123;
        n--;
        cur2 &#x3D; cur2.next;
    &#125;
    &#x2F;&#x2F;此时N就是链表长度的值
    if(cur1 !&#x3D; cur2)&#123;
        return null;
    &#125;
    &#x2F;&#x2F;定位谁的链表长
    cur1 &#x3D; n&gt;0 ? head1 : head2;
    &#x2F;&#x2F;转换短链表的头指针
    cur2 &#x3D; (cur1 &#x3D;&#x3D; head1 ?head2 : head1);
    &#x2F;&#x2F;保证N总是正的
    n &#x3D; Math.abs(n);
    &#x2F;&#x2F;现在开始找cur
    while(n !&#x3D; 0)&#123;
        n--;
        cur1 &#x3D; cur1.next;
    &#125;
    return cur1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        另外一个：如果1个是NULL，另一个不是NULL，那就肯定是不相交！（相交了的化就肯定不会产生NULL）</p>
<p>​        都是非空的，说明两个都有环！但是呢又有三种情况</p>
<p>1）</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230210223422319.png?lastModify=1685936981" alt="image-20230210223422319"></p>
<p>2）</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230210223432900.png?lastModify=1685936981" alt="image-20230210223432900"></p>
<p>3）</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230210223445432.png?lastModify=1685936981" alt="image-20230210223445432"></p>
<p>​        第二种最好说：就是无环链表的相交问题：只需要到入环处作为结点就好了。现在，让我们的Loop1和Loop2转圈圈，如果遇到了即使第三种，返回LOOP1或者LOOP2，都可以！否则就是第一种，返回NULL。</p>
<pre class="line-numbers language-none"><code class="language-none">public static Node bothLoop(Node head1, Node head2,Node loop1,Node loop2)
&#123;
    Node cur1 &#x3D; null;
    Node cur2 &#x3D; null;
    if(loop1 &#x3D;&#x3D; loop2)&#123;
        cur1 &#x3D; head1;
        cur2 &#x3D; head2;
        int n &#x3D; 0;
        while(cur1 !&#x3D; loop1)&#123;
            n++;
            cur1 &#x3D; cur1.next; 
        &#125;
        while(cur2 !&#x3D;loop2)&#123;
            n--;
            cur1 &#x3D; cur1.next;
        &#125;
        while(cur1 !&#x3D; cur2)&#123;
            cur1 &#x3D; cur1.next;
            cur2 &#x3D; cur2.next;
        &#125;
        return cur1;
    &#125;
    else&#123;
        cur1 &#x3D; loop1.next;
        while(cur1 !&#x3D; loop1)&#123;
            if(cur1 &#x3D;&#x3D; loop2)&#123;
                return loop1;
            &#125;
            cur1 &#x3D; cur1.next;
        &#125;
        return null;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面，我们开始加大难度，整点花活了！</p>
<h3 id="二叉树的节点结构"><a href="#二叉树的节点结构" class="headerlink" title="二叉树的节点结构"></a>二叉树的节点结构</h3><pre class="line-numbers language-none"><code class="language-none">class node&lt;V&gt;&#123;
    V value;
    Node left;
    Node right;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在Java语言下，二叉树是这样描述的，而在C语言下，二叉树可以这样看：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct _NODE_&#123;
    void* value;
    struct _NODE_* left_child;
    struct _NODE_* right_child;
&#125;Node;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们来使用递归和非递归的方式来实现二叉树的先序，中序和后序遍历！接着来直观的打印一个二叉树，最后来完成二叉树的宽度优先遍历（如：求解一棵二叉树的宽度）。</p>
<p>​        </p>
<pre class="line-numbers language-none"><code class="language-none">public static void preCurNode(Node head)&#123;
    if(head &#x3D;&#x3D; null)&#123;
        return;
    &#125;
    &#x2F;&#x2F;Go left node:
    preCurNode(head.left);
    
    &#x2F;&#x2F;until the cur_node has no left child
    &#x2F;&#x2F;that is : head &#x3D;&#x3D; null! we return
    &#x2F;&#x2F;and go to the right one:
    
    preCurNode(head.right);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230211190238573.png?lastModify=1685936981" alt="image-20230211190238573"></p>
<p>​        对于先序遍历：就是先访问根节点，后访问左子树，后访问右子树！</p>
<p>​        非递归又是如何呢，以先序遍历为例：</p>
<p>​        我们首先把头节点放到一个栈，然后：开始循环</p>
<p>1）<code>从栈里弹出一个节点Cur</code></p>
<p>2）<code>处理Cur</code></p>
<p>3）<code>先右再左的压入孩子节点（有就压）没有就跳过</code></p>
<p>4）<code>周而复始上述流程</code></p>
<pre class="line-numbers language-none"><code class="language-none">public static void preOrderUnRecur(Node head)&#123;
    System.out.printIn(&quot;here comes the pre-order:&quot;);
    if(head !&#x3D; null)
    &#123;
        Stack&lt;Node&gt; stack &#x3D; new Stack&lt;Node&gt;();
        stack.add(head);
        while(!stack.isEmpty())&#123;
            head &#x3D; stack.pop();
            System.out.printIn(head.val+&quot; &quot;);
            if(head.right !&#x3D; null)
            &#123;
                stack.push(head.right);
            &#125;
            if(head.left !&#x3D; null)
            &#123;
                stack.push(head.left);
            &#125;
        &#125;
    &#125;
    System.out.printIn();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对于中序遍历：就是先访问左子树，接着访问根节点，在访问右子树</p>
<p>​        <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230211192901074.png?lastModify=1685936981" alt="image-20230211192901074"></p>
<p>​        我们使用图像中的左边界来分解二叉树（左，头），对于右子树，类似递归的再处理（左，头）</p>
<pre class="line-numbers language-none"><code class="language-none">public static void inOrderUnRecur(Node head)&#123;
    System.out.printIn(&quot;here comes the in-order:&quot;);
    if(head !&#x3D; null)
    &#123;
        Stack&lt;Node&gt; stack &#x3D; new Stack&lt;Node&gt;();
        while(!stack.isEmpty() || head !&#x3D;null)&#123;
            if(head !&#x3D; null)
            &#123;
                stack.push(head);
            &#125;
            else
            &#123;
                head &#x3D; stack.pop();
                System.out.print(head.value+&quot; &quot;);
                head &#x3D; head.right()
            &#125;
        &#125;
    &#125;
    System.out.printIn();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对于后序遍历：就是先访问左子树，接着访问右子树，在访问根节点</p>
<p>​        类似的，他是先序遍历的逆过程，我们准备两个栈：一个叫弹出栈，一个叫收集栈</p>
<pre class="line-numbers language-none"><code class="language-none">public static void posOrderUnRecur(Node head)&#123;
    System.out.printIn(&quot;here comes the post-order:&quot;);
    if(head !&#x3D; null)
    &#123;
        Stack&lt;Node&gt; stack1 &#x3D; new Stack&lt;Node&gt;();
        Stack&lt;Node&gt; stack2 &#x3D; new Stack&lt;Node&gt;();
        stack1.push(head);
        while(!stack1.isEmpty())&#123;
            head &#x3D; stack1.pop();
            s2.push(head);
            if(head.left !&#x3D; null)
            &#123;
                stack1.push(head.left);
            &#125;
              if(head.right !&#x3D; null)
            &#123;
                stack1.push(head.right);
            &#125;
        &#125;
        while(!s2.isEmpty())&#123;
            System.out.print(s2.pop().value+&quot; &quot;);
        &#125;
    &#125;
    System.out.printIn();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>直观打印一颗二叉树（福利lol）</p>
<p>(嫖来的~)</p>
<pre class="line-numbers language-none"><code class="language-none">怎么看呢？

首先，将二叉树顺时针选择90°
接下来，需要清晰的确定任何一个节点的父节点：
如果一个节点打印结果的前缀和后缀都有&quot;H&quot;（H1H），说明这个节点是头结点，不存放父节点
如果一个节点的前缀和后缀都带有v，表示父节点在该节点所在列的前一列，在该节点所在行的下方，并且是离该节点最近的节点。
上图中v3v、v6v、v7v，父节点分别为H1H、v3v、^4^
如果一个节点的前缀和后缀都带有^，表示父节点在该节点所在列的前一列，在该节点所在行的上方，并且是离该节点最近的节点。
上图中^5^、^2^、4^4，父节点分别为v3v、H1H、^2^
（2）第二个要解决的问题：规定节点打印时占用的统一长度。

我们必须规定一个节点在打印时到达占多长
比如，“1”、&quot;433261&quot;等，如果不统一规定打印长度，那么打印一个长短值交替的二叉树必然会出现格式不齐的问题
那么，需要多少呢？整形值(INT32_MIN)占用的长度是11；加上前缀和后缀(H、v、^)之后占用长度为13；另外为了在打印之后更好的区分，再在前面加上两个空格，后面加上两个空格；总共长度是13 + 4 &#x3D; 17
举个例子，比如v8v长度为3，一共17个字符，那么17-3&#x3D;14，所以前面补7个空格、后面也补7个空格
举个例子，比如v11v长度为4，一共17个字符，那么17-3&#x3D;13，所以前面补6个空格、后面补7个空格
（3）怎么实现

打印的整体过程是：右子树–&gt;根节点–&gt;左子树
class Solution &#123;
    static std::string getSpace(int num)&#123;
        std::string s(num, &#39; &#39;);
        return s;
    &#125;
    void process(TreeNode *head, int height, const std::string&amp; to, int len)&#123;
        if(head &#x3D;&#x3D; nullptr)&#123;
            return;
        &#125;

        process(head-&gt;right, height + 1, &quot;v&quot;, len);
        std::string val &#x3D; to + std::to_string(head-&gt;val) + to;
        int lenM &#x3D; val.length();
        int lenL &#x3D; (len - lenM) &#x2F; 2;
        int lenR &#x3D; len - lenM - lenL;
        val &#x3D; getSpace(lenL) + val + getSpace(lenR);
        std::cout  &lt;&lt; getSpace(height * len) &lt;&lt; val &lt;&lt; &quot;\n&quot;;  &#x2F;&#x2F; getSpace(height * len)用来区分每一层
        process(head-&gt;left, height + 1, &quot;^&quot;, len);
    &#125;
public:
    void printTree(TreeNode *head)&#123;
        process(head, 0, &quot;H&quot;, 17);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>​        我们前面的都是深度优先的遍历（先最快的下降到叶子层），现在来介绍广度优先的搜索：</p>
<p>​        就是说 ：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230211195236973.png?lastModify=1685936981" alt="image-20230211195236973"></p>
<p>​        我们使用队列来实现：</p>
<pre class="line-numbers language-none"><code class="language-none">public static void BFS(Node head)&#123;
    if(head &#x3D;&#x3D; null)&#123;
        return;
    &#125;
    Queue&lt;Node&gt; queue &#x3D; new LinkedList&lt;&gt;();
    queue.add(head);
    while(!queue.isEmpty())&#123;
        Node cur &#x3D; queue.poll();
        System.out.printIn(cur.value);
        if(cur.left !&#x3D; null)
        &#123;
            queue.add(cur.left);
        &#125;
        if(cur.right !&#x3D; null)
        &#123;
            queue.add(cur.right);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在统计一下各个层上节点的个数：使用一个表：</p>
<pre class="line-numbers language-none"><code class="language-none">public static void BFS(Node head)&#123;
    if(head &#x3D;&#x3D; null)&#123;
        return;
    &#125;
    Queue&lt;Node&gt; queue &#x3D; new LinkedList&lt;&gt;();
    queue.add(head);
    &#x2F;&#x2F;引出一个表，记录他在第几层
    HashMap&lt;Node, Integer&gt;levelMap &#x3D; new HashMap&lt;&gt;();
    &#x2F;&#x2F;直接放头节点再第一层
    levelMap.put(head,1);
    &#x2F;&#x2F;当前在哪一层？
    int curLevel &#x3D; 1;
    
    &#x2F;&#x2F;当前层数有几个节点
    int curLevelNodes &#x3D; 0;
    
    &#x2F;&#x2F;哪个层数的最大节点数
    int max &#x3D; Integer.MIN_VALUE;
    while(!queue.isEmpty())&#123;
        Node cur &#x3D; queue.poll();
        int curNodeLevel &#x3D; levelMap.get(cur);
        if(curNodeLevel &#x3D;&#x3D; curLevel)
        &#123;
            curLevelNodes++;
        &#125;
        else
        &#123;
            max &#x3D; Math.max(max, curLevelNodes);
            curLevel++;
            curLevelNodes &#x3D; 0;
        &#125;
        if(cur.left !&#x3D; null)
        &#123;
            levelMap.put(cur.left,curNodeLevel+1)
            queue.add(cur.left);
        &#125;
        if(cur.right !&#x3D; null)
        &#123;
            levelMap.put(cur.right,curNodeLevel+1)
            queue.add(cur.right);
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="判断二叉树是不是搜索二叉树"><a href="#判断二叉树是不是搜索二叉树" class="headerlink" title="判断二叉树是不是搜索二叉树"></a>判断二叉树是不是搜索二叉树</h3><p>​        二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： <strong>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</strong> 它的左、右子树也分别为二叉排序树。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。 </p>
<p>​        说白了，就是如此的二叉树，左子树比根节点小，根节点比右子树小。</p>
<p>​        说白了，使用中序遍历，就好了嘛！（左 &lt; 根 &lt; 右）</p>
<pre class="line-numbers language-none"><code class="language-none">public static int preValue &#x3D; Integer.MIN_VALUE;
public static boolean checkBST(Node head)&#123;
    if( head &#x3D;&#x3D; null)&#123;
        return true;
    &#125;
    boolean isLeftBst &#x3D; checkBST(head.left);
    if( !isLeftBst)&#123;
        return false;
    &#125; &#x2F;&#x2F; 检查左树是不是BST
    if(head.value &lt;&#x3D; preValue)&#123;
        return false;
    &#125;
    else&#123;
        preValue &#x3D; head.value;
    &#125;
    return check(head.right);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        或者这样：</p>
<pre class="line-numbers language-none"><code class="language-none">public static boolean checkBST2(Node head)&#123;
    List&lt;Node&gt;inOrderList &#x3D; new ArrayList&lt;&gt;();
    process2(head, inOrderList);
    &#x2F;&#x2F; 检查一下 inOrderList 里的数据是不是上升的
&#125;

public static void process2(Node head, List&lt;Node&gt;inOrderList)&#123;
    if(head &#x3D;&#x3D; null)&#123;
        return;
    &#125;
     process2(head.left, inOrderList);
     inOrderList.add(head);
     process2(head.left, inOrderList);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>甚至可以不递归：</p>
<pre class="line-numbers language-none"><code class="language-none">public static void checkBST3(Node head)&#123;
    
    if(head !&#x3D; null)&#123;
        if(head.left &#x3D;&#x3D; null &amp;&amp; head.right &#x3D;&#x3D; null)&#123;
            return true;&#x2F;&#x2F; 只有一个节点，直接return
        &#125;
        
        
        int preValue &#x3D; Integer.MIN_VALUE;
        Stack&lt;Node&gt; stack &#x3D; new Stack&lt;Node&gt;();
        
        
        while(!stack.isEmpty() || head !&#x3D; null)
        &#123;
            
            
            if(head !&#x3D; null)&#123;
                stack.push(head);
                head &#x3D; head.left;
            &#125;
            else
            &#123;
                head &#x3D; stack.pop();
                
                if(head.value &lt;&#x3D; preValue)
                &#123;
                    return false;
                &#125;
                else
                &#123;
                    preValue &#x3D; head.value;
                &#125;
                
                head &#x3D; head.right;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="判断一个二叉树是不是完全二叉树"><a href="#判断一个二叉树是不是完全二叉树" class="headerlink" title="判断一个二叉树是不是完全二叉树"></a>判断一个二叉树是不是完全二叉树</h4><p>​        很简单：</p>
<p>1）一个节点只有右子树的情况：</p>
<p>2）在1）下，第一个左右节点不全的，后续的必须是叶子节点！否则也不是完全二叉树：</p>
<pre class="line-numbers language-none"><code class="language-none">public static boolean isCBT(Node head)&#123;
    if(head &#x3D;&#x3D; null)&#123;
        return true;
    &#125;
    LinkedList&lt;Node&gt; queue &#x3D; new  LinkedList&lt;Node&gt;();
    &#x2F;&#x2F; 是否遇到左右两个孩子双全的情况
    boolean leaf &#x3D; false;
    Node l &#x3D; null;
    Node r &#x3D; null;
    queue.add(head);
    while(!queue.isEmpty())&#123;
        head &#x3D; queue.poll();
        l &#x3D; head.left();
        r &#x3D; head.right();
        if(
        	(leaf &amp;&amp; (l !&#x3D; null || r !&#x3D; null)) &#x2F;&#x2F; 后面中必须是叶子节点
            ||
            (l &#x3D;&#x3D; null &amp;&amp; r !&#x3D; null)
        )
        &#123;
            return false;
        &#125;
        
        if(l !&#x3D; null)&#123;
            queue.add(l);
        &#125;
         if(r !&#x3D; null)&#123;
            queue.add(r);
        &#125;
        if(l &#x3D;&#x3D; null || r &#x3D;&#x3D; null)&#123;
            leaf &#x3D; true;
        &#125;
    &#125;
    return true;
&#125;
public static class ReturnData&#123;
    public boolean isBST;
    public int min;
    public int max;
    public ReturnData(boolean is,int mi,int ma)&#123;
        isBST &#x3D; is;
        min &#x3D; mi;
        max &#x3D; ma;
    &#125;
&#125;

public static ReturnData process(Node x)&#123;
    if(x &#x3D;&#x3D; null)&#123;
        return null;
    &#125;
    &#x2F;&#x2F;先取到信息,这是黑盒！总是可以给我我想要的！
    ReturnData leftdata &#x3D;  process(x.left);
    ReturnData rightdata &#x3D;  process(x.right);
    
    int min &#x3D; x.value;
    int max &#x3D; x.value
    if(leftdata !&#x3D; null)&#123;
        &#x2F;&#x2F;更新一下 min max
        min &#x3D; Math.min(min,leftData.min);
        max &#x3D; Math.max(max,leftData.max);
        
    &#125;
    if(rightdata !&#x3D; null)&#123;
        &#x2F;&#x2F;更新一下 min max
        min &#x3D; Math.min(min,rightData.min);
        max &#x3D; Math.max(max,rightData.max);
    &#125;
    
    boolean isBST &#x3D; true;
    if(leftData !&#x3D; null &amp;&amp; (!leftData.isBST || leftData.max &gt;&#x3D; x.value ))&#123;
        isBST &#x3D; false;
    &#125;
    if(rightData !&#x3D; null &amp;&amp; (!rightData.isBST || rightData.min &lt;&#x3D; x.value ))&#123;
        isBST &#x3D; false;
    &#125;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="判断是不是满二叉树-amp-amp-是不是平衡二叉树-amp-amp-套路"><a href="#判断是不是满二叉树-amp-amp-是不是平衡二叉树-amp-amp-套路" class="headerlink" title="判断是不是满二叉树 &amp;&amp; 是不是平衡二叉树&amp;&amp;套路"></a>判断是不是满二叉树 &amp;&amp; 是不是平衡二叉树&amp;&amp;套路</h4><p>​        结合满二叉树的重要性质：设最大深度为 <code>l</code> ,节点数是<code>N</code></p>
<p>N=2l−1</p>
<pre class="line-numbers language-none"><code class="language-none">public static boolean isFull(Node head)&#123;
    if(head &#x3D;&#x3D; null)&#123;
        return true;
    &#125;
    Info data &#x3D; process(head);
    return data.nodes &#x3D;&#x3D; (1 &lt;&lt; data.height -1);
&#125;

public static class Info&#123;
    public int height;
    public int nodes;
    
    public Info(int h, int n)&#123;
        height &#x3D; h;
        nodes &#x3D; n;
    &#125;
&#125;

public static Info process(Node x)&#123;
    if(x &#x3D;&#x3D; null)
    &#123;
        return new Info(0,0);
    &#125;
    
    Info leftData &#x3D; process(x.left);
    Info rightData &#x3D; process(x.right);
    
    int height &#x3D; Math.max(left.height,right.height)+1;
    int nodes &#x3D; leftData.nodes + rightData.nodes + 1;
    
    return new Info(height,nodes);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <strong>平衡二叉树</strong>（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。</p>
<p>​        现在来看：以一个节点<code>X</code>的二叉树若是平衡的二叉树，则它的子树也必须是平衡的：更何况，其左树高 - 右树高 ≤ 1。</p>
<p>​        我们需要子树向我们反馈树是否平衡！</p>
<pre class="line-numbers language-none"><code class="language-none">public static class ReturnType&#123;
    public boolen isBalanced;
    public int height;
    
    public ReturnType(boolen isBa , int hei)&#123;
        isBalanced &#x3D; isBa;
        height&#x3D; hei
    &#125;
&#125;

public static ReturnType process(Node x)&#123;
    if(x &#x3D;&#x3D; null)&#123;
        return new ReturnType(true,0);
    &#125;
    ReturnType leftData &#x3D; process(x.left);
    ReturnType rightData &#x3D; process(x.right);
    
    int height &#x3D; Math.max(leftData.height,rightData.height) + 1;
    boolean isBalanced &#x3D; leftData.isBalanced &amp;&amp; rightData.isBalanced
        &amp;&amp;
        Math.abs(leftData.height - rightData.height) &lt; 2
    return new ReturnType(isBalanced,height)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>TIPS</code> :排错优先！</p>
<pre class="line-numbers language-none"><code class="language-none">工程化的代码也是这样写，一个一个if先排错，最后剩下的就是对的,相反，先去找怎样对的，会写很多if嵌套的代码，并且容易漏想!<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>套路：</p>
<p>1）左递归找左子树的信息</p>
<p>2）右递归找右递归的信息</p>
<p>3）处理当前情况的信息判断</p>
<p>4）return 状态</p>
<p>​        不是所有的问题都可以使用：如果涉及到全局的不可<code>Dynamic Planning</code>问题的，不可以使用：如求中位数！</p>
<p>例题：</p>
<p>​        给定两个二叉树的节点<code>node1</code>和<code>node2</code>，找到他们的最低公共祖先节点！</p>
<pre class="line-numbers language-none"><code class="language-none">public class LowestCommonAncestor&#123;
    
    public static class Node&#123;
        public int value;
        public Node left;
        public Node right;
        
        public Node(int data)&#123;
            this.value &#x3D; data;
        &#125;
    &#125;
    &#x2F;&#x2F; limitation : o1 and o2 must be the BT whose head is HEAD!
    public static Node lowestCommonAncestor(Node head ,Node o1, Node o2)&#123;
        HashMap&lt;Node,Node&gt; fathermap &#x3D; new HashMap&lt;&gt;();
        fatherMap.put(head,head);
        process(head,fathermap);
        HashSet&lt;Node&gt; set1 &#x3D; new HashSet&lt;&gt;();
    	Node cur &#x3D; o1;
        while(cur !&#x3D; fatherMap.get(cur))&#123;
            set1.add(cur);
            cur &#x3D; fatherMap.get(cur);
        &#125;
        set1.add(head);
        
        HashSet&lt;Node&gt; set2 &#x3D; new HashSet&lt;&gt;();
        Node cur &#x3D; o2;
        while(cur !&#x3D; fatherMap.get(cur))&#123;
            set2.add(cur);
            cur &#x3D; fatherMap.get(cur);
        &#125;
        set2.add(head);
        
        &#x2F;&#x2F; then compare the set1 and set2
    &#125;
    
    public static void process(Node head,HashMap&lt;Node,Node&gt; fathermap)&#123;
        if(head &#x3D;&#x3D; null)&#123;
            return;
        &#125;
        father.put(head.left,head);
        father.put(head.right,head)
        process(head.left,fatherMap);
        process(head.right,fatherMap);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        还有一个离谱版本的：</p>
<pre class="line-numbers language-none"><code class="language-none">public static Node lowestCommonAncestor(Node head ,Node o1, Node o2)&#123;
    if(head &#x3D;&#x3D; null || head &#x3D;&#x3D; o1 || head &#x3D;&#x3D; o2)&#123;
        return head;
    &#125; &#x2F;&#x2F; 说明就是之前找到的一个head，直接向上返回
    Node left &#x3D; lowestCommonAncestor(head ,o1,  o2);
    Node right &#x3D; lowestCommonAncestor(head ,o1,  o2);
    
    &#x2F;&#x2F; 情况1 ：不走这个if
    &#x2F;&#x2F; 情况2 ：把自己返回，因为自己的下侧就有 O1 ， O2
    if(left !&#x3D; null &amp;&amp; right !&#x3D; null)&#123;
        return head;
    &#125;
    
    return left !&#x3D; null ? left : right;&#x2F;&#x2F;说明O1，O2就是在一侧子树
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>1)这是：一个是另一个的父节点</p>
<p>2） 这是很好想到的汇聚的模式</p>
<h4 id="在二叉树里找自己的后继节点"><a href="#在二叉树里找自己的后继节点" class="headerlink" title="在二叉树里找自己的后继节点"></a>在二叉树里找自己的后继节点</h4><p>​        定义如下的结构：</p>
<pre class="line-numbers language-none"><code class="language-none">public class Node &#123;
	public int val;
    public Node left;
     public Node right;
     public Node parent;
    public Node(int val)&#123;
        value &#x3D; val;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        该结构的 parent 指向自己的父节点， 头节点的父节点是null 现在只给出一个二叉树的摸一个节点 node ，请写出一个返回 node 后继节点的函数。</p>
<p>​        可以这样看：中序遍历下的一个节点的后继节点是它的中序遍历下下一节点</p>
<p>​        一句话理解：左子树的最右结点，右子树的最左节点</p>
<p>​        这个原理让算法优化到 <code>O(k)</code></p>
<pre class="line-numbers language-none"><code class="language-none">public static Node getSuccessorNode(Node node)&#123;
    if(node &#x3D;&#x3D; null)&#123;
        return node;
    &#125;
    if(node.right !&#x3D; null)
        return getLeftMost(node.right);
    else
    &#123;
        Node parent &#x3D; node.parent;
        while(parent !&#x3D; null &#x2F;&#x2F; 最右的节点
              &amp;&amp; 
              parent.left !&#x3D; node &#x2F;&#x2F; 发现还得是走右节点
             )&#123; 
            node &#x3D; parent;
            parent &#x3D; node.parent;
        &#125;
        return parent;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图(Graph)是由顶点的有穷非空集合V ( G ) 和顶点之间边的集合E ( G ) 组成，通常表示为: G=(V,E)，其中，G 表示个图，V是图G 中顶点的集合，E 是图G 中边的集合。若</p>
<p>V={v1,v2,…,vn}</p>
<p>则用∣V∣表示图G 中顶点的个数，也称图G的阶，E = { ( u , v ) ∣ u ∈ V , v ∈ V } ，用∣ E ∣ 表示图G 中边的条数。</p>
<h3 id="图的存储方式"><a href="#图的存储方式" class="headerlink" title="图的存储方式"></a>图的存储方式</h3><p>1）邻接表</p>
<p>​        我们定义一些离散的但是有联系的点集是图（不准确的讲），而且还分为有向图和无向图（一个有向图指的是链接必须是有方向的）：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230216092513123.png?lastModify=1685936981" alt="image-20230216092513123"></p>
<p>这个图中：</p>
<p>​        A的直接邻居是 C 和 D ！对于 B 的直接邻居 C，C 的邻居是ABD，而D是AC，</p>
<p>2）邻接矩阵</p>
<p>​        我们也可以使用矩阵来表达这个关系，使用一个正方形的矩阵：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230216092803921.png?lastModify=1685936981" alt="image-20230216092803921"></p>
<p>​        图的表达方式很多！可以自行查找。对于图的问题，找到一个喜欢的模板，之后再区讲其他问题转换成这个模板的框架！</p>
<p>​        比如说这个模板：</p>
<pre class="line-numbers language-none"><code class="language-none">public class Gragh &#123;
    &#x2F;&#x2F; int 是自己节点的编号，点是元素
	public HashMap&lt;Integer,Node&gt; nodes;
    &#x2F;&#x2F; 边集
    public HashSet&lt;Edge&gt; edges;
    
    public Gragh()&#123;
        nodes &#x3D; new HashMap&lt;&gt;();
        edges &#x3D; new HashSet&lt;&gt;();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​    </p>
<pre class="line-numbers language-none"><code class="language-none">public class Node&#123;
    public int value; &#x2F;&#x2F;数据项
    public int in; &#x2F;&#x2F;入度
    public int out; &#x2F;&#x2F; 出度
    public ArrayList&lt;Node&gt; nexts; &#x2F;&#x2F; 直接连向的点
    public ArrayList&lt;Edge&gt; edges; &#x2F;&#x2F; 边集
    
    public Node(int value)&#123;
        this.value &#x3D; value;
        in &#x3D; 0;
        out &#x3D; 0;
        nexts &#x3D; new ArrayList&lt;&gt;();
        edges &#x3D; new ArrayList&lt;&gt;();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        in : 入度，就是说有多少个节点指向的这个节点！</p>
<p>​        out : 出度，自己的这个节点可以指向多少个节点！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230216095606281.png?lastModify=1685936981" alt="image-20230216095606281"></p>
<pre class="line-numbers language-none"><code class="language-none">public class Edges&#123;
    public int weight;
    public Node from;
    public Node to;
    
    public Edge(int weight,Node from,Node to)&#123;
        this.weight &#x3D; weight;
        this.from &#x3D; from;
        this.to &#x3D; to;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="图的宽度优先遍历"><a href="#图的宽度优先遍历" class="headerlink" title="图的宽度优先遍历"></a>图的宽度优先遍历</h3><p>​        1.利用队列实现</p>
<pre class="line-numbers language-none"><code class="language-none">public static void bfs(Node node)&#123;
    if(node &#x3D;&#x3D; null)&#123;
        return;
    &#125;
    Queue&lt;Node&gt; queue &#x3D; new LinkedList&lt;&gt;();
    HashSet&lt;Node&gt; set &#x3D; new HashSet&lt;&gt;();
    queue.add(node);
    set.add(node);
    while(!queue.isEmpty())&#123;
        Node cur &#x3D; queue.poll();
        &#x2F;&#x2F; Do something to the  cur node
        for(Node next : cur.nexts)&#123;
            if(!set.contains(next))&#123;
                set.add(next);
                queue.add(next);
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        很简单！准备一个队列来遍历，同时，准备一个Hashset来记录我们走的节点，如果有下一个节点就一直往下走。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230216113711996.png?lastModify=1685936981" alt="image-20230216113711996"></p>
<h3 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h3><p>​        使用栈和HashSet来完成这项工作。</p>
<pre class="line-numbers language-none"><code class="language-none">public static void DFS(Node node)&#123;
    if(node &#x3D;&#x3D; null)&#123;
        return;
    &#125;
    Stack&lt;Node&gt; stack &#x3D; new Stack&lt;&gt;();
    HashSet&lt;Node&gt; set &#x3D; new HashSet&lt;&gt;();
    stack.add(node);
    set.add(node);
    &#x2F;&#x2F;Do somethong to the headnode
    while(!stack.isEmpty())&#123;
        Node cur &#x3D; stack.pop();
        for(Node next : cur.nexts)&#123;
            if(!set.contains(next))&#123;
                stack.push(cur); &#x2F;&#x2F; 压回去已经弹出的节点
                stack.push(next);
                set.add(next);
                 &#x2F;&#x2F;Do somethong to the node
                break;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>​        对于一个有向图：我们首先看入度为0的点，随后擦去这个点和边集，递归处理。</p>
<pre class="line-numbers language-none"><code class="language-none">public static List&lt;Node&gt; sortedTopology(Graph graph)&#123;
    &#x2F;&#x2F;key : 一个node
    &#x2F;&#x2F;value: 剩余的入度
    HashMap&lt;Node,Integer&gt; inMap &#x3D; new HashMap&lt;&gt;();
    Queue&lt;Node&gt; zeroInQueue &#x3D; new LinkedList&lt;&gt;();
    
    &#x2F;&#x2F; 入度为0才可以进入
    for(Node node : graph.nodes.values())&#123;
        inMap.put(node,node.in);
        if(node.in &#x3D;&#x3D; 0)&#123;
            zeroInQueue.add(node); 
        &#125;
    &#125;
    &#x2F;&#x2F; 排序
    List&lt;Node&gt; result &#x3D; new ArrayList&lt;&gt;();
    while(!zeroInQueue.isEmpty())&#123;
        Node cur &#x3D; zeroInQueue.poll();
        result.add(cur);
        for(Node next : cur.nexts)&#123;
            &#x2F;&#x2F; 因为裁掉了一个节点，相关的入度减1
            inMap.put(next,inMap.get(next)-1);
            if(inMap.get(next) &#x3D;&#x3D; 0)&#123;
                zeroInQueue.add(next); 
            &#125;
        &#125;
    &#125;
    return result;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="kruskal算法（无向图算法）"><a href="#kruskal算法（无向图算法）" class="headerlink" title="kruskal算法（无向图算法）"></a>kruskal算法（无向图算法）</h3><p>​        从边出发，依次选择最小的边开始考虑，连起来的时候，如果形成了环就不要，反之就要</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230216120841449.png?lastModify=1685936981" alt="image-20230216120841449"></p>
<p>​        怎么判断？先假设所有的点是孤立的，依次从小到大加上边，连到的地方塞进集合，如果在考察的时候发现两个边里集合都有，那就去掉这个边。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 一个简单并查集
public static class Mysets&#123;
    
    public HashMap&lt;Node,List&lt;Node&gt;&gt; setMap;
    
    public Mysets(List&lt;Node&gt; nodes)
    &#123;
        for(Node cur : nodes)
        &#123;
            List&lt;Node&gt; set &#x3D; new ArrayList&lt;Node&gt;();
            set.add(cur);
            setMap.put(cur,set);
        &#125;
    &#125;
    
    public boolean isSameSet(Node from,Node to)&#123;
        List&lt;Node&gt; fromSet &#x3D; setMap.get(from);
        List&lt;Node&gt; toSet &#x3D; setMap.get(to);
        return fromSet &#x3D;&#x3D; toSet;
    &#125;
    
    public void union(Node from,Node to)&#123;
        List&lt;Node&gt; fromSet &#x3D; setMap.get(from);
        List&lt;Node&gt; toSet &#x3D; setMap.get(to);
        
        for(Node toNode : toSet)&#123;
            fromSet.add(toNode);
            setMap.put(toNode,fromSet); 
        &#125;
    &#125;
&#125; 
public static Set&lt;Edge&gt; kruskalMST(Graph graph)&#123;
    UnionFind unionFind &#x3D; new  UnionFind();
    unionFind.makeSets(graph.nodes.values());
    PriorityQueue&lt;Edge&gt; priorityQueue &#x3D; new  PriorityQueue&lt;&gt;(new EgdeComparator);&#x2F;&#x2F; 可以自己实现自己的比较器传入
    for(Edge edge : graph.edges)&#123;
        priorityQueue.add(edge);
    &#125;
    Set&lt;Edge&gt; result &#x3D; new HashSet&lt;&gt;();
    while(!priorityQueue.isEmpty())&#123;
        Edge edge &#x3D; priorityQueue.poll();
        if(!unionFind.isSameSet(edge.from,edge.to))&#123; &#x2F;&#x2F; 是不是集合里面的
            result.add(edge);
            unionFind.union(edge.from,edge.to);
        &#125;
    &#125;
     return result;   
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="prim算法（无向图）"><a href="#prim算法（无向图）" class="headerlink" title="prim算法（无向图）"></a>prim算法（无向图）</h3><p>​        这次，我们入列的是一个一个节点，再顺藤摸瓜找到其他的</p>
<pre class="line-numbers language-none"><code class="language-none">public static Set&lt;Edge&gt; primSet(Graph graph)&#123;
    
    &#x2F;&#x2F; 解锁的边进入小根堆
    PriorityQueue&lt;Edge&gt; priorityQueue.add &#x3D; new  PriorityQueue&lt;&gt;(
    	new EdgeComparator
    );
    HashSet&lt;Node&gt; set &#x3D; new HashSet&lt;&gt;();
    
    Set&lt;Edge&gt; result &#x3D; new HashSet&lt;&gt;(); &#x2F;&#x2F; 依次挑选的边放进这里
    
    for(Node node: graph.nodes.values())
    &#123;
        &#x2F;&#x2F;node start
        if(!set.contains(node))
        &#123;
            set.add(node);
            for(Edge edge : node.edges)
            &#123;
                priorityQueue.add(edge);
            &#125;
            while(!priorityQueue.isEmpty())
            &#123;
                Edge edge &#x3D; priorityQueue.poll(); &#x2F;&#x2F; 弹出解锁的边中最小的边
                Node toNode &#x3D; edge.to; &#x2F;&#x2F; 可能的新点
                if(!set.contains(toNode))
                &#123;
                    set.add(toNode);
                     result.add(edge);
                    for(Edge nextEdge : toNode.edges)
                    &#123;
                         priorityQueue.add(nextEdge);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230216125218550.png?lastModify=1685936981" alt="image-20230216125218550"></p>
<h1 id="Learn-Linux-入门"><a href="#Learn-Linux-入门" class="headerlink" title="Learn Linux 入门"></a>Learn Linux 入门</h1><h1 id="Linux入门"><a href="#Linux入门" class="headerlink" title="Linux入门"></a>Linux入门</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><p>​        首先计算机由硬件和软件组成，这是大家都知道的。硬件，就是你看到到的实体。至于软件，就是用户和计算机硬件之间的接口和桥梁。我们这次的主题：操作系统，就是软件！他是用户和计算机硬件之间的桥梁，调度和管理计算机硬件进行工作。</p>
<p>​        当代计算机不能失去计算机，就像西方不能失去耶路撒冷一样（）</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230411185638955.png?lastModify=1685936981" alt="image-20230411185638955"></p>
<p>​        操作系统可以：调度CPU和内存进行工作，使用硬盘来进行数据存储，来使用网卡进行网络通讯，调用音响发出声音，调用打印机打印东西等等。</p>
<p>​        这是一个操作系统调用网卡的过程：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230411190152332.png?lastModify=1685936981" alt="image-20230411190152332"></p>
<p>​        常见的操作系统有：Windows 11 ， Linux， macOS（PC操作系统）和android, IOS Harmony OS等等是移动端操作系统了。</p>
<h2 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h2><p>​        1991年，Linux从一个佬那里诞生，并且逐渐被世界所接受。</p>
<p>​        Linux由Linux系统内核和系统级应用程序组成。</p>
<p>​        内核提供系统最核心的功能：比如说：调度CPU，调度缓存，调度文件系统，调度网络通信，调度IO等。</p>
<p>​        系统应用：比如说图片查看等等</p>
<p>​        </p>
<h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>​        Linux的目录结构是一个树形的结构，Linux不同于Windows，他只有一个根目录/，所有的文件都在它的下面</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230411195709234.png?lastModify=1685936981" alt="image-20230411195709234"></p>
<p>​        首先，我们这个是在阐述文件路径的层级关系，打开你的Windows cmd (Win + R + Enter) ，发现这个：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230411195944592.png?lastModify=1685936981" alt="image-20230411195944592"></p>
<p>​        如果我们到Linux底下（不管是CentOS 还是 Ubuntu）都是 / 的</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230411200155312.png?lastModify=1685936981" alt="image-20230411200155312"></p>
<p>​    （以Ubuntu 20.04作为示例）</p>
<p>​        于是，想要在文件中找到一个目标文件，在Windows中，我们已经很熟悉了：</p>
<pre class="line-numbers language-none"><code class="language-none">D:\data\work\hello.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在Linux下就是</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;usr&#x2F;local&#x2F;hello.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        注意到<strong>Linux中，/出现在开头：根目录，/出现在中间：层次关系</strong></p>
<h2 id="第一个Linux命令：ls"><a href="#第一个Linux命令：ls" class="headerlink" title="第一个Linux命令：ls"></a>第一个Linux命令：ls</h2><p>​        先停！搞清楚什么是命令很重要：他是Linux的 Terminal，下命令提示符页面我们单纯的使用’字符’来操作系统，也就是使用各种字符指令来对系统发出操作指令。</p>
<p>​        而命令，本质上还是一个程序，只是没有图形化的相关界面。其反馈又以字符串的形式返回来。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414222522060.png?lastModify=1685936981" alt="image-20230414222522060"></p>
<p>​        比如说在CentOS下，我们敲入字符ls 发现返回了东西。就是说明 ls 是程序，而下面的结果就是字符形式的返回</p>
<p>​        在Linux,命令具有相同的通用格式！</p>
<pre class="line-numbers language-none"><code class="language-none">command [-options] [parameters]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        command 即是命令本身，</p>
<p>​        （选填）而 -options 就是 控制行为的一些具体的设置细节</p>
<p>​        （选填）parameter 就是命令之下的参数</p>
<p>​        举个例子：</p>
<pre class="line-numbers language-none"><code class="language-none">ls -l &#x2F;home<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        ls 就是命令， -l 就是选项，表明如何执行这样的命令，/home表示参数。于是这条指令正是： 查看home文件夹下的内容，其显示方式使用列表</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414224112645.png?lastModify=1685936981" alt="image-20230414224112645"></p>
<p>​        现在主要看 ls ，他的格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">ls [-a -l -h] [&#x2F;Linux&#x2F;Path]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        直接使用ls 表明直接通过平铺的方式展示这一目录下的工作内容</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414224455558.png?lastModify=1685936981" alt="image-20230414224455558"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414224618031.png?lastModify=1685936981" alt="image-20230414224618031"></p>
<p>​        还就是桌面上那个home文件夹的内容！于是 ls 就是等同于我们来看当前文件夹下的东西。</p>
<h2 id="什么是工作目录"><a href="#什么是工作目录" class="headerlink" title="什么是工作目录"></a>什么是工作目录</h2><p>​        当我们启动命令行时，默认我们的 home下的用户名为名称的目录正是工作目录：也就是我们准备执行若干操作的当下目录</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414225017894.png?lastModify=1685936981" alt="image-20230414225017894"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414225600771.png?lastModify=1685936981" alt="image-20230414225600771"></p>
<h2 id="ls-参数详解"><a href="#ls-参数详解" class="headerlink" title="ls 参数详解"></a>ls 参数详解</h2><p>​        -a : all 的意思。于是。。。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414231338693.png?lastModify=1685936981" alt="image-20230414231338693"></p>
<p>​        在 .Name 之类的就是Linux下的隐藏文件。总而言之，-a 就是展示所有的文件，包括那些被隐藏的文件</p>
<p>​        而在-l 下，就是以列表的方式展示我们的文件是怎样的。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414232357814.png?lastModify=1685936981" alt="image-20230414232357814"></p>
<p>​        那如果我想： 既想展示所有的隐藏文件，又想用列表的方式展示，那就是可以有下面三种方式。</p>
<pre class="line-numbers language-none"><code class="language-none">ls -l -a 
ls -la
ls -al<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414232421335.png?lastModify=1685936981" alt="image-20230414232421335"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414232443582.png?lastModify=1685936981" alt="image-20230414232443582"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414232507927.png?lastModify=1685936981" alt="image-20230414232507927"></p>
<p>​        最后是 -h, 他表示我们以一种方便阅读的方式来列出文件的大小！注意必须和-l 一同使用，否则不会显示相关的效果！ </p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414232733351.png?lastModify=1685936981" alt="image-20230414232733351"></p>
<p>​        可以看到我们更容易阅读文件的大小了</p>
<h2 id="cd-pwd指令"><a href="#cd-pwd指令" class="headerlink" title="cd  -  pwd指令"></a>cd  -  pwd指令</h2><p>​        使用 cd 命令来切换工作目录（Change Directory）</p>
<pre class="line-numbers language-none"><code class="language-none">cd &#x2F;Linux&#x2F;Path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当我们不指定路径时，直接回到home目录</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415215546677.png?lastModify=1685936981" alt="image-20230415215546677"></p>
<p>​        ls并不是专门打印当下目录的正确指令，至少不恰当！事实上，还是pwd才合适，他就是 print work directory 的缩写</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415215936705.png?lastModify=1685936981" alt="image-20230415215936705"></p>
<p>​        只需要输入 pwd 就可以查看当下的目录了！·</p>
<h2 id="相对路径-绝对路径-特殊路径符"><a href="#相对路径-绝对路径-特殊路径符" class="headerlink" title="相对路径/绝对路径/特殊路径符"></a>相对路径/绝对路径/特殊路径符</h2><p>​        我们书写目录，一种是从根目录开始找： /usr/ Path，还有一种是从 当下的工作目录开始找： cd LinuxPath, 前者是就是从根目录找，称之为绝对路径，非常的绝对，代价即是很长。后者就是在当前目录去找！</p>
<p>​        下面是一些特殊的符号：</p>
<pre class="line-numbers language-none"><code class="language-none">. : 当前目录，常用的就是切换到当前目录下的文件夹，比如说：
cd .&#x2F;Desktop&#x2F;SomeThing

.. : 返回上一级目录 退两级：cd ..&#x2F;..

~ : 直接回到home<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h2><pre class="line-numbers language-none"><code class="language-none">mkdir [-p] LinuxPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        mkdir正如缩写所义：make directory。创建一个在父目录之下的子目录。而参数 -p 是可选的，他让我们可以创建一个递归的目录，适用于直接创建多层的文件夹，实际看一下就是这个意思！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415221252797.png?lastModify=1685936981" alt="image-20230415221252797"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415221608598.png?lastModify=1685936981" alt="image-20230415221608598"></p>
<h2 id="torch-cat-more"><a href="#torch-cat-more" class="headerlink" title="torch cat more"></a>torch cat more</h2><p>​        使用torch命令来创建文件，格式是：</p>
<pre class="line-numbers language-none"><code class="language-none">touch LinuxPath&#x2F;Filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415222041990.png?lastModify=1685936981" alt="image-20230415222041990"></p>
<p>​        随后，我们可以先给这个文件写点东西，会使用 vim 就用 vim：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; type in shell &gt;&gt;&gt;vim touch.txt
&#x2F;&#x2F; press i to get into the insert mode
&#x2F;&#x2F; write in file : Hello,welcome using cat to check the note off this file

&#x2F;&#x2F; press ESC
&#x2F;&#x2F; write :wq
&#x2F;&#x2F; back to shell: &gt;&gt;&gt; cat touch.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415222728934.png?lastModify=1685936981" alt="image-20230415222728934"></p>
<pre class="line-numbers language-none"><code class="language-none">cat Linux&#x2F;Path&#x2F;FileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        对于more命令，那表示的是如果文件内容过长，可以使用more命令来查看文档</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415223140319.png?lastModify=1685936981" alt="image-20230415223140319"></p>
<p>​        </p>
<pre class="line-numbers language-none"><code class="language-none">more Linux&#x2F;Path&#x2F;FileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        回车一行行查看，空格是一页一页看，退出是q</p>
<h2 id="cp-mv-rm"><a href="#cp-mv-rm" class="headerlink" title="cp mv rm"></a>cp mv rm</h2><p>​        cp是copy的缩写，就是复制文件的意思。</p>
<pre class="line-numbers language-none"><code class="language-none">cp [-r] LinuxPath_beCopied LinuxPath_toThePlace<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        -r 递归复制文件</p>
<p>​        第一个Path表明被复制的对象，第二个表示的是复制到何处。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415223633861.png?lastModify=1685936981" alt="image-20230415223633861"></p>
<p>​        而mv:即是 move 的缩写了！</p>
<pre class="line-numbers language-none"><code class="language-none">mv LinuxPath&#x2F;FileName(or dirName) LinuxPathDir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当然目标不存在的话就会改名保证目标的存在</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415223930574.png?lastModify=1685936981" alt="image-20230415223930574"></p>
<p>​        <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415224110470.png?lastModify=1685936981" alt="image-20230415224110470"></p>
<p>​        看，1.txt就被改成3.txt了</p>
<p>​        rm命令就是remove，表明删除</p>
<pre class="line-numbers language-none"><code class="language-none">rm [-r -f] file1 dir1 file2 dir2 ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        -r :递归删除，可以用来删除文件夹</p>
<p>​        -f: 强迫删除，不需要询问，都可以删！（force）</p>
<p>​        如此多的参数就是我们想要删除的内容，使用空格隔开</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415224446501.png?lastModify=1685936981" alt="image-20230415224446501"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415224550942.png?lastModify=1685936981" alt="image-20230415224550942"></p>
<p>​        rm支持通配符*用来进行模糊搜索：如</p>
<p>​        test*表明以test开头的所有文件</p>
<p>​        *test表示以test结尾的所有文件</p>
<p>​        <em>test</em>表所有包含了test这个子字符串的文件名</p>
<h2 id="which和find"><a href="#which和find" class="headerlink" title="which和find"></a>which和find</h2><p>​        我们知道，Linux下的大部分命令就是程序代码，which则会告诉我们这些程序的二进制代码在哪里</p>
<pre class="line-numbers language-none"><code class="language-none">which instName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415225204867.png?lastModify=1685936981" alt="image-20230415225204867"></p>
<p>​        Find既是搜索指定的文件名查找</p>
<pre class="line-numbers language-none"><code class="language-none">find PathStart -name &quot;fileNameBeSearched&quot; &#x2F;&#x2F; 文件名查找<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415225404584.png?lastModify=1685936981" alt="image-20230415225404584"></p>
<p>​        (Permisson denied 表明权限不够，回开root的开root试试)</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415225529928.png?lastModify=1685936981" alt="image-20230415225529928"></p>
<p>​        这个也支持模糊查找！具体的不再演示</p>
<p>​        另一个find即是：按照大小查找：</p>
<pre class="line-numbers language-none"><code class="language-none">find pathStart -size +|- n[KMG]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        +表大于 - 表小于，后面带上数字和单位表大小（k(小写！！)多少KB，MB，GB）</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230415230150000.png?lastModify=1685936981" alt="image-20230415230150000"></p>
<h2 id="grep-与-wc"><a href="#grep-与-wc" class="headerlink" title="grep 与 wc"></a>grep 与 wc</h2><pre class="line-numbers language-none"><code class="language-none">grep [-n] 关键字 文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        &gt;这里有可选参数 -n 表明在结果之中显示匹配的行的行号。</p>
<p>​        关键字参数时，表明查询的关键字，如果含有特殊符号请使用“”括起来</p>
<p>​        文件路径 表文件路径，可以作为内容输入端口</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416103713665.png?lastModify=1685936981" alt="image-20230416103713665"></p>
<p>​        wc做字符统计</p>
<pre class="line-numbers language-none"><code class="language-none">wc [-c -m -l -w] 文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        -c  : 统计bytes数量</p>
<p>​        -m 统计字符数量</p>
<p>​        -l 统计行数</p>
<p>​        -w 统计单词数量</p>
<p>​        文件路径那自然指向的时被统计文件，可以作为输入端的端口</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416105615266.png?lastModify=1685936981" alt="image-20230416105615266"></p>
<p>​        单词是用空格划分的！这是我们需要注意的。</p>
<h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h2><p>​        我们现在尝试管道符：他正是表示的是将左边命令的结果作为右边命令的输入。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416110106424.png?lastModify=1685936981" alt="image-20230416110106424"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416110206546.png?lastModify=1685936981" alt="image-20230416110206546"></p>
<p>​        这个表明的是将检索到的内容来统计行数</p>
<h2 id="echo命令输出内容"><a href="#echo命令输出内容" class="headerlink" title="echo命令输出内容"></a>echo命令输出内容</h2><pre class="line-numbers language-none"><code class="language-none">echo 输出的内容<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416110707817.png?lastModify=1685936981" alt="image-20230416110707817"></p>
<p>​        当然有特殊符号请用 “ “来括起来。</p>
<p>​        想要让他作为命令输出，如输出pwd的内容，加上`</p>
<pre class="line-numbers language-none"><code class="language-none">echo &#96;pwd&#96; &#x2F;&#x2F; 没什么用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="重定向符号-gt-与-gt-gt"><a href="#重定向符号-gt-与-gt-gt" class="headerlink" title="重定向符号 &gt; 与&gt;&gt;"></a>重定向符号 &gt; 与&gt;&gt;</h2><p>​        &gt; :将左侧命令的结果覆盖到符号右侧的指定文件</p>
<p>​        &gt;&gt; : 将左侧命令的结果追加到符号右侧的指定文件</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416111428026.png?lastModify=1685936981" alt="image-20230416111428026"></p>
<h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><pre class="line-numbers language-none"><code class="language-none">tail [-f -num] LinuxPath<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数，Linux的路径，这表示的是被跟踪的文件路径</p>
<p>​        -f 表示持续跟踪</p>
<p>​        -num 表示查看多少行，不填就是10行</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416111911011.png?lastModify=1685936981" alt="image-20230416111911011"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416111948298.png?lastModify=1685936981" alt="image-20230416111948298"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416112026385.png?lastModify=1685936981" alt="image-20230416112026385"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416112203086.png?lastModify=1685936981" alt="image-20230416112203086"></p>
<h2 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h2><p>​        这是最经典的文本编辑器</p>
<p>​        下面开始介绍：</p>
<p>​        Command mode命令模式：这里所有的输入编辑器都理解为命令，从而驱动执行不同的功能</p>
<p>​        Insert mode： 我们可以对文编编辑</p>
<p>​        Last Line mode : 用 : 作为起头，通常用在文件的保存和退出</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416112744542.png?lastModify=1685936981" alt="image-20230416112744542"></p>
<pre class="line-numbers language-none"><code class="language-none">1&#x2F;&#x2F; 

vim LinuxPath<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        如果文件不存在就会创建一个新的文件，要不就会打开已经存在的文件。</p>
<p>​        一般打开的时候，会默认在命令模式。想要编写文件，必须先敲入 i 进入插入模式。</p>
<p>编辑结束后 esc 即可</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416113105108.png?lastModify=1685936981" alt="image-20230416113105108"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416113210159.png?lastModify=1685936981" alt="image-20230416113210159"></p>
<h2 id="Root权限"><a href="#Root权限" class="headerlink" title="Root权限"></a>Root权限</h2><p>​        拥有最大的权限就是root.我们几乎做任何事情都不会受到阻挠。进入的方式就是</p>
<pre class="line-numbers language-none"><code class="language-none">su root
&gt;&gt;&gt; encode your password in the Linux
[root@...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        su 就是账户切换的系统命令，switch user</p>
<pre class="line-numbers language-none"><code class="language-none">su [-] -usrName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这个符号是可选的，是用来加载环境变量的，建议带上</p>
<p>​        可以用exit指令退回到上一个用户，快捷键是 ctrl + d</p>
<pre class="line-numbers language-none"><code class="language-none">sudo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        用户临时使用root权限。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416114249475.png?lastModify=1685936981" alt="image-20230416114249475"></p>
<h2 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h2><p>​        我们可以配置多个用户和用户组。用户也可以加入多个用户组。在Linux下，权限管控分为针对用户的权限控制和针对用户组的权限控制。</p>
<h3 id="创建与删除用户组"><a href="#创建与删除用户组" class="headerlink" title="创建与删除用户组"></a>创建与删除用户组</h3><pre class="line-numbers language-none"><code class="language-none">groupadd groupname # in root
groupdel groupname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="用户的操作"><a href="#用户的操作" class="headerlink" title="用户的操作"></a>用户的操作</h3><p>1）useradd [-g -d]用户名</p>
<p>-g 用于指定用户所在的组，不指定-g会创建同名的组并让其进入这个组，注意如果指定的了的话必须组是存在的</p>
<p>-d 用于指定home在哪里，不写就是: /home/usrname</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416115407673.png?lastModify=1685936981" alt="image-20230416115407673"></p>
<p>2)userdel [-r] usrname</p>
<p>​        -r就是同时删除其用户的home文件夹</p>
<p>3)id [usrname]</p>
<p>​        查看自己所在的用户组，带上可选参数usrname就是查看 usrname 的用户组</p>
<p>4）usermod -aG 将指定的用户加到指定的用户组</p>
<p>5）getend 查看当前系统有哪些用户。</p>
<h2 id="查看权限工作"><a href="#查看权限工作" class="headerlink" title="查看权限工作"></a>查看权限工作</h2><p>在root下，输入ls -l即可：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416120246176.png?lastModify=1685936981" alt="image-20230416120246176"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416120355916.png?lastModify=1685936981" alt="image-20230416120355916"></p>
<p>其中：r有读权限 w有写权限 x有执行权限</p>
<p>当然具体来说也可能会有写不同：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416120458085.png?lastModify=1685936981" alt="image-20230416120458085"></p>
<h2 id="修改权限控制"><a href="#修改权限控制" class="headerlink" title="修改权限控制"></a>修改权限控制</h2><p>chmod</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416120610230.png?lastModify=1685936981" alt="image-20230416120610230"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416120725024.png?lastModify=1685936981" alt="image-20230416120725024"></p>
<p>chown </p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416120752474.png?lastModify=1685936981" alt="image-20230416120752474"></p>
<h2 id="一些快速操作快捷键"><a href="#一些快速操作快捷键" class="headerlink" title="一些快速操作快捷键"></a>一些快速操作快捷键</h2><p>Ctrl + c强制停止</p>
<p>Ctrl + d 退出账户</p>
<p>history: 查看历史执行的命令， !命令前缀，自动执行从后往前的找到第一个匹配前缀的指令</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121054792.png?lastModify=1685936981" alt="image-20230416121054792"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121101651.png?lastModify=1685936981" alt="image-20230416121101651"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121123675.png?lastModify=1685936981" alt="image-20230416121123675"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121152194.png?lastModify=1685936981" alt="image-20230416121152194"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121219359.png?lastModify=1685936981" alt="image-20230416121219359"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121319303.png?lastModify=1685936981" alt="image-20230416121319303"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121350614.png?lastModify=1685936981" alt="image-20230416121350614"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121411677.png?lastModify=1685936981" alt="image-20230416121411677"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121432968.png?lastModify=1685936981" alt="image-20230416121432968"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121446642.png?lastModify=1685936981" alt="image-20230416121446642"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121528040.png?lastModify=1685936981" alt="image-20230416121528040"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121543781.png?lastModify=1685936981" alt="image-20230416121543781"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121622511.png?lastModify=1685936981" alt="image-20230416121622511"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121635041.png?lastModify=1685936981" alt="image-20230416121635041"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121702592.png?lastModify=1685936981" alt="image-20230416121702592"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121713490.png?lastModify=1685936981" alt="image-20230416121713490"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121736563.png?lastModify=1685936981" alt="image-20230416121736563"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121748284.png?lastModify=1685936981" alt="image-20230416121748284"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121823770.png?lastModify=1685936981" alt="image-20230416121823770"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121835516.png?lastModify=1685936981" alt="image-20230416121835516"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121849522.png?lastModify=1685936981" alt="image-20230416121849522"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121904518.png?lastModify=1685936981" alt="image-20230416121904518"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121932632.png?lastModify=1685936981" alt="image-20230416121932632"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416121949219.png?lastModify=1685936981" alt="image-20230416121949219"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416122008858.png?lastModify=1685936981" alt="image-20230416122008858"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416122034234.png?lastModify=1685936981" alt="image-20230416122034234"></p>
<p>​        这个有点像Windows下的PATH</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416122057738.png?lastModify=1685936981" alt="image-20230416122057738"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416122108863.png?lastModify=1685936981" alt="image-20230416122108863"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416122125643.png?lastModify=1685936981" alt="image-20230416122125643"></p>
<h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416122233062.png?lastModify=1685936981" alt="image-20230416122233062"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416122248474.png?lastModify=1685936981" alt="image-20230416122248474"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416122257252.png?lastModify=1685936981" alt="image-20230416122257252"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230416122319744.png?lastModify=1685936981" alt="image-20230416122319744"></p>
<h1 id="Linux-学习2"><a href="#Linux-学习2" class="headerlink" title="Linux 学习2"></a>Linux 学习2</h1><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>​        我们使用这个指令来控制软件的启动和停止，开机自启！而支持这样管理的软件我们称之为服务，其语法是基础的：</p>
<pre class="line-numbers language-none"><code class="language-none">systemctl start | stop | status | enable | disable 服务名 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        系统的内置服务很多，比如说、</p>
<p>​        NetWorkManager 主网络服务</p>
<p>​        network 副网络服务</p>
<p>​        firewalld 防火墙服务</p>
<p>​        sshd ssh服务</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425221313870.png?lastModify=1685936981" alt="image-20230425221313870"></p>
<p>​        我们调用了一个，结果如上图所示！</p>
<p>​        最后面的disable 和 enable 是控制开机要不要自启动了！</p>
<h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>​        软链接，可以让文件，文件夹链接到其他地方或者是位置。</p>
<p>​        类似于Windows下的快捷方式！</p>
<pre class="line-numbers language-none"><code class="language-none">ln -s  参数1 参数2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>参数1 ： 被链接的文件或者是文件夹</p>
<p>参数2： 要链接去的目的地</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425222444660.png?lastModify=1685936981" alt="image-20230425222444660"></p>
<p>​        也可以对文件夹使用这个方法！</p>
<h2 id="查看日期和实现"><a href="#查看日期和实现" class="headerlink" title="查看日期和实现"></a>查看日期和实现</h2><h3 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h3><p>​        依赖date命令可以在命令行中查看系统的时间：</p>
<pre class="line-numbers language-none"><code class="language-none">date [-d] [+格式化字符串]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        -d 按照给定的字符串显示日期，一般用于日期计算</p>
<p>​        格式化字符串：通过特定的字符串标记来控制显示的时间格式</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426201011750.png?lastModify=1685936981" alt="image-20230426201011750"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426201118602.png?lastModify=1685936981" alt="image-20230426201118602"></p>
<p>​        我们的Linux也自然支持日期的计算，他是如下做的，给定参数-d来做日期计算</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426201654843.png?lastModify=1685936981" alt="image-20230426201654843"></p>
<p>​        当然，我们也支持随后使用格式化字符串来输出！</p>
<pre class="line-numbers language-none"><code class="language-none">date [-d] &quot;operation&quot; &quot;%y-%m-%d %D:%M:%S&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="使用命令行修改时区"><a href="#使用命令行修改时区" class="headerlink" title="使用命令行修改时区"></a>使用命令行修改时区</h3><p>​        我们可以使用命令行来修改时区：</p>
<pre class="line-numbers language-none"><code class="language-none">su -
rm -f &#x2F;etc&#x2F;localtime
sudo ln -s &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426202216724.png?lastModify=1685936981" alt="image-20230426202216724"></p>
<p>​    或者使用ntp</p>
<pre class="line-numbers language-none"><code class="language-none">yum install ntp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426202455974.png?lastModify=1685936981" alt="image-20230426202455974"></p>
<p>​        设定好 systemctl 一下，让之开机自启动！</p>
<h2 id="IP地址与主机名"><a href="#IP地址与主机名" class="headerlink" title="IP地址与主机名"></a>IP地址与主机名</h2><p>​        每一台联网的电脑都有一个地址，我们使用它来和其他计算机进行通信。如今的IP地址主要有两个版本。IPV4 和 IPV6</p>
<p>​        对于IPv4 其基本格式是：a.b.c.d，abcd各是一个0~255的数组</p>
<p>​        我们可以通过ifconfig的指令来查看本机的IP，若发现自己查看不了，可以安装</p>
<pre class="line-numbers language-none"><code class="language-none">yum install net-tools<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426203243180.png?lastModify=1685936981" alt="image-20230426203243180"></p>
<p>​        127.0.0.1是本机的IP</p>
<p>​        0.0.0.0表示代指本机IP，或者是在端口绑定中用来确定绑定关系，以及在放行规则中允许任意IP进行访问！</p>
<h1 id="Linux学习3"><a href="#Linux学习3" class="headerlink" title="Linux学习3"></a>Linux学习3</h1><h2 id="虚拟机配置固定IP"><a href="#虚拟机配置固定IP" class="headerlink" title="虚拟机配置固定IP"></a>虚拟机配置固定IP</h2><p>​        当前我们虚拟机的Linux操作系统的IP是通过DHCP服务获取的。DHCP：动态获取IP地址，也就是说我们每一次重启设备后都会获取一次IP。 我们的IP地址会频繁的变动！</p>
<p>​        在VMware WorkStation中配固定的IP: 首先需要我们拿管理员模式进行运行.这样才可以修改</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506185240424.png?lastModify=1685936981" alt="image-20230506185240424"></p>
<p>​        你看,现在可以修改了!</p>
<p>​        打开Linux虚拟机,登陆后转向 root 用户,这里重复一下指令:</p>
<pre class="line-numbers language-none"><code class="language-none">su root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        转向这个文件:</p>
<pre class="line-numbers language-none"><code class="language-none">cd &#x2F;etc&#x2F;systemcfg&#x2F;newwork-scripts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        ls一下,找到这个文件:</p>
<pre class="line-numbers language-none"><code class="language-none">chmod 744 ifcfg-ens33
vim ifcfg-ens33<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        首先,因为我们不在需要从DHCP中获取IP了,因此,我们选择static表示的是固定的地址</p>
<pre class="line-numbers language-none"><code class="language-none">BOOTPROTO&#x3D;&quot;static&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        并且在下面塞上这些东西!</p>
<pre class="line-numbers language-none"><code class="language-none">IPADDR&#x3D;&quot;192.168.88.114&quot;
NETMASK&#x3D;&quot;255.255.255.0&quot;
GATEWAY&#x3D;&quot;192.168.88.2&quot;
DNS1&#x3D;&quot;192.168.88.2&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        保存一下,随后:</p>
<pre class="line-numbers language-none"><code class="language-none">systemctl stop network
systemctl start network<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        我们看网卡正常启动了</p>
<pre class="line-numbers language-none"><code class="language-none">ifconfig<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506191839093.png?lastModify=1685936981" alt="image-20230506191839093"></p>
<p>​        (发出了满意的叫声)</p>
<h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h2><h3 id="下载与网络请求"><a href="#下载与网络请求" class="headerlink" title="下载与网络请求"></a>下载与网络请求</h3><h4 id="Ping命令"><a href="#Ping命令" class="headerlink" title="Ping命令"></a>Ping命令</h4><p>​        我们手头有一个IP或者是域名,我们不确定可不可以打开之 .我们就可以使用ping命令来完成我们的检查工作</p>
<pre class="line-numbers language-none"><code class="language-none">ping [-c num] ip或主机名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506192843040.png?lastModify=1685936981" alt="image-20230506192843040"></p>
<h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><p>​        wget是非交互式的文件下载器,可以在命令行中获取网络文件</p>
<pre class="line-numbers language-none"><code class="language-none">wget [-b] url<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        -b表示是否在后台下载,系统会把日志写进当前工作目录的wget-log文件中去.</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506193453043.png?lastModify=1685936981" alt="image-20230506193453043"></p>
<p>​        红色的文件表示下载未完全</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506193614901.png?lastModify=1685936981" alt="image-20230506193614901"></p>
<p>删掉就好了</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506193744017.png?lastModify=1685936981" alt="image-20230506193744017"></p>
<h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>​        curl用于发送HTTP网络请求,可用于:下载文件,获取信息等等</p>
<pre class="line-numbers language-none"><code class="language-none">curl [-O] url<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        -O表示用于下载文件,当URL是下载连接的时候.这个选项可以用于保存文件.</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506194233850.png?lastModify=1685936981" alt="image-20230506194233850"></p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>​        端口是设备与外界交流的出入口.端口自己可以分为物理端口和虚拟端口两类.</p>
<p>物理端口: 外号接口,是可见的端口</p>
<p>虚拟端口: 指的是计算机内部的端口,他是不可见的,是操作系统与外界相互作用的!</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506194937082.png?lastModify=1685936981" alt="image-20230506194937082"></p>
<p>​        IP是计算机的地址,但是无法定位到程序,端口就帮助我们锁定程序.</p>
<p>Linux支持65535个端口,其中有如下的分类:</p>
<p>1.公认端口 1~1023</p>
<p>2.注册端口 1024~49151 注册端口</p>
<p>3.动态端口 (余下)临时端口.</p>
<h4 id="nmap指令来查看端口-netstat命令占用"><a href="#nmap指令来查看端口-netstat命令占用" class="headerlink" title="nmap指令来查看端口,netstat命令占用"></a>nmap指令来查看端口,netstat命令占用</h4><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>​        程序的运行在操作系统中被注册,这就是一个进程!并且还会为其给予一个ID/(进程号).</p>
<p>​        查看进程</p>
<pre class="line-numbers language-none"><code class="language-none">ps [-e -f]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506212434872.png?lastModify=1685936981" alt="image-20230506212434872"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506214232487.png?lastModify=1685936981" alt="image-20230506214232487"></p>
<p>​        对于一个指定的进程,配合grep</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230506214838774.png?lastModify=1685936981" alt="image-20230506214838774"></p>
<h2 id="主机状态"><a href="#主机状态" class="headerlink" title="主机状态"></a>主机状态</h2><p>​        我们使用</p>
<pre class="line-numbers language-none"><code class="language-none">top <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        命令来查看当前电脑的状态：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230509222258373.png?lastModify=1685936981" alt="image-20230509222258373"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230509222441640.png?lastModify=1685936981" alt="image-20230509222441640"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230509222717102.png?lastModify=1685936981" alt="image-20230509222717102"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230509223014259.png?lastModify=1685936981" alt="image-20230509223014259"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230509223156270.png?lastModify=1685936981" alt="image-20230509223156270"></p>
<h2 id="df查看磁盘"><a href="#df查看磁盘" class="headerlink" title="df查看磁盘"></a>df查看磁盘</h2><pre class="line-numbers language-none"><code class="language-none">df [-h]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230509223526503.png?lastModify=1685936981" alt="image-20230509223526503"></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>​        首先，我们的一个个命令就是基于程序的，如：usr/bin/cd 保证了 cd 的运行。而不同环境下cd都起作用是因为环境变量</p>
<p>​        环境变量是一对 Key - Value 变量。</p>
<p>​        有这样一个键值对：</p>
<pre class="line-numbers language-none"><code class="language-none">env | grep PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230509224515178.png?lastModify=1685936981" alt="image-20230509224515178"></p>
<p>​        这就是为什么：因为系统会直接在下面的地址中寻找程序</p>
<h3 id=""><a href="#" class="headerlink" title="$"></a>$</h3><p>​        $ 是取变量的意思。可以通过 $的意思：如</p>
<pre class="line-numbers language-none"><code class="language-none">$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        取出了这个变量的值，于是可以输出到控制台上：</p>
<pre class="line-numbers language-none"><code class="language-none">echo $PATH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        取之并拼接：</p>
<pre class="line-numbers language-none"><code class="language-none">echo $&#123;PATH&#125;ABC
&gt;&gt;&gt; ...ABC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="自行设置变量"><a href="#自行设置变量" class="headerlink" title="自行设置变量"></a>自行设置变量</h3><pre class="line-numbers language-none"><code class="language-none">export VARNAME&#x3D;VAL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230509225156394.png?lastModify=1685936981" alt="image-20230509225156394"></p>
<h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><p>​        </p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230509225748238.png?lastModify=1685936981" alt="image-20230509225748238"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230509230111637.png?lastModify=1685936981" alt="image-20230509230111637"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230509230414086.png?lastModify=1685936981" alt="image-20230509230414086"></p>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><pre class="line-numbers language-none"><code class="language-none">zip [-r] file1 ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当包含文件夹的时候需要指定参数 -r</p>
<pre class="line-numbers language-none"><code class="language-none">upzip [-d] place<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当需要指定位置的时候，带上参数 -d 并且写上place参数</p>
<h1 id="简单CMake教程"><a href="#简单CMake教程" class="headerlink" title="简单CMake教程"></a>简单CMake教程</h1><p>​        下面请在 Linux 系统下操作，建议虚拟机！</p>
<h2 id="干嘛的这个"><a href="#干嘛的这个" class="headerlink" title="干嘛的这个"></a>干嘛的这个</h2><p>​        我们构建程序非常需要这个玩意！使用它来构建比如说VS下的项目！</p>
<h2 id="怎么下载？"><a href="#怎么下载？" class="headerlink" title="怎么下载？"></a>怎么下载？</h2><p>​        先尝试一个指令：</p>
<pre class="line-numbers language-none"><code class="language-none">cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果出现了这个，那就说明你的Cmake已经装好了！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230216193703982.png?lastModify=1685936981" alt="image-20230216193703982"></p>
<p>​        如果不是，仔细阅读提示，大概是自己没有安装这个东西：</p>
<pre class="line-numbers language-none"><code class="language-none">sudo install cmake<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        等一会儿就好了！</p>
<p>​        为了测试，也自行安装一下 g++ 编译器！</p>
<pre class="line-numbers language-none"><code class="language-none">sudo install g++<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        方便我们后续的编译。</p>
<p>​        以及为了方便我们的书写，自然推介 vim 编辑器来干活：</p>
<pre class="line-numbers language-none"><code class="language-none">sudo install vim
&#x2F;&#x2F; 先别急，一般你的linux已经安装好了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="先熟悉一下！"><a href="#先熟悉一下！" class="headerlink" title="先熟悉一下！"></a>先熟悉一下！</h2><p>​        先 cd 到一个工作文件夹吧！</p>
<p>​        先创建一个文件夹</p>
<pre class="line-numbers language-none"><code class="language-none">mkdir work<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        进入：</p>
<pre class="line-numbers language-none"><code class="language-none">cd work<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        直接整一个 main.cpp</p>
<pre class="line-numbers language-none"><code class="language-none">vim main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        按 i 来进入编辑模式, copy，请</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
int main()
&#123;
	std::cout&lt;&lt;&quot;Hello Cpp&quot;&lt;&lt;std::endl
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        然后摁 esc 键，输入:wq退出</p>
<p>​        然后开始入门！</p>
<pre class="line-numbers language-none"><code class="language-none">vim CMakeLists.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        严格区分大小写！！！！</p>
<p>​        然后还是 copy ! 先不论这些都是什么东西</p>
<pre class="line-numbers language-none"><code class="language-none">PROJECT(HELLO)

SET(SRC_LIST main.cpp)

MESSAGE(STATUS &quot;this is binary dir&quot; $&#123;HELLO_BINARY_DIR&#125;)

MESSAGE(STATUS &quot;this is SOURCE dir&quot; $&#123;HELLO_SOURCE_DIR&#125;)

ADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        保存一下，还是一样的 esc :wq</p>
<p>​        然后编译一下，.的意思是在当前目录找CMakeList，在哪个目录下cmake产生的文件就在哪个目录下</p>
<pre class="line-numbers language-none"><code class="language-none">cmake .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        然后可以运行了：</p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h2><pre class="line-numbers language-none"><code class="language-none">PROJECT (HELLO)   		# 指定了工程的名字，并且支持所有语言—建议

PROJECT (HELLO CXX)      # 指定了工程的名字，并且支持语言是C++

PROJECT (HELLO C CXX)    # 指定了工程的名字，并且支持语言是C和C++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        该指定隐式定义了两个CMAKE的变量</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;projectname&gt;_BINARY_DIR，本例中是 HELLO_BINARY_DIR

&lt;projectname&gt;_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录。</p>
<p>​        问题：如果改了工程名，这两个变量名也会改变</p>
<p>​        解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p>
<h2 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h2><p>​        用来显示的指定变量的</p>
<p>​        SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p>
<p>​        也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p>
<h2 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h2><p>​        向终端输出用户自定义的信息</p>
<p>​        主要包含三种信息：    </p>
<ul>
<li>SEND_ERROR，产生错误，生成过程被跳过。</li>
<li>SATUS，输出前缀为—的信息。</li>
<li>FATAL_ERROR，立即终止所有 cmake 过程.</li>
</ul>
<h2 id="ADD-EXECUTABLE关键字"><a href="#ADD-EXECUTABLE关键字" class="headerlink" title="ADD_EXECUTABLE关键字"></a>ADD_EXECUTABLE关键字</h2><p>​        生成可执行文件</p>
<p>​        ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p>
<p>​        也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p>
<p>​        上述例子可以简化的写成</p>
<pre class="line-numbers language-none"><code class="language-none">PROJECT(HELLO)
ADD_EXECUTABLE(hello main.cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p>
<h2 id="语法的基本原则"><a href="#语法的基本原则" class="headerlink" title="语法的基本原则"></a>语法的基本原则</h2><p>​        1. 变量使用 ${} 方式取值，但是在 IF 控制语句中是直接使用变量名</p>
<p>​        2.</p>
<ul>
<li>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，</li>
<li>如果存在另外一个 func.cpp 源文件，就要写成：</li>
<li><code>ADD_EXECUTABLE(hello main.cpp func.cpp)</code>或者<code>ADD_EXECUTABLE(hello main.cpp;func.cpp)</code></li>
<li>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</li>
<li>指令是大小写无关的，参数和变量是大小写相关的。</li>
</ul>
<h2 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a>语法注意事项</h2><ul>
<li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li>
<li>ADD_EXECUTABLE(hello main) 后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li>
</ul>
<h2 id="内部构建和外部构建"><a href="#内部构建和外部构建" class="headerlink" title="内部构建和外部构建"></a>内部构建和外部构建</h2><ul>
<li><p>我们刚刚讲的例子就是内部构建，他生产的临时文件特别多，不方便清理</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230216202047986.png?lastModify=1685936981" alt="image-20230216202047986"></p>
<p>​        一大堆文件混在一起</p>
</li>
<li><p>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</p>
</li>
</ul>
<p>​        首先</p>
<pre class="line-numbers language-none"><code class="language-none">mkdir build
cd build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        然后</p>
<pre class="line-numbers language-none"><code class="language-none">cmake .. # 在上两级编译<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        现在干净了：（查看时cd ..）</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230216202644656.png?lastModify=1685936981" alt="image-20230216202644656"></p>
<p>​        (记得再cd回去)</p>
<pre class="line-numbers language-none"><code class="language-none">make
.&#x2F;hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        总结一下：</p>
<p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p>
<p>2、进入build，运行cmake ..    当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p>
<p>3、在build目录下，运行make来构建工程</p>
<p>​        注意外部构建的两个变量</p>
<p>1、HELLO_SOURCE_DIR  还是工程路径</p>
<p>2、HELLO_BINARY_DIR   编译路径 也就是 /root/cmake/bulid</p>
<h2 id="让Hello-World看起来更像一个工程"><a href="#让Hello-World看起来更像一个工程" class="headerlink" title="让Hello World看起来更像一个工程"></a>让Hello World看起来更像一个工程</h2><ul>
<li>为工程添加一个子目录 src，用来放置工程源代码</li>
<li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li>
<li>在工程目录添加文本文件 COPYRIGHT, README</li>
<li>在工程目录添加一个 <a target="_blank" rel="noopener" href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li>
<li>将构建后的目标文件放入构建目录的 bin 子目录</li>
<li>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</li>
</ul>
<p>每个目录下都要有一个CMakeLists.txt说明</p>
<pre class="line-numbers language-none"><code class="language-none">[root@localhost cmake]# tree
.
├── build
├── CMakeLists.txt
└── src
    ├── CMakeLists.txt
    └── main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>外层CMakeLists.txt</p>
<pre class="line-numbers language-none"><code class="language-none">PROJECT(HELLO)
ADD_SUBDIRECTORY(src bin)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>src下的CMakeLists.txt</p>
<pre class="line-numbers language-none"><code class="language-none">ADD_EXECUTABLE(hello main.cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        可执行文件在 bin 下面</p>
<h2 id="ADD-SUBDIRECTORY-指令"><a href="#ADD-SUBDIRECTORY-指令" class="headerlink" title="ADD_SUBDIRECTORY 指令"></a>ADD_SUBDIRECTORY 指令</h2><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p>
<ul>
<li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p>
</li>
<li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p>
</li>
<li><p>ADD_SUBDIRECTORY(src bin)</p>
<p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p>
<p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p>
</li>
</ul>
<h2 id="更改二进制的保存路径"><a href="#更改二进制的保存路径" class="headerlink" title="更改二进制的保存路径"></a>更改二进制的保存路径</h2><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p>
<p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p>
<p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p>
<h2 id="如何安装HelloWord"><a href="#如何安装HelloWord" class="headerlink" title="如何安装HelloWord"></a>如何安装HelloWord</h2><p>​        使用CMAKE一个新的指令：INSTALL</p>
<p>​        INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p>
<p>​        使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p>
<h2 id="安装文件COPYRIGHT和README"><a href="#安装文件COPYRIGHT和README" class="headerlink" title="安装文件COPYRIGHT和README"></a>安装文件COPYRIGHT和README</h2><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p>
<p>FILES：文件</p>
<p>DESTINATION：</p>
<p>1、写绝对路径</p>
<p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/<DESTINATION 定义的路径></p>
<p>CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</p>
<p>cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p>
<h2 id="安装脚本runhello-sh"><a href="#安装脚本runhello-sh" class="headerlink" title="安装脚本runhello.sh"></a>安装脚本runhello.sh</h2><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p>
<p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p>
<p>说明：实际安装到的是 /usr/bin</p>
<p>使用: make install 安装东西</p>
<pre class="line-numbers language-none"><code class="language-none">sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="安装-doc-中的-hello-txt"><a href="#安装-doc-中的-hello-txt" class="headerlink" title="安装 doc 中的 hello.txt"></a>安装 doc 中的 hello.txt</h2><ul>
<li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p>
</li>
<li><p>二、是直接在工程目录通过</p>
<p>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p>
</li>
</ul>
<p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p>
<p>注意：abc 和 abc/有很大的区别</p>
<p>目录名不以/结尾：这个目录将被安装为目标路径下的</p>
<p>目录名以/结尾：将这个目录中的内容安装到目标路径</p>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><p>cmake ..</p>
<p>make</p>
<p>make install</p>
<h2 id="静态库和动态库的构建"><a href="#静态库和动态库的构建" class="headerlink" title="静态库和动态库的构建"></a>静态库和动态库的构建</h2><p>静态库和动态库的区别</p>
<ul>
<li><p>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</p>
</li>
<li><p>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</p>
</li>
<li><p>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</p>
<h2 id="构建实例"><a href="#构建实例" class="headerlink" title="构建实例"></a>构建实例</h2><pre class="line-numbers language-none"><code class="language-none">[root@localhost cmake2]# tree
.
├── build
├── CMakeLists.txt
└── lib
    ├── CMakeLists.txt
    ├── hello.cpp
    └── hello.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>hello.h中的内容</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef HELLO_H
#define Hello_H

void HelloFunc();

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>hello.cpp中的内容</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;hello.h&quot;
#include &lt;iostream&gt;
void HelloFunc()&#123;
    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>项目中的cmake内容</p>
<pre class="line-numbers language-none"><code class="language-none">PROJECT(HELLO)
ADD_SUBDIRECTORY(lib bin)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>lib中CMakeLists.txt中的内容</p>
<pre class="line-numbers language-none"><code class="language-none">SET(LIBHELLO_SRC hello.cpp)
ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="ADD-LIBRARY"><a href="#ADD-LIBRARY" class="headerlink" title="ADD_LIBRARY"></a>ADD_LIBRARY</h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p>
<ul>
<li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li>
<li>SHARED，动态库    STATIC，静态库</li>
<li>${LIBHELLO_SRC} ：源文件</li>
</ul>
<h3 id="同时构建静态和动态库"><a href="#同时构建静态和动态库" class="headerlink" title="同时构建静态和动态库"></a>同时构建静态和动态库</h3><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a
ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)
ADD_LIBRARY(hello STATIC $&#123;LIBHELLO_SRC&#125;)

&#x2F;&#x2F; 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已
ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)
ADD_LIBRARY(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="SET-TARGET-PROPERTIES"><a href="#SET-TARGET-PROPERTIES" class="headerlink" title="SET_TARGET_PROPERTIES"></a>SET_TARGET_PROPERTIES</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p>
<p>同时构建静态和动态库</p>
<pre class="line-numbers language-none"><code class="language-none">SET(LIBHELLO_SRC hello.cpp)

ADD_LIBRARY(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)

&#x2F;&#x2F;对hello_static的重名为hello
SET_TARGET_PROPERTIES(hello_static PROPERTIES  OUTPUT_NAME &quot;hello&quot;)
&#x2F;&#x2F;cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a
SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)

ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)

SET_TARGET_PROPERTIES(hello PROPERTIES  OUTPUT_NAME &quot;hello&quot;)
SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="动态库的版本号"><a href="#动态库的版本号" class="headerlink" title="动态库的版本号"></a>动态库的版本号</h2><p>一般动态库都有一个版本号的关联</p>
<pre class="line-numbers language-none"><code class="language-none">libhello.so.1.2
libhello.so -&gt;libhello.so.1
libhello.so.1-&gt;libhello.so.1.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>CMakeLists.txt 插入如下</p>
<p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p>
<p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p>
<h2 id="安装共享库和头文件"><a href="#安装共享库和头文件" class="headerlink" title="安装共享库和头文件"></a>安装共享库和头文件</h2><p>我们将 hello 的共享库安装到<prefix>/lib目录，</p>
<p>将 hello.h 安装到<prefix>/include/hello 目录</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;文件放到该目录下
INSTALL(FILES hello.h DESTINATION include&#x2F;hello)

&#x2F;&#x2F;二进制，静态库，动态库安装都用TARGETS
&#x2F;&#x2F;ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。
INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：</p>
<p>安装的时候，指定一下路径，放到系统下</p>
<p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p>
<h2 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h2><p>准备工作，新建一个目录来使用外部共享库和头文件</p>
<pre class="line-numbers language-none"><code class="language-none">[root@MiWiFi-R4CM-srv cmake3]# tree
.
├── build
├── CMakeLists.txt
└── src
    ├── CMakeLists.txt
    └── main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>main.cpp</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;hello.h&gt;

int main()&#123;
	HelloFunc();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="解决：make后头文件找不到的问题"><a href="#解决：make后头文件找不到的问题" class="headerlink" title="解决：make后头文件找不到的问题"></a>解决：make后头文件找不到的问题</h2><p>PS：include <hello/hello.h>  这样include是可以，这么做的话，就没啥好讲的了</p>
<p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p>
<p>在CMakeLists.txt中加入头文件搜索路径</p>
<p>INCLUDE_DIRECTORIES(/usr/include/hello)</p>
<h2 id="解决：找到引用的函数问题"><a href="#解决：找到引用的函数问题" class="headerlink" title="解决：找到引用的函数问题"></a>解决：找到引用的函数问题</h2><p>报错信息：undefined reference to `HelloFunc()’</p>
<p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p>
<p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p>
<p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p>
<p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p>
<p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p>
<p>查看main的链接情况</p>
<pre class="line-numbers language-none"><code class="language-none">[root@MiWiFi-R4CM-srv bin]# ldd main 
	linux-vdso.so.1 &#x3D;&gt;  (0x00007ffedfda4000)
	libhello.so &#x3D;&gt; &#x2F;lib64&#x2F;libhello.so (0x00007f41c0d8f000)
	libstdc++.so.6 &#x3D;&gt; &#x2F;lib64&#x2F;libstdc++.so.6 (0x00007f41c0874000)
	libm.so.6 &#x3D;&gt; &#x2F;lib64&#x2F;libm.so.6 (0x00007f41c0572000)
	libgcc_s.so.1 &#x3D;&gt; &#x2F;lib64&#x2F;libgcc_s.so.1 (0x00007f41c035c000)
	libc.so.6 &#x3D;&gt; &#x2F;lib64&#x2F;libc.so.6 (0x00007f41bff8e000)
	&#x2F;lib64&#x2F;ld-linux-x86-64.so.2 (0x00007f41c0b7c000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>链接静态库</p>
<p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p>
<h2 id="特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH"><a href="#特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH" class="headerlink" title="特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH"></a>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h2><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p>
<p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p>
<p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p>
<p>补充：生产debug版本的方法： cmake .. -DCMAKE_BUILD_TYPE=debug</p>
</li>
</ul>
<h1 id="Opencv-With-VS"><a href="#Opencv-With-VS" class="headerlink" title="Opencv With VS"></a>Opencv With VS</h1><h1 id="Opencv-with-Visual-Studio"><a href="#Opencv-with-Visual-Studio" class="headerlink" title="Opencv with Visual Studio"></a>Opencv with Visual Studio</h1><h2 id="C-Version"><a href="#C-Version" class="headerlink" title="C++ Version"></a>C++ Version</h2><h2 id="1-环境配置问题"><a href="#1-环境配置问题" class="headerlink" title="1.环境配置问题"></a>1.环境配置问题</h2><p>​        我们首先下好 Opencv 4.5.1 的包，安装好 Cmake 之后开始使用！</p>
<p>​        下面为了配置好 Opencv 的开发环境：我们必须书写一个 CmakeLists来链接库：</p>
<pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 2.8)
project(def) # 工程名称
 
set(SOURCES
    default.cpp # 源文件
)
 
set(HEADERS
    #main.hpp # 头文件
)
 
add_executable(Main #产生可执行区域
    $&#123;SOURCES&#125;
    $&#123;HEADERS&#125;
)
 
set(OpenCV_DIR &quot;D:&#x2F;Opencv4.5.1&#x2F;opencv&#x2F;build&#x2F;x64&#x2F;vc15&#x2F;lib&quot;) # 找到二进制的坤文件
find_package(OpenCV REQUIRED)
if(OpenCV_FOUND)
    target_include_directories(Main PUBLIC $&#123;OpenCV_INCLUDE_DIRS&#125;)
    target_link_libraries(Main $&#123;OpenCV_LIBS&#125;)
    # 上面两行代码把 Opencv 库所需要的文件和程序链接
 
endif()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        随后，点击Cmake 把工作区和二进制生成文件的地址传进去</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305134917646.png?lastModify=1685936981" alt="image-20230305134917646"></p>
<p>​        平台选择 64 位，点击 Configure 随后点击 Generate :留意有没有报错！</p>
<p>​        如果一切没有问题，那么，回到你的工作文件夹，选择BUILD文件夹，打开，随后找到：def.sIn文件，单击启动项目，当然我们需要更改启动项</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305135524174.png?lastModify=1685936981" alt="image-20230305135524174"></p>
<p>​        选择Main启动项即可！</p>
<p>​        当然可以使用以下代码测试你的环境！</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
using namespace cv;

int main()
&#123;
	string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;
	Mat img &#x3D; imread(path);
	if (img.empty()) &#123;
		return -1;
	&#125;
	imshow(&quot;1&quot;, img);
	waitKey(0);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="项目入门1："><a href="#项目入门1：" class="headerlink" title="项目入门1："></a>项目入门1：</h2><p>​        我们首先来了解什么是图像：这很简单！我们在计算机中用一个矩阵，向里面填入色块实现图像的显示，我们的图像越高清，就说明我们的矩阵划分的越密集，这样，表现出来的就越是清晰！</p>
<p>​        在黑白图中，我们使用 8 位图来刻画我们的黑白图！0代表黑色，255 则是白色。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305140523343.png?lastModify=1685936981" alt="image-20230305140523343"></p>
<p>​        对于彩色图像，我们使用 BGR 三色图，以不同的比例的亮度来叠加在一起。</p>
<h3 id="显示一个图像"><a href="#显示一个图像" class="headerlink" title="显示一个图像"></a>显示一个图像</h3><p>​        下面我们来使用一个函数 imread 和 imshow!</p>
<p>​        先来引入头文件</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
using namespace cv;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​         现在看一下，有没有报错，一般而言成功了的环境是不会报错的！正是如此！</p>
<p>​        如果你有幸浏览到了 opencv  的文档，你会注意到 imread 表示的是从程序外面读取一个图像，并且将对象返回给一个叫做 Mat 的类型！函数需要一个string，表示的是图像的地址</p>
<pre class="line-numbers language-none"><code class="language-none"># 这里找到一个图像的地址：
string path &#x3D; &quot;path_DIR&quot;;

# 然后传进去：
Mat img &#x3D; imread(path);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个 Mat 就是一个矩阵，存储着图像的信息。显示图像也是简单的：</p>
<pre class="line-numbers language-none"><code class="language-none">imshow(&quot;NameWindows&quot;,img);
waitKey(0);&#x2F;&#x2F; 防止图像一闪而过<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Examples:</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
using namespace cv;

int main()
&#123;
	string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;
	Mat img &#x3D; imread(path);
	if (img.empty()) &#123;
		return -1;
	&#125;
	imshow(&quot;1&quot;, img);
	waitKey(0);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305141742942.png?lastModify=1685936981" alt="image-20230305141742942"></p>
<p>​        效果如上！</p>
<h3 id="显示一个视频"><a href="#显示一个视频" class="headerlink" title="显示一个视频"></a>显示一个视频</h3><p>​        视频的本质是一帧一帧图像的播放，基于此，我们可以导入，以及导出一个视频：</p>
<pre class="line-numbers language-none"><code class="language-none">string path &#x3D; &quot;C:\\Users\\陈冠豪\\Videos\\2023-03-05 14-24-15.mp4&quot;;
VideoCapture videocap(path);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        我们的 Opencv 里有一个专门搞视频的类型：</p>
<pre class="line-numbers language-none"><code class="language-none">VideoCapture <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        类型，支持这样的构造：</p>
<pre class="line-numbers language-none"><code class="language-none">VideoCapture videocap(path)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        随后声明一个矩阵，他将会存储我们的视频中一帧的图片：</p>
<pre class="line-numbers language-none"><code class="language-none">Mat img;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们视频的读取是这样的：读取每一帧，然后显示，直到视频结束或者我们人为的退出：</p>
<pre class="line-numbers language-none"><code class="language-none">while(1)
&#123;
	videocap.read(img);
    imshow(&quot;Video&quot;,img);
    waitKey(1); &#x2F;&#x2F; 我们在这里决定了延迟是如何的，这里实现倍速或者是慢速播放
&#125;
#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
using namespace cv;

int main()
&#123;
	string path &#x3D; &quot;C:\\Users\\陈冠豪\\Videos\\2023-03-05 14-31-23.mp4&quot;;
	VideoCapture videocap(path);
	Mat img;
	while (1)
	&#123;
		videocap.read(img);
		imshow(&quot;1&quot;, img);
		waitKey(20);
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        你当然可以选择你的摄像头！电脑的默认头是0，这意味着：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
using namespace cv;

int main()
&#123;
	VideoCapture videocap(0);
	Mat img;
	while (1)
	&#123;
		videocap.read(img);
		imshow(&quot;1&quot;, img);
		waitKey(20);
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        就可以看到你自己了！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305144156399.png?lastModify=1685936981" alt="image-20230305144156399"></p>
<p>​        很好。</p>
<h2 id="项目入门2：图像处理"><a href="#项目入门2：图像处理" class="headerlink" title="项目入门2：图像处理"></a>项目入门2：图像处理</h2><p>​        下面，我们来一 一介绍函数的图像处理：</p>
<p>​        1）转化为灰度图：</p>
<p>来看这个函数：</p>
<pre class="line-numbers language-none"><code class="language-none">cvtColor(imgSrc,imgDst,code);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这个函数把源图像转化为目标图像，以及转化方式：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
using namespace cv;

int main()
&#123;
	Mat imgSrc, imgDst;
	string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;
	imgSrc &#x3D; imread(path);
	cvtColor(imgSrc, imgDst, COLOR_BGR2GRAY);
	imshow(&quot;gray&quot;, imgDst);
	waitKey(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305145310719.png?lastModify=1685936981" alt="image-20230305145310719"></p>
<h2 id="图像模糊（高斯模糊）"><a href="#图像模糊（高斯模糊）" class="headerlink" title="图像模糊（高斯模糊）"></a>图像模糊（高斯模糊）</h2><p>​        使用函数 GaussainBlur 来实现！</p>
<p>​        小技巧，如果你不知道这个函数是干什么的，传什么样的参数：可以Ctrl+单击</p>
<pre class="line-numbers language-none"><code class="language-none">CV_EXPORTS_W void GaussianBlur( InputArray src, OutputArray dst, Size ksize,
                                double sigmaX, double sigmaY &#x3D; 0,
                                int borderType &#x3D; BORDER_DEFAULT );

&#x2F;** @brief Applies the bilateral filter to an image.

The function applies bilateral filtering to the input image, as described in
http:&#x2F;&#x2F;www.dai.ed.ac.uk&#x2F;CVonline&#x2F;LOCAL_COPIES&#x2F;MANDUCHI1&#x2F;Bilateral_Filtering.html
bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is
very slow compared to most filters.

_Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (\&lt;
10), the filter will not have much effect, whereas if they are large (\&gt; 150), they will have a very
strong effect, making the image look &quot;cartoonish&quot;.

_Filter size_: Large filters (d \&gt; 5) are very slow, so it is recommended to use d&#x3D;5 for real-time
applications, and perhaps d&#x3D;9 for offline applications that need heavy noise filtering.

This filter does not work inplace.
@param src Source 8-bit or floating-point, 1-channel or 3-channel image.
@param dst Destination image of the same size and type as src .
@param d Diameter of each pixel neighborhood that is used during filtering. If it is non-positive,
it is computed from sigmaSpace.
@param sigmaColor Filter sigma in the color space. A larger value of the parameter means that
farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting
in larger areas of semi-equal color.
@param sigmaSpace Filter sigma in the coordinate space. A larger value of the parameter means that
farther pixels will influence each other as long as their colors are close enough (see sigmaColor
). When d\&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is
proportional to sigmaSpace.
@param borderType border mode used to extrapolate pixels outside of the image, see #BorderTypes
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        可以看到，这个函数需要源图像，目标图像和高斯核的大小，以及两个方差（其中有一个是必须的）</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305150011615.png?lastModify=1685936981" alt="image-20230305150011615"></p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
using namespace cv;

int main()
&#123;
	Mat imgSrc,imgBlur;
	string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;
	imgSrc &#x3D; imread(path);
	GaussianBlur(imgSrc, imgBlur, Size(7, 7), 5, 0);
	imshow(&quot;1&quot;, imgBlur);
	imshow(&quot;org&quot;, imgSrc);
	waitKey(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="图像边缘检测"><a href="#图像边缘检测" class="headerlink" title="图像边缘检测"></a>图像边缘检测</h3><p>​        下面我们要使用函数Canny 来给我们的图像进行检测！</p>
<p>​        <strong>我们在使用 Canny 检测的时候，往往还会在之前使用模糊来更好的检测！！！</strong></p>
<p>​        通读一下函数需求：</p>
<pre class="line-numbers language-none"><code class="language-none">CV_EXPORTS_W void Canny( InputArray image, OutputArray edges,
                         double threshold1, double threshold2,
                         int apertureSize &#x3D; 3, bool L2gradient &#x3D; false );

&#x2F;** \overload

Finds edges in an image using the Canny algorithm with custom image gradient.

@param dx 16-bit x derivative of input image (CV_16SC1 or CV_16SC3).
@param dy 16-bit y derivative of input image (same type as dx).
@param edges output edge map; single channels 8-bit image, which has the same size as image .
@param threshold1 first threshold for the hysteresis procedure.
@param threshold2 second threshold for the hysteresis procedure.
@param L2gradient a flag, indicating whether a more accurate \f$L_2\f$ norm
\f$&#x3D;\sqrt&#123;(dI&#x2F;dx)^2 + (dI&#x2F;dy)^2&#125;\f$ should be used to calculate the image gradient magnitude (
L2gradient&#x3D;true ), or whether the default \f$L_1\f$ norm \f$&#x3D;|dI&#x2F;dx|+|dI&#x2F;dy|\f$ is enough (
L2gradient&#x3D;false ).
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        可以看到，我们需要源图像，目标图像，两个阈值</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305150945109.png?lastModify=1685936981" alt="image-20230305150945109"></p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
using namespace cv;

int main()
&#123;
	Mat imgSrc,imgBlur,imgCanny;
	string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;
	imgSrc &#x3D; imread(path);
	GaussianBlur(imgSrc, imgBlur, Size(7, 7), 5, 0);
	Canny(imgBlur,imgCanny,50,150);
	imshow(&quot;org&quot;, imgSrc);
	imshow(&quot;canny&quot;, imgCanny);
	waitKey(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们用这个来检测阈值，当然，阈值越低，对边界越敏感：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305151111912.png?lastModify=1685936981" alt="image-20230305151111912"></p>
<p>​        下调阈值为 25,75后的结果！</p>
<h3 id="图像膨胀"><a href="#图像膨胀" class="headerlink" title="图像膨胀"></a>图像膨胀</h3><p>​        当我们的图像特征不明显的时候，我们可以放大特征来便于我们的检测：</p>
<p>​        使用的是函数 dilate:</p>
<pre class="line-numbers language-none"><code class="language-none">CV_EXPORTS_W void dilate( InputArray src, 
                         OutputArray dst, 
                         InputArray kernel,
                          Point anchor &#x3D; Point(-1,-1), 
                         int iterations &#x3D; 1,
                          int borderType &#x3D; BORDER_CONSTANT,
                          const Scalar&amp; borderValue &#x3D; 											morphologyDefaultBorderValue() 
                        );

&#x2F;** @brief Performs advanced morphological transformations.

The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as
basic operations.

Any of the operations can be done in-place. In case of multi-channel images, each channel is
processed independently.

@param src Source image. The number of channels can be arbitrary. The depth should be one of
CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
@param dst Destination image of the same size and type as source image.
@param op Type of a morphological operation, see #MorphTypes
@param kernel Structuring element. It can be created using #getStructuringElement.
@param anchor Anchor position with the kernel. Negative values mean that the anchor is at the
kernel center.
@param iterations Number of times erosion and dilation are applied.
@param borderType Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.
@param borderValue Border value in case of a constant border. The default value has a special
meaning.
@sa  dilate, erode, getStructuringElement
@note The number of iterations is the number of times erosion or dilatation operation will be applied.
For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply
successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate).
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在我们使用完Canny之后：</p>
<p>​        我们的核怎么来呢？专门使用函数 getStructuringElement来完成我们的工作</p>
<pre class="line-numbers language-none"><code class="language-none">Mat kernel &#x3D; getStructuringElement(MORPH_RECT,Size(5,5));
# 这个核越大膨胀越厉害<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305151930037.png?lastModify=1685936981" alt="image-20230305151930037"></p>
<p>​        特征被明显的放大了！</p>
<h3 id="图像侵蚀"><a href="#图像侵蚀" class="headerlink" title="图像侵蚀"></a>图像侵蚀</h3><p>​        我们使用的函数是 Erode:</p>
<pre class="line-numbers language-none"><code class="language-none">CV_EXPORTS_W void erode( InputArray src, OutputArray dst, InputArray kernel,
                         Point anchor &#x3D; Point(-1,-1), int iterations &#x3D; 1,
                         int borderType &#x3D; BORDER_CONSTANT,
                         const Scalar&amp; borderValue &#x3D; morphologyDefaultBorderValue() );

&#x2F;** @example samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Morphology_1.cpp
Erosion and Dilation sample code
![Sample Screenshot-Erosion](Morphology_1_Tutorial_Erosion_Result.jpg)![Sample Screenshot-Dilation](Morphology_1_Tutorial_Dilation_Result.jpg)
Check @ref tutorial_erosion_dilatation &quot;the corresponding tutorial&quot; for more details
*&#x2F;

&#x2F;** @brief Dilates an image by using a specific structuring element.

The function dilates the source image using the specified structuring element that determines the
shape of a pixel neighborhood over which the maximum is taken:
\f[\texttt&#123;dst&#125; (x,y) &#x3D;  \max _&#123;(x&#39;,y&#39;):  \, \texttt&#123;element&#125; (x&#39;,y&#39;) \ne0 &#125; \texttt&#123;src&#125; (x+x&#39;,y+y&#39;)\f]

The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In
case of multi-channel images, each channel is processed independently.

@param src input image; the number of channels can be arbitrary, but the depth should be one of
CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.
@param dst output image of the same size and type as src.
@param kernel structuring element used for dilation; if elemenat&#x3D;Mat(), a 3 x 3 rectangular
structuring element is used. Kernel can be created using #getStructuringElement
@param anchor position of the anchor within the element; default value (-1, -1) means that the
anchor is at the element center.
@param iterations number of times dilation is applied.
@param borderType pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported.
@param borderValue border value in case of a constant border
@sa  erode, morphologyEx, getStructuringElement
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305152314781.png?lastModify=1685936981" alt="image-20230305152314781"></p>
<p>代码一览：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
using namespace cv;

int main()
&#123;
	Mat imgSrc,imgBlur,imgCanny,imgDial,imgErode;
	string path &#x3D; &quot;C:\\Users\\陈冠豪\\Pictures\\Camera Roll\\2022-06-20_16.14.20.png&quot;;
	imgSrc &#x3D; imread(path);
	GaussianBlur(imgSrc, imgBlur, Size(7, 7), 5, 0);
	Canny(imgBlur,imgCanny,50,150);
	Mat kernel &#x3D; getStructuringElement(MORPH_RECT, Size(5, 5));
	dilate(imgCanny, imgDial, kernel);
	erode(imgDial, imgErode, kernel);
	imshow(&quot;org&quot;, imgSrc);
	imshow(&quot;dilate&quot;, imgDial);
	imshow(&quot;erode&quot;, imgErode);
	waitKey(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="图像大小调整与变换"><a href="#图像大小调整与变换" class="headerlink" title="图像大小调整与变换"></a>图像大小调整与变换</h3><p>​        很容易猜到重新设定大小的函数就是Resize:</p>
<p>​        我们首先学习一下怎样查看图像的大小：</p>
<pre class="line-numbers language-none"><code class="language-none">cout &lt;&lt; img.size()&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305153228802.png?lastModify=1685936981" alt="image-20230305153228802"></p>
<p>​        现在我们可以调整大小了：</p>
<pre class="line-numbers language-none"><code class="language-none">resize(img,imgResize,Size(640,480));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305153352540.png?lastModify=1685936981" alt="image-20230305153352540"></p>
<p>​        如果希望是等比例的放缩，可以采用这样的方式：</p>
<pre class="line-numbers language-none"><code class="language-none">resize(img,imgResize,Size(),xRatio,yRatio);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​         我们也可以裁剪图像：</p>
<pre class="line-numbers language-none"><code class="language-none">Rect roi(100,100,200,300); &#x2F;&#x2F; 这里产生一个区域矩形
imgCrop &#x3D; img(roi);&#x2F;&#x2F;从图像中生成子图像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​    <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230305154148790.png?lastModify=1685936981" alt="image-20230305154148790"></p>
<h1 id="Opencv-with-Visual-Studio-1"><a href="#Opencv-with-Visual-Studio-1" class="headerlink" title="Opencv with Visual Studio"></a>Opencv with Visual Studio</h1><h2 id="纯图像应用"><a href="#纯图像应用" class="headerlink" title="纯图像应用"></a>纯图像应用</h2><p>​        Opencv当然可以创建纯色的图片。只需要我们指定图像的种类和每一位的BGR值</p>
<pre class="line-numbers language-none"><code class="language-none">Mat img(height,width,imgType,bkColorScalar);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        今为了创建一个彩色图像，选择 CV_8UC3，表明是CV下的8bit unsigned char（就是0~255）下的3通道图.</p>
<p>​        太单调了，画个圆：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
using namespace cv;

int main()
&#123;
	&#x2F;&#x2F; create a blank img

	&#x2F;&#x2F; CV_8bits(2~255) Unsigned Char 3dims 
	Mat img(512, 512, CV_8UC3, Scalar(255,0,0));

	&#x2F;&#x2F;create a circle

	circle(img, Point(256, 256), 155,Scalar(0,255,0),10);

	imshow(&quot;blue one&quot;, img);

	waitKey(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230322220017113.png?lastModify=1685936981" alt="image-20230322220017113"></p>
<p>​        当然可以玩其他东西：不过，也就是可以查看API自己搞定：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
using namespace cv;

int main()
&#123;
	&#x2F;&#x2F; create a blank img

	&#x2F;&#x2F; CV_8bits(2~255) Unsigned Char 3dims 
	Mat img(512, 512, CV_8UC3, Scalar(255,0,0));

	&#x2F;&#x2F;create a circle

	circle(img, Point(256, 256), 155,Scalar(0,255,0),10);


	&#x2F;&#x2F; rectangle create
	rectangle(img, Point(150, 150), Point(300, 300), Scalar(255, 255, 255), FILLED);

	&#x2F;&#x2F; line

	line(img, Point(200, 400), Point(400, 400), Scalar(100, 100, 100), 20);
	&#x2F;&#x2F; putText

	putText(img, &quot;hello,world&quot;, Point(100, 100), FONT_HERSHEY_DUPLEX, 2, Scalar(0, 0, 0));
	
	imshow(&quot;blue one&quot;, img);

	waitKey(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230322221142413.png?lastModify=1685936981" alt="image-20230322221142413"></p>
<h2 id="Warp我们的图像：图像变换1"><a href="#Warp我们的图像：图像变换1" class="headerlink" title="Warp我们的图像：图像变换1"></a>Warp我们的图像：图像变换1</h2><p>​        下面我们继续！</p>
<p>​        <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/1-16825202276533.png?lastModify=1685936981" alt="1"></p>
<p>​        现在，我们想要变换这中间的一个扑克牌使之正立！我们转向：先把目标放到一个Demo 上，就是King这张牌。现在，我们找出它的四个点！不必打开画图，我们使用 <code>setMouseCallBack</code>这个函数！</p>
<pre class="line-numbers language-none"><code class="language-none">void setMouseCallback(const String&amp; winname, MouseCallback onMouse, void* userdata &#x3D; 0);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        winname就是目标窗口名称，那这个 MouseCallback是啥呢？进一步去看</p>
<pre class="line-numbers language-none"><code class="language-none">typedef void (*MouseCallback)(int event, int x, int y, int flags, void* userdata);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        再明显不过了，我们重写一个函数，其原型是如上的，我们编写一个！</p>
<pre class="line-numbers language-none"><code class="language-none">void onMouse(int event, int x, int y, int flags, void*) &#123;
	
	if(event &#x3D;&#x3D; EVENT_LBUTTONDOWN)
	cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y&lt;&lt;endl;

&#125;
int main()
&#123;
	string path &#x3D; &quot;C:\\Users\\usr\\Desktop\\My coding repositary\\learnopencv\\2\\source_file\\1.png&quot;;
	Mat warp &#x3D; imread(path);
	if (warp.empty()) &#123;
		return -1;
	&#125;

	imshow(&quot;1&quot;, warp);
	setMouseCallback(&quot;1&quot;, onMouse);


	waitKey(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        啊哈！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230419220733947.png?lastModify=1685936981" alt="image-20230419220733947"></p>
<p>​        这几个点收下了！</p>
<p>​        然后，我们想要立正之后，图片的宽和高也应当要给出来！</p>
<pre class="line-numbers language-none"><code class="language-none">float w &#x3D; 250, h &#x3D; 350;

Point2f points[4] &#x3D; &#123; &#123;575 ,195&#125;,&#123;440 ,465&#125;,&#123;733 ,528&#125;,&#123;833 ,247&#125; &#125;;
Point2f after[4] &#x3D; &#123; &#123;0,0&#125;,&#123;w ,0&#125;,&#123;0 ,h&#125;,&#123;w ,h&#125; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        然后转向API的调用！</p>
<pre class="line-numbers language-none"><code class="language-none">mat &#x3D; getPerspectiveTransform(points, after);
warpPerspective(warp,imgWarp, mat, Point(w, h));
imshow(&quot;Warp&quot;, imgWarp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230419222906918.png?lastModify=1685936981" alt="image-20230419222906918"></p>
<h1 id="Opencv-with-Visual-Studio3"><a href="#Opencv-with-Visual-Studio3" class="headerlink" title="Opencv with Visual Studio3"></a>Opencv with Visual Studio3</h1><p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230423222216217.png?lastModify=1685936981" alt="image-20230423222216217"></p>
<p>​        看到这个图片了嘛，这个就是我们今天的任务！通过颜色来检测于识别小车！</p>
<h2 id="颜色检测"><a href="#颜色检测" class="headerlink" title="颜色检测"></a>颜色检测</h2><p>​        我们首先来转化一下这个图片，我们的图片都是采用BGR绘制的。但是还有另一套颜色系统，是用HSV来描述的：</p>
<pre class="line-numbers language-none"><code class="language-none">每一种颜色都是由色相（Hue，简H），饱和度（Saturation，简S）和色明度（Value，简V）所表示的。这个模型中颜色的参数分别是：色调（H），饱和度（S），亮度（V）。


色调H参数表示色彩信息，即所处的光谱颜色的位置。该参数用一角度量来表示，取值范围为0°～360°。若从红色开始按逆时针方向计算，红色为0°，绿色为120°，蓝色为240°。它们的补色是：黄色为60°，青色为180°，紫色为300°；
饱和度S：取值范围为0.0～1.0；
亮度V：取值范围为0.0(黑色)～1.0(白色)。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在Opencv中，转化的方式同将图片二值化是一致的，都是cvtColor(),其调用的参数我想很容易猜：COLOR_BGR2HSV.</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230423222747297.png?lastModify=1685936981" alt="img"></p>
<p>​        但是，我们若是想要筛选，就必须要采用滑条的方式来搞！</p>
<p>​        怎么搞呢？</p>
<p>​        首先，我们创建滑动条，就必须要使用Scalar来搞，我们的HSV有上下限制，这就意味着。两个vector是被需要的：</p>
<pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt; lower;
vector&lt;int&gt; upper;
int arr[6] &#x3D; &#123; 0,0,0,255,255,255 &#125;;
	for (int i &#x3D; 0; i &lt; 3; i++) &#123;

		lower.push_back(arr[i]);
		upper.push_back(arr[i + 3]);

	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        随后，使用由inRange函数</p>
<pre class="line-numbers language-none"><code class="language-none">CV_EXPORTS_W void inRange(InputArray src, InputArray lowerb,
                          InputArray upperb, OutputArray dst);

&#x2F;** @brief Performs the per-element comparison of two arrays or an array and scalar value.

The function compares:
*   Elements of two arrays when src1 and src2 have the same size:
    \f[\texttt&#123;dst&#125; (I) &#x3D;  \texttt&#123;src1&#125; (I)  \,\texttt&#123;cmpop&#125;\, \texttt&#123;src2&#125; (I)\f]
*   Elements of src1 with a scalar src2 when src2 is constructed from
    Scalar or has a single element:
    \f[\texttt&#123;dst&#125; (I) &#x3D;  \texttt&#123;src1&#125;(I) \,\texttt&#123;cmpop&#125;\,  \texttt&#123;src2&#125;\f]
*   src1 with elements of src2 when src1 is constructed from Scalar or
    has a single element:
    \f[\texttt&#123;dst&#125; (I) &#x3D;  \texttt&#123;src1&#125;  \,\texttt&#123;cmpop&#125;\, \texttt&#123;src2&#125; (I)\f]
When the comparison result is true, the corresponding element of output
array is set to 255. The comparison operations can be replaced with the
equivalent matrix expressions:
@code&#123;.cpp&#125;
    Mat dst1 &#x3D; src1 &gt;&#x3D; src2;
    Mat dst2 &#x3D; src1 &lt; 8;
    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        产生掩码：但是这里要求的时Scalar，我们先搞一下</p>
<pre class="line-numbers language-none"><code class="language-none">Scalar down(lower[0], lower[1], lower[2]);

Scalar up(upper[0], upper[1], upper[2]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        现在可以了</p>
<pre class="line-numbers language-none"><code class="language-none">inRange(HSV, down, up, mask);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        但是，反复的调值太麻烦，我们使用滑动条调值！</p>
<p>​        先建立一个窗口，在基于这个窗口创立滑动条！</p>
<pre class="line-numbers language-none"><code class="language-none">namedWindow(&quot;TrackBars&quot;, (640, 480));
createTrackbar(&quot;Hue Min&quot;, &quot;TrackBars&quot;, &amp;lower[0], 255);
createTrackbar(&quot;Hue Max&quot;, &quot;TrackBars&quot;, &amp;upper[0], 255);
createTrackbar(&quot;Sat Min&quot;, &quot;TrackBars&quot;, &amp;lower[1], 255);	createTrackbar(&quot;Sat Max&quot;, &quot;TrackBars&quot;, &amp;upper[1], 255);
createTrackbar(&quot;Val Min&quot;, &quot;TrackBars&quot;, &amp;lower[2], 255);
createTrackbar(&quot;Val Max&quot;, &quot;TrackBars&quot;, &amp;upper[2], 255);
CV_EXPORTS_W void namedWindow(const String&amp; winname, int flags &#x3D; WINDOW_AUTOSIZE);

&#x2F;** @brief Destroys the specified window.

The function destroyWindow destroys the window with the given name.

@param winname Name of the window to be destroyed.
 *&#x2F;
CV_EXPORTS int createTrackbar(const String&amp; trackbarname, const String&amp; winname,
                              int* value, int count,
                              TrackbarCallback onChange &#x3D; 0,
                              void* userdata &#x3D; 0);

&#x2F;** @brief Returns the trackbar position.

The function returns the current position of the specified trackbar.

@note

[__Qt Backend Only__] winname can be empty if the trackbar is attached to the control
panel.

@param trackbarname Name of the trackbar.
@param winname Name of the window that is the parent of the trackbar.
 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，使用一个死循环来完成我们的工作：</p>
<pre class="line-numbers language-none"><code class="language-none">while(1)
&#123;
	Scalar down(lower[0], lower[1], lower[2]);

	Scalar up(upper[0], upper[1], upper[2]);

	inRange(HSV, down, up, mask);

	imshow(&quot;work&quot;, mask);
	waitKey(1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样就好了。</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
using namespace cv;

string path &#x3D; &quot;D:\\My coding repositary\\learnopencv\\5\\source_file\\1.png&quot;;

vector&lt;int&gt; lower;
vector&lt;int&gt; upper;

void showVec(vector&lt;int&gt; pVec) &#123;

	

	for (auto i &#x3D; pVec.begin(); i !&#x3D; pVec.end(); i++) &#123;

		cout &lt;&lt; *i &lt;&lt; &quot; &quot;;

	&#125;

	cout &lt;&lt; &#39;\n&#39;;

&#125;

Mat HSV , mask;

int main()
&#123;
	int arr[6] &#x3D; &#123; 0,0,0,255,255,255 &#125;;
	for (int i &#x3D; 0; i &lt; 3; i++) &#123;

		lower.push_back(arr[i]);
		upper.push_back(arr[i + 3]);

	&#125;
	
	showVec(lower);
	showVec(upper);
	Mat workPng &#x3D; imread(path);
	if (workPng.empty()) &#123;
		return -1;
	&#125;

	cvtColor(workPng, HSV, COLOR_BGR2HSV);

	namedWindow(&quot;TrackBars&quot;, (640, 480));
	createTrackbar(&quot;Hue Min&quot;, &quot;TrackBars&quot;, &amp;lower[0], 255);
	createTrackbar(&quot;Hue Max&quot;, &quot;TrackBars&quot;, &amp;upper[0], 255);
	createTrackbar(&quot;Sat Min&quot;, &quot;TrackBars&quot;, &amp;lower[1], 255);
	createTrackbar(&quot;Sat Max&quot;, &quot;TrackBars&quot;, &amp;upper[1], 255);
	createTrackbar(&quot;Val Min&quot;, &quot;TrackBars&quot;, &amp;lower[2], 255);
	createTrackbar(&quot;Val Max&quot;, &quot;TrackBars&quot;, &amp;upper[2], 255);
	while(1)
	&#123;
		Scalar down(lower[0], lower[1], lower[2]);

		Scalar up(upper[0], upper[1], upper[2]);

		inRange(HSV, down, up, mask);

		imshow(&quot;work&quot;, mask);
		waitKey(1);
	&#125;



	waitKey();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426213925062.png?lastModify=1685936981" alt="image-20230426213925062"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426214024473.png?lastModify=1685936981" alt="image-20230426214024473"></p>
<h1 id="Opencv-with-Visual-Studio4"><a href="#Opencv-with-Visual-Studio4" class="headerlink" title="Opencv with Visual Studio4"></a>Opencv with Visual Studio4</h1><p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426214208705.png?lastModify=1685936981" alt="image-20230426214208705"></p>
<p>​        这是一个简单的图像，我们尝试来用之检测形状！</p>
<h2 id="轮廓检测"><a href="#轮廓检测" class="headerlink" title="轮廓检测"></a>轮廓检测</h2><p>​        现在我们想要检测形状的轮廓，是需要对图片做出若干预处理的！我们必须保证我们的图片经过开闭运算：</p>
<pre class="line-numbers language-none"><code class="language-none">Mat&amp; preWork(Mat&amp; pic)
&#123;
	Mat grey, blur, canny, dil, erode;
	cvtColor(pic, grey, COLOR_BGR2GRAY);
	GaussianBlur(grey, blur, Size(3, 3), 3, 0);
	Canny(blur, canny, 25, 75);
	Mat kernel &#x3D; getStructuringElement(MORPH_RECT, Size(3, 3));
	dilate(canny, dil, kernel);

	imshow(&quot;grey&quot;, grey);
	imshow(&quot;blur&quot;, blur);
	imshow(&quot;canny&quot;, canny);
	imshow(&quot;dil&quot;, dil);
	&#x2F;&#x2F;imshow(&quot;erode&quot;, erode);
	waitKey(0);

	Mat* work &#x3D; new Mat(dil);

	return *work;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们返回的就是经过预处理的图片了！下面开始重点讲轮廓！</p>
<p>​        我们的轮廓是用点来描述的，轮廓有若干层数，这就需要我们使用 vector<vector< int >&gt;</p>
<p>​        还有层级，这里我们使用 vector&lt; Vec4i &gt;来定义类型！它表明当前的每一个类型有四个整数构成，就不需要我们自己手动指定原生的C++类型了</p>
<p>​        这里是找到轮廓的函数</p>
<pre class="line-numbers language-none"><code class="language-none">findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
&#x2F;** @brief Finds contours in a binary image.

The function retrieves contours from the binary image using the algorithm @cite Suzuki85 . The contours
are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the
OpenCV sample directory.
@note Since opencv 3.2 source image is not modified by this function.

@param image Source, an 8-bit single-channel image. Non-zero pixels are treated as 1&#39;s. Zero
pixels remain 0&#39;s, so the image is treated as binary . You can use #compare, #inRange, #threshold ,
#adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one.
If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).
@param contours Detected contours. Each contour is stored as a vector of points (e.g.
std::vector&lt;std::vector&lt;cv::Point&gt; &gt;).
@param hierarchy Optional output vector (e.g. std::vector&lt;cv::Vec4i&gt;), containing information about the image topology. It has
as many elements as the number of contours. For each i-th contour contours[i], the elements
hierarchy[i][0] , hierarchy[i][1] , hierarchy[i][2] , and hierarchy[i][3] are set to 0-based indices
in contours of the next and previous contours at the same hierarchical level, the first child
contour and the parent contour, respectively. If for the contour i there are no next, previous,
parent, or nested contours, the corresponding elements of hierarchy[i] will be negative.
@param mode Contour retrieval mode, see #RetrievalModes
@param method Contour approximation method, see #ContourApproximationModes
@param offset Optional offset by which every contour point is shifted. This is useful if the
contours are extracted from the image ROI and then they should be analyzed in the whole image
context.
 *&#x2F;
CV_EXPORTS_W void findContours( InputArray image, OutputArrayOfArrays contours,
                              OutputArray hierarchy, int mode,
                              int method, Point offset &#x3D; Point());

&#x2F;** @overload *&#x2F;
CV_EXPORTS void findContours( InputArray image, OutputArrayOfArrays contours,
                              int mode, int method, Point offset &#x3D; Point());

&#x2F;** @example samples&#x2F;cpp&#x2F;squares.cpp
A program using pyramid scaling, Canny, contours and contour simplification to find
squares in a list of images (pic1-6.png). Returns sequence of squares detected on the image.
*&#x2F;

&#x2F;** @example samples&#x2F;tapi&#x2F;squares.cpp
A program using pyramid scaling, Canny, contours and contour simplification to find
squares in the input image.
*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这里是一些参数的文档</p>
<pre class="line-numbers language-none"><code class="language-none">enum RetrievalModes &#123;
    &#x2F;** retrieves only the extreme outer contours. It sets &#96;hierarchy[i][2]&#x3D;hierarchy[i][3]&#x3D;-1&#96; for
    all the contours. *&#x2F;
    RETR_EXTERNAL  &#x3D; 0,
    &#x2F;** retrieves all of the contours without establishing any hierarchical relationships. *&#x2F;
    RETR_LIST      &#x3D; 1,
    &#x2F;** retrieves all of the contours and organizes them into a two-level hierarchy. At the top
    level, there are external boundaries of the components. At the second level, there are
    boundaries of the holes. If there is another contour inside a hole of a connected component, it
    is still put at the top level. *&#x2F;
    RETR_CCOMP     &#x3D; 2,
    &#x2F;** retrieves all of the contours and reconstructs a full hierarchy of nested contours.*&#x2F;
    RETR_TREE      &#x3D; 3,
    RETR_FLOODFILL &#x3D; 4 &#x2F;&#x2F;!&lt;
&#125;;
enum ContourApproximationModes &#123;
    &#x2F;** stores absolutely all the contour points. That is, any 2 subsequent points (x1,y1) and
    (x2,y2) of the contour will be either horizontal, vertical or diagonal neighbors, that is,
    max(abs(x1-x2),abs(y2-y1))&#x3D;&#x3D;1. *&#x2F;
    CHAIN_APPROX_NONE      &#x3D; 1,
    &#x2F;** compresses horizontal, vertical, and diagonal segments and leaves only their end points.
    For example, an up-right rectangular contour is encoded with 4 points. *&#x2F;
    CHAIN_APPROX_SIMPLE    &#x3D; 2,
    &#x2F;** applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 *&#x2F;
    CHAIN_APPROX_TC89_L1   &#x3D; 3,
    &#x2F;** applies one of the flavors of the Teh-Chin chain approximation algorithm @cite TehChin89 *&#x2F;
    CHAIN_APPROX_TC89_KCOS &#x3D; 4
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        上面是一些具体的参数说明！</p>
<p>​        我们的findCountours 取到轮廓之后呢，就向我们传入空的轮廓和层级输入数据。随后，我们在 原图像（很重要，不要画在二值化后的图里去了！！！）绘制轮廓，这样就好了！</p>
<pre class="line-numbers language-none"><code class="language-none">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)
&#123;
	vector&lt;vector&lt;Point&gt;&gt; countours;
	vector&lt;Vec4i&gt; hierarchy;

	findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

	Mat* workMat &#x3D; new Mat(org);

	drawContours(*workMat, countours, -1, Scalar(255, 0, 0), 3);

	return *workMat;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426221756602.png?lastModify=1685936981" alt="image-20230426221756602"></p>
<p>​        但是一些原因我们的图片可能是有多个绘制的，他们是由图片的噪点 造成的，我们现在使用面积筛选法筛选！</p>
<pre class="line-numbers language-none"><code class="language-none">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)
&#123;
	vector&lt;vector&lt;Point&gt;&gt; countours;
	vector&lt;Vec4i&gt; hierarchy;

	findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

	Mat* workMat &#x3D; new Mat(org);

	

	for (int i &#x3D; 0; i &lt; countours.size(); i++) &#123;

		auto area &#x3D; contourArea(countours[i]);
		cout &lt;&lt; area &lt;&lt; endl;

		if (area &gt; 1000) &#123;


			drawContours(*workMat, countours, i, Scalar(255, 0, 0), 3);
		&#125;&#x2F;&#x2F; 第I个轮廓满足！

	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下面呢，我们使用矩形将找到的形状括起来！这就需要我们：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;** @brief Calculates a contour perimeter or a curve length.

The function computes a curve length or a closed contour perimeter.

@param curve Input vector of 2D points, stored in std::vector or Mat.
@param closed Flag indicating whether the curve is closed or not.
 *&#x2F;
CV_EXPORTS_W double arcLength( InputArray curve, bool closed );
double peri &#x3D; arcLength(countours[i], true);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        以及我们之后可能需要通过多少个角点来判定他们是什么，就需要我们：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;** @brief Approximates a polygonal curve(s) with the specified precision.

The function cv::approxPolyDP approximates a curve or a polygon with another curve&#x2F;polygon with less
vertices so that the distance between them is less or equal to the specified precision. It uses the
Douglas-Peucker algorithm &lt;http:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Ramer-Douglas-Peucker_algorithm&gt;

@param curve Input vector of a 2D point stored in std::vector or Mat
@param approxCurve Result of the approximation. The type should match the type of the input curve.
@param epsilon Parameter specifying the approximation accuracy. This is the maximum distance
between the original curve and its approximation.
@param closed If true, the approximated curve is closed (its first and last vertices are
connected). Otherwise, it is not closed.
 *&#x2F;
CV_EXPORTS_W void approxPolyDP( InputArray curve,
                                OutputArray approxCurve,
                                double epsilon, bool closed );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        为此，我们需要一个跟轮廓一个数据结构的大小来接受结果，随后用之来绘制轮廓，那就是：</p>
<pre class="line-numbers language-none"><code class="language-none">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)
&#123;
	vector&lt;vector&lt;Point&gt;&gt; countours;
	vector&lt;Vec4i&gt; hierarchy;

	findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

	Mat* workMat &#x3D; new Mat(org);

	vector&lt;vector&lt;Point&gt;&gt; conPoly(countours.size());

	for (int i &#x3D; 0; i &lt; countours.size(); i++) &#123;

		auto area &#x3D; contourArea(countours[i]);
		cout &lt;&lt; area &lt;&lt; endl;

		if (area &gt; 1000) &#123;

			double peri &#x3D; arcLength(countours[i], true);
			
			approxPolyDP(countours[i], conPoly[i], 0.02 * peri, true);

			drawContours(*workMat, conPoly, i, Scalar(255, 0, 0), 3);
		
		&#125;

	&#125;
	return *workMat;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426223109977.png?lastModify=1685936981" alt="image-20230426223109977"></p>
<p>​        而框住矩形是由给出：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;** @brief Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image.

The function calculates and returns the minimal up-right bounding rectangle for the specified point set or
non-zero pixels of gray-scale image.

@param array Input gray-scale image or 2D point set, stored in std::vector or Mat.
 *&#x2F;
CV_EXPORTS_W Rect boundingRect( InputArray array );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        函数每一次扫描ConPoly后返回最小矩形，我们用一个vector&lt; Rect &gt;接受就好了</p>
<pre class="line-numbers language-none"><code class="language-none">Mat&amp; receiveCountours(Mat&amp; afterPreWork,Mat&amp; org)
&#123;
	vector&lt;vector&lt;Point&gt;&gt; countours;
	vector&lt;Vec4i&gt; hierarchy;

	findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

	Mat* workMat &#x3D; new Mat(org);

	vector&lt;vector&lt;Point&gt;&gt; conPoly(countours.size());
	vector&lt;Rect&gt; boundRect(countours.size());
	for (int i &#x3D; 0; i &lt; countours.size(); i++) &#123;

		auto area &#x3D; contourArea(countours[i]);
		cout &lt;&lt; area &lt;&lt; endl;

		if (area &gt; 1000) &#123;

			double peri &#x3D; arcLength(countours[i], true);
			
			approxPolyDP(countours[i], conPoly[i], 0.02 * peri, true);


			boundRect[i]  &#x3D; boundingRect(conPoly[i]);

			drawContours(*workMat, conPoly, i, Scalar(255, 0, 0), 3);
			
			rectangle(*workMat, boundRect[i].tl(), boundRect[i].br(), Scalar(255, 0, 100),5);
		&#125;

	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230426223759367.png?lastModify=1685936981" alt="image-20230426223759367"></p>
<h1 id="Opencv-in-Visual-Studio-5"><a href="#Opencv-in-Visual-Studio-5" class="headerlink" title="Opencv in Visual Studio 5"></a>Opencv in Visual Studio 5</h1><h2 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h2><p>​        什么？自己写？有点蠢！我们来用以及训练好的数据就好了！</p>
<p>​        他在你的Opencv 的\opencv\build\etc下面，看到这个了嘛：</p>
<pre class="line-numbers language-none"><code class="language-none">haarcascade_frontalface_default.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        对，就是这个文件，拿过来用就好了！</p>
<p>​        下面开始使用它！，我们创建一个</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;** @example samples&#x2F;cpp&#x2F;facedetect.cpp
This program demonstrates usage of the Cascade classifier class
\image html Cascade_Classifier_Tutorial_Result_Haar.jpg &quot;Sample screenshot&quot; width&#x3D;321 height&#x3D;254
*&#x2F;
&#x2F;** @brief Cascade classifier class for object detection.
 *&#x2F;
class CV_EXPORTS_W CascadeClassifier
&#123;
public:
    CV_WRAP CascadeClassifier();
    &#x2F;** @brief Loads a classifier from a file.

    @param filename Name of the file from which the classifier is loaded.
     *&#x2F;
    CV_WRAP CascadeClassifier(const String&amp; filename); &#x2F;&#x2F; 使用这个API
    ~CascadeClassifier();
    &#x2F;** @brief Checks whether the classifier has been loaded.
    *&#x2F;
    CV_WRAP bool empty() const;
    &#x2F;** @brief Loads a classifier from a file.

    @param filename Name of the file from which the classifier is loaded. The file may contain an old
    HAAR classifier trained by the haartraining application or a new cascade classifier trained by the
    traincascade application.
     *&#x2F;
    CV_WRAP bool load( const String&amp; filename ); &#x2F;&#x2F; 使用这个API
    &#x2F;** @brief Reads a classifier from a FileStorage node.

    @note The file may contain a new cascade classifier (trained traincascade application) only.
     *&#x2F;
    CV_WRAP bool read( const FileNode&amp; node );

    &#x2F;** @brief Detects objects of different sizes in the input image. The detected objects are returned as a list
    of rectangles.

    @param image Matrix of the type CV_8U containing an image where objects are detected.
    @param objects Vector of rectangles where each rectangle contains the detected object, the
    rectangles may be partially outside the original image.
    @param scaleFactor Parameter specifying how much the image size is reduced at each image scale.
    @param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have
    to retain it.
    @param flags Parameter with the same meaning for an old cascade as in the function
    cvHaarDetectObjects. It is not used for a new cascade.
    @param minSize Minimum possible object size. Objects smaller than that are ignored.
    @param maxSize Maximum possible object size. Objects larger than that are ignored. If &#96;maxSize &#x3D;&#x3D; minSize&#96; model is evaluated on single scale.

    The function is parallelized with the TBB library.

    @note
       -   (Python) A face detection example using cascade classifiers can be found at
            opencv_source_code&#x2F;samples&#x2F;python&#x2F;facedetect.py
    *&#x2F;
    CV_WRAP void detectMultiScale( InputArray image,
                          CV_OUT std::vector&lt;Rect&gt;&amp; objects,
                          double scaleFactor &#x3D; 1.1,
                          int minNeighbors &#x3D; 3, int flags &#x3D; 0,
                          Size minSize &#x3D; Size(),
                          Size maxSize &#x3D; Size() );

    &#x2F;** @overload
    @param image Matrix of the type CV_8U containing an image where objects are detected.
    @param objects Vector of rectangles where each rectangle contains the detected object, the
    rectangles may be partially outside the original image.
    @param numDetections Vector of detection numbers for the corresponding objects. An object&#39;s number
    of detections is the number of neighboring positively classified rectangles that were joined
    together to form the object.
    @param scaleFactor Parameter specifying how much the image size is reduced at each image scale.
    @param minNeighbors Parameter specifying how many neighbors each candidate rectangle should have
    to retain it.
    @param flags Parameter with the same meaning for an old cascade as in the function
    cvHaarDetectObjects. It is not used for a new cascade.
    @param minSize Minimum possible object size. Objects smaller than that are ignored.
    @param maxSize Maximum possible object size. Objects larger than that are ignored. If &#96;maxSize &#x3D;&#x3D; minSize&#96; model is evaluated on single scale.
    *&#x2F;
    CV_WRAP_AS(detectMultiScale2) void detectMultiScale( InputArray image,
                          CV_OUT std::vector&lt;Rect&gt;&amp; objects,
                          CV_OUT std::vector&lt;int&gt;&amp; numDetections,
                          double scaleFactor&#x3D;1.1,
                          int minNeighbors&#x3D;3, int flags&#x3D;0,
                          Size minSize&#x3D;Size(),
                          Size maxSize&#x3D;Size() ); &#x2F;&#x2F; 使用这个API

    &#x2F;** @overload
    This function allows you to retrieve the final stage decision certainty of classification.
    For this, one needs to set &#96;outputRejectLevels&#96; on true and provide the &#96;rejectLevels&#96; and &#96;levelWeights&#96; parameter.
    For each resulting detection, &#96;levelWeights&#96; will then contain the certainty of classification at the final stage.
    This value can then be used to separate strong from weaker classifications.

    A code sample on how to use it efficiently can be found below:
    @code
    Mat img;
    vector&lt;double&gt; weights;
    vector&lt;int&gt; levels;
    vector&lt;Rect&gt; detections;
    CascadeClassifier model(&quot;&#x2F;path&#x2F;to&#x2F;your&#x2F;model.xml&quot;);
    model.detectMultiScale(img, detections, levels, weights, 1.1, 3, 0, Size(), Size(), true);
    cerr &lt;&lt; &quot;Detection &quot; &lt;&lt; detections[0] &lt;&lt; &quot; with weight &quot; &lt;&lt; weights[0] &lt;&lt; endl;
    @endcode
    *&#x2F;
    CV_WRAP_AS(detectMultiScale3) void detectMultiScale( InputArray image,
                                  CV_OUT std::vector&lt;Rect&gt;&amp; objects,
                                  CV_OUT std::vector&lt;int&gt;&amp; rejectLevels,
                                  CV_OUT std::vector&lt;double&gt;&amp; levelWeights,
                                  double scaleFactor &#x3D; 1.1,
                                  int minNeighbors &#x3D; 3, int flags &#x3D; 0,
                                  Size minSize &#x3D; Size(),
                                  Size maxSize &#x3D; Size(),
                                  bool outputRejectLevels &#x3D; false );

    CV_WRAP bool isOldFormatCascade() const;
    CV_WRAP Size getOriginalWindowSize() const;
    CV_WRAP int getFeatureType() const;
    void* getOldCascade();

    CV_WRAP static bool convert(const String&amp; oldcascade, const String&amp; newcascade);

    void setMaskGenerator(const Ptr&lt;BaseCascadeClassifier::MaskGenerator&gt;&amp; maskGenerator);
    Ptr&lt;BaseCascadeClassifier::MaskGenerator&gt; getMaskGenerator();

    Ptr&lt;BaseCascadeClassifier&gt; cc;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        看到我标注的地方，他们是这次我们要使用的API了！</p>
<p>​        老规矩：创建对象：加载模型，检查是否合法！</p>
<pre class="line-numbers language-none"><code class="language-none">CascadeClassifier faceCascade;

faceCascade.load(path);

if (faceCascade.empty()) &#123;
	return -1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下面，尝试预测！我们这次调用摄像头来干活！</p>
<pre class="line-numbers language-none"><code class="language-none">Mat img;
VideoCapture cap(0);
while (1) &#123;
	cap &gt;&gt; img;
	vector&lt;Rect&gt; face;
	faceCascade.detectMultiScale(img, face, 1.1, 10);
	for (int i &#x3D; 0; i &lt; face.size(); i++) &#123;

		rectangle(img, face[i].tl(), face[i].br(), Scalar(rand() % 		255, rand() % 255, rand() % 255), 3); &#x2F;&#x2F; 框出检测到的点

	&#125;


	imshow(&quot;hello&quot;, img);

	waitKey(1);
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        </p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230502215345298.png?lastModify=1685936981" alt="image-20230502215345298"></p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
using namespace cv;

string path &#x3D; &quot;D:\\My coding repositary\\learnopencv\\7\\source_file\\haarcascade_frontalface_default.xml&quot;;

int main()
&#123;
	srand((unsigned int)time(NULL));

	CascadeClassifier faceCascade;

	faceCascade.load(path);

	if (faceCascade.empty()) &#123;
		return -1;
	&#125;

	Mat img;
	VideoCapture cap(0);
	while (1) &#123;
		cap &gt;&gt; img;
		vector&lt;Rect&gt; face;
		faceCascade.detectMultiScale(img, face, 1.1, 10);
		for (int i &#x3D; 0; i &lt; face.size(); i++) &#123;

			rectangle(img, face[i].tl(), face[i].br(), Scalar(rand() % 255, rand() % 244, rand() % 255), 3);

		&#125;


		imshow(&quot;hello&quot;, img);

		waitKey(1);
	&#125;
	
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Pro-1-画笔画在屏幕上！"><a href="#Pro-1-画笔画在屏幕上！" class="headerlink" title="Pro 1: 画笔画在屏幕上！"></a>Pro 1: 画笔画在屏幕上！</h2><pre class="line-numbers language-none"><code class="language-none">#include&lt;opencv2&#x2F;opencv.hpp&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
using namespace std;
using namespace cv;

string path &#x3D; &quot;D:\\My coding repositary\\learnopencv\\7\\source_file\\haarcascade_frontalface_default.xml&quot;;
vector&lt;vector&lt;int&gt;&gt;myColors&#123; &#123;0,9,46,255,63,255&#125;,&#123;46,127,43,255,25,255&#125; &#125;;&#x2F;&#x2F; red blue 这里自己调一下罢，哥们开摆了
vector&lt;Scalar&gt; colorBGR&#123; &#123;255,0,0&#125; ,&#123;0,0,255&#125; &#125;;

vector&lt;vector&lt;int&gt;&gt; newPoints;
Point&amp; receiveCountours(Mat&amp; afterPreWork, Mat&amp; org)
&#123;
	vector&lt;vector&lt;Point&gt;&gt; countours;
	vector&lt;Vec4i&gt; hierarchy;
	
	findContours(afterPreWork, countours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

	Mat* workMat &#x3D; new Mat(org);

	vector&lt;vector&lt;Point&gt;&gt; conPoly(countours.size());
	vector&lt;Rect&gt; boundRect(countours.size());

	Point* mypoint &#x3D; new Point(0, 0);

	for (int i &#x3D; 0; i &lt; countours.size(); i++) &#123;

		auto area &#x3D; contourArea(countours[i]);
		&#x2F;&#x2F;cout &lt;&lt; area &lt;&lt; endl;

		if (area &gt; 6000) &#123;

			double peri &#x3D; arcLength(countours[i], true);

			approxPolyDP(countours[i], conPoly[i], 0.02 * peri, true);

			boundRect[i] &#x3D; boundingRect(conPoly[i]);

			&#x2F;&#x2F;drawContours(*workMat, conPoly, i, Scalar(255, 0, 0), 3);

			mypoint-&gt;x &#x3D; boundRect[i].x + boundRect[i].width &#x2F; 2;
			mypoint-&gt;y &#x3D; boundRect[i].y + boundRect[i].height &#x2F; 2;
			rectangle(*workMat, boundRect[i].tl(), boundRect[i].br(), Scalar(255, 0, 100), 5);

			
		&#125;

	&#125;
	
	return *mypoint;
&#125;


void drawThings(vector&lt;vector&lt;int&gt;&gt; points,Mat&amp; pic)
&#123;
	int v &#x3D; 1;


	for (int i &#x3D; 0; i &lt; points.size(); i++) &#123;

		if (points[i][2] &#x3D;&#x3D; 0) &#123;

			v &#x3D; 1;

		&#125;
		else
		&#123;
			v &#x3D; 0;
		&#125;

		circle(pic, Point(points[i][0], points[i][1]), 10, colorBGR[v], FILLED);

	&#125;
	


&#125;



void getColor(Mat&amp; pic)
&#123;
	Mat* org &#x3D; new Mat(pic);

	cvtColor(*org, *org, COLOR_BGR2HSV);
	GaussianBlur(*org, *org, Size(11,11), 5, 0);
	

	for (int i &#x3D; 0; i &lt; myColors.size(); i++) &#123;

		Scalar lower(myColors[i][0], myColors[i][2], myColors[i][4]);
		Scalar upper(myColors[i][1], myColors[i][3], myColors[i][5]);
		Mat mask;
		inRange(pic, lower, upper, mask);
		&#x2F;&#x2F;imshow(to_string(i), mask);
		Point p&#x3D; receiveCountours(mask, pic);
		if (p.x !&#x3D; 0 &amp;&amp; p.y !&#x3D; 0) &#123;
			vector&lt;int&gt; ve;
			ve.push_back(p.x);
			ve.push_back(p.y);
			ve.push_back(i);
			newPoints.push_back(ve);
		&#125;
	&#125;
	
&#125;





int main()
&#123;
	VideoCapture cap(0);
	Mat pic;
	while (1) &#123;

		cap.read(pic);
		getColor(pic);

		drawThings(newPoints, pic);

		imshow(&quot;p&quot;, pic);

		waitKey(1);

	&#125;
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        他们是前面的排列组合！这里不做太多的说明！</p>
<h1 id="QT开发入门"><a href="#QT开发入门" class="headerlink" title="QT开发入门"></a>QT开发入门</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>​    注意创建工程路径的时候不要不要不要整到含有中文的路径！</p>
<p>​        我们下载了 QT 之后，创建信息之后，会发现有三个类：</p>
<p>1）QWeidge 作为父类</p>
<p>2）QMainWindows子类</p>
<p>3）QDialog子类</p>
<p>2，3是1的子类</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230228192413374.png?lastModify=1685936981" alt="image-20230228192413374"></p>
<p>​        可以看到，有一个.pro文件，跟VS文件是一样的，他是一个工程文件！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230228192501749.png?lastModify=1685936981" alt="image-20230228192501749"></p>
<p>​        这是一个工程的目录</p>
<p>​        先看主要的显示文件：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;widget.h&quot;
#include &lt;QApplication&gt; &#x2F;&#x2F; 包含一个应用程序类的文件

&#x2F;&#x2F;argc 命令行变量的数量， *argv[] 是命令行变量的数组
int main(int argc, char *argv[])
&#123;
    &#x2F;&#x2F;应用程序对象，再QT中方，应用程序对像只有一个
    QApplication a(argc, argv);
    
    &#x2F;&#x2F;窗口对象， widget- 父类 -&gt; QWedget
    Widget w;
    &#x2F;&#x2F; 显示窗口
    w.show();

    &#x2F;&#x2F; 让应用程序对象进入消息循环
    return a.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个循环可以被类比成如下的C程序：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;conio.h&gt;
int main()
&#123;
	while(_get() &#x3D;&#x3D; &#39; &#39;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这里，是点击窗口’ X ‘来关闭！</p>
<h2 id="看看工程文件"><a href="#看看工程文件" class="headerlink" title="看看工程文件"></a>看看工程文件</h2><p>​        工程文件自身可以在QT里打开：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230228193538543.png?lastModify=1685936981" alt="image-20230228193538543"></p>
<p>​        点击 1.pro 文件，可以看到如下的内容</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230228193615493.png?lastModify=1685936981" alt="image-20230228193615493"></p>
<pre class="line-numbers language-none"><code class="language-none">#-------------------------------------------------
# &#x2F;&#x2F;工程创建时间
# Project created by QtCreator 2023-02-28T19:15:11
#
#-------------------------------------------------

QT       +&#x3D; core gui &#x2F;&#x2F; 包含的模块（1）

greaterThan(QT_MAJOR_VERSION, 4): QT +&#x3D; widgets &#x2F;&#x2F; 大于这个版本才添加模块

TARGET &#x3D; 1 &#x2F;&#x2F; 目标 生成的.exe文件的名字（2）不满意名字可以自行更换
TEMPLATE &#x3D; app &#x2F;&#x2F;模板

# The following define makes your compiler emit warnings if you use
# any feature of Qt which as been marked as deprecated (the exact warnings
# depend on your compiler). Please consult the documentation of the
# deprecated API in order to know how to port your code away from it.
DEFINES +&#x3D; QT_DEPRECATED_WARNINGS

# You can also make your code fail to compile if you use deprecated APIs.
# In order to do so, uncomment the following line.
# You can also select to disable deprecated APIs only up to a certain version of Qt.
#DEFINES +&#x3D; QT_DISABLE_DEPRECATED_BEFORE&#x3D;0x060000    # disables all the APIs deprecated before Qt 6.0.0


SOURCES +&#x3D; \
        main.cpp \ &#x2F;&#x2F;源文件
        widget.cpp

HEADERS +&#x3D; \
        widget.h &#x2F;&#x2F; 头文件

FORMS +&#x3D; \
        widget.ui<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（1）：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230228193822499.png?lastModify=1685936981" alt="image-20230228193822499"></p>
<p>（2）那个exe文件在这里：打开你的工程目录，返回上级会发现：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230228194240791.png?lastModify=1685936981" alt="image-20230228194240791"></p>
<p>点击下面的文件夹</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230228194256086.png?lastModify=1685936981" alt="image-20230228194256086"></p>
<p>点击 debug</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230228194315627.png?lastModify=1685936981" alt="image-20230228194315627"></p>
<p>就在这里的 1.exe</p>
<h2 id="看看头文件和widget-cpp"><a href="#看看头文件和widget-cpp" class="headerlink" title="看看头文件和widget.cpp"></a>看看头文件和widget.cpp</h2><pre class="line-numbers language-none"><code class="language-none">#ifndef WIDGET_H
#define WIDGET_H

#include &lt;QWidget&gt;

namespace Ui &#123;
class Widget;
&#125;

class Widget : public QWidget
&#123;
    Q_OBJECT &#x2F;&#x2F; 允许类中使用信号和槽的宏，不要轻易改动

public:
    explicit Widget(QWidget *parent &#x3D; 0);&#x2F;&#x2F; 默认构造函数
    ~Widget();

private:
    Ui::Widget *ui;
&#125;;

#endif &#x2F;&#x2F; WIDGET_H
#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>​        类名：首字母大写，单词与单词之间首字母大写</p>
<p>​        函数名，变量名称：首字母小写，但单词与单词之间首字母大写</p>
<p>​        快捷键一览：</p>
<p>​        注释：ctrl + /</p>
<p>​        运行：ctrl + r</p>
<p>​        编译：ctrl + b</p>
<p>​        查找：ctrl + f</p>
<p>​        整行移动：ctrl + shift + ↑ 或者 ↓</p>
<p>​        自动对齐：ctrl + i</p>
<p>​        同名的.cpp 和 .h: F4</p>
<h2 id="创建一个按钮"><a href="#创建一个按钮" class="headerlink" title="创建一个按钮"></a>创建一个按钮</h2><p>​        我们查询帮助文档，得到这些信息</p>
<pre class="line-numbers language-none"><code class="language-none">QPushButton Class
The QPushButton widget provides a command button. More...

Header:
#include &lt;QPushButton&gt; 
qmake:
QT +&#x3D; widgets
Inherits:
QAbstractButton
Inherited By:
QCommandLinkButton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        当然要留意是什么模块，如果 pro 文件里没有，那需要我们手动添加，在</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230301221926786.png?lastModify=1685936981" alt="image-20230301221926786"></p>
<p>​        的QT += 处 添加模块。</p>
<p>​        当然可以看看函数的功能</p>
<pre class="line-numbers language-none"><code class="language-none">QPushButton(QWidget *parent &#x3D; Q_NULLPTR)

QPushButton(const QString &amp;text, QWidget *parent &#x3D; Q_NULLPTR)

QPushButton(const QIcon &amp;icon, const QString &amp;text, QWidget *parent &#x3D; Q_NULLPTR)

~QPushButton()

bool 
autoDefault() const

bool 
isDefault() const

bool 
isFlat() const

QMenu *
menu() const

void 
setAutoDefault(bool)

void 
setDefault(bool)

void 
setFlat(bool)

void 
setMenu(QMenu *menu)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        于是可以在 widget.cpp 中书写如下代码：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;widget.h&quot;
#include&lt;QPushButton&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    QPushButton* btn &#x3D; new QPushButton;
    btn-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点

    btn-&gt;setText(&quot;hello world&quot;);
&#125;

Widget::~Widget()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230301222534315.png?lastModify=1685936981" alt="image-20230301222534315"></p>
<p>​        如果我们重新设置一下窗口大小，那就</p>
<pre class="line-numbers language-none"><code class="language-none">resize(int Height,int Width);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        但是如果我们直接创建第二个按钮，那就会覆盖第一个，那怎么办？使用 move 方法！</p>
<pre class="line-numbers language-none"><code class="language-none">btn-&gt;move(int x_pos,int y_pos)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当然啊，我们可以设置窗口的名字：</p>
<pre class="line-numbers language-none"><code class="language-none">setWindowTitle(&quot;My first windows&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        以及可以固定窗口大小：</p>
<pre class="line-numbers language-none"><code class="language-none">setFixedSize(int Height,int Width)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230301223238957.png?lastModify=1685936981" alt="image-20230301223238957"></p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;widget.h&quot;
#include&lt;QPushButton&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    QPushButton* btn &#x3D; new QPushButton;
    btn-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点

    btn-&gt;setText(&quot;hello world&quot;);
    QPushButton* btn2 &#x3D; new QPushButton;
    btn2-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点
    btn2-&gt;move(100,100);
    setWindowTitle(&quot;My first Window&quot;);
    resize(600,400);
    setFixedSize(600,400);
&#125;

Widget::~Widget()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h1 id="5-1-按钮类的控件"><a href="#5-1-按钮类的控件" class="headerlink" title="5.1 按钮类的控件"></a>5.1 按钮类的控件</h1><p>本节介绍图形程序里常见的按钮，包括普通的按钮按钮，之前都用过多次了，还有<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=单选按钮&amp;spm=1001.2101.3001.7020">单选按钮</a>、复选框、命令链接按钮等。本节安排两个简单例子，第一个例子是普通的按压按 钮和单选按钮使用示范，第二个例子主要是复选框和命令链接按钮使用示范。</p>
<p>按钮<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=类继承&amp;spm=1001.2101.3001.7020">类继承</a>关系：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/2954060946014d6fb9367364d3259ecb.png?lastModify=1685936981" alt="img"></p>
<h2 id="5-1-1-按钮概述"><a href="#5-1-1-按钮概述" class="headerlink" title="5.1.1 按钮概述"></a>5.1.1 按钮概述</h2><p>我们在 Qt 设计师或 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QtCreator&amp;spm=1001.2101.3001.7020">QtCreator</a> 的设计界面编辑 ui 文件时，可以看到 Buttons 分类的按钮控件：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/4d2b19266e71b127c369eeb48e739604.png?lastModify=1685936981" alt="img"></p>
<p>逐个解释一下各个用途： <strong>（1）按压按钮 QPushButton</strong> 最基本的按钮，点击该按钮通常是通知程序进行一个操作，比如弹个窗、下一步、保存、退出等等，这是经常用到的，操作系统里的对话框里几乎全部都有这种按压按 钮，5.1.2 节详细讲解按压按钮。</p>
<p><strong>（2）工具按钮 QToolButton</strong> 工具按钮通常都不是一个，是一排放置在工具栏 QToolBar 里面，作为快捷按钮来用，比如 Qt 设计师的工具栏：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/19cc6a5980499be654dc6622203be1ae.png?lastModify=1685936981" alt="img"></p>
<p>工具按钮暂时不讲，等到后面讲带有菜单和工具栏的程序一块讲。</p>
<p><strong>（3）单选按钮 QRadioButton</strong> 单选按钮通常是多个放在一块，表示互斥的一组选项，只能选择其中一个来填写，比如一个人性别有男、女，只能选择一个，而不能同时是男的又是女的，5.1.3 节详 细讲解单选按钮。</p>
<p><strong>（4）复选框 QCheckBox</strong> 与单选按钮不同，复选框通常表示多个可以同时存在的选项，比如一个人可以同时多个爱好，比如读书、看电影、爬山、游泳等，5.1.4 节介绍复选框。</p>
<p><strong>（5）命令链接按钮 QCommandLinkButton</strong> 这是 Qt 仿造 Vista 里的命令链接按钮引入的扁平风格按钮，点击这个按钮一般意味着打开新的功能窗口或网站链接等，5.1.5 节介绍这个命令链接按钮。</p>
<p><strong>（6）标准按钮盒 QDialogButtonBox</strong> 标准按钮盒通常用于对话框程序，举例来说，我们常见的保存询问对话框里面有“保存”、“丢弃”、“取消”三个标准按钮，确认对话框有 “OK”“Cancel”等标准按钮，Qt 将这些典型的按钮做成标准按钮盒，并将相应的信号加以封装，方便程序员使用。这个标准按钮盒等到对话框相关章节再详细 介绍，这里只贴张图尝鲜看看：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/3ac396b1f13368c4b70cfdce851b765a.png?lastModify=1685936981" alt="img"></p>
<h2 id="5-1-2-QPushButton"><a href="#5-1-2-QPushButton" class="headerlink" title="5.1.2 QPushButton"></a>5.1.2 QPushButton</h2><p>按压按钮 QPushButton 我们之前用过多次了，点击之后弹出个消息框，打印调试信息等。QPushButton 常用的构造函数有两个：</p>
<pre class="line-numbers language-none"><code class="language-none">QPushButton::QPushButton(const QString &amp; text, QWidget * parent &#x3D; 0)
QPushButton::QPushButton(const QIcon &amp; icon, const QString &amp; text, QWidget * parent &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一个构造函数有两个参数 text 是按钮显示的文本，第二个 parent 是父窗口指针。 第二个构造函数多了参数 icon，表示按钮图标，图标意味着有相关的图片资源，本章 5.6 节介绍使用自定义的图片作为按钮图标。</p>
<p>除了可以在构造函数里指定文本和图标，QPushButton 类还有对应的 get/set 函数，获取和设置文本的函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QString    text() const
void    setText(const QString &amp; text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>获取和设置图标的函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QIcon    icon() const
void    setIcon(const QIcon &amp; icon)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>QPushButton 类另外有一种特殊用途，可以为按钮添加菜单，类似 Qt 设计师编辑样式表对话框里的：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/892299bb332da5718ab16cdcd0a6c58b.png?lastModify=1685936981" alt="img"></p>
<p>带菜单的按钮等到菜单相关章节再讲解，不能一口吃成胖子，本节我们先用简单的按钮。</p>
<p>按压按钮被点击之后会触发 clicked 信号：</p>
<pre class="line-numbers language-none"><code class="language-none">void QAbstractButton::clicked(bool checked &#x3D; false)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong><strong>QAbstractButton 是各种按钮类的抽象基类，QPushButton 从这个基类继承了点击按钮的信号 clicked。\</strong></strong> 按压按钮一般不会用到 checked 参数，因为按压按钮一般按下去就自动弹起来，没有两种状态。而下面的单选按钮和复选框默认都是有两种状态的，被选中和没被选中。下面来看看单选按钮和本节第一个例子。</p>
<h2 id="5-1-3-QRadioButton"><a href="#5-1-3-QRadioButton" class="headerlink" title="5.1.3 QRadioButton"></a>5.1.3 QRadioButton</h2><p>单选按钮通常用于从一组选项里面选择一个，各个选项之间是互斥的，因此名字叫“单选按钮”。单选按钮的构造函数是比较简单的：</p>
<pre class="line-numbers language-none"><code class="language-none">QRadioButton::QRadioButton(const QString &amp; text, QWidget * parent &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>text 是显示的文本，parent 是父窗口。文本操作也有类似的 text() 和 setText() 函数，不赘述了。</p>
<p>单选按钮有选中和非选中两种状态，获取当前状态通过函数：</p>
<pre class="line-numbers language-none"><code class="language-none">bool isChecked() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果希望通过代码来改变单选按钮的状态，可以用如下函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void setChecked(bool)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在一个窗体里面，<strong>默认所有的单选按钮都是互斥的</strong>，然而我们单选按钮可能有多种用途，比如两个单选按钮表示性别选择，四个单选按钮表示年龄段选择。不同用途的单选按 钮需要进行分组管理，常见的手段有两种，<strong>一种是在图形界面放置一个分组框 Group Box，将同组的几个单选按钮塞到分组框里面；另一种是手动编写代码，将单选按钮添加到虚拟的管理组 QButtonGroup 实例里面</strong>，后面我们会在例子里给出两种用法的代码。</p>
<p>因为单选按钮的工作原理与按压按钮不一样，多个按压按钮之间通常互不影响，但是同组的单选按钮，一旦点击一个，其他的都是非选中状态。因此单选按钮通常使用 <strong>t\</strong>o*<em>ggled()*</em> 信号，无论单选按钮是变成选中状态（该按钮被点击）或非选中状态（同组其他按钮被点击），只要单选按钮的状态发生变化，这个信号就会触发：</p>
<pre class="line-numbers language-none"><code class="language-none">void    toggled(bool checked)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>参数里 checked 表示<strong><strong>新的选中或非选中状态\</strong></strong>，当然，还可以利用公开函数 isChecked() 获取是否处于选中状态。</p>
<p>对于使用 QButtonGroup 实例管理的多个单选按钮，还有一个好处是可以进行数值映射，不需要给每一个单选按钮都配备槽函数，而只需要根据 QButtonGroup 实例发出的 buttonClicked() 信号来统一处理整组的单选按钮，向 QButtonGroup 实例添加按钮的函数为：</p>
<pre class="line-numbers language-none"><code class="language-none">void QButtonGroup::addButton(QAbstractButton * button, int id &#x3D; -1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可以为每个单选按钮设置唯一的 id （不要用负数，<strong><strong>-1 是不设置序号的意思\</strong></strong>），然后QButtonGroup 分组里的任意一个单选按钮被点击时，都会触发信号：</p>
<pre class="line-numbers language-none"><code class="language-none">void QButtonGroup::buttonClicked(int id)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>根据参数里的 id 就可以判断是哪个单选按钮被点击了。</p>
<p>下面来动手编写本节第一个例子，打开 QtCreator，新建一个 Qt Widgets Application 项目，在新建项目的向导里填写： ①项目名称 singleselection，创建路径 D:\QtProjects\ch05，点击下一步； ②套件选择里面选择全部套件，点击下一步； ③基类选择 QWidget，点击下一步； ④项目管理不修改，点击完成。 建好项目之后，打开窗体 widget.ui 文件，进入设计模式，按照下图排布先拖入两个标签控件和五个单选按钮：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/8ca1be4400d4f67a4ce6ecff85bba81d.png?lastModify=1685936981" alt="img"></p>
<p>按照图上显示的文本修改控件 text 属性，并修改单选按钮的 objectName ： 第一排单选按钮对象名称分别为 radioButtonMan 和 radioButtonWoman； 第二排单选按钮对象名称分别为 radioButtonBang、radioButtonMeng 和 radioButtonYao。 因为控件比较多，注意控件水平方向和垂直方向的对齐，可以手动拖拽控件或者选中控件然后按方向键调整各个控件位置，尽量像上图一样对齐。 如果选择控件，然后按键盘上的方向键，那么默认以 10 像素移动，对齐到 整十 的点阵格子里面，所以控件是比较好对齐的。正式的程序里面要么手动调整控件位置 对齐，或者用下一章的布局控件。我们这里先手动对齐。 这两组单选按钮将在代码里通过虚拟按钮组 QButtonGroup 来管理。</p>
<p>然后再向窗体里面拖入一个 Group Box 控件和一个按压按钮，调整它们的位置和大小，按压按钮放在主窗体最下方，按压按钮文本显示为“弹窗显示”，中间的大部分区域都归分组框。 这个分组框会在窗体里显示出来，是实际能看到的控件，而虚拟按钮组 QButtonGroup 只存在于内存，是没有界面的。 拖入分组框之后，再向分组框内部拖入四个单选按钮，如下图所示：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/0a6d103f205aa4f8a34c947e4056c7cd.png?lastModify=1685936981" alt="img"></p>
<p>分组框的文本不是通过 text 属性，而是 title 属性来设置分组框的标题文本，按上图将分组框标题文本设置为“年龄段”，将分组框位置和大小调整一下，方便放置内部的单选按钮。分组框除了标题文本，它自动绘制自己的边框 线，就是上图分组框的四个边界线。 分组框内部的四个单选按钮文本按上图设置，四个单选按钮 objectName 分别为 radioButton0to19、radioButton20to39、radioButton40to59 和 radioButton60to 。尽量让四个单选按钮水平和垂直方向都对齐，这样界面看起来整洁一些。</p>
<p>然后就可以通过 QtCreator 菜单“工具”—&gt;“Form Editor”—&gt;“预览…”，或者按快捷键 Alt+Shift+R 预览窗体效果，预览时点击各个单选按钮，可以发现头两排按钮只能选中一个，下面分组框里可以选中一个：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/2d8c1cbef125f6b3d2d8ad1330820ed3.png?lastModify=1685936981" alt="img"></p>
<p>头两排单选按钮父窗口都是主窗体，默认情况下是互斥的，所以只能选中一个。而分组框里的单选按钮，它们的父窗口是分组框控件，所以与上面两排的不冲突。下面我们开 始编写代码，调整上面两排单选按钮的分组。 保存修改后的界面文件，回到代码编辑模式，打开 widget.h 文件，添加虚拟分组指针和两个槽函数：</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef WIDGET_H
#define WIDGET_H
#include &lt;QWidget&gt;
#include &lt;QButtonGroup&gt; &#x2F;&#x2F;按钮分组类头文件
namespace Ui &#123;
class Widget;
&#125;
class Widget : public QWidget
&#123;
    Q_OBJECT
public:
    explicit Widget(QWidget *parent &#x3D; 0);
    ~Widget();
public slots:
    void RecvGenderID(int id); &#x2F;&#x2F;接收性别单选按钮分组信号
    void RecvStatusID(int id); &#x2F;&#x2F;接收状态单选按钮分组信号
private:
	Ui::Widget *ui;
    &#x2F;&#x2F;按钮分组
    QButtonGroup *m_pGenderGroup;   &#x2F;&#x2F;性别单选按钮分组
    QButtonGroup *m_pStatusGroup;   &#x2F;&#x2F;状态单选按钮分组
&#125;;
#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>头文件编辑好之后，下面编辑 widget.cpp 文件，添加两个虚拟分组的代码，并关联它们对应的槽函数：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include &lt;QDebug&gt;               &#x2F;&#x2F;调试输出类
#include &lt;QMessageBox&gt;		&#x2F;&#x2F;消息框类
Widget::Widget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);
    &#x2F;&#x2F;新建性别虚拟分组，并添加按钮和id
    m_pGenderGroup &#x3D; new QButtonGroup(this);
    m_pGenderGroup-&gt;addButton(ui-&gt;radioButtonMan, 0);   &#x2F;&#x2F;男
    m_pGenderGroup-&gt;addButton(ui-&gt;radioButtonWoman, 1); &#x2F;&#x2F;女
    &#x2F;&#x2F;新建状态虚拟分组，并添加按钮和id
	m_pStatusGroup &#x3D; new QButtonGroup(this);
    &#x2F;&#x2F;不同分组的 id 是无关的，不冲突
    m_pStatusGroup-&gt;addButton(ui-&gt;radioButtonBang, 0);  &#x2F;&#x2F;棒棒哒
    m_pStatusGroup-&gt;addButton(ui-&gt;radioButtonMeng, 1);  &#x2F;&#x2F;萌萌哒
    m_pStatusGroup-&gt;addButton(ui-&gt;radioButtonYao, 2);   &#x2F;&#x2F;该吃药了
    &#x2F;&#x2F;关联两个分组的信号和槽
    connect(m_pGenderGroup, SIGNAL(buttonClicked(int)), this, SLOT(RecvGenderID(int)));
    connect(m_pStatusGroup, SIGNAL(buttonClicked(int)), this, SLOT(RecvStatusID(int)));
&#125;
Widget::~Widget()
&#123;
    delete ui;
&#125;
&#x2F;&#x2F;接收性别分组的id
void Widget::RecvGenderID(int id)
&#123;
    switch (id) &#123;
    case 0:
        qDebug()&lt;&lt;tr(&quot;性别：男&quot;);
        break;
    case 1:
        qDebug()&lt;&lt;tr(&quot;性别：女&quot;);
        break;
    default:
        break;
    &#125;
&#125;
&#x2F;&#x2F;接收状态分组的id
void Widget::RecvStatusID(int id)
&#123;
    switch (id) &#123;
    case 0:
        qDebug()&lt;&lt;tr(&quot;状态：棒棒哒&quot;);
	break;
    case 1:
        qDebug()&lt;&lt;tr(&quot;状态：萌萌哒&quot;);
        break;
    case 2:
        qDebug()&lt;&lt;tr(&quot;状态：该吃药了&quot;);
		 break;
    default:
        break;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在构造函数里，首先新建了 m_pGenderGroup 分组，然后将 ui-&gt;radioButtonMan 作为序号 0 添加到该分组，将ui-&gt;radioButtonWoman 作为序号 1 添加到该分组。 接下来新建了第二个 m_pStatusGroup 分组，将 ui-&gt;radioButtonBang 作为序号 0 添加到该分组，不同分组之间的 id 没有关系，所以这里序号也是以 0 打头，然后将 ui-&gt;radioButtonMeng 作为序号 1 添加到该分组，将 ui-&gt;radioButtonYao 作为序号 2 添加到该分组。</p>
<p>​        两个分组建立之后，将各组的 buttonClicked(int) 信号分别关联到对应的 RecvGenderID(int) 槽函数和 RecvStatusID(int) 槽函数。</p>
<p>​        这两个槽函数的内容就是打印调试输出，RecvGenderID(）函数内部就是根据参数 id 打印相应的性别信息，注意 switch-case 代码里，每一个 case 末尾都要加 break 跳出，否则后面的 case 会继续执行。RecvStatusID() 也是根据参数里的 id，打印状态信息。这样例子的前半部分代码就完成了。这时候可以生成运行例子试试看，先不截图了，下面进行分组框里面单选按钮部分的编程。</p>
<p>​        再打开 widget.ui 界面文件，进入设计模式，我们从图形界面为分组框里的单选按钮添加槽函数，右击分组框里的单选按钮，右键菜单里选择“转到槽…”：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/05183b942bca17390e0737161c180c5e.png?lastModify=1685936981" alt="img"></p>
<p>​        选择信号 toggled(bool) ，点击下面的 OK 按钮，然后就为分组框里面第一个按钮生成了槽函数 void on_radioButton0to19_toggled(bool checked); 为剩下三个单选按钮都如法炮制，添加 信号 toggled(bool) 对应的槽函数。</p>
<p>​        最后再为下面的 “弹窗显示” 按压按钮添加 clicked() 信号对应的槽函数，按压按钮的槽函数等会留着用。 如上添加四个单选按钮对应的槽函数和按压按钮的槽函数之后，现在完整的 widget.h 头文件内容如下：</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef WIDGET_H
#define WIDGET_H
#include &lt;QWidget&gt;
#include &lt;QButtonGroup&gt; &#x2F;&#x2F;按钮分组类头文件

namespace Ui &#123;
class Widget;
&#125;
class Widget : public QWidget
&#123;
    Q_OBJECT
public:
    explicit Widget(QWidget *parent &#x3D; 0);
    ~Widget();
public slots:
    void RecvGenderID(int id); &#x2F;&#x2F;接收性别单选按钮分组信号
    void RecvStatusID(int id); &#x2F;&#x2F;接收状态单选按钮分组信号
private slots:
    void on_radioButton0to19_toggled(bool checked);
    void on_radioButton20to39_toggled(bool checked);
    void on_radioButton40to59_toggled(bool checked);
    void on_radioButton60to_toggled(bool checked);
    void on_pushButton_clicked();
private:
	Ui::Widget *ui;
    &#x2F;&#x2F;按钮分组
    QButtonGroup *m_pGenderGroup;   &#x2F;&#x2F;性别单选按钮分组
    QButtonGroup *m_pStatusGroup;   &#x2F;&#x2F;状态单选按钮分组
&#125;;
#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>头文件现在内容完整了，我们先编辑 widget.cpp 里面四个年龄段单选按钮对应的槽函数，根据参数里 bool 变量打印不同信息：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;年龄段 0-19
void Widget::on_radioButton0to19_toggled(bool checked)
&#123;
    if(checked)
    &#123;
        qDebug()&lt;&lt;tr(&quot;年龄段：0-19&quot;);
    &#125;
    else
    &#123;
        qDebug()&lt;&lt;tr(&quot;不是 0-19&quot;);
    &#125;
&#125;
&#x2F;&#x2F;年龄段 20-39
void Widget::on_radioButton20to39_toggled(bool checked)
&#123;
    if(checked)
    &#123;
        qDebug()&lt;&lt;tr(&quot;年龄段：20-39&quot;);
    &#125;
    else&#123;   
        qDebug()&lt;&lt;tr(&quot;不是 20-39&quot;);
    &#125;
&#125;
&#x2F;&#x2F;年龄段 40-59
void Widget::on_radioButton40to59_toggled(bool checked)
&#123;
   if(checked)
    &#123;
        qDebug()&lt;&lt;tr(&quot;年龄段：40-59&quot;);
    &#125;
    else
    &#123;
        qDebug()&lt;&lt;tr(&quot;不是 40-59&quot;);
    &#125;
&#125;
&#x2F;&#x2F;年龄段 60 以上
void Widget::on_radioButton60to_toggled(bool checked)
&#123;
    if(checked)
    &#123;
		 qDebug()&lt;&lt;tr(&quot;年龄段：60 以上&quot;);
    &#125;
    else
    &#123;
        qDebug()&lt;&lt;tr(&quot;不是 60 以上&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意，<strong><strong>每次点击分组框里一个新的单选按钮，那么旧的按钮从选中变为非选中状态，会发出 toggled() 信号，参数值是 false；而新的单选按钮会从非选中状态变成选中状态，也会发出 toggled() 信号，参数值是 true。\</strong></strong>其他的两个状态不变，一直是非选中状态的单选按钮不会发信号，这点需要留心，等会运行会看到实际效果。</p>
<p>​        关于单选按钮配套的槽函数都编辑好了，从单选按钮对应的槽函数参数里，可以知道单选按钮的新状态。但是如果在其他函数里，如何获知各个单选按钮的状态呢？我们从按压按钮的槽函数代码里，获取单选按钮的状态，并弹窗显示信息：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;在单选按钮信号对应的槽函数之外，来获取单选按钮的状态
void Widget::on_pushButton_clicked()
&#123;
    &#x2F;&#x2F;结果字符串
    QString strResult;
    &#x2F;&#x2F;性别分组
    int nGenderID &#x3D; m_pGenderGroup-&gt;checkedId();    &#x2F;&#x2F;获取被选中的 id

    switch (nGenderID) &#123;
    case 0:
        strResult +&#x3D; tr(&quot;性别：男\r\n&quot;);
        break;
    case 1:
        strResult +&#x3D; tr(&quot;性别：女\r\n&quot;);
        break;
    default:
        strResult +&#x3D; tr(&quot;性别：未选中\r\n&quot;);
        break;
    &#125;
    &#x2F;&#x2F;状态分组
    int nStatusID &#x3D; m_pStatusGroup-&gt;checkedId();    &#x2F;&#x2F;获取被选中的 id
    switch (nStatusID) &#123;
    case 0:
        strResult +&#x3D; tr(&quot;状态：棒棒哒\r\n&quot;);
        break;
    case 1:
        strResult +&#x3D; tr(&quot;状态：萌萌哒\r\n&quot;);
        break;
    case 2:
        strResult +&#x3D; tr(&quot;状态：该吃药了\r\n&quot;);
     	break;
    default:
        strResult +&#x3D; tr(&quot;状态：未选中\r\n&quot;);
        break;
    &#125;
    &#x2F;&#x2F;年龄段四个按钮判断
    if( ui-&gt;radioButton0to19-&gt;isChecked() )
    &#123;
        strResult +&#x3D; tr(&quot;年龄段：0-19\r\n&quot;);
    &#125;
    else if( ui-&gt;radioButton20to39-&gt;isChecked() )
    &#123;
        strResult +&#x3D; tr(&quot;年龄段：20-39\r\n&quot;);
    &#125;
    else if( ui-&gt;radioButton40to59-&gt;isChecked() )
    &#123;
        strResult +&#x3D; tr(&quot;年龄段：40-59\r\n&quot;);
    &#125;
    else if( ui-&gt;radioButton60to-&gt;isChecked() )
    &#123;
        strResult +&#x3D; tr(&quot;年龄段：60 以上\r\n&quot;);
    &#125;
    else
    &#123;
  strResult +&#x3D; tr(&quot;年龄段：未选中\r\n&quot;);
    &#125;
    &#x2F;&#x2F;strResult 获取信息完毕，弹窗显示
    QMessageBox::information(this, tr(&quot;综合信息&quot;), strResult);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于虚拟分组里的按钮，可以用类似 m_pGenderGroup-&gt;checkedId() 获取处于选中状态的单选按钮序号，然后根据序号来确定不同的信息显示。QString 类的 += 运算符就是字符串追加的意思，字符串里结尾的 “\r\n” 是回车换行两个字符，用于字符串分行显示。 对于状态分组的单选按钮也是类似的处理方法，根据组内序号为 strResult 追加字符串。 而年龄段的四个单选按钮，没有虚拟分组，仅仅是作为分组框的子控件存在，默认互斥。要判断它们的选中状态就得一个个地调用它们的 isChecked() 函数判断是否处于选中状态，然后根据选中状态追加相应的字符串到结果 strResult 里面。</p>
<p>所有单选按钮代表的信息都处理之后，通过 QMessageBox::information() 函数弹窗显示综合信息。</p>
<p>下面我们来生成并运行这个例子，首先一个单选按钮都不点击，直接点最下面的“弹窗显示”按钮：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/a618f022701ef78f267149eeaa8f4013.png?lastModify=1685936981" alt="img"></p>
<p>代码里面没有设置三个组选中的初始按钮，所有单选按钮默认是非选中状态，所以弹窗显示都是未选中。 点击消息框的 “OK” 按钮关闭消息框。 然后我们分别点击三个组的第一个单选按钮，然后点击下方的“弹窗显示”，运行结果变为：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/1c9e7788007771ede100fe210058cdbd.png?lastModify=1685936981" alt="img"></p>
<p>头两个组的信号触发比较好理解，来看第三个组，因为只有 ui-&gt;radioButton0to19 状态发生变化，从未选中变成选中，所以只有一个信号。 点击消息框的 “OK” 按钮关闭消息框。 然后我们依次点击三个组的第二个单选按钮，然后再点击下方的“弹窗显示”按钮，结果如下：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/9ef075d9bc9d4fcf164f834c3bd431f6.png?lastModify=1685936981" alt="img"></p>
<p>头两组的信号还是比较清楚，都各自打印一个。 而第三组的单选按钮，发生状态变化的是两个按钮，ui-&gt;radioButton0to19 从选中变为非选中，发一个信号打印一次； ui-&gt;radioButton20to39 从未选中变成选中状态，也发一个信号，因此又打印了一条字符串。 以后在点击第三组的其他单选按钮，过程是类似的，都是状态变化的两个单选按钮发信号。</p>
<p>这样本例子示范就完成了。例子头两组通过 QButtonGroup 虚拟按钮组管理，这样一个分组只需要一个槽函数就搞定了，按钮加入虚拟组时分配 id，接收信号时就可以根据 id 来判断是哪个单选按钮被点击了。<strong>注意分配的序号至少要大于等于 0，不要用 -1 作为序号，-1 是不设置序号的意思</strong>。</p>
<p>例子第三组是通过将四个单选按钮塞到 QGroupBox 控件里面，四个单选按钮自动成为分组框子控件，这样就与其他分组的单选按钮无关了。QGroupBox 控件里的四个单选按钮没有设置虚拟组，所以需要通过各自的槽函数来处理，四个单选按钮配了四个槽函数，函数变多了，看起来复杂些。</p>
<p>一般情况下，建议使用 QButtonGroup 虚拟按钮组管理成组的单选按钮。当然，分组框与虚拟管理组是不冲突的，分组框里的按钮也可以添加到新的虚拟分组里面进行管理。分组框本身是控件，它有标题栏，可以 用于显示该组按钮的主题信息。</p>
<p>现在可能还剩下一个问题，如果我们希望三个组的单选按钮，在启动时都默认选中各自第一个按钮，那怎么办呢？ 可以通过单选按钮的 void  setChecked(bool) 函数设置单选按钮的状态，将下面三句代码放置在主窗体的构造函数末尾即可：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;初始化选中状态
ui-&gt;radioButtonMan-&gt;setChecked(true);
ui-&gt;radioButtonBang-&gt;setChecked(true);
ui-&gt;radioButton0to19-&gt;setChecked(true);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="5-1-4-QCheckBox"><a href="#5-1-4-QCheckBox" class="headerlink" title="5.1.4 QCheckBox"></a>5.1.4 QCheckBox</h2><p>复选框的选项就是多选题，而之前单选框是单选题。这两种按钮应用都很广泛，遇到可以选择多个选项时，复选框就派上用场了。多个复选框之间是不冲突了，它们的信号是 无关的，各自顾各自的。 复选框构造函数如下：</p>
<pre class="line-numbers language-none"><code class="language-none">QCheckBox::QCheckBox(const QString &amp; text, QWidget * parent &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>text 是显示文本，parent 是父窗口指针。文本获取和设置也是使用 text() 和 setText() 函数。</p>
<p>复选框也是有选中和非选中两种状态，通过如下函数获取当前状态：</p>
<pre class="line-numbers language-none"><code class="language-none">bool    isChecked() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>通过代码设置复选框的状态， 使用如下函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void setChecked(bool)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>复选框状态变化时，会发出信号：</p>
<pre class="line-numbers language-none"><code class="language-none">void    toggled(bool checked)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>信号里的参数 checked 是复选框新的状态值。</p>
<p>对于复选框，不要用虚拟组 QButtonGroup 管理多个复选框，因为虚拟组 QButtonGroup 里面按钮默认全是互斥的，多个复选框添加到虚拟组里，那么默认只有一个按钮能被选中，就强行变成单选按钮了。</p>
<p>可以从界面拖动分组框 QGroupBox 包裹多个复选框，分组框其实就是一个带标题的框，它不会改变复选框的特性，也不会改变其他按钮的特性，所以可以放心用 分组框。</p>
<p>复选框还有一种特殊用途，叫<strong><strong>三态复选框\</strong></strong>，比如 WORD 办公软件，一段文字既可以是加粗、部分加粗、都不加粗三种状态，三态复选框就是用来干这类事情的。 将传统两种状态复选框变成三态复选框的函数是：</p>
<pre class="line-numbers language-none"><code class="language-none">void setTristate(bool y &#x3D; true)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果要获知当前复选框是不是三态的，通过函数：</p>
<pre class="line-numbers language-none"><code class="language-none">bool isTristate() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>三态复选框的状态枚举 enum Qt::CheckState 有三个枚举常量：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>枚举常量</strong></th>
<th><strong>数值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Qt::Unchecked</strong></td>
<td>0</td>
<td>条目未选中</td>
</tr>
<tr>
<td>Qt::PartiallyChecked</td>
<td>1</td>
<td>条目有部分选中</td>
</tr>
<tr>
<td><strong>Qt::Checked</strong></td>
<td>2</td>
<td>条目全选中</td>
</tr>
</tbody>
</table>
</div>
<p>获知当前三态复选框的状态使用函数：</p>
<pre class="line-numbers language-none"><code class="language-none">Qt::CheckState QCheckBox::checkState() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果要通过代码改变三态复选框的状态，那使用函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void QCheckBox::setCheckState(Qt::CheckState state)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>三态复选框状态变化时触发信号：</p>
<pre class="line-numbers language-none"><code class="language-none">void QCheckBox::stateChanged(int state)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将 state 值与三种状态的枚举常量比较一下，就可以获知不同的状态了。 点击三态复选框，复选框就会在三种状态之间轮流切换，这三种状态的显示效果如下图：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/73e47aa2438069e5367682f40692e8b2.png?lastModify=1685936981" alt="img"></p>
<p>复选框的例子放到本节最后编写，下面先看看命令链接按钮。</p>
<h2 id="5-1-5-QCommandLinkButton"><a href="#5-1-5-QCommandLinkButton" class="headerlink" title="5.1.5 QCommandLinkButton"></a>5.1.5 QCommandLinkButton</h2><p> QCommandLinkButton 是类似 Vista 风格的命令链接按钮，命令链接按钮相当于是单选按钮和普通按压按钮的结合体，用于从互斥的一堆选项里选择一个执行，并进入下一步操作或打开新的网页链接窗口。使用命令链接按钮就可以将窗体里的多个单选按钮和“下一步”按钮省掉了，变成一排命令链接按钮，每个命令链接按钮对应一条执行路径。这样界面看起来更简洁直观，只需要点 击一次按钮，而不需要先点单选按钮，再点“下一步” 按钮。 命令链接按钮是扁平风格，默认带有一个向右的箭头图标，并允许附带一个描述文本。点击命令链接按钮，一般意味着进入下一个窗体或弹出网页浏览器访问网页链接。</p>
<p>命令链接按钮常用的构造函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QCommandLinkButton::QCommandLinkButton(const QString &amp; text, QWidget * parent &#x3D; 0)
QCommandLinkButton::QCommandLinkButton(const QString &amp; text, const QString &amp; description, QWidget * parent &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>text 是按钮显示的文本，parent 是父窗口指针。第二个构造函数 description 是额外的描述信息，额外信息会显示在按钮普通文本的下方。 按钮显示文本通过 text() 函数获取，setText() 函数设置。 命令链接按钮的额外描述可以通过下面两个函数获取或设置：</p>
<pre class="line-numbers language-none"><code class="language-none">QString description() const
void setDescription(const QString &amp; description)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>命令链接按钮被点击的信号也是 clicked()</strong> 。其实命令链接按钮就是长相与普通按钮按钮不一样，多个默认图标和额外描述，其他功能与普通按压按钮是一样的。</p>
<p>点击按钮弹出消息框不是什么新鲜的了，但是如果点击命令链接按钮之后，自动调用操作系统默认的浏览器访问我们指定的网址，该如何实现呢？ 看起来很复杂的样子，对于 Qt ，这其实是再简单不过的事了。通过静态函数：</p>
<pre class="line-numbers language-none"><code class="language-none">bool QDesktopServices::openUrl(const QUrl &amp; url)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>QUrl 是用于描述网页链接或本地文件链接的类，其常用的构造函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QUrl::QUrl(const QString &amp; url, ParsingMode parsingMode &#x3D; TolerantMode)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>构造函数里的字符串 url 就是<strong>网页链接或本地文件链接</strong>，parsingMode 就用默认的宽容模式 TolerantMode 即可。 如果要打开本教程的主页，先包含头文件 <QDesktopServices> 和 <QUrl>，然后调用：</p>
<pre class="line-numbers language-none"><code class="language-none">QDesktopServices::openUrl( QUrl(&quot;https:&#x2F;&#x2F;lug.ustc.edu.cn&#x2F;sites&#x2F;qtguide&#x2F;&quot;) );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果要打开 D:\QtProjects 文件夹，那么调用：</p>
<pre class="line-numbers language-none"><code class="language-none">QDesktopServices::openUrl( QUrl(&quot;file:&#x2F;&#x2F;&#x2F;D:&#x2F;QtProjects&quot;) );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意 URL 里面都是用右斜杠，<strong>file:/// 是三根右斜杠</strong>，表示打开本地文件系统里的文件夹或文件。</p>
<p>关于命令链接按钮的知识就讲到这，下面我们把复选框和命令链接按钮例子放一块来编写。</p>
<p>下面来动手编写本节第二个例子，重新打开 QtCreator，新建一个 Qt Widgets Application 项目，在新建项目的向导里填写： ①项目名称 multiselection，创建路径 D:\QtProjects\ch05，点击下一步； ②套件选择里面选择全部套件，点击下一步； ③基类选择 QWidget，点击下一步； ④项目管理不修改，点击完成。 建好项目之后，打开窗体 widget.ui 文件，进入设计模式，如下图拖控件到窗体里：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/6f3debf6603e960353c0d0097d682322.png?lastModify=1685936981" alt="img"></p>
<p>首先拖一个 Group Box 分组框到窗体上半部分，调整分组框大小，这样能装得下 6 个复选框， 设置分组框的 title 属性，将标题文本改为“兴趣爱好”。</p>
<p>然后向分组框内部拖 6 个复选框，多个兴趣爱好是不冲突的，所以用复选框，复选框的文本按图上设置即可， 6 个复选框的 objectName 依次修改为： checkBoxRead、checkBoxClimb、 checkBoxSwim、checkBoxDaze、 checkBoxShopping、checkBoxEat。 注意调整 6 个复选框位置，尽量对齐，看起来工整。</p>
<p>接着向分组框外部的下面拖一个额外的复选框，文本为“三态显示”，objectName 为 checkBoxTristate； 与这个额外的复选框并排再放一个普通按压按钮，文本为“弹窗显示”，objectName 为 pushButton，调整按钮高度和位置，与左边复选框尽量对齐点。</p>
<p>最后向窗体底部拖两个 Command Link Button，第一个命令链接按钮的文本为“打开文件夹”，objectName 为 commandLinkButtonFolder，第二个命令链接按钮的文本为“打开主页”，objectName 为 commandLinkButtonWeb，并调整这两个按钮的宽度和位置，使界面看起来比较工整。</p>
<p>这样界面控件的设置就完成了，在编写代码之前，先说一下这个例子要实现的功能，在分组框里的兴趣爱好共 6 个，每一个复选框都可以选中或不选中。分组框外的三态复选框根据 6 个兴趣复选框状态自动变化：</p>
<ul>
<li>如果 6 个兴趣复选框都不选中，那么分组框外面的三态复选框显示不选中；</li>
<li>如果 6 个兴趣复选框部分选中，那么三态复选框显示部分选中状态；</li>
<li>如果 6 个兴趣复选框都选中，那么三态复选框显示全选中状态。</li>
</ul>
<p>按压按钮“弹窗显示”，会弹出消息框，显示选中了的兴趣爱好信息。 窗体下方两个命令链接按钮一个用于打开本地文件夹，另一个打开本教程主页。</p>
<p>下面先从设计模式为 6 个兴趣复选框的 toggled() 信号添加 6 个槽函数：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/09afbefa7f865a110b4e4e59ae48a92f.png?lastModify=1685936981" alt="img"></p>
<p>然后为普通按压按钮和两个命令链接按钮的 clicked() 信号添加槽函数，共三个：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/51f40a0a5e1f63f146f317db369c4a5f.png?lastModify=1685936981" alt="img"></p>
<p>槽函数添加好之后，保存界面文件，回到代码编辑模式，向头文件 widget.h 添加一个 CheckHobbies() 函数声明，其他的不用动， widget.h 完整内容为：</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef WIDGET_H
 
#define WIDGET_H
 
#include &lt;QWidget&gt;
 
namespace Ui &#123;
class Widget;
&#125;
 
class Widget : public QWidget
&#123;
    Q_OBJECT
 
public:
    explicit Widget(QWidget *parent &#x3D; 0);
    ~Widget();
 
    &#x2F;&#x2F;检查兴趣爱好，同步更新三态复选框的状态
    void CheckHobbies();
 
private slots:
    void on_checkBoxRead_toggled(bool checked);
 
    void on_checkBoxClimb_toggled(bool checked);
 
    void on_checkBoxSwim_toggled(bool checked);
 
    void on_checkBoxDaze_toggled(bool checked);
 
    void on_checkBoxShopping_toggled(bool checked);
 
    void on_checkBoxEat_toggled(bool checked);
 
    void on_pushButton_clicked();
 
    void on_commandLinkButtonFolder_clicked();
 
    void on_commandLinkButtonWeb_clicked();
 
private:
    Ui::Widget *ui;
&#125;;
 
#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>6 个复选框的槽函数和 3 个按钮的槽函数都是通过设计模式“转到槽…”添加的，这些槽函数都能自动关联，省了许多事。</p>
<p>接下来我们打开 widget.cpp 文件，首先添加头文件包含，并在构造函数里添加代码：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;widget.h&quot;
 
#include &quot;ui_widget.h&quot;
#include &lt;QDebug&gt;
#include &lt;QMessageBox&gt;
#include &lt;QDesktopServices&gt;
#include &lt;QUrl&gt;
 
Widget::Widget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);
 
    &#x2F;&#x2F;设置三态工作模式
    ui-&gt;checkBoxTristate-&gt;setTristate(true);
 
&#125;
 
Widget::~Widget()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>构造函数里将 ui-&gt;checkBoxTristate 三态工作模式。这个三态按钮会根据 6 个兴趣复选框来显示状态，我们下面编写 CheckHobbies() 函数内容，检查选中的兴趣复选框个数，然后更新三态复选框状态：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;检查 6 个兴趣爱好复选框，根据兴趣复选框状态，更新三态复选框显示
 
void Widget::CheckHobbies()
&#123;
    int count &#x3D; 0;  &#x2F;&#x2F;兴趣计数
    if( ui-&gt;checkBoxRead-&gt;isChecked() )
    &#123;
        count++;
    &#125;
    if( ui-&gt;checkBoxClimb-&gt;isChecked() )
    &#123;
        count++;
    &#125;
    if( ui-&gt;checkBoxSwim-&gt;isChecked() )
    &#123;
        count++;
    &#125;
    if( ui-&gt;checkBoxDaze-&gt;isChecked() )
    &#123;
        count++;
    &#125;
    if( ui-&gt;checkBoxShopping-&gt;isChecked() )
    &#123;
        count++;
    &#125;
    if( ui-&gt;checkBoxEat-&gt;isChecked() )
    &#123;
        count++;
    &#125;
    &#x2F;&#x2F;根据兴趣计数设置三态按钮的状态
    if( count &lt;&#x3D; 0)
    &#123;
        ui-&gt;checkBoxTristate-&gt;setCheckState(Qt::Unchecked);
        return;
    &#125;
    else if( count &lt;&#x3D; 5 )
    &#123;
        ui-&gt;checkBoxTristate-&gt;setCheckState(Qt::PartiallyChecked);
        return;
    &#125;
    else
    &#123;
        ui-&gt;checkBoxTristate-&gt;setCheckState(Qt::Checked);
        return;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>count 就是 6 个兴趣复选框选中的个数，可以使用复选框的 isChecked() 函数判断是否处于选中状态，然后更新计数 count 。 计数统计好之后，根据计数范围，如果小于等于 0，那么设置三态复选框为 Qt::Unchecked，并返回； 如果计数位于 1 到 5 之间，那么设置三态复选框为 Qt::PartiallyChecked，并返回； 如果计数达到 6 个，那么设置三态复选框为 Qt::Checked，并返回。</p>
<p>CheckHobbies() 只是普通函数，<strong><strong>当每个兴趣复选框状态发出信号 toggled() 时，我们都要调用这个函数检查一下兴趣爱好计数，重新设置三态按钮状态。\</strong></strong>6 个兴趣复选框的槽函数内容都是类似的，如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">void Widget::on_checkBoxRead_toggled(bool checked)
 
&#123;
    if(checked)
    &#123;
        qDebug()&lt;&lt;tr(&quot;读书&quot;);
    &#125;
    CheckHobbies(); &#x2F;&#x2F;更新三态复选框
&#125;
 
void Widget::on_checkBoxClimb_toggled(bool checked)
&#123;
    if(checked)
    &#123;
        qDebug()&lt;&lt;tr(&quot;爬山&quot;);
    &#125;
    CheckHobbies(); &#x2F;&#x2F;更新三态复选框
&#125;
 
void Widget::on_checkBoxSwim_toggled(bool checked)
&#123;
    if(checked)
    &#123;
        qDebug()&lt;&lt;tr(&quot;游泳&quot;);
    &#125;
    CheckHobbies(); &#x2F;&#x2F;更新三态复选框
&#125;
 
void Widget::on_checkBoxDaze_toggled(bool checked)
&#123;
    if(checked)
    &#123;
        qDebug()&lt;&lt;tr(&quot;发呆&quot;);
    &#125;
    CheckHobbies(); &#x2F;&#x2F;更新三态复选框
&#125;
 
void Widget::on_checkBoxShopping_toggled(bool checked)
&#123;
    if(checked)
    &#123;
        qDebug()&lt;&lt;tr(&quot;逛街&quot;);
    &#125;
    CheckHobbies(); &#x2F;&#x2F;更新三态复选框
&#125;
 
void Widget::on_checkBoxEat_toggled(bool checked)
&#123;
    if(checked)
    &#123;
        qDebug()&lt;&lt;tr(&quot;吃货&quot;);
    &#125;
    CheckHobbies(); &#x2F;&#x2F;更新三态复选框
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        6 个复选框的槽函数首先根据 checked 判断是否打印文本，打印文本说明该复选框处于选中状态。         然后调用 CheckHobbies() 函数更新三态复选框。</p>
<p>​        普通的按压按钮槽函数会根据选中的兴趣复选框，弹窗显示选中的兴趣爱好信息：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;弹窗显示选中的兴趣爱好
void Widget::on_pushButton_clicked()
&#123;
    QString strResult &#x3D; tr(&quot;兴趣爱好为：\r\n&quot;);
    if( ui-&gt;checkBoxRead-&gt;isChecked() )
    &#123;
        strResult +&#x3D; tr(&quot;读书\r\n&quot;);
    &#125;
    if( ui-&gt;checkBoxClimb-&gt;isChecked() )
    &#123;
        strResult +&#x3D; tr(&quot;爬山\r\n&quot;);
    &#125;
    if( ui-&gt;checkBoxSwim-&gt;isChecked() )
    &#123;
        strResult +&#x3D; tr(&quot;游泳\r\n&quot;);
    &#125;
    if( ui-&gt;checkBoxDaze-&gt;isChecked() )
    &#123;
        strResult +&#x3D; tr(&quot;发呆\r\n&quot;);
    &#125;
    if( ui-&gt;checkBoxShopping-&gt;isChecked() )
    &#123;
        strResult +&#x3D; tr(&quot;逛街\r\n&quot;);
    &#125;
    if( ui-&gt;checkBoxEat-&gt;isChecked() )
    &#123;
        strResult +&#x3D; tr(&quot;吃货\r\n&quot;);
    &#125;
    &#x2F;&#x2F;弹窗显示
    QMessageBox::information(this, tr(&quot;兴趣爱好&quot;), strResult);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>普通按压按钮的槽函数工作原理很简单，如果某兴趣复选框处于选中状态，就添加一行对应的兴趣爱好字符串，最后弹窗显示就行了。</p>
<p>关于复选框的代码就是上面的部分。接下来是两个命令链接按钮对应的槽函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void Widget::on_commandLinkButtonFolder_clicked()
&#123;
    QDesktopServices::openUrl( QUrl(&quot;file:&#x2F;&#x2F;&#x2F;D:&#x2F;QtProjects&quot;) );
&#125;
void Widget::on_commandLinkButtonWeb_clicked()
&#123;
    QDesktopServices::openUrl( QUrl(&quot;https:&#x2F;&#x2F;lug.ustc.edu.cn&#x2F;sites&#x2F;qtguide&#x2F;&quot;) );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        第一个命令链接按钮的槽函数会打开本地文件夹，第二个命令链接按钮的槽函数会打开本教程主页。         widget.cpp 里面的函数代码按上面添加完成就行了。         可以生成运行例子，看看效果，下面两张运行效果图显示的是三态复选框的部分选中和全选中的状态：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/0cf6c3eccdab338e9a027a4ef171780b.png?lastModify=1685936981" alt="img"></p>
<p> <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/b5ac116cfe465e17afbf3215d657cbd1.png?lastModify=1685936981" alt="img"></p>
<p>至于两个命令链接按钮点击之后的运行效果，大家自己点击试试看。</p>
<h2 id="QT对象树"><a href="#QT对象树" class="headerlink" title="QT对象树"></a>QT对象树</h2><p>​        我们发现，程序结束后，不需要一个一个手动的释放对象，这是因为，我们调用构造函数指定了一个Parent父对象，其父对象会把我们自己搞的子对象挂到对象树上，</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230411202327161.png?lastModify=1685936981" alt="image-20230411202327161"></p>
<p>​        （补充：一个类创建时需要调用一个函数来构造初始化这个类，这叫构造函数。当类的什么周期结束时需要调用一个删除函数，释放类占用的空间，这叫析构函数。类默认有这两个函数）于是在QT中只要指定好父对象就会帮助管理！不需要我们手动释放，很是方便</p>
<p>​        现在，我们来创建一个新类：MyPushBtn</p>
<p>​        右键工程-&gt; 添加新文件-&gt;C++ Class -&gt;选择 QWedget就好了。</p>
<p>​        随后，就发现多了一些文件</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230411203853556.png?lastModify=1685936981" alt="image-20230411203853556"></p>
<p>​        pro文件下多了我们自己定义的类的cpp文件和头文件</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230411204458973.png?lastModify=1685936981" alt="image-20230411204458973"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230411204545650.png?lastModify=1685936981" alt="image-20230411204545650"></p>
<p>​        现在我们调一下自己写的：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230411205908628.png?lastModify=1685936981" alt="image-20230411205908628"></p>
<p>​        可以看到我们自己的按钮产生了！</p>
<h2 id="QT-坐标系"><a href="#QT-坐标系" class="headerlink" title="QT 坐标系"></a>QT 坐标系</h2><p>​        QT的坐标原点在窗口的最左上角，这是值得注意的一点，同时：X向右增大，向左减小，而Y 向下增大，向上减小。对于嵌套窗口，则是以父窗口为例子的！</p>
<p>​        </p>
<p>一.基本介绍 创建qt项目是，如果选择空窗口QWidget，那么mian函数中会有如下代码：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;myWindow.h&quot;

#include &lt;QApplication&gt;

int main(int argc, char *argv[])
&#123;
    QApplication a(argc, argv);
    myWindow w;
    w.show();
    return a.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，含义分别如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>QApplicata：</td>
<td>应用程序对象，必须有且只能有一个</td>
</tr>
<tr>
<td>Qwidget：</td>
<td>qt自带空窗口类，即运行时的窗口。</td>
</tr>
<tr>
<td>myWindow:</td>
<td>自定义窗口类，继承自QWidget</td>
</tr>
<tr>
<td>a.exec()：</td>
<td>进入消息循环，除非人为结束进程，否则阻塞在这里等待用户输入，死循环。</td>
</tr>
<tr>
<td>qmake：</td>
<td>qt的编译器。</td>
</tr>
<tr>
<td>.pro文件：</td>
<td>qt的项目文件。</td>
</tr>
</tbody>
</table>
</div>
<p>其内部代码含义如下：</p>
<p>​        我们自定义的myWindow类中默认使用宏Q_OBJECT。其含义是允许使用信号与槽</p>
<p>二.对象树     对象树是qt中非常重要的内容，主要用于自动析构对象。</p>
<p>​        在qt中，我们自定义的类可以继承自qt中已有的类。比如上述myWindow就是继承自QWidget。</p>
<p>​        QWidget又是继承自QObject。</p>
<p>​        在qt中QObject是所有类的祖先，向下生成了许多子类，这样一个关系就叫做对象树。</p>
<p>​        使用时，需要通过setParent函数将对象间确定父子关系，之后子对象会进入父对象的children列表。 </p>
<p>​        当析构时，会先从父对象开始，先走父对象析构函数（注意，只是析构没有真正释放），然后依旧children列表析构子对象，直到走到叶子对象后，释放叶子对象，再返回父对象释放，直到回到一开始的父对象。</p>
<p>​        当释放一个对象时，会把它所有的子对象都释放掉，因此，之后不能再去释放子对象，否则会发生二次释放的错误。</p>
<p>比如下述代码就会发生二次释放：</p>
<pre class="line-numbers language-none"><code class="language-none">int main(int argc, char *argv[])
&#123;
    QApplication a(argc, argv);
    myWidget * c &#x3D; new myWidget;
    QWidget * s &#x3D; new QWidget;
    c-&gt;setParent(s);&#x2F;&#x2F;s是c的父对象
    delete s;&#x2F;&#x2F;删释放s同时也会将c释放
    delete c;&#x2F;&#x2F;错误，二次释放
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是，如果我们不手动写delete c就不会二次释放，因为c已经释放过了。对象树的存在大大简化了释放对象的复杂性。</p>
<pre class="line-numbers language-none"><code class="language-none">int main(int argc, char *argv[])
&#123;
    QApplication a(argc, argv);
    myWidget * c &#x3D; new myWidget;
    QWidget * s &#x3D; new QWidget;
    c-&gt;setParent(s);&#x2F;&#x2F;s是c的父对象
    delete s;&#x2F;&#x2F;删释放s同时也会将c释放
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>值得注意的是，如果是栈对象，那么定义时一定要按先定义父再定义子的顺序，否则在程序结束是会先析构父（此时也会把子析构），再析构子（发生二次析构）！</p>
<p>比如下述错误代码：</p>
<pre class="line-numbers language-none"><code class="language-none">int main(int argc, char *argv[])
&#123;
    QApplication a(argc, argv);
    myWidget c;
    QWidget s;&#x2F;&#x2F; s后定义，结束时先析构
    c.setParent(&amp;s);&#x2F;&#x2F;s为父，c为子
    return 0;
    &#x2F;&#x2F;发生错误，s先析构会把c也析构，
    &#x2F;&#x2F;之后c调用析构函数时会二次析构
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        正确的应该先定义父对象QWidget，再定义子对象myWidget。</p>
<p><strong>原型的价值就在于它对你的教育，而不是代码本身——Alan Cooper</strong></p>
<h2 id="信号与槽的基础概念"><a href="#信号与槽的基础概念" class="headerlink" title="信号与槽的基础概念"></a>信号与槽的基础概念</h2><p>​        我们现在开始关联我们的行为和效果！比若说：我希望点击按钮后就帮我关闭窗口！于是</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230412232937449.png?lastModify=1685936981" alt="image-20230412232937449"></p>
<p>​        这就是我们分解完后发现就是这样的，现在开始关联他们：</p>
<p>​        英语里：connect就是连接的，结合上图发现，想要表达一个链接，无非就是：</p>
<pre class="line-numbers language-none"><code class="language-none">connect(sender, sendSignal, receiver, slogAsActionReact)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        注意了：注意！我们点击按钮，不一定是去关闭窗口，而窗口关闭了不一定时我点击了按钮导致的</p>
<p>​        于是，信号槽的优点就是：松散耦合的！他们之间本来没啥关联！但是现在我们直接用connect函数来耦合在一起！</p>
<p>​        QT里，就是connect函数完成我们的工作！先来看发送者：按钮！那信号呢？</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230412233514694.png?lastModify=1685936981" alt="image-20230412233514694"></p>
<p>​        于是找到一个信号clicked. </p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230412233547084.png?lastModify=1685936981" alt="image-20230412233547084"></p>
<p>​        所以传入一个函数的地址！&amp;QPushButton::clicked</p>
<p>​        接收者同理！：</p>
<pre class="line-numbers language-none"><code class="language-none">connect(mine, &amp;QPushButton::clicked,this,&amp;QWidget::close);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这一思想十分重要！还是需要好好消化！</p>
<p>​        现在尝试自己来书写两个类，来建立相应的关系！</p>
<p>​        现在构建程序如下：</p>
<p>​        在最大工程文件之下添加两个类！，首先是 Teacher类。 随后是学生类。假设这一场景！老师要求学生交作业！学生听到老师的要求来拿出作业，老师看到学生拿出作业之后再上前收取。这个行为我们使用 QT 的槽与信号来完成我们的实现。</p>
<p>​        选择新建两个类： Student 和 Teacher. 注意到为了能够使用 QT系统的一些性质，有必要来选择继承QT类。</p>
<p>​        当我们完成了新建，马上就发现，它同我们所想象的不太一样！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230414145816352.png?lastModify=1685936981" alt="image-20230414145816352"></p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef TEACHER_H
#define TEACHER_H

#include &lt;QObject&gt;

class Teacher : public QObject &#x2F;&#x2F; QObject 是 Teacher 的一个基类
&#123;
    Q_OBJECT &#x2F;&#x2F; 这是QObject宏，声明启用Slot - Signals关系的
public:
    explicit Teacher(QObject *parent &#x3D; nullptr);
    
    &#x2F;&#x2F; 只有在有 Q_OBJECT下才生效
signals:
	&#x2F;&#x2F; 我们在这里书写 signals 作为信号函数
public slots:
    
    &#x2F;&#x2F; 我们在这里书写 slots 作为响应信号的槽函数
&#125;;

#endif &#x2F;&#x2F; TEACHER_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意到我们在这里完成槽函数和信号函数的书写！</p>
<p>​        以及这里需要提醒的是：槽函数在这里是一个实现的占位函数，这是在底层的文件中，QT为我们实现了函数了，不要在定义实现文件里再次定义信号函数，否则会发生报错。</p>
<p>​        但是，槽函数需要实现，这是需要在实现文件里自己重写的！</p>
<pre class="line-numbers language-none"><code class="language-none">void student::reactions()&#123;

	qDebug() &lt;&lt; &quot;Yep, I think I will help you!&quot;;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        书写完响应之后，我们现在可以来干活了（在Widget.cpp）</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;widget.h&quot;
#include&quot;student.h&quot;
#include&quot;teacher.h&quot;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;

    Teacher* t &#x3D; new Teacher(this);
    student* s &#x3D; new student(this);
	
    &#x2F;&#x2F; 这里是链接信号和槽，但是这又这样是不行的，英文不是所有的这个函数都是信号，只有当我们认为指定他是信号的时候才需要出发槽函数
    connect(t,&amp;Teacher::announceHungry,s,&amp;s-&gt;reactions);
	&#x2F;&#x2F; 而emit就是声命这是这是一个信号函数且需要调用s-&gt;reactions
    emit t-&gt;announceHungry();


&#125;

Widget::~Widget()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样，只要我们一开始运行程序，就会发现</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230418202145548.png?lastModify=1685936981" alt="image-20230418202145548"></p>
<p>​        嗯，打印了（如果跑的是我的那个demo就是Yep, I think I will help you!）</p>
<h2 id="槽函数的重载版本"><a href="#槽函数的重载版本" class="headerlink" title="槽函数的重载版本"></a>槽函数的重载版本</h2><p>​        下面，我们进一步的探索可以重载版本的槽函数</p>
<p>​        以上一小节的场景为例子，加上槽函数的重载版本！</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; in .h

slots:
	void reactions(QString s); 

&#x2F;&#x2F; .cpp

void student::reactions(QSrting s)&#123;
	qDebug() &lt;&lt; &quot;yep, I think it is&quot; &lt;&lt; s;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，注释掉原先的emit 就可以发现智能提示上函数有重载版本！</p>
<p>​        但是，当我们直接单击运行的时候，QT报错了！原因很简单！QT不知道你要那个回应！于是，我们转向传专门到具体的函数的指针！也就是直接传重载版本的函数指针！</p>
<p>​        但是，我们的信号来源信息是需要从信号函数那里来的，于是还要重载Signal函数</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;.h

signal:
	void announceHungry(QString s);

&#x2F;&#x2F; .cpp
void Teacher::announceHungry(QString s);&#x2F;&#x2F; 仍然不实现！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，告诉引发的信号是来自：</p>
<pre class="line-numbers language-none"><code class="language-none">emit t-&gt;announceHungry(&quot;111&quot;); &#x2F;&#x2F; 从这里编译器判断函数类型
void (Teacher::*StringOne)(QString) &#x3D; &amp;Teacher::announceHungry;
void (student::*reacOne)(QString) &#x3D; &amp;student::reactions;
connect(t,StringOne,s,reacOne);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230418210445433.png?lastModify=1685936981" alt="image-20230418210445433"></p>
<h2 id="令人恼火的是："><a href="#令人恼火的是：" class="headerlink" title="令人恼火的是："></a>令人恼火的是：</h2><p>​        马上强迫症发现了：不对啊，我们的111不应该打印“” 啊！，这是因为类型是QString导致的，这个时候只要我们进行转化就好了</p>
<pre class="line-numbers language-none"><code class="language-none">qDebug() &lt;&lt; s.toUtf8().data()
    
&#x2F;&#x2F; QString -&gt; ByteArray -&gt; const char*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230418211415114.png?lastModify=1685936981" alt="image-20230418211415114"></p>
<h2 id="高级一点的信号与槽"><a href="#高级一点的信号与槽" class="headerlink" title="高级一点的信号与槽"></a>高级一点的信号与槽</h2><p>​        现在，让我们点击按钮，连续的触发事件来让样例复杂起来。</p>
<p>​        信号与槽的一个重要的要求就是信号和槽的函数的参数必须一致(有参的信号和QPushButton的clicked信号的参数不匹配就会编译报错)，于是，包装一个Emit函数</p>
<pre class="line-numbers language-none"><code class="language-none">void Widget::Emit()
&#123;
	&#x2F;&#x2F; 预先在Widget里添加成员t，并且初始化
	Emit t-&gt;announcement(&quot;111&quot;)

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，开始关联：</p>
<pre class="line-numbers language-none"><code class="language-none">QPushButton* btn &#x3D; new QPushButton(&quot;Press me&quot;,this);
btn-&gt;move(200,200);

connect(btn,QPushButton::clicked,this,&amp;Widget::Emit);
void (Teacher::*StringOne)(QString) &#x3D; &amp;Teacher::announceHungry;
void (student::*reacOne)(QString) &#x3D; &amp;student::reactions;
connect(t,StringOne,s,reacOne);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230418213636339.png?lastModify=1685936981" alt="image-20230418213636339"></p>
<p>​        对了，信号也可以来连接信号，就是：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230418214613353.png?lastModify=1685936981" alt="image-20230418214613353"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230418214631458.png?lastModify=1685936981" alt="image-20230418214631458"></p>
<h2 id="断开链接"><a href="#断开链接" class="headerlink" title="断开链接"></a>断开链接</h2><pre class="line-numbers language-none"><code class="language-none">disconnect(s1,signalF,sloter,slotF);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>​        就我个人来理解，信号槽机制与Windows下消息机制类似，消息机制是基于回调函数，Qt中用信号与槽来代替函数指针，使程序更安全简洁。</p>
<p>​        信号和槽机制是 Qt 的核心机制，可以让编程人员将互不相关的对象绑定在一起，实现对象之间的通信。</p>
<p>信号</p>
<p>​        当对象改变其状态时，信号就由该对象发射 (emit) 出去，而且对象只负责发送信号，它不知道另一端是谁在接收这个信号。这样就做到了真正的信息封装，能确保对象被当作一个真正的软件组件来使用。</p>
<p>槽</p>
<p>​        用于接收信号，而且槽只是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。而且对象并不了解具体的通信机制。</p>
<p>信号与槽的连接</p>
<p>所有从 QObject 或其子类 ( 例如 Qwidget ) 派生的类都能够包含信号和槽。因为信号与槽的连接是通过 QObject 的 connect() 成员函数来实现的。</p>
<p>connect(sender, SIGNAL(signal), receiver, SLOT(slot)); 其中 sender 与 receiver 是指向对象的指针，SIGNAL() 与 SLOT() 是转换信号与槽的宏。</p>
<p>二. 特点     一个信号可以连接多个槽</p>
<p>​        当信号发射时，会以不确定的顺序一个接一个的调用各个槽。</p>
<p>​        多个信号可以连接同一个槽</p>
<p>​        即无论是哪一个信号被发射，都会调用这个槽。</p>
<p>​        信号直接可以相互连接</p>
<p>​        发射第一个信号时，也会发射第二个信号。</p>
<p>​        连接可以被移除</p>
<p>​        这种情况用得比较少，因为在对象被删除时，Qt会自动移除与这个对象相关的所有连接。语法如下：</p>
<pre class="line-numbers language-none"><code class="language-none">disconnect(sender, SIGNAL(signal), receiver, SLOT(slot));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>三. 应注意的问题     信号与槽机制与普通函数的调用一样，如果使用不当的话，在程序执行时也有可能产生死循环。因此，在定义槽函数时一定要注意避免间接形成无限循环，即在槽中再次发射所接收到的同样信号。例如 , 在前面给出的例子中如果在 mySlot() 槽函数中加上语句 emit mySignal() 即可形成死循环。     如果一个信号与多个槽相联系的话，那么，当这个信号被发射时，与之相关的槽被激活的顺序将是随机的。     宏定义不能用在 signal 和 slot 的参数中。     信号和槽的参数个数与类型必须一致。 四. 程序举例     这个demo程序由一个Label和PushButton组成，第一个例子中点击按钮，可以让label关闭，这是最简单的信号与槽的连接；第二例子中点击按钮，在label上获取当前系统时间，这个涉及到的知识点有：信号与槽的参数类型不同时如何连接、自定义槽函数、自定义信号。</p>
<p>​        首先，新建一个Qt GUI程序，父窗口选为QDialog，类名为getTime，在头文件和CPP文件分别加入如下代码（小生愚钝，还没弄清楚博客园MarkDown代码块怎么高亮，所以只好贴截图了，见谅）</p>
<p>头文件</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/format,png.png?lastModify=1685936981" alt="img"></p>
<p>实现文件</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/format,png-168593354419357.png?lastModify=1685936981" alt="img"></p>
<p>保存、编译、运行之后点击按钮即可看到label消失了。</p>
<p>然后在头文件中加入自定义的槽函数和信号，并在CPP文件中实现槽函数，具体如下：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/format,png-168593355332760.png?lastModify=1685936981" alt="img"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/format,png-168593355849563.png?lastModify=1685936981" alt="img"></p>
<p>​        然后保存，编译运行即可，点击按钮后就能看到label上显示当前时间了。</p>
<p>总结:</p>
<p>1、signals前面不可加public、private和protected进行修饰；slots前面可以加，因为Qt说槽函数可以当普通函数使用。</p>
<p>2、signals区域的函数必须是void类型，而且这些信号函数没有函数体，也就是说不可以自己定义这些信号函数，你只要声明它就够了，其它不用管，Qt内部自己弄。</p>
<p>3、宏定义和函数指针不能用于信号和槽的参数，信号和槽也不能有缺省参数。</p>
<p>​        信号和槽作为QT的核心机制在QT编程中有着广泛的应用，本文介绍了信号和槽的一些基本概念、元对象工具及在实际使用过程中应注意的一些问题。 </p>
<p>​        QT 是个跨平台的C++ GUI应用构架，他提供了丰富的窗口部件集，具有面向对象、易于扩展、真正的组件编程等特点，更为引人注目的是目前Linux上最为流行的KDE桌面环境就是建立在QT库的基础之上。QT支持下列平台：MS/WINDOWS-95、98、NT和2000；UNIX/X11-Linux、Sun Solaris、HP-UX、Digital Unix、IBM AIX、SGI IRIX；EMBEDDED-支持framebuffer的Linux平台。伴随着KDE的快速发展和普及，QT非常可能成为Linux窗口平台上进行软件研发时的GUI最佳选择。 </p>
<p>一、概述  信号和槽机制是QT的核心机制，要精通QT编程就必须对信号和槽有所了解。信号和槽是一种高级接口，应用于对象之间的通信，他是QT的核心特性，也是QT差别于其他工具包的重要地方。信号和槽是QT自行定义的一种通信机制，他独立于标准的C/C++语言，因此要正确的处理信号和槽，必须借助一个称为moc（Meta Object Compiler）的QT工具，该工具是个C++预处理程式，他为高层次的事件处理自动生成所需要的附加代码。  在我们所熟知的非常多GUI工具包中，窗口小部件(widget)都有一个回调函数用于响应他们能触发的每个动作，这个回调函数通常是个指向某个函数的指针。不过，在 QT中信号和槽取代了这些凌乱的函数指针，使得我们编写这些通信程式更为简洁明了。信号和槽能携带任意数量和任意类型的参数，他们是类型完全安全的，不会像回调函数那样产生core dumps。  所有从QObject或其子类(例如Qwidget)派生的类都能够包含信号和槽。当对象改动其状态时，信号就由该对象发射(emit)出去，这就是对象所要做的全部事情，他不知道另一端是谁在接收这个信号。这就是真正的信息封装，他确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但他们是普通的对象成员函数。一个槽并不知道是否有所有信号和自己相连接。而且，对象并不了解具体的通信机制。  你能将非常多信号和单个的槽进行连接，也能将单个的信号和非常多的槽进行连接，甚至于将一个信号和另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射系统都将即时发射第二个信号。总之，信号和槽构造了一个强大的部件编程机制。 </p>
<p>二、信号  当某个信号对其客户或所有者发生的内部状态发生改动，信号被一个对象发射。只有定义过这个信号的类及其派生类能够发射这个信号。当一个信号被发射时，和其相关联的槽将被即时执行，就象一个正常的函数调用相同。信号-槽机制完全独立于所有GUI事件循环。只有当所有的槽返回以后发射函数（emit）才返回。如果存在多个槽和某个信号相关联，那么，当这个信号被发射时，这些槽将会一个接一个地执行，不过他们执行的顺序将会是随机的、不确定的，我们不能人为地指定哪个先执行、哪个后执行。  信号的声明是在头文件中进行的，QT的signals关键字指出进入了信号声明区，随后即可声明自己的信号。例如，下面定义了三个信号：  signals:  void mySignal();  void mySignal(int x);  void mySignalParam(int x,int y);  在上面的定义中，signals是QT的关键字，而非C/C++的。接下来的一行void mySignal() 定义了信号mySignal，这个信号没有携带参数；接下来的一行void mySignal(int x)定义了重名信号mySignal，不过他携带一个整形参数，这有点类似于C++中的虚函数。从形式上讲信号的声明和普通的C++函数是相同的，不过信号却没有函数体定义，另外，信号的返回类型都是void，不要指望能从信号返回什么有用信息。  信号由moc自动产生，他们不应该在.cpp文件中实现。 </p>
<p>三、槽 </p>
<p>槽是普通的C++成员函数，能被正常调用，他们唯一的特别性就是非常多信号能和其相关联。当和其关联的信号被发射时，这个槽就会被调用。槽能有参数，但槽的参数不能有缺省值。  既然槽是普通的成员函数，因此和其他的函数相同，他们也有存取权限。槽的存取权限决定了谁能够和其相关联。同普通的C++成员函数相同，槽函数也分为三种类型，即public slots、private slots和protected slots。  public slots：在这个区内声明的槽意味着所有对象都可将信号和之相连接。这对于组件编程非常有用，你能创建彼此互不了解的对象，将他们的信号和槽进行连接以便信息能够正确的传递。  protected slots：在这个区内声明的槽意味着当前类及其子类能将信号和之相连接。这适用于那些槽，他们是类实现的一部分，不过其界面接口却面向外部。  private slots：在这个区内声明的槽意味着只有类自己能将信号和之相连接。这适用于联系非常紧密的类。  槽也能够声明为虚函数，这也是非常有用的。  槽的声明也是在头文件中进行的。例如，下面声明了三个槽： </p>
<pre class="line-numbers language-none"><code class="language-none">public slots:
void mySlot();
void mySlot(int x);
void mySignalParam(int x,int y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>四、信号和槽的关联  通过调用QObject对象的connect函数来将某个对象的信号和另外一个对象的槽函数相关联，这样当发射者发射信号时，接收者的槽函数将被调用。该函数的定义如下：  bool QObject::connect ( const QObject <em> sender, const char </em> signal, const QObject <em> receiver, const char </em> member ) [static]  这个函数的作用就是将发射者sender对象中的信号signal和接收者receiver中的member槽函数联系起来。当指定信号signal时必须使用QT的宏SIGNAL()，当指定槽函数时必须使用宏SLOT()。如果发射者和接收者属于同一个对象的话，那么在connect调用中接收者参数能省略。  例如，下面定义了两个对象：标签对象label和滚动条对象scroll，并将valueChanged()信号和标签对象的setNum()相关联，另外信号还携带了一个整形参数，这样标签总是显示滚动条所处位置的值。 </p>
<pre class="line-numbers language-none"><code class="language-none">QLabel *label &#x3D; new QLabel; 
QScrollBar *scroll &#x3D; new QScrollBar; 
QObject::connect( scroll, SIGNAL(valueChanged(int)), label, SLOT(setNum(int)) ); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>一个信号甚至能够和另一个信号相关联，看下面的例子： </p>
<pre class="line-numbers language-none"><code class="language-none">class MyWidget : public QWidget 
&#123; 
　　public: 
　　MyWidget(); 
　　… 
　　signals: 
　　void aSignal(); 
　　… 
　　private: 
　　… 
　　QPushButton *aButton; 
&#125;; 
MyWidget::MyWidget() 
&#123; 
　　aButton &#x3D; new QPushButton( this ); 
　　connect( aButton, SIGNAL(clicked()), SIGNAL(aSignal()) ); 
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在上面的构造函数中，MyWidget创建了一个私有的按钮aButton，按钮的单击事件产生的信号clicked()和另外一个信号aSignal() 进行了关联。这样一来，当信号clicked()被发射时，信号aSignal()也接着被发射。当然，你也能直接将单击事件和某个私有的槽函数相关联，然后在槽中发射aSignal()信号，这样的话似乎有点多余。  当信号和槽没有必要继续保持关联时，我们能使用disconnect函数来断开连接。其定义如下： </p>
<pre class="line-numbers language-none"><code class="language-none">bool QObject::disconnect ( const QObject * sender, const char * signal, const Object * receiver, const char * member ) [static] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这个函数断开发射者中的信号和接收者中的槽函数之间的关联。          有三种情况必须使用disconnect()函数：  （1）断开和某个对象相关联的所有对象。这似乎有点不可理解，事实上，当我们在某个对象中定义了一个或多个信号，这些信号和另外若干个对象中的槽相关联，如果我们要切断这些关联的话，就能利用这个方法，非常之简洁。  disconnect( myObject, 0, 0, 0 ) 或 myObject-&gt;disconnect()  （2）断开和某个特定信号的所有关联。  disconnect( myObject, SIGNAL(mySignal()), 0, 0 ) 或 myObject-&gt;disconnect( SIGNAL(mySignal()) )  （3）断开两个对象之间的关联。  disconnect( myObject, 0, myReceiver, 0 ) 或 myObject-&gt;disconnect( myReceiver ) </p>
<p>​        在disconnect函数中0能用作一个通配符，分别表示所有信号、所有接收对象、接收对象中的所有槽函数。不过发射者sender不能为0，其他三个参数的值能等于0。  </p>
<p>五、元对象工具      元对象编译器moc（meta object compiler）对C++文件中的类声明进行分析并产生用于初始化元对象的C++代码，元对象包含全部信号和槽的名字及指向这些函数的指针。  moc 读C++源文件，如果发现有Q_OBJECT宏声明的类，他就会生成另外一个C++源文件，这个新生成的文件中包含有该类的元对象代码。例如，假设我们有一个头文件mysignal.h，在这个文件中包含有信号或槽的声明，那么在编译之前 moc 工具就会根据该文件自动生成一个名为mysignal.moc.h的C++源文件并将其提交给编译器；类似地，对应于mysignal.cpp文件moc 工具将自动生成一个名为mysignal.moc.cpp文件提交给编译器。 </p>
<p>​        元对象代码是signal/slot机制所必须的。用moc产生的C++源文件必须和类实现一起进行编译和连接，或用#include语句将其包含到类的源文件中。moc并不扩展#include或#define宏定义,他只是简单的跳过所遇见的所有预处理指令。 </p>
<p>六、程式样例      这里给出了一个简单的样例程式，程式中定义了三个信号、三个槽函数，然后将信号和槽进行了关联，每个槽函数只是简单的弹出一个对话框窗口。读者能用kdevelop生成一个简单的QT应用程式，然后将下面的代码添加到相应的程式中去。      信号和槽函数的声明一般位于头文件中，同时在类声明的开始位置必须加上Q_OBJECT语句，这条语句是不可缺少的，他将告诉编译器在编译之前必须先应用 moc工具进行扩展。关键字signals指出随后开始信号的声明，这里signals用的是复数形式而非单数，siganls没有public、 private、protected等属性，这点不同于slots。另外，signals、slots关键字是QT自己定义的，不是C++中的关键字。  信号的声明类似于函数的声明而非变量的声明，左边要有类型，右边要有括号，如果要向槽中传递参数的话，在括号中指定每个形式参数的类型，当然，形式参数的个数能多于一个。      关键字slots指出随后开始槽的声明，这里slots用的也是复数形式。      槽的声明和普通函数的声明相同，能携带零或多个形式参数。既然信号的声明类似于普通C++函数的声明，那么，信号也可采用C++中虚函数的形式进行声明，即同名但参数不同。例如，第一次定义的void mySignal()没有带参数，而第二次定义的却带有参数，从这里我们能看到QT的信号机制是非常灵活的。  信号和槽之间的联系必须事先用connect函数进行指定。如果要断开二者之间的联系，能使用函数disconnect。 </p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;tsignal.h 
… 
 3 class TsignalApp:public QMainWindow 
 4 &#123; 
 5 Q_OBJECT 
 6 … 
 7 &#x2F;&#x2F;信号声明区 
 8 signals: 
 9 &#x2F;&#x2F;声明信号mySignal() 
10 void mySignal(); 
11 &#x2F;&#x2F;声明信号mySignal(int) 
12 void mySignal(int x); 
13 &#x2F;&#x2F;声明信号mySignalParam(int,int) 
14 void mySignalParam(int x,int y); 
15 &#x2F;&#x2F;槽声明区 
16 public slots: 
17 &#x2F;&#x2F;声明槽函数mySlot() 
18 void mySlot(); 
19 &#x2F;&#x2F;声明槽函数mySlot(int) 
20 void mySlot(int x); 
21 &#x2F;&#x2F;声明槽函数mySignalParam (int，int) 
22 void mySignalParam(int x,int y); 
23 &#125; 
24 … 
25 &#x2F;&#x2F;tsignal.cpp 
26 … 
27 TsignalApp::TsignalApp() 
28 &#123; 
29 … 
30 &#x2F;&#x2F;将信号mySignal()和槽mySlot()相关联 
31 connect(this,SIGNAL(mySignal()),SLOT(mySlot())); 
32 &#x2F;&#x2F;将信号mySignal(int)和槽mySlot(int)相关联 
33 connect(this,SIGNAL(mySignal(int)),SLOT(mySlot(int))); 
34 &#x2F;&#x2F;将信号mySignalParam(int,int)和槽mySlotParam(int,int)相关联 
35 connect(this,SIGNAL(mySignalParam(int,int)),SLOT(mySlotParam(int,int))); 
36 &#125; 
37 &#x2F;&#x2F; 定义槽函数mySlot() 
38 void TsignalApp::mySlot() 
39 &#123; 
40 QMessageBox::about(this,”Tsignal”, “This is a signal&#x2F;slot sample without 
41 parameter.”); 
42 &#125; 
43 &#x2F;&#x2F; 定义槽函数mySlot(int) 
44 void TsignalApp::mySlot(int x) 
45 &#123; 
46 QMessageBox::about(this,”Tsignal”, “This is a signal&#x2F;slot sample with one 
47 parameter.”); 
48 &#125; 
49 &#x2F;&#x2F; 定义槽函数mySlotParam(int,int) 
50 void TsignalApp::mySlotParam(int x,int y) 
51 &#123; 
52 char s[256]; 
53 sprintf(s,”x:%d y:%d”,x,y); 
54 QMessageBox::about(this,”Tsignal”, s); 
55 &#125; 
56 void TsignalApp::slotFileNew() 
57 &#123; 
58 &#x2F;&#x2F;发射信号mySignal() 
59 emit mySignal(); 
60 &#x2F;&#x2F;发射信号mySignal(int) 
61 emit mySignal(5); 
62 &#x2F;&#x2F;发射信号mySignalParam(5，100) 
63 emit mySignalParam(5,100); 
64 &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>七、应注意的问题  信号和槽机制是比较灵活的，但有些局限性我们必须了解，这样在实际的使用过程中做到有的放矢，避免产生一些错误。下面就介绍一下这方面的情况。  （1）信号和槽的效率是非常高的，不过同真正的回调函数比较起来，由于增加了灵活性，因此在速度上还是有所损失，当然这种损失相对来说是比较小的，通过在一台 i586-133的机器上测试是10微秒（运行Linux），可见这种机制所提供的简洁性、灵活性还是值得的。但如果我们要追求高效率的话，比如在实时系统中就要尽可能的少用这种机制。  （2）信号和槽机制和普通函数的调用相同，如果使用不当的话，在程式执行时也有可能产生死循环。因此，在定义槽函数时一定要注意避免间接形成无限循环，即在槽中再次发射所接收到的同样信号。例如,在前面给出的例子中如果在mySlot()槽函数中加上语句emit mySignal()即可形成死循环。  （3）如果一个信号和多个槽相联系的话，那么，当这个信号被发射时，和之相关的槽被激活的顺序将是随机的。  （4）宏定义不能用在signal和slot的参数中。  既然moc工具不扩展#define，因此，在signals和slots中携带参数的宏就不能正确地工作，如果不带参数是能的。例如，下面的例子中将带有参数的宏SIGNEDNESS(a)作为信号的参数是不合语法的： </p>
<pre class="line-numbers language-none"><code class="language-none">#ifdef ultrix 
#define SIGNEDNESS(a) unsigned a 
#else 
#define SIGNEDNESS(a) a 
#endif 
class Whatever : public QObject 
&#123; 
[…] 
signals: 
void someSignal( SIGNEDNESS(a) ); 
[…] 
&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（5）构造函数不能用在signals或slots声明区域内。  的确，将一个构造函数放在signals或slots区内有点不可理解，无论怎么，不能将他们放在</p>
<pre class="line-numbers language-none"><code class="language-none">private slots、protected slots或public slots区内。下面的用法是不合语法需求的： 
class SomeClass : public QObject 
&#123; 
Q_OBJECT 
public slots: 
SomeClass( QObject *parent, const char *name ) 
: QObject( parent, name ) &#123;&#125; &#x2F;&#x2F; 在槽声明区内声明构造函数不合语法 
[…] 
&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（6） 函数指针不能作为信号或槽的参数。  例如，下面的例子中将void (<em>applyFunction)(QList</em>, void*)作为参数是不合语法的： </p>
<pre class="line-numbers language-none"><code class="language-none">class someClass : public QObject 
&#123; 
Q_OBJECT 
[…] 
public slots: 
void apply(void (*applyFunction)(QList*, void*), char*); &#x2F;&#x2F; 不合语法 
&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你能采用下面的方法绕过这个限制： </p>
<pre class="line-numbers language-none"><code class="language-none">typedef void (*ApplyFunctionType)(QList*, void*); 
class someClass : public QObject 
&#123; 
Q_OBJECT 
[…] 
public slots: 
void apply( ApplyFunctionType, char *); 
&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（7）信号和槽不能有缺省参数。  既然signal-&gt;slot绑定是发生在运行时刻，那么，从概念上讲使用缺省参数是困难的。下面的用法是不合理的： </p>
<pre class="line-numbers language-none"><code class="language-none">class SomeClass : public QObject 
&#123; 
Q_OBJECT 
public slots: 
void someSlot(int x&#x3D;100); &#x2F;&#x2F; 将x的缺省值定义成100，在槽函数声明中使用是错误的 

&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（8）信号和槽也不能携带模板类参数。 </p>
<p>如果将信号、槽声明为模板类参数的话，即使moc工具不报告错误，也不可能得到预期的结果。例如，下面的例子中当信号发射时，槽函数不会被正确调用： </p>
<pre class="line-numbers language-none"><code class="language-none">[…] 
public slots: 
void MyWidget::setLocation (pair location); 
[…] 
public signals: 
void MyObject::moved (pair location); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过，你能使用typedef语句来绕过这个限制。如下所示： </p>
<pre class="line-numbers language-none"><code class="language-none">typedef pair IntPair; 
[…] 
public slots: 
void MyWidget::setLocation (IntPair location); 
[…] 
public signals: 
void MyObject::moved (IntPair location); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样使用的话，你就能得到正确的结果。 </p>
<p>（9）嵌套的类不能位于信号或槽区域内，也不能有信号或槽。 </p>
<p>例如，下面的例子中，在class B中声明槽b()是不合语法的，在信号区内声明槽b()也是不合语法的。 </p>
<pre class="line-numbers language-none"><code class="language-none">class A 
&#123; 
Q_OBJECT 
public: 
class B 
&#123; 
public slots: &#x2F;&#x2F; 在嵌套类中声明槽不合语法 
void b(); 
[….] 
&#125;; 
signals: 
class B 
&#123; 
&#x2F;&#x2F; 在信号区内声明嵌套类不合语法 
void b(); 
[….] 
&#125;: 
&#125;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（10）友元声明不能位于信号或槽声明区内。相反，他们应该在普通C++的private、protected或public区内进行声明。下面的例子是不合语法规范的： </p>
<pre class="line-numbers language-none"><code class="language-none">class someClass : public QObject 
&#123; 
Q_OBJECT 
[…] 
signals: &#x2F;&#x2F;信号定义区 
friend class ClassTemplate; &#x2F;&#x2F; 此处定义不合语法 
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>复习一下：</p>
<p>​        1）信号可以链接信号</p>
<p>​        2）一个信号可以链接多个槽函数</p>
<p>​        3）多个信号可以链接同一个槽函数</p>
<p>​        4）但是信号与槽函数的参数必须一一对应</p>
<p>这是我们练习生活实际是不难发现的！关于四，仔细看看！</p>
<pre class="line-numbers language-none"><code class="language-none">void (Teacher::*StringOne)(QString) &#x3D; &amp;Teacher::announceHungry;
void (student::*reacOne)(QString) &#x3D; &amp;student::reactions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        可以看到必须一 一对应！</p>
<p>​        5）信号的参数个数是可以多于槽的参数，也就是说，信号携带的信息必须多余槽需要的！</p>
<pre class="line-numbers language-none"><code class="language-none">void(A::*sig)(QString,int) &#x3D; &amp;A::singals;
void(B::*slot)(QString,int) &#x3D; &amp;B::slots;(√)

void(A::*sig)(QString,int) &#x3D; &amp;A::singals;
void(B::*slot)(int，QString) &#x3D; &amp;B::slots;(×)
必须一一对应<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        而在QT4之前，我们使用SIGNAL,SLOT宏链接的。</p>
<pre class="line-numbers language-none"><code class="language-none">connect(sig1,SIGNAL(signals()),slot1,SLOT(slot()))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="补充Lambda表达式"><a href="#补充Lambda表达式" class="headerlink" title="补充Lambda表达式"></a>补充Lambda表达式</h2><p>​        这是C++11的产物，我们由此创建一个匿名的函数以简化编程工作：</p>
<pre class="line-numbers language-none"><code class="language-none">[capture](parameters)mutable-&gt;return-type&#123;
	
	statements

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        人话：[函数对象参数]（操作符重载函数参数）mutable-&gt;返回值{函数体实现}</p>
<h3 id="1-函数对象参数"><a href="#1-函数对象参数" class="headerlink" title="1.函数对象参数"></a>1.函数对象参数</h3><p>​        [ ]，这标志Lambda表达式的开始，不允许省略！其中，空表示没有使用任何函数对象。</p>
<p>​        [=] : 函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this），并且传递方式是值传递</p>
<p>​        [&amp;]： 函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this），并且传递方式是引用传递。</p>
<p>​        这是一个修改的demo.</p>
<pre class="line-numbers language-none"><code class="language-none">[&#x3D;]()&#123;
   btn2-&gt;setText(&quot;Lol&quot;);
&#125;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        最后的（）表示的是当地声明马上调用</p>
<p>​        [this] :函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this和内部成员的变量），并且传递方式是值传递</p>
<p>​        [varName] 只认识varName，其他都看不见到，用于仅操作一个变量的匿名表达式</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230419202055676.png?lastModify=1685936981" alt="image-20230419202055676"></p>
<p>​        当然后面的很少使用！</p>
<p>​        mutable关键字：可以修改按值传递进来的拷贝</p>
<p>​        可以观察这个代码</p>
<pre class="line-numbers language-none"><code class="language-none">QPushButton* btn2 &#x3D; new QPushButton(&quot;this is a btn2&quot;,this);
int n &#x3D; 10;
connect(btn2,&amp;QPushButton::clicked,this,[n]()mutable&#123;n&#x3D;110,qDebug()&lt;&lt;n;&#125;);
QPushButton* btn3 &#x3D; new QPushButton(&quot;this is a btn3&quot;,this);
btn3-&gt;move(100,100);
connect(btn3,QPushButton::clicked,this,[&#x3D;]()mutable&#123;qDebug()&lt;&lt;n;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        你会发现，点击btn2之后又点击btn3，发现并没有修改n，说明确实只是更改了拷贝而已！</p>
<p>​        下面来用一下，复盘一下我们学习的知识，那就是设计一个按钮，位于图片中学附近，且点击之后可以使传入的一个值+=10，同时打印信息：From lambda’s reactions!</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);
    resize(640,480);
    btn-&gt;move(320,240);
    connect(btn,&amp;QPushButton::clicked,this,[]()&#123;qDebug()&lt;&lt;&quot;From lambda&#39;s reactions!&quot;;&#125;);
    unsigned int m &#x3D; 10;
    connect(btn,&amp;QPushButton::clicked,this,[m]()mutable&#123;m+&#x3D;10;qDebug()&lt;&lt;m;&#125;);
&#125;

Widget::~Widget()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        返回值：就是在（）后写 -&gt; type随后写实现！</p>
<pre class="line-numbers language-none"><code class="language-none">[]()-&gt;int&#123;return 1000&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如</p>
<pre class="line-numbers language-none"><code class="language-none">int in &#x3D; 10;
  int res &#x3D; [&#x3D;]()-&gt;int&#123;return in*in;&#125;();
  qDebug() &lt;&lt; res;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        又如点击按钮关闭窗口的demo:</p>
<pre class="line-numbers language-none"><code class="language-none">QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);
resize(640,480);
btn-&gt;move(320,240);
connect(btn,&amp;QPushButton::clicked,this,&amp;Widget::close);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        好吧，那又加一个打印log?转向Lambda就好了</p>
<pre class="line-numbers language-none"><code class="language-none">QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);
resize(640,480);
btn-&gt;move(320,240);
connect(btn,&amp;QPushButton::clicked,this,[this]()&#123;this-&gt;close();qDebug()&lt;&lt;&quot;Windows is closed!&quot;;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>QMainWindow是一个为用户提供主窗口程序的类，它包含一个菜单栏，多个工具栏，多个铆接部件，一个状态栏和一个中心部件，是多个应用程序的基础，如文本编辑器，图片编辑器等等</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425213236864.png?lastModify=1685936981" alt="image-20230425213236864"></p>
<p>​        现在我们尝试创建一个QMainWindow，并运行之：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425213429856.png?lastModify=1685936981" alt="image-20230425213429856"></p>
<p>​        好小！调整一下，在MainWindow里头resize一下完事！</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;mainwindow.h&quot;

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
	resize(640,480);
&#125;

MainWindow::~MainWindow()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425213559077.png?lastModify=1685936981" alt="image-20230425213559077"></p>
<p>​        下面创建一个菜单栏，他是QMenuBar类的</p>
<pre class="line-numbers language-none"><code class="language-none">QMenuBar* bar &#x3D; menuBar();

&#x2F;&#x2F; 设置当前窗口的菜单栏

setMenuBar(bar);

&#x2F;&#x2F; 设定名称
&#x2F;&#x2F; 事实上不是这样用的，但是为了展示效果如此
bar-&gt;addMenu(&quot;文件&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425214129151.png?lastModify=1685936981" alt="image-20230425214129151"></p>
<p>​        好吧，事实上是我们是使用一个菜单对象来接受之：</p>
<pre class="line-numbers language-none"><code class="language-none">QMenu* fileMenu &#x3D; bar-&gt;addMenu(&quot;文件&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们这样做是为了后续的其他操作！比如说，现在我们想点击它让他下拉一个菜单来，那就</p>
<pre class="line-numbers language-none"><code class="language-none">fileMenu-&gt;addAction(&quot;新建&quot;);
   
&#x2F;&#x2F;添加一个分割符
fileMenu-&gt;addSeparator();
   
fileMenu-&gt;addAction(&quot;打开&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425214843993.png?lastModify=1685936981" alt="image-20230425214843993"></p>
<h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;工具栏

 QToolBar* toolBar &#x3D; new QToolBar(this);
 addToolBar(toolBar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​            这个流程为我们的窗口添加了一个工具栏</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425215242772.png?lastModify=1685936981" alt="image-20230425215242772"></p>
<p>​        看到有变化！是的就是我们的工具栏。</p>
<p>​        工具栏是允许有多个的！我们再仔细瞧瞧其他的add重载函数！</p>
<p>​        这个引起了我们的注意</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425215627044.png?lastModify=1685936981" alt="image-20230425215627044"></p>
<p>​        这个函数究竟实现了啥功能呢？把这个函数扔进QT  帮助手册里</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425215808333.png?lastModify=1685936981" alt="image-20230425215808333"></p>
<p>​        这个地方，点击第一个参数的类去</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425215834180.png?lastModify=1685936981" alt="image-20230425215834180"></p>
<p>​        很明显了！就是再说这个工具栏初始时停靠在哪里！</p>
<pre class="line-numbers language-none"><code class="language-none">addToolBar(Qt::LeftToolBarArea,toolBar);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230425215957733.png?lastModify=1685936981" alt="image-20230425215957733"></p>
<p>​        这是设计默认区域。总结一下</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;mainwindow.h&quot;
#include&lt;QMenuBar&gt;
#include&lt;QToolBar&gt;
#include&lt;QDebug&gt;

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
    &#x2F;&#x2F;重置窗口大小
    resize(640,480);


    &#x2F;&#x2F;创建菜单栏，最多只能有一个
    QMenuBar* bar&#x3D; menuBar();
    &#x2F;&#x2F;设置显示窗口为当前窗口
    setMenuBar(bar);
    &#x2F;&#x2F;菜单
    QMenu* fileMenu &#x3D; bar-&gt;addMenu(&quot;文件&quot;);

    QMenu* editMenu &#x3D; bar-&gt;addMenu(&quot;编辑&quot;);
    &#x2F;&#x2F;添加菜单项
    fileMenu-&gt;addAction(&quot;新建&quot;);
    &#x2F;&#x2F;添加分隔符
    fileMenu-&gt;addSeparator();

    fileMenu-&gt;addAction(&quot;打开&quot;);
    &#x2F;&#x2F;添加工具栏
    QToolBar* toolBar &#x3D; new QToolBar(this);
    addToolBar(Qt::LeftToolBarArea,toolBar);
    
    
&#125;

MainWindow::~MainWindow()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下面说说它只允许停靠在一个方向。我们可以查看QToolBar的成员函数：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; constructor
QToolBar(const QString &amp;title, QWidget *parent &#x3D; Q_NULLPTR)

QToolBar(QWidget *parent &#x3D; Q_NULLPTR)
&#x2F;&#x2F; destructor
~QToolBar()
QAction *
actionAt(const QPoint &amp;p) const
QAction *
actionAt(int x, int y) const
QAction *
addAction(const QString &amp;text)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text)
QAction *
addAction(const QString &amp;text, const QObject *receiver, const char *member)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *receiver, const char *member)
QAction *
addAction(const QString &amp;text, const QObject *receiver, PointerToMemberFunction method)
QAction *
addAction(const QString &amp;text, Functor functor)
QAction *
addAction(const QString &amp;text, const QObject *context, Functor functor)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *receiver, PointerToMemberFunction method)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, Functor functor)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *context, Functor functor)
QAction *
addSeparator()
QAction *
addWidget(QWidget *widget)
Qt::ToolBarAreas 
allowedAreas() const
void 
clear()
QSize 
iconSize() const
QAction *
insertSeparator(QAction *before)
QAction *
insertWidget(QAction *before, QWidget *widget)
bool 
isAreaAllowed(Qt::ToolBarArea area) const
bool 
isFloatable() const
bool 
isFloating() const
bool 
isMovable() const
Qt::Orientation 
orientation() const
void 
setAllowedAreas(Qt::ToolBarAreas areas)
void 
setFloatable(bool floatable)
void 
setMovable(bool movable)
void 
setOrientation(Qt::Orientation orientation)
QAction *
toggleViewAction() const
Qt::ToolButtonStyle 
toolButtonStyle() const
QWidget *
widgetForAction(QAction *action) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        看到</p>
<pre class="line-numbers language-none"><code class="language-none">bool 
isAreaAllowed(Qt::ToolBarArea area) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        不正是表明停靠范围！</p>
<pre class="line-numbers language-none"><code class="language-none">toolBar-&gt;setAllowedAreas(Qt::RightToolBarArea|Qt::LeftToolBarArea);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        以及设置是否可以浮动：</p>
<pre class="line-numbers language-none"><code class="language-none">toolBar-&gt;setFloatable(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        甚至可以设置是否可以移动！</p>
<pre class="line-numbers language-none"><code class="language-none">toolBar-&gt;setMovable(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        下面设置内容：</p>
<pre class="line-numbers language-none"><code class="language-none">toolBar-&gt;addAction(&quot;这是action 1&quot;);

toolBar-&gt;addAction(&quot;这是action2&quot;);

&#x2F;&#x2F;使用这个方法表明的是跟菜单栏是公用同一个功能的！
&#x2F;&#x2F;需要接受返回值
&#x2F;&#x2F;QAction* newAct &#x3D; fileMenu-&gt;addAction(&quot;新建&quot;);
toolBar-&gt;addAction(openAct);
&#x2F;&#x2F;其他类似
toolBar-&gt;addAction(newAct);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        工具栏也可以添加分割线：</p>
<pre class="line-numbers language-none"><code class="language-none">toolBar-&gt;addSeparator();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        还可以添加控件！！！</p>
<pre class="line-numbers language-none"><code class="language-none">QPushButton* btn &#x3D; new QPushButton(&quot;a btn for the toolBar&quot;,this);

toolBar-&gt;addWidget(btn);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>​        最多也只能有一个</p>
<pre class="line-numbers language-none"><code class="language-none">QStatusBar* stbar &#x3D; statusBar();

setStatusBar(stbar);

QLabel* lab &#x3D; new QLabel(&quot;a mentions&quot;,this);
&#x2F;&#x2F; QLable是Widget控件
stbar-&gt;addWidget(lab);&#x2F;&#x2F; 左侧
QLabel* lab2 &#x3D; new QLabel(&quot;2 mentions&quot;,this);
stbar-&gt;addPermanentWidget(lab2);&#x2F;&#x2F;右侧<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        也可以添加铆接部件，可以有多个</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;铆接部件（可以一大堆）
QDockWidget* dock &#x3D; new QDockWidget(this);
addDockWidget(Qt::BottomDockWidgetArea,dock);
&#x2F;&#x2F;设置中心部件.可以别让浮动窗口占据窗口
QTextEdit* edit &#x3D; new QTextEdit(this);
setCentralWidget(edit);
dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对于全局者，都是set,只能有一个，反之可以多个（add_）</p>
<p>​        回顾一下：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;mainwindow.h&quot;
#include&lt;QMenuBar&gt;
#include&lt;QToolBar&gt;
#include&lt;QDebug&gt;
#include&lt;QPushButton&gt;
#include&lt;QStatusBar&gt;
#include&lt;QLabel&gt;
#include&lt;QDockWidget&gt;
#include&lt;QTextEdit&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
    &#x2F;&#x2F;重置窗口大小
    resize(1640,880);


    &#x2F;&#x2F;创建菜单栏，最多只能有一个
    QMenuBar* bar&#x3D; menuBar();
    &#x2F;&#x2F;设置显示窗口为当前窗口
    setMenuBar(bar);
    &#x2F;&#x2F;菜单
    QMenu* fileMenu &#x3D; bar-&gt;addMenu(&quot;文件&quot;);

    QMenu* editMenu &#x3D; bar-&gt;addMenu(&quot;编辑&quot;);
    &#x2F;&#x2F;添加菜单项
    QAction* newAct&#x3D; fileMenu-&gt;addAction(&quot;新建&quot;);
    &#x2F;&#x2F;添加分隔符
    fileMenu-&gt;addSeparator();

     QAction* openAct&#x3D; fileMenu-&gt;addAction(&quot;打开&quot;);
    &#x2F;&#x2F;添加工具栏
    QToolBar* toolBar &#x3D; new QToolBar(this);
    addToolBar(Qt::LeftToolBarArea,toolBar);
    &#x2F;&#x2F;设置允许停靠区域
    toolBar-&gt;setAllowedAreas(Qt::RightToolBarArea|Qt::LeftToolBarArea);
    &#x2F;&#x2F;设置行为
    toolBar-&gt;addAction(&quot;这是action 1&quot;);

    toolBar-&gt;addAction(&quot;这是action2&quot;);

    toolBar-&gt;addAction(openAct);

    toolBar-&gt;addSeparator();

    toolBar-&gt;addAction(newAct);
    &#x2F;&#x2F;放置控件
    QPushButton* btn &#x3D; new QPushButton(&quot;a btn for the toolBar&quot;,this);

    toolBar-&gt;addWidget(btn);

    &#x2F;&#x2F;状态栏
    QStatusBar* stbar &#x3D; statusBar();

    setStatusBar(stbar);
    &#x2F;&#x2F;加点东西
    QLabel* lab &#x3D; new QLabel(&quot;a mentions&quot;,this);
    &#x2F;&#x2F; QLable是Widget控件
    stbar-&gt;addWidget(lab);
    QLabel* lab2 &#x3D; new QLabel(&quot;2 mentions&quot;,this);
    stbar-&gt;addPermanentWidget(lab2);

    &#x2F;&#x2F;铆接部件（可以一大堆）
    QDockWidget* dock &#x3D; new QDockWidget(this);
    addDockWidget(Qt::BottomDockWidgetArea,dock);

    &#x2F;&#x2F;设置中心部件.可以别让浮动窗口占据窗口
    QTextEdit* edit &#x3D; new QTextEdit(this);
    setCentralWidget(edit);
    dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea);
&#125;

MainWindow::~MainWindow()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="添加资源文件"><a href="#添加资源文件" class="headerlink" title="添加资源文件"></a>添加资源文件</h2><p>​        我们现在打开UI设计一栏，现在可以直接开始先设计后构建代码逻辑了</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230514102111415.png?lastModify=1685936981" alt="image-20230514102111415"></p>
<p>​        菜单项必须必须输入英文，这是因为跟变量命名有关，可以后续改动text 值来改变显示</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230514101928675.png?lastModify=1685936981" alt="image-20230514101928675"></p>
<p>​        其他就不多阐述了，类似的。</p>
<p>​        如何使用代码访问ui呢？会带mainwindow.cpp</p>
<pre class="line-numbers language-none"><code class="language-none">MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this); &#x2F;&#x2F; 类似于这样的！
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        添加一个图标吧：</p>
<pre class="line-numbers language-none"><code class="language-none">ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;D:&#x2F;QT projects&#x2F;9&#x2F;source&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        首先先把资源放到项目目录路径下，不然肯定找不到！</p>
<p>​        如何快速的在项目中添加文件呢？先去右键项目：添加性文件，选择QT下的Qt resource files</p>
<p>​        然后，添加：会发现要求你写一个前缀，这是为了分类资源文件。可以偷懒直接写一个\</p>
<p>​        在项目中引用只需要按照格式：</p>
<pre class="line-numbers language-none"><code class="language-none">: + prefix + fileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        也即是: + 前缀加上文件名即可</p>
<pre class="line-numbers language-none"><code class="language-none">ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;:&#x2F;source&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    可是我们的点击事件还是没有任何反应。下面使用信号与槽让他动起来</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QDialog&gt;
#include&lt;QDebug&gt;
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F; 点击新建按钮来弹出对话框

    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;
        &#x2F;&#x2F; 对话框 分类
        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）
        QDialog dlg(this);  &#x2F;&#x2F;创建一个
        dlg.exec();

        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;
    &#125;);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230516215248714.png?lastModify=1685936981" alt="image-20230516215248714"></p>
<p>​        出现这样的警告，说明是对话框太小了，需要调整</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230516215825806.png?lastModify=1685936981" alt="image-20230516215825806"></p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QDialog&gt;
#include&lt;QDebug&gt;
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F; 点击新建按钮来弹出对话框

    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;
        &#x2F;&#x2F; 对话框 分类
        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）
        QDialog dlg(this);
        dlg.resize(100,200);
        dlg.exec();
        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;
    &#125;);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        那我们现在来看一个非模糊的：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QDialog&gt;
#include&lt;QDebug&gt;
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F; 点击新建按钮来弹出对话框

    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;
        &#x2F;&#x2F; 对话框 分类
        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）
&#x2F;&#x2F;        QDialog dlg(this);
&#x2F;&#x2F;        dlg.resize(100,200);
&#x2F;&#x2F;        dlg.exec();
        QDialog* dig &#x3D; new QDialog(this); &#x2F;&#x2F; 不可以开栈上，对象一show完就没了！
        dig-&gt;resize(100,200);
        dig-&gt;show();
        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;
    &#125;);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        为了防止用户一直点，一直创建对话框，我们可以设置关闭就删掉的属性</p>
<pre class="line-numbers language-none"><code class="language-none">dig-&gt;setAttribute(Qt::WA_DeleteOnClose);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="消息对话框"><a href="#消息对话框" class="headerlink" title="消息对话框"></a>消息对话框</h2><p>​        系统自己提供了大量的对话框，如：</p>
<p>​        QColorDialog                选择颜色</p>
<p>​        QFileDialog                    选择文件或者目录</p>
<p>​        QFontDialog                    选择字体</p>
<p>​        QInputDialog                允许用户输入一个值</p>
<p>​        QMessageDialog            模态对话框</p>
<p>​        QPageSetUpDialog        为打印机提供相关选项</p>
<p>​        QPrintDialog                    打印机配置</p>
<p>​        QPrintPreviewDialog        打印预览</p>
<p>​        QProcessDialog                显示操作过程</p>
<p>​        我们现在着重看看消息框是啥情况！在帮助文档下搜索QMessageBox</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519123236586.png?lastModify=1685936981" alt="image-20230519123236586"></p>
<p>​        下面显示之。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;

QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    ui.setupUi(this);

    QMessageBox::critical(this, &quot;critical&quot;, &quot;666&quot;);
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519123918761.png?lastModify=1685936981" alt="image-20230519123918761"></p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;

QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    ui.setupUi(this);

    QMessageBox::information(this, &quot;information&quot;, &quot;666&quot;);
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>C++</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519124310043.png?lastModify=1685936981" alt="image-20230519124310043"></p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;

QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    ui.setupUi(this);

    QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;);
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519124401064.png?lastModify=1685936981" alt="image-20230519124401064"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519124448267.png?lastModify=1685936981" alt="image-20230519124448267"></p>
<p>​        于是可以更改参数就好了。</p>
<pre class="line-numbers language-none"><code class="language-none">QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;,QMessageBox::Save|QMessageBox::Cancel);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519124653246.png?lastModify=1685936981" alt="image-20230519124653246"></p>
<p>​        这个函数参数是这样的：</p>
<p>​        参数1：父类</p>
<p>​        参数2：标题</p>
<p>​        参数3：提示内容</p>
<p>​        参数4：按键类型</p>
<p>​        参数5：默认回车关联的按键</p>
<p>​        返回参数：用户选择</p>
<p>如：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;
#include&lt;tchar.h&gt;
QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    setLocale(QLocale::AnyLanguage);
    ui.setupUi(this);

    if (QMessageBox::Save &#x3D;&#x3D; QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;, QMessageBox::Save | QMessageBox::Cancel)) &#123;
        qDebug() &lt;&lt; &quot;you clicked the save&quot;;
    &#125;
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        想看Debug信息去项目属性那里更改一下输出为控制台即可！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519125534877.png?lastModify=1685936981" alt="image-20230519125534877"></p>
<p>​        来看看其他demo:</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;
#include&lt;qcolordialog.h&gt;
#include&lt;qcolor.h&gt;
QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    setLocale(QLocale::AnyLanguage);
    ui.setupUi(this);

    QColor color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));
    qDebug() &lt;&lt; &quot;r &#x3D; &quot; &lt;&lt; color.red() &lt;&lt; &quot;g &#x3D; &quot; &lt;&lt; color.green() &lt;&lt; &quot;h &#x3D; &quot; &lt;&lt; color.blue() ;
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519125944025.png?lastModify=1685936981" alt="image-20230519125944025"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519125950425.png?lastModify=1685936981" alt="image-20230519125950425"></p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;
#include&lt;qcolordialog.h&gt;
#include&lt;qcolor.h&gt;
#include&lt;qfile.h&gt;
#include&lt;qfiledialog.h&gt;
QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    setLocale(QLocale::AnyLanguage);
    ui.setupUi(this);

    &#x2F;*QColor color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));
    qDebug() &lt;&lt; &quot;r &#x3D; &quot; &lt;&lt; color.red() &lt;&lt; &quot;g &#x3D; &quot; &lt;&lt; color.green() &lt;&lt; &quot;h &#x3D; &quot; &lt;&lt; color.blue() ;*&#x2F;

&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;
    QFileDialog::getOpenFileName(

        this,&#x2F;&#x2F; 设置父亲
        &quot;open the file&quot;, &#x2F;&#x2F; caption
        &#x2F;&#x2F;目录
        &quot;D:\\&quot;&#x2F;&#x2F;文件夹
        &quot;(*.txt)&quot;&#x2F;&#x2F;过滤器，回忆Linux通配符就好了！
    );

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519130333549.png?lastModify=1685936981" alt="image-20230519130333549"></p>
<p>​        返回的是文件的路径！这个可以注意一下！</p>
<h2 id="登录窗口界面布局介绍"><a href="#登录窗口界面布局介绍" class="headerlink" title="登录窗口界面布局介绍"></a>登录窗口界面布局介绍</h2><p>​        现在使用Widget控件把一些模块分类装之，随后垂直布局，就是这样</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519131530620.png?lastModify=1685936981" alt="image-20230519131530620"></p>
<h2 id="QListWidget空间"><a href="#QListWidget空间" class="headerlink" title="QListWidget空间"></a>QListWidget空间</h2><p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230523200845020.png?lastModify=1685936981" alt="image-20230523200845020"></p>
<p>​        是的！从这里拖一个QListWidget控件出来！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230523201158972.png?lastModify=1685936981" alt="image-20230523201158972"></p>
<p>​        代码里如上图所示，运行：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230523201220072.png?lastModify=1685936981" alt="image-20230523201220072"></p>
<p>​        也可以使用类似于list的容器放置一大堆内容：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include &lt;QListWidgetItem&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    QListWidgetItem* item &#x3D; new QListWidgetItem(&quot;锄禾日当午&quot;);

    ui-&gt;listWidget-&gt;addItem(item);

    item-&gt;setTextAlignment(Qt::AlignHCenter);

    &#x2F;&#x2F; QStringList      List&lt;String&gt;
    QStringList list;
    list &lt;&lt; &quot;锄禾日当午&quot;&lt;&lt;&quot;汗&quot;;
    ui-&gt;listWidget-&gt;addItems(list);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230523201833675.png?lastModify=1685936981" alt="image-20230523201833675"></p>
<p>对话框是 GUI 程序中不可或缺的组成部分。一些不适合在主窗口实现的功能组件都必须放在对话框中设置。对话框通常会是一个顶层窗口，出现在程序最上层，用于实现短期任务或者简洁的用户交互。所谓标准对话框，是 Qt 内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同。</p>
<p>Qt常用的内置对话框有QFileDialog、QColorDialog、QFontDialog、QInputDialog和QMessageBox。下面对这些对话框做一些简单示例。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230605105705746.png?lastModify=1685936981" alt="image-20230605105705746"></p>
<p>QFileDialog文件对话框 </p>
<p>文件对话框可以通过调用QFileDialog::getOpenFileName方法实现，方法的第一个参数指定窗体的父窗体、第二个参数指定窗体的标题、第三个参数指定窗体的打开目录、第四个参数用于限定打开的文件类型，有多个类型时中间用;;隔开。下面程序演示了当用户点击按钮后会弹出文件对话框，之后将用户选择的文件路劲显示在文本框中。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;文件对话框
void Dialog::ShowFileDlg()
&#123;
    &#x2F;&#x2F;打开文件对话框
    &#x2F;&#x2F;函数返回打开的路径
    QString sPath &#x3D; QFileDialog::getOpenFileName(
                this,&#x2F;&#x2F;指定父窗口
                &quot;标准文件对话框&quot;,&#x2F;&#x2F;打开文件对话框的标题
                &quot;.&quot;,&#x2F;&#x2F;打开目录，&quot;.&quot; 表示当前目录
                &quot;C++ files(*.cpp);;&quot;
                 &quot;C files(*.c);;&quot;
                &quot;Header files(*.h)&quot;&#x2F;&#x2F;设置文件过滤器，有多个条件时中间以两个;;隔开
                );
    m_fileEdit-&gt;setText(sPath);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        m_fileEdit是一个QLineEdit部件名，用来显示用户打开文件的路径。 </p>
<p>​         QColorDialog颜色对话框         颜色对话框可以通过调用QColorDialog::getColor方法实现，方法的第一个参数表示默认选择的颜色。该方法会返回一个颜色类。</p>
<pre class="line-numbers language-none"><code class="language-none">void Dialog::ShowColorDlg()
&#123;
    QColor color &#x3D; QColorDialog::getColor(
                Qt::yellow&#x2F;&#x2F;默认选择的颜色
                );
    &#x2F;&#x2F;判断颜色选择是否合法
    if(color.isValid())&#123;
        &#x2F;&#x2F;设置边宽颜色
        m_colorFrame-&gt;setPalette(QPalette(color));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> m_colorFram是一个QFrame类型，用来展示用户选择的颜色</p>
<p>QFontDialog字体对话框 字体对话框可以通过调用QFontDialog::getFont方法实现，该方法需要传入一个bool类型的参数用来接收函数是否成功执行，方法会返回一个字体字体类。</p>
<p>//字体对话框</p>
<pre class="line-numbers language-none"><code class="language-none">void Dialog::ShowFontDlg()
&#123;
    bool ok;&#x2F;&#x2F;接收函数是否执行成功
    QFont font &#x3D; QFontDialog::getFont(
                    &amp;ok&#x2F;&#x2F;接收函数是否执行成功
                );
    if(ok)&#123;
        &#x2F;&#x2F;设置字体
        m_fontEdit-&gt;setFont(font);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> m_fontEdit是一个QLineEdit类型，用来展示用户选择的字体效果</p>
<p>QInputDialog输入对话框</p>
<p>设置姓名，可以调用的是QInputDialog::getText( )方法用来获取输入的单行文本。方法的第一个参数指定父窗体，第二个参数指定对话框的标题，第三个参数指定对话框显示的内容，第四个参数纸档输入框的模式，第五个参数指定默认值，第六个参数是一个bool类型用来接收函数是否执行成功。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;文本输入对话框
void InputDlg::editName()&#123;
    bool ok;
    QString strName &#x3D; QInputDialog::getText(
                this,&#x2F;&#x2F;指定父窗体
                &quot;标准文本输入对话框&quot;,&#x2F;&#x2F;指定对话框标题
                &quot;请编辑姓名&quot;,&#x2F;&#x2F;提示字符串
                QLineEdit::Normal,&#x2F;&#x2F;输入框显示模式
                m_nameLabel-&gt;text(),&#x2F;&#x2F;输入框的默认文本
                &amp;ok&#x2F;&#x2F;接收函数调用是否成功
                &#x2F;&#x2F;最后一个参数表示窗体风格，这里采用默认的
                );
    if(ok &amp;&amp; !strName.isEmpty())&#123;
        m_nameLabel-&gt;setText(strName);
    &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置性别，可以调用的是QInputDialog::getItem( ) 方法用来获取用户从下拉列表选择的值。QInputDialog第三个参数用来设置下拉列表框，要传入一个QStringList类型的值。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;条目输入对话框
void InputDlg::editSex()&#123;
    QStringList sexList;
    bool ok;
    sexList&lt;&lt;&quot;男&quot;&lt;&lt;&quot;女&quot;&lt;&lt;&quot;未知&quot;;
    &#x2F;&#x2F;可选项是QString 类型，接收也是QString
    QString strSex &#x3D; QInputDialog::getItem(
                this,
                &quot;标准条目输入对话框&quot;,&#x2F;&#x2F;指定对话框标题
                &quot;请选择性别&quot;,    &#x2F;&#x2F;指定显示内容
                sexList,&#x2F;&#x2F;设置可选项，可选项是一个QStringList类型
                0,&#x2F;&#x2F;设置默认选选项
                false,&#x2F;&#x2F;是否可编辑
                &amp;ok&#x2F;&#x2F;接收函数是否调用成功
                );
    if(ok &amp;&amp; !strSex.isEmpty())&#123;
        m_sexLabel-&gt;setText(strSex);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置年龄，可以调用QInputDialog::getInt方法用来获取用户填入的整数值。getInt方法的第四个参数和第五个参数分别用来设置整数的最小值和最大值，第六个参数用来设置步长，即点击增加按钮时每次增加的值。</p>
<pre class="line-numbers language-none"><code class="language-none">void InputDlg::editAge()&#123;
    bool ok;
    int age &#x3D; QInputDialog::getInt(
                this,
                &quot;标注int数据类型输入对话框&quot;,&#x2F;&#x2F;对话框标题
                &quot;请编辑年龄&quot;,&#x2F;&#x2F;对话框显示的内容
                m_ageLabel-&gt;text().toInt(),&#x2F;&#x2F;默认值
                0,&#x2F;&#x2F;最小值
                120,&#x2F;&#x2F;最大值
                1,&#x2F;&#x2F;步长
                &amp;ok&#x2F;&#x2F;接收函数是否调用成功
                );
    if(ok)&#123;
        m_ageLabel-&gt;setText(QString(&quot;%1&quot;).arg(age));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        设置分数，可以调用QInputDialog::getDouble方法用来获取用户填入的浮点数值。getDouble方法的第四个参数和第五个参数分别用来设置整数的最小值和最大值，第六个参数用来设置精度，即点数据的小数位。</p>
<pre class="line-numbers language-none"><code class="language-none">void InputDlg::editScore()&#123;
    bool ok;
    double score &#x3D; QInputDialog::getDouble(
                this,&#x2F;&#x2F;设置父窗体
                &quot;标准double数据类型输入对话框&quot;,&#x2F;&#x2F;对话框标题
                &quot;请编辑分数&quot;,&#x2F;&#x2F;对话框显示的内容
                m_scoreLabel-&gt;text().toDouble(),&#x2F;&#x2F;默认值
                0,&#x2F;&#x2F;最小值
                100,&#x2F;&#x2F;最大值
                1,&#x2F;&#x2F;精度
                &amp;ok&#x2F;&#x2F;接收函数是否执行成功
                );
    if(ok)&#123;
        m_scoreLabel-&gt;setText(QString::number(score));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        QMessageBox消息框</p>
<p>​        问题消息框，可以调用QMessageBox::question() 显示问题消息框，问题消息框可设置要显示的按钮，方法会返回一个枚举类型表示用户所点击的按钮。这里设置的是“确定”和“取消”按钮。</p>
<pre class="line-numbers language-none"><code class="language-none">void MsgBoxDlg::showQuestionMsgDlg() &#123;
    m_tipLabel-&gt;setText(&quot;问题消息框&quot;);
    int res &#x3D; QMessageBox::question(
                this,&#x2F;&#x2F;指定父窗体
                &quot;问题消息框&quot;,&#x2F;&#x2F;指定标题
                &quot;已打开问题消息框，是否关闭？&quot;,&#x2F;&#x2F;显示的文本
                QMessageBox::Ok|QMessageBox::Cancel,&#x2F;&#x2F;标注按钮
                QMessageBox::Ok&#x2F;&#x2F;默认选择的按钮
                );
    switch (res) &#123;
    case QMessageBox::Ok:
        m_tipLabel-&gt;setText(&quot;问题消息框 - 确定&quot;);
        break;
    case QMessageBox::Cancel:
        m_tipLabel-&gt;setText(&quot;问题消息框 - 取消&quot;);
        break;
    default:
        break;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>信息消息框，可以调用QMessageBox::information( )方法实现，信息消息框的作用是给用户展示一段消息，无需用户做出操作，函数参数也比较简单。</p>
<pre class="line-numbers language-none"><code class="language-none">void MsgBoxDlg::showInformationMsgDlg() &#123;
    m_tipLabel-&gt;setText(&quot;信息消息框&quot;);
    QMessageBox::information(
                this,&#x2F;&#x2F;父窗体
                &quot;信息提示框&quot;,&#x2F;&#x2F;标题
                &quot;这是个信息提示框&quot;&#x2F;&#x2F;文本内容
                );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        警告消息框，可以调用QMessageBox::waring方法，警告消息框同样可以设置消息框的按钮，方法会一个枚举类型表示用户的操作。这里设置的是“保存”、“忽视”和“取消”按钮。</p>
<pre class="line-numbers language-none"><code class="language-none">void MsgBoxDlg::showWarningMsgDlg() &#123;
    m_tipLabel-&gt;setText(&quot;警告消息框&quot;);
    int res &#x3D; QMessageBox::warning(
                this,&#x2F;&#x2F;父窗体
                &quot;警告消息框&quot;,&#x2F;&#x2F;标题
                &quot;有为保存的文件&quot;,&#x2F;&#x2F;警告内容
                QMessageBox::Save|QMessageBox::Discard|QMessageBox::Cancel,
                QMessageBox::Save&#x2F;&#x2F;默认选择的按钮
                );
    switch (res) &#123;
    case QMessageBox::Save:
        m_tipLabel-&gt;setText(&quot;警告提示框 - 保存&quot;);
        break;
    case QMessageBox::Discard:
        m_tipLabel-&gt;setText(&quot;警告提示框 - 忽视&quot;);
        break;
    case QMessageBox::Cancel:
        m_tipLabel-&gt;setText(&quot;警告提示框 - 取消&quot;);
        break;
    default:
        break;
    &#125;
&#125;		错误消息框，可以调用QMessageBox::critical方法，错误消息框也相当于一种消息提醒，会比信息消息框的效果显目，调用方法和信息消息框类似。
void MsgBoxDlg::showCriticalMsgDlg() &#123;
    m_tipLabel-&gt;setText(&quot;错误消息框&quot;);
    QMessageBox::critical(
                this,&#x2F;&#x2F;父窗体
                &quot;错误消息框&quot;,&#x2F;&#x2F;标题
                &quot;发生重大错误！！&quot;&#x2F;&#x2F;显示内容
                );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        关于消息框，调用QMessageBox::about方法，关于消息框也是一种消息提醒，调用方法与信息消息框类似。</p>
<pre class="line-numbers language-none"><code class="language-none">void MsgBoxDlg::showAboutMsgDlg() &#123;
    m_tipLabel-&gt;setText(&quot;关于消息框&quot;);
    QMessageBox::about(
                this,&#x2F;&#x2F;父窗体
                &quot;关于消息框&quot;,&#x2F;&#x2F;标题
                &quot;这是个关于休斯顿的信息&quot;&#x2F;&#x2F;显示内容
                );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        关于QT消息框，调用QMessageBox::aboutQt方法，关于QT消息框会弹出一个有关QT的信息。其他功能暂无。</p>
<pre class="line-numbers language-none"><code class="language-none">void MsgBoxDlg::showAboutQtMsgDlg() &#123;
    m_tipLabel-&gt;setText(&quot;关于QT消息框&quot;);
    QMessageBox::aboutQt(
                this,&#x2F;&#x2F;父窗体
                &quot;关于QT消息框&quot;&#x2F;&#x2F;标题
                );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        自定义消息框         自定义消息框设置了一个图标和三个按钮，其中两个按钮采用自定义形式，另一个按钮采用标准形式，当用户点击按钮后，从对话框中获取用户点击的按钮，然后显示出对应的文本。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;自定义消息框
void Dialog::ShowCustomDlg() &#123;
    m_customLabel-&gt;setText(&quot;自定义消息框&quot;);
    QMessageBox customMsgBox;
    customMsgBox.setWindowTitle(&quot;自定义消息框&quot;);
    &#x2F;&#x2F;返回一个按钮对象
    &#x2F;&#x2F;自定义按钮
    QPushButton *yes &#x3D; customMsgBox.addButton(
                &quot;真的吗？&quot;,&#x2F;&#x2F;指定文本
                QMessageBox::ActionRole&#x2F;&#x2F;指定角色
                );
    &#x2F;&#x2F;自定义按钮
    QPushButton *no &#x3D; customMsgBox.addButton(
                &quot;假的&quot;,&#x2F;&#x2F;指定文本
                QMessageBox::ActionRole&#x2F;&#x2F;指定角色
                );
    &#x2F;&#x2F;标准按钮
    QPushButton *cancel &#x3D; customMsgBox.addButton(
                QMessageBox::Cancel);
    &#x2F;&#x2F;设置图标
    customMsgBox.setIconPixmap(QPixmap(&quot;msg.jpg&quot;));
    customMsgBox.exec();
    if(customMsgBox.clickedButton()&#x3D;&#x3D;yes)&#123;
        m_customLabel-&gt;setText(&quot;点了“真的吗？”&quot;);
    &#125;else if(customMsgBox.clickedButton()&#x3D;&#x3D;no)&#123;
        m_customLabel-&gt;setText(&quot;点了“假的   ”&quot;);
    &#125;else if(customMsgBox.clickedButton()&#x3D;&#x3D;cancel)&#123;
        m_customLabel-&gt;setText(&quot;点了“取消”&quot;);
    &#125;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="一些经典容器的若干操作"><a href="#一些经典容器的若干操作" class="headerlink" title="一些经典容器的若干操作"></a>一些经典容器的若干操作</h2><h3 id="QListWidget"><a href="#QListWidget" class="headerlink" title="QListWidget"></a>QListWidget</h3><p>​        下面的文段来自QT帮助助手！</p>
<pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230526191818350.png?lastModify=1685936981" alt="image-20230526191818350"></p>
<p>​        QListWidget is a convenience class that provides a list view similar to the one supplied by QListView, but with a classic item-based interface for adding and removing items. QListWidget uses an internal model to manage each QListWidgetItem in the list. For a more flexible list view widget, use the QListView class with a standard model. List widgets are constructed in the same way as other widgets:</p>
<pre class="line-numbers language-none"><code class="language-none">QListWidget *listWidget &#x3D; new QListWidget(this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        The selectionMode() of a list widget determines how many of the items in the list can be selected at the same time, and whether complex selections of items can be created. This can be set with the setSelectionMode() function. There are two ways to add items to the list: they can be constructed with the list widget as their parent widget, or they can be constructed with no parent widget and added to the list later. If a list widget already exists when the items are constructed, the first method is easier to use:</p>
<pre class="line-numbers language-none"><code class="language-none">new QListWidgetItem(tr(&quot;Oak&quot;), listWidget);
new QListWidgetItem(tr(&quot;Fir&quot;), listWidget);
new QListWidgetItem(tr(&quot;Pine&quot;), listWidget);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        If you need to insert a new item into the list at a particular position, then it should be constructed without a parent widget. The insertItem() function should then be used to place it within the list. The list widget will take ownership of the item.</p>
<pre class="line-numbers language-none"><code class="language-none">QListWidgetItem *newItem &#x3D; new QListWidgetItem;
newItem-&gt;setText(itemText);
listWidget-&gt;insertItem(row, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        For multiple items, insertItems() can be used instead. The number of items in the list is found with the count() function. To remove items from the list, use takeItem().         The current item in the list can be found with currentItem(), and changed with setCurrentItem(). The user can also change the current item by navigating with the keyboard or clicking on a different item. When the current item changes, the currentItemChanged() signal is emitted with the new current item and the item that was previously current.</p>
<p>​        大致就是创建一个长得像那样链表似的一个控件！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230526192003545.png?lastModify=1685936981" alt="image-20230526192003545">        在QT 的 UI设计下，常常见这个控件于： List Widget下面。</p>
<p>​        我们这里不对对象名称做什么修改了！默认的情况下——</p>
<pre class="line-numbers language-none"><code class="language-none">ui -&gt; listWidget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        找到它来！</p>
<p>​        为了添加控件，我们有两种方式来进行：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 方式1
QListWidgetItem* item &#x3D; new QListWidgetItem(&quot;卢本伟牛逼&quot;);

ui-&gt;listWidget-&gt;addItem(item);

item-&gt;setTextAlignment(Qt::AlignHCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这就是一种方式——通过包装成 Item 送到Widget里去。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 方式2
QStringList list;
list &lt;&lt; &quot;卢&quot;&lt;&lt;&quot;本&quot;&lt;&lt;&quot;伪&quot;&lt;&lt;&quot;牛&quot;&lt;&lt;&quot;逼&quot;;
ui-&gt;listWidget-&gt;addItems(list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是通过传入String List 链表的方式送数据。</p>
<h3 id="1）添加条目的函数"><a href="#1）添加条目的函数" class="headerlink" title="1）添加条目的函数"></a>1）<strong>添加条目的函数</strong></h3><pre class="line-numbers language-none"><code class="language-none">void QListWidget::addItem(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这个添加函数需要实现 new 一个 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 条目对象，然后添加到列表控件末尾，下面小节会专门讲 QListWidgetItem 类。</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::addItem(const QString &amp; label)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这第二个添加函数其实更常用，因为更简便，功能是将字符串 label 添加到列表控件末尾显示，其实该函数内部会自动根据字符串 new 一个条目对象添加到列表控件。 如果有设置好的字符串列表，那么可以通过如下函数把多个字符串全部添加到列表控件：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::addItems(const QStringList &amp; labels)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>add<em> 函数是将条目添加到末尾，如果要将条目插入到指定行 row 位置，则使用 insert</em> 函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::insertItem(int row, QListWidgetItem * item) &#x2F;&#x2F;插入条目到第 row 行
void QListWidget::insertItem(int row, const QString &amp; label) &#x2F;&#x2F;插入字符串到第 row 行
void QListWidget::insertItems(int row, const QStringList &amp; labels) &#x2F;&#x2F;插入多个字符串到从 row 行开始的多个行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>获取列表控件里面的条目计数使用如下函数：</p>
<pre class="line-numbers language-none"><code class="language-none">int QListWidget::count() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（2）删除函数"><a href="#（2）删除函数" class="headerlink" title="（2）删除函数"></a>（2）<strong>删除函数</strong></h2><p>​        因为是基于条目的控件，所以列表控件的删除单个条目函数名字是 <strong>takeItem()</strong>：</p>
<pre class="line-numbers language-none"><code class="language-none">QListWidgetItem * QListWidget::takeItem(int row)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        takeItem() 根据行号从列表控件移除一个条目，并返回该条目指针，如果行号不合法，返回 NULL 指针。         如果返回的是实际存在的条目，那么需要注意，返回的条目指针需要手动 delete 掉，因为列表控件不再拥有该条目，该条目<strong>不会由列表控件析构时自动删除。</strong>         <strong>takeItem() 函数还有第二个用途，因为列表控件没有直接的调整条目前后顺序的函数，可以先将要调整顺序的条目移出来takeItem()，然后再调用 insertItem() 把这个条目插入到新的位置。</strong>（重点关注之）</p>
<p>​        如果要清空整个列表控件，删除之前添加的所有条目，可以调用槽函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（3）条目访问函数"><a href="#（3）条目访问函数" class="headerlink" title="（3）条目访问函数"></a>（3）<strong>条目访问函数</strong></h2><p>​        根据行号获取条目对象的指针，使用如下函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QListWidgetItem * QListWidget::item(int row) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果已知列表控件含有的条目对象指针，反查当前行号，使用如下函数：</p>
<pre class="line-numbers language-none"><code class="language-none">int QListWidget::row(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>在图形界面，如果希望根据列表控件在屏幕显示的相对坐标位置（以列表控件内部左上角为原点）来获取条目，使用如下函数：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">QListWidgetItem * QListWidget::itemAt(const QPoint &amp; p) const

QListWidgetItem * QListWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>反过来，如果根据已知条目，获取这个条目占据的矩形区域，使用如下函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QRect QListWidget::visualItemRect(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（4）当前选中条目的操作"><a href="#（4）当前选中条目的操作" class="headerlink" title="（4）当前选中条目的操作"></a>（4）<strong>当前选中条目的操作</strong></h2><p>获取列表控件当前选中条目的函数如下：</p>
<pre class="line-numbers language-none"><code class="language-none">QListWidgetItem * QListWidget::currentItem() const &#x2F;&#x2F;当前选中 条目
int QListWidget::currentRow() const  &#x2F;&#x2F;当前选中的行号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果当前没有选中的条目，那么返回的指针为 NULL，返回的序号为 -1 ，代码里要注意判断返回值。</p>
<p>设置已存在的某个条目为选中状态，使用函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::setCurrentItem(QListWidgetItem * item)    &#x2F;&#x2F;设置当前选中条目为 item
void QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)
void QListWidget::setCurrentRow(int row, QItemSelectionModel::SelectionFlags command)&#x2F;&#x2F;设置当前选中行为 row
void QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        第二个和第四个设置函数有个 SelectionFlags 类型的参数 command，这个参数决定选中的方式，是要选中QItemSelectionModel::Select ，还是取消选中 QItemSelectionModel::Deselect，还有其他选中方式，等到表格控件一节再详细列出来。 如果当前选中的条目发生变化，会触发如下三个信号，可以根据实际用途选择合适的信号：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::currentItemChanged(QListWidgetItem * current, QListWidgetItem * previous)

void QListWidget::currentRowChanged(int currentRow)

void QListWidget::currentTextChanged(const QString &amp; currentText)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意参数里的指针有可能为空值，序号可能为 -1，字符串也可能是空串，一定要注意判断非法的参数值。</p>
<p>​        本章的三个控件都可以设置选中模式，比如单选模式，一次只能选中一个条目，多选模式，一次可以选中多个条目等等，详细的选中模式在放到表格控件一节讲解，因为表格 中涉及的选中模式较多，一块讲解。本节的列表控件默认情况下，选中模式为单选 。QAbstractItemView::SingleSelection，以上的 <em>current</em> 等函数都是基于默认的单选模式的。</p>
<p>​        如果需要用到多选模式，可以设置 selectionMode 属性为 QAbstractItemView::ExtendedSelection，这种扩展选中模式类似常见的文件资源管理器的选中模式，可以使用 Ctrl 或 Shift 加鼠标点击实现多选：</p>
<pre class="line-numbers language-none"><code class="language-none">void setSelectionMode(QAbstractItemView::SelectionMode mode)  &#x2F;&#x2F;设置选中模式
QAbstractItemView::SelectionMode    selectionMode() const     &#x2F;&#x2F;获取选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        QAbstractItemView 是本章所有控件的抽象基类，本章后面控件也有类似的选中模式设置，如果把列表控件设置成多选模式，那么可以用如下函数获取同 时选中的多个条目：</p>
<pre class="line-numbers language-none"><code class="language-none">QList&lt;QListWidgetItem *&gt; QListWidget::selectedItems() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        不论单选还是多选模式，条目选中情况有任何变化时，会触发如下信号：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::itemSelectionChanged()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（5）条目查找和排序"><a href="#（5）条目查找和排序" class="headerlink" title="（5）条目查找和排序"></a>（5）<strong>条目查找和排序</strong></h2><p>​        如果需要根据文本查找匹配的条目，使用如下函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QList&lt;QListWidgetItem *&gt; QListWidget::findItems(const QString &amp; text, Qt::MatchFlags flags) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        该函数第一个参数 text 是要查找的模板子串，第二个参数是匹配标志，Qt::MatchFlags 是非常通用的枚举类型，不仅可用于字符串匹配，还能用于其他类型变量的匹配，Qt::MatchFlags 包含关于查找匹配的多种方式的枚举值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Qt::MatchFlags 枚举常量</strong></th>
<th><strong>数值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::MatchExactly</td>
<td>0</td>
<td>精确匹配，执行基于 QVariant 的匹配。</td>
</tr>
<tr>
<td>Qt::MatchFixedString</td>
<td>8</td>
<td>执行基于字符串的匹配，如果不指定 MatchCaseSensitive，默认是大小写不敏感。</td>
</tr>
<tr>
<td>Qt::MatchContains</td>
<td>1</td>
<td>条目包含要查找的模板子串。</td>
</tr>
<tr>
<td>Qt::MatchStartsWith</td>
<td>2</td>
<td>条目以要查找的模板子串打头。</td>
</tr>
<tr>
<td>Qt::MatchEndsWith</td>
<td>3</td>
<td>条目以要查找的模板子串结尾。</td>
</tr>
<tr>
<td>Qt::MatchCaseSensitive</td>
<td>16</td>
<td>查找时大小写敏感。</td>
</tr>
<tr>
<td>Qt::MatchRegExp</td>
<td>4</td>
<td>根据正则表达式模板子串匹配字符串。</td>
</tr>
<tr>
<td>Qt::MatchWildcard</td>
<td>5</td>
<td>根据通配符模板子串（如 *.txt）匹配字符串。</td>
</tr>
<tr>
<td>Qt::MatchWrap</td>
<td>32</td>
<td>执行回绕查找，当查找到最后一个条目时返回到第一个的条目继续查找，直到所有的条目都检查一遍。</td>
</tr>
<tr>
<td>Qt::MatchRecursive</td>
<td>64</td>
<td>递归查找，遍历所有子条目。</td>
</tr>
</tbody>
</table>
</div>
<p>​        后面两节的表格控件和树形控件也有类似的查找函数 findItems() ，第二个匹配标志参数也是一样的类型。</p>
<p>​        列表控件的自动排序是通过 sortingEnabled 属性来控制，获取和设置函数如下：</p>
<pre class="line-numbers language-none"><code class="language-none">bool isSortingEnabled() const
void setSortingEnabled(bool enable)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        列表控件条目默认是不排序的，如果希望自动按照字典序排序，调用 setSortingEnabled(true) 即可。另外还可以手动对列表控件现有条目排序：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::sortItems(Qt::SortOrder order &#x3D; Qt::AscendingOrder)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Qt::AscendingOrder 是按升序排列，Qt::DescendingOrder 是按降序排列。</p>
<h2 id="（6）条目显示和运行时条目编辑"><a href="#（6）条目显示和运行时条目编辑" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）<strong>条目显示和运行时条目编辑</strong></h2><p>​        关于列表控件 QListWidget 和里面的条目 QListWidgetItem，需要注意条目 QListWidgetItem 仅仅是数据，不是控件或子控件，列表控件根据多个 QListWidgetItem 对象，来呈现条目里的数据，<strong>只有列表控件自己是控件实体。</strong> 列表控件默认以自己的方式呈现条目数据，比如白底黑字的普通条目显示，如果要按照特殊的子控件来显示字符串，比如用 QLabel 对象显示条目数据，可以用如下函 数：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::setItemWidget(QListWidgetItem * item, QWidget * widget)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        列表控件会同时拥有 item 数据条目和用于显示 item 的子控件 widget。注意这里的子控件 widget 只有静态显示功能，如果用按钮作为显示子控件，那么按钮是不可点击的。如果希望自己定制一个能交互操作的子条目显示控件，需要使用 QListView 并子类化 QItemDelegate 类，这些复杂的等到模型视图章节再讲。</p>
<p>​        对于本节列表控件，如果要获取 setItemWidget() 函数指定某个条目的显示子控件，使用如下函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QWidget * QListWidget::itemWidget(QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果要删除上面 setItemWidget() 指定的特殊显示控件，使用函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::removeItemWidget(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        特殊的显示子控件移除后，该条目就还按照列表控件原来的普通条目显示。</p>
<p>​        <strong>如果希望在程序运行时编辑列表控件的条目，有两种方式，本小节先讲第一种（第二种是设置条目自身的特性标志），手动打开条目的文本编辑器（这个编辑器是列表控件自 带功能，与 setItemWidget 设置的显示子控件没关系）：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::openPersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>这个函数名是打开条目的持续编辑器，持续的意思是如果不调用关闭函数，该条目的编辑器会一直开启，关闭这个持续编辑器使用如下函数：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::closePersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>一般可以在检测到条目激活信号（itemActivated）时调用打开函数 openPersistentEditor() ，在当前条目变化（ currentItemChanged）时调用关闭函数 closePersistentEditor() 。</strong> 使用这一对开关持续编辑器函数涉及到编写多个信号的槽函数，使用比较麻烦，建议用后面第二小节介绍的条目标 志位和 QListWidget::editItem(QListWidgetItem * item) 实现条目的可编辑功能。</p>
<h2 id="（7）其他信号和槽函数"><a href="#（7）其他信号和槽函数" class="headerlink" title="（7）其他信号和槽函数"></a>（7）<strong>其他信号和槽函数</strong></h2><p>除了上面关于当前条目变化和选中条目变化的信号，条目还有激活、单击、双击等信号，罗列如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::itemActivated(QListWidgetItem * item)  &#x2F;&#x2F;激活信号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当用户点击或双击条目时，条目会被激活，具体哪些操作会激活条目，要根据操作系统设置来定，比如 Windows 一般是双击打开激活，KDE 桌面通常是单击打开激活。另外，系统的快捷键也可以激活条目，如 Windows 和 Linux X11 桌面是回车键激活，Mac OS X 是 Ctrl+0 ，一般激活信号用于开启编辑等操作。</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::itemChanged(QListWidgetItem * item)   &#x2F;&#x2F;条目内容发生变化<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意这是条目内容变化的信号，不是选中状态变化，程序如果在运行时改变了条目文本内容，比如持续编辑器修改了文本，会触发这个信号。 剩下几个单击、双击、进入、按压等信号意义比较直白，不详细解释了：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::itemClicked(QListWidgetItem * item)   &#x2F;&#x2F;条目单击信号
void QListWidget::itemDoubleClicked(QListWidgetItem * item)  &#x2F;&#x2F;条目双击信号
void QListWidget::itemEntered(QListWidgetItem * item)  &#x2F;&#x2F;鼠标追踪时进入条目的信号，一般用不着
void QListWidget::itemPressed(QListWidgetItem * item)  &#x2F;&#x2F;鼠标按键在条目上处于按下状态时发的信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>列表控件的槽函数除了前面讲过的 clear() 槽函数用于清空所有条目，还有个比较实用的条目滚动函数，列表控件自带滚动条，当条目总数超出控件矩形能呈现的数目时，滚动条自动出现，通过滚动条支持更多的条目显示。使 用如下槽函数可 以让列表控件滚动到想显示的某个条目位置：</p>
<pre class="line-numbers language-none"><code class="language-none">void QListWidget::scrollToItem(const QListWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第一个参数 item 就是想显示出来的条目，第二个参数是滚动显示方式，默认是 QAbstractItemView::EnsureVisible，即保证指定条目显示出来，还有其他的滚动显示方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>QAbstractItemView::ScrollHint 枚举常量</strong></th>
<th><strong>数值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>QAbstractItemView::EnsureVisible</td>
<td>0</td>
<td>滚动到指定条目能显示出来即可。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtTop</td>
<td>1</td>
<td>滚动直到将指定条目显示到可视区域的顶部。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtBottom</td>
<td>2</td>
<td>滚动直到将指定条目显示到可视区域的底部。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtCenter</td>
<td>3</td>
<td>滚动直到将指定条目显示到可视区域的中间。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="主要控件"><a href="#主要控件" class="headerlink" title="主要控件"></a>主要控件</h2><h3 id="QTreeWidget"><a href="#QTreeWidget" class="headerlink" title="QTreeWidget"></a>QTreeWidget</h3><pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        The QTreeWidget class is a convenience class that provides a standard tree widget with a classic item-based interface similar to that used by the QListView class in Qt 3. This class is based on Qt’s Model/View architecture and uses a default model to hold items, each of which is a QTreeWidgetItem.         Developers who do not need the flexibility of the Model/View framework can use this class to create simple hierarchical lists very easily. A more flexible approach involves combining a QTreeView with a standard item model. This allows the storage of data to be separated from its representation.         In its simplest form, a tree widget can be constructed in the following way:</p>
<pre class="line-numbers language-none"><code class="language-none">QTreeWidget *treeWidget &#x3D; new QTreeWidget();
treeWidget-&gt;setColumnCount(1);
QList&lt;QTreeWidgetItem *&gt; items;
for (int i &#x3D; 0; i &lt; 10; ++i)
&#123; 
	items.append(new QTreeWidgetItem(static_cast&lt;QTreeWidget *&gt;\		(nullptr), 
	QStringList(QString(&quot;item: %1&quot;).arg(i))));
&#125;
 treeWidget-&gt;insertTopLevelItems(0, items);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        Before items can be added to the tree widget, the number of columns must be set with setColumnCount(). This allows each item to have one or more labels or other decorations. The number of columns in use can be found with the columnCount() function. The tree can have a header that contains a section for each column in the widget. It is easiest to set up the labels for each section by supplying a list of strings with setHeaderLabels(), but a custom header can be constructed with a QTreeWidgetItem and inserted into the tree with the setHeaderItem() function.         The items in the tree can be sorted by column according to a predefined sort order. If sorting is enabled, the user can sort the items by clicking on a column header. Sorting can be enabled or disabled by calling setSortingEnabled(). The isSortingEnabled() function indicates whether sorting is enabled.</p>
<h2 id="一些详解："><a href="#一些详解：" class="headerlink" title="一些详解："></a>一些详解：</h2><p>原博客：</p>
<p>​        <a target="_blank" rel="noopener" href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p>
<p>​        树形控件的节点可以有多层、多个子节点， 如果将子节点全部展开，那么每一行都是一个数据条目。<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QTreeWidgetItem&amp;spm=1001.2101.3001.7020">QTreeWidgetItem</a> 比较特殊，一个条目内部可以有多列数据信息，相当于表格控件一整行的表格单元集成为一个条目，所以树形条目要比前面两节的列表条目和表格条目都复杂。树形控件每行的条目之间可以是兄弟关系或父子关系，含有子节点的条目可以折叠也可以展开，进行遍历时有专门的迭代器 QTreeWidgetItemIterator 实现，也可以自行编写<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=递归算法&amp;spm=1001.2101.3001.7020">递归算法</a>遍历所有条目。</p>
<h3 id="8-3-1-QTreeWidget"><a href="#8-3-1-QTreeWidget" class="headerlink" title="8.3.1 QTreeWidget"></a>8.3.1 QTreeWidget</h3><p>在 Qt 设计师界面可以直接拖动树形控件到窗口里，下图展示树形控件的外观和构成：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/1.png?lastModify=1685936981" alt="f1ce3ab52d8fb8ed2698fa14a9ddb2b0.png"></p>
<p> 默认情况下，树形控件<strong>最上面是一个树头条目</strong>，<strong><strong>树头条目也是 QTreeWidgetItem 对象\</strong></strong>，可以有<strong>多列内容</strong>。 树头下面是真正的树形控件所有条目，在折叠的情况下，如上图所示，每行一个顶级条目，顶级条目也是 QTreeWidgetItem 对象，<strong>顶级条目的父节点指针 QTreeWidgetItem::parent() 为 NULL</strong>。 将所有节点展开之后，可以看到每个节点可以有多个子节点：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/2d11f9ba73fbaed337db73e2e141f4e7.png?lastModify=1685936981" alt="2d11f9ba73fbaed337db73e2e141f4e7.png"></p>
<p>对于包含子节点的父节点，左边会有小的三角形指示器，用于控制折叠或展开父节点。子节点也可以拥有更低级别的子节点（孙节点），以此类推，树形控件没 有限定子节点 的层数。顶级节点和其子孙节点的数据结构一样，都可以有多列数据，只是添加的函数、父节点指针不一样。下面介绍树形控件的函数和功能。</p>
<h3 id="（0）树形控件的构造函数很简单："><a href="#（0）树形控件的构造函数很简单：" class="headerlink" title="（0）树形控件的构造函数很简单："></a>（0）树形控件的构造函数很简单：</h3><pre class="line-numbers language-none"><code class="language-none">QTreeWidget(QWidget * parent &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里只有指定父窗口或父控件的指针 parent 。树形控件在添加条目之前，必须要先设置列数：</p>
<pre class="line-numbers language-none"><code class="language-none">void setColumnCount(int columns) &#x2F;&#x2F;设置列数
int columnCount() const &#x2F;&#x2F;获取列数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>默认的列数是 1 列</strong>，如果涉及到多列数据，比如文件浏览树，有文件名、文件类型、大小、修改时间等等，就需要设置为多列数据的树。 树形控件设置好列数就可以添加相应的顶级条目，添加顶级条目是由树形控件自身的函数实现，而子条目则由 QTreeWidgetItem 的函数实现。本小节主要围绕树形控件和其基类的函数来讲，<strong>树形控件也可以设置和表格控件类似的表头，这里称为树头条目</strong>。</p>
<h3 id="（1）添加和访问顶级条目"><a href="#（1）添加和访问顶级条目" class="headerlink" title="（1）添加和访问顶级条目"></a>（1）添加和访问顶级条目</h3><p>树形控件顶级条目的操作比较类似 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidget&amp;spm=1001.2101.3001.7020">QListWidget</a> 的列表条目操作函数。新建条目之后，可以用如下函数把条目添加到树形控件的顶级条目<strong>列表末尾</strong>：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::addTopLevelItem(QTreeWidgetItem * item) &#x2F;&#x2F;添加一个顶级条目到末尾
void QTreeWidget::addTopLevelItems(const QList&lt;QTreeWidgetItem *&gt; &amp; items) &#x2F;&#x2F;添加多个顶级条目到末尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        如果希望将条目插入到指定顶级条目列表的 index 序号位置，使用如下函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::insertTopLevelItem(int index, QTreeWidgetItem * item)
void QTreeWidget::insertTopLevelItems(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; items)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>树形控件所有的顶级条目父节点指针都为 NULL</strong> （父节点是指树形层次中的节点关系，<strong>而条目的父控件依然是树形控件本身</strong>）。         添加了顶级条目之后，可以对顶级条目进行计数：</p>
<pre class="line-numbers language-none"><code class="language-none">int QTreeWidget::topLevelItemCount() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（2）移除顶级条目"><a href="#（2）移除顶级条目" class="headerlink" title="（2）移除顶级条目"></a>（2）移除顶级条目</h3><p>​        移除顶级条目的函数也是take*打头：</p>
<pre class="line-numbers language-none"><code class="language-none">QTreeWidgetItem * QTreeWidget::takeTopLevelItem(int index)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        index是顶级条目的序号，<strong>该函数只是从树形控件卸下顶级条目，但不会删除条目的内存空间，如果希望彻底删除，那么手动 delete 该函数返回的条目。</strong> 如果要清空所有的顶级条目和子条目，使用槽函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（3）条目访问函数-1"><a href="#（3）条目访问函数-1" class="headerlink" title="（3）条目访问函数"></a>（3）条目访问函数</h3><p>​        对于顶级条目，如果知道顶级条目的序号获取对应的条目：</p>
<pre class="line-numbers language-none"><code class="language-none">QTreeWidgetItem * QTreeWidget::topLevelItem(int index) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        反过来，对于已知顶级条目对象，查看其顶级序号：</p>
<pre class="line-numbers language-none"><code class="language-none">int QTreeWidget::indexOfTopLevelItem(QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果条目不是顶级条目或者条目不属于该控件，那么会返回 -1。         树形控件实际运行时，可能既有顶级条目，也有展开后的子孙条目同时显示，<strong>所以某个条目上面或下面的相邻条目不一定是同级别的兄弟条目，有可能是叔辈祖 辈的条目，也 可能是子辈孙辈条目。</strong>获取某个条目的相邻条目函数为：</p>
<pre class="line-numbers language-none"><code class="language-none">QTreeWidgetItem * QTreeWidget::itemAbove(const QTreeWidgetItem * item) const &#x2F;&#x2F;上面相邻条目
QTreeWidgetItem * QTreeWidget::itemBelow(const QTreeWidgetItem * item) const &#x2F;&#x2F;下面相邻条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        从屏幕控件显示角度，如果根据树形控件<strong>内部相对坐标</strong>获取条目（树形控件显示区域的左上角为原点），使用下面函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QTreeWidgetItem * QTreeWidget::itemAt(const QPoint &amp; p) const
QTreeWidgetItem * QTreeWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这两个函数是一个意思，一<strong>个用 QPoint 对象表示相对坐标，另一个直接用 x 和 y 数值表示坐标，如果对应坐标没有条目，会返回</strong> <strong>NULL</strong>，注意判断 返回值。         树形控件也是自带滚动条的，如果条目特别多，自动显示滚动条，对于树形控件在屏幕可见的条目，可以根据条目对象获取它的<strong>可视矩形</strong>（树形控件显示区域的 左上角为原 点）：</p>
<pre class="line-numbers language-none"><code class="language-none">QRect QTreeWidget::visualItemRect(const QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（4）当前条目的操作"><a href="#（4）当前条目的操作" class="headerlink" title="（4）当前条目的操作"></a>（4）当前条目的操作</h3><p>​        树形控件的选中操作默认比较像 QListWidget，如果不手动设置，<strong>只能选中一个高亮条目</strong>。 获取当前高亮选中条目的函数为：</p>
<pre class="line-numbers language-none"><code class="language-none">QTreeWidgetItem * QTreeWidget::currentItem() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        树形控件可以有多列，当前条目被点击选中的列号为：</p>
<pre class="line-numbers language-none"><code class="language-none">int QTreeWidget::currentColumn() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        树形控件内的条目一般都没有固定行号，<strong>因为条目可以展开也可以折叠，行号是变化的，所以没有基于行号的操作函数。</strong></p>
<p>​        如果要设置某个条目为当前选中的状态：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::setCurrentItem(QTreeWidgetItem * item)
void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column)
void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        第一个 setCurrentItem() 函数相当<strong>于设置该条目整行高亮选中</strong>，第二个是设置该条目行的 column <strong>列高亮选中</strong>，第三个函数是<strong>单次选中命令</strong>，参考“8.2.4 选中区域和选中行为”的单次选中命令内容，<strong>只是树形控件是一整行为一个条目，定位到条目的某列数据，就 类似指定表格控件的单元格。</strong> 如果当前高亮选中的状态发生变化，会触发如下信号：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::currentItemChanged(QTreeWidgetItem * current, QTreeWidgetItem * previous)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里分别是当前高亮选中的条目，和之前高亮选中的条目，注意指针可能是 NULL，使用指针前一定要判断指针非空</p>
<h3 id="（5）条目查找和排序-1"><a href="#（5）条目查找和排序-1" class="headerlink" title="（5）条目查找和排序"></a>（5）条目查找和排序</h3><p>​        如果要根据模板子串查找某列文本匹配的条目，使用如下函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QList&lt;QTreeWidgetItem *&gt; QTreeWidget::findItems(const QString &amp; text, Qt::MatchFlags flags, int column &#x3D; 0) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里text是模板子串，flags是匹配标志（参看“8.1.1 QListWidget”中的字符串匹配标志表格），第三个参数是指定查找的列。<strong>该函数只查找一列的文本，其他列的文本是不查找的</strong>。如果需要查找所有列数据，那么要根据不同列号逐列查询。</p>
<p>​        类似表格控件，树形控件也可以按照列的文本进行自动排序，自动排序的设置函数为：</p>
<pre class="line-numbers language-none"><code class="language-none">bool    isSortingEnabled() const          &#x2F;&#x2F;设置是否自动排序
void    setSortingEnabled(bool enable)   &#x2F;&#x2F;查看是否开启自动排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        指定排序的列号和升序降序，使用从基类继承的函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeView::sortByColumn(int column, Qt::SortOrder order)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>在没有开启自动排序的情况下，也可以调用该函数进行一次性的条目排序。</strong></p>
<h3 id="（6）条目显示和运行时条目编辑-1"><a href="#（6）条目显示和运行时条目编辑-1" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）条目显示和运行时条目编辑</h3><p>​        可以为条目的某列“单元格”设置单独的控件来静态显示（控件不具有编辑功能）：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::setItemWidget(QTreeWidgetItem * item, int column, QWidget * widget) &#x2F;&#x2F;设置条目列控件
QWidget * QTreeWidget::itemWidget(QTreeWidgetItem * item, int column) const &#x2F;&#x2F;获取条目列控件，不设置就是NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        注意该函数只能在条目添加到树形控件之后<strong>才能调用，否则无效，\并且条目列控件只能用于显示，无法编辑，如果要定制可编辑的“单元格”控件，必须用基类 QTreeView 并继承 QItemDelegate 做代理，这些内容到后面模型视图章节讲解         再次强调：itemWidget 条目控件，在默认情况下是与条目本身数据完全无关的，是条目数据的替换品，而不是协作模式。</strong>只有手动设置信号与槽，它们才可能关联上。<strong> QListWidget 和 QTreeWidget 的条目控件</strong>都是静态显示，不能编辑。<strong>         QTreeWidget 控件的条目列控件 widget 还必须把默认是透明背景</strong>，**这样控件的内容和内部模型数据（就是条目的列数据）同时显示，文本会重影，效果就糟糕了。 删除条目的列控件使用如下函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::removeItemWidget(QTreeWidgetItem * item, int column)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>这个函数没有返回值，会自动地彻底删除条目列控件。</strong></p>
<p>​        在大多数情况下都用不到 itemWidget ，因为能够为条目设置可编辑标志位，然后调用如下函数开启树形控件自带的文本编辑器：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::editItem(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数 item 是指定的条目，column 是条目的列（类似“单元格”）。在没有为条目设置可编辑标志位的情况下，可以调用下面一对函数进行持续编辑器的开启和关闭：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::openPersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)
void QTreeWidget::closePersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>注意这对函数一开一关，要成对调用，否则编辑完了不会自动关闭持续编辑器。</strong></p>
<h3 id="（7）信号"><a href="#（7）信号" class="headerlink" title="（7）信号"></a>（7）信号</h3><p>​        关于当前高亮选中变化的信号 currentItemChanged() 前面讲过了，这里先列几个常规的信号，然后再将树形控件独有的信号。常规信号就是下面这 几个：（条目列就类似表格控件的单元格）</p>
<pre class="line-numbers language-none"><code class="language-none">void itemActivated(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被激活
void itemChanged(QTreeWidgetItem * item, int column)   &#x2F;&#x2F;条目列的数据发生变化，比如文本或图标修改了
void itemClicked(QTreeWidgetItem * item, int column)  &#x2F;&#x2F;条目列被单击
void itemDoubleClicked(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被双击
void itemEntered(QTreeWidgetItem * item, int column) &#x2F;&#x2F;进入条目列
void itemPressed(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被点 击按下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>树形控件最独特的就是展开和折叠信号：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::itemExpanded(QTreeWidgetItem * item)  &#x2F;&#x2F;条目展开时发送信号
void QTreeWidget::itemCollapsed(QTreeWidgetItem * item) &#x2F;&#x2F;条目折叠时发送信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        如果调用槽函数 expandAll() 展开所有子孙条目，那么不会触发 itemExpanded() 信号，因为触发太多会非常影响性能。         类似地，如果用槽函数 collapseAll() 折叠所有子孙条目，也不会触发 itemCollapsed() 信号，以免影响性能。 举例来说，在文件夹浏览的时候，因为操作系统里的文件太多，没法一次性构建完整的文件树，那么就可以用展开和折叠信号实时枚举某一层次文件夹的内容， 而不是一次性 枚举文件系统所有文件，因为一次性枚举所有文件的性能太糟糕。 树形控件还有一个 <strong>itemSelectionChanged</strong>() 信号，一般在多选模式才会用到，稍后讲解。</p>
<h3 id="（8）槽函数"><a href="#（8）槽函数" class="headerlink" title="（8）槽函数"></a>（8）槽函数</h3><p>​        树形控件的槽函数包括四个（基类的另算）：</p>
<pre class="line-numbers language-none"><code class="language-none">void clear() &#x2F;&#x2F;清空整个树形控件
void collapseItem(const QTreeWidgetItem * item) &#x2F;&#x2F;折叠指定的条目
void expandItem(const QTreeWidgetItem * item)  &#x2F;&#x2F;展开指定 条目
void scrollToItem(const QTreeWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible) &#x2F;&#x2F;滚动到指定条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        滚动函数 scrollToItem() 第二个参数是<strong><strong>滚到到该条目的显示方式\</strong></strong>，参考“8.1.1 QListWidget”QAbstractItemView::  ScrollHint 枚举常量的表格。</p>
<h3 id="（9）基类-QTreeView-的函数"><a href="#（9）基类-QTreeView-的函数" class="headerlink" title="（9）基类 QTreeView 的函数"></a>（9）基类 QTreeView 的函数</h3><p>QTreeView 的功能函数也很多，这里列举几个可能常用的，详细的内容等到模型视图章节讲解。关于列隐藏或显示、设置列宽的函数如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeView::setColumnHidden(int column, bool hide) &#x2F;&#x2F;设置列隐藏或显示
bool QTreeView::isColumnHidden(int column) const &#x2F;&#x2F;判断列是否隐藏
void QTreeView::hideColumn(int column) &#x2F;&#x2F;槽函数，隐藏指定列
void QTreeView::showColumn(int column) &#x2F;&#x2F;槽函数，显示指定列
void QTreeView::setColumnWidth(int column, int width) &#x2F;&#x2F;设置列宽
int QTreeView::columnWidth(int column) const &#x2F;&#x2F;获取指定列的宽度
void QTreeView::resizeColumnToContents(int column) &#x2F;&#x2F;槽函数，自动调整 指定列的宽度属性 
 &#x2F;&#x2F;indentation 控制显示父子节点的缩进宽度：
int indentation() const    &#x2F;&#x2F;获取父子节点的缩进宽度
void setIndentation(int i) &#x2F;&#x2F;设置缩进宽度
void resetIndentation()    &#x2F;&#x2F;重置缩进宽度为默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基类还有几个常用的折叠和展开槽函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void collapseAll() &#x2F;&#x2F;折叠所有子孙节点，这样只能看到顶级节点
void expandAll() &#x2F;&#x2F;展开所有子孙节点，完全展开的树
void expandToDepth(int depth) &#x2F;&#x2F;展开 depth 层级的子节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        expandToDepth() 函数是指一直展开，直到将第 depth 层级的子节点都展开为止。以顶级条目为第 0 层级，顶级条目的直接子节点为第 1 层级，孙子节点为第 2 层级，依次类推。         例如 expandToDepth(0) 的效果如下：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/c1f8eac3f9ec327ea98347e5abab1354.png?lastModify=1685936981" alt="c1f8eac3f9ec327ea98347e5abab1354.png"></p>
<p>​        如果调用 expandToDepth(1) 展开第1级的节点：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/590d3ad8a2fcae012d2240bdbe9a012c.png?lastModify=1685936981" alt="590d3ad8a2fcae012d2240bdbe9a012c.png"></p>
<p>​        如果把 expandToDepth() <strong>参数设置成负数，那么相当于展开无穷大级别，就是展开所有的子孙节点。</strong></p>
<h3 id="（10）树头条目"><a href="#（10）树头条目" class="headerlink" title="（10）树头条目"></a>（10）树头条目</h3><p>​        树形控件只有一个表头，就是<strong>显示在上面的水平表头，本节也叫树头条目</strong>。设置树头条目的函数为：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::setHeaderItem(QTreeWidgetItem * item) &#x2F;&#x2F;设置树头条目，树头条目可以有多列数据，相当于多列的表头一次性设置了。
void QTreeWidget::setHeaderLabel(const QString &amp; label) &#x2F;&#x2F;只设置第 0 列的表头
void QTreeWidget::setHeaderLabels(const QStringList &amp; labels) &#x2F;&#x2F;设置多列的表头
QTreeWidgetItem * QTreeWidget::headerItem() const &#x2F;&#x2F;获取树头条目
树头条目本质其实也是由 QHeaderView 子控件来显示的，可以在基类找到相关函数：
QHeaderView * QTreeView::header() const &#x2F;&#x2F;获取表头视图控件
void QTreeView::setHeader(QHeaderView * header) &#x2F;&#x2F;设置表头视图， 一般树形控件不需要用这个函数
void QTreeView::setHeaderHidden(bool hide) &#x2F;&#x2F;设置表头是否隐藏
bool QTreeView::isHeaderHidden() const &#x2F;&#x2F;判断是否隐藏了表头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        无论是 QTableWidget 还是 QTreeWidget 的表头，都是 QHeaderView 子控件显示，QHeaderView 参考“8.2.3 表头设置”的内容。</p>
<h3 id="（11）选中行为和选中模式"><a href="#（11）选中行为和选中模式" class="headerlink" title="（11）选中行为和选中模式"></a>（11）选中行为和选中模式</h3><p>​        与 QTableWidget 类似，QTreeWidget也从祖类 QAbstractItemView 继承了选中行为和选中模式的属性：</p>
<pre class="line-numbers language-none"><code class="language-none">QAbstractItemView::SelectionBehavior  selectionBehavior() const &#x2F;&#x2F;获取选中行为，按条目选中、整行或整列选中
void setSelectionBehavior(QAbstractItemView::SelectionBehavior behavior) &#x2F;&#x2F;设置选中行为
QAbstractItemView::SelectionMode  selectionMode() const &#x2F;&#x2F;获取选中模式，比如单选、多选、扩展选择
void setSelectionMode(QAbstractItemView::SelectionMode mode) &#x2F;&#x2F;设置选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        关于选中模式和选中行为的枚举常量参看“8.2.4 选中区域和选中行为”小节中的枚举常量表格，单次选中命令的函数和枚举常量也参考该小节。</p>
<p>​        默认情况下，树形控件是按照整行选中，并且是单选模式，如果把选中模式改成多选的 QAbstractItemView::ExtendedSelection，那么树形控件也可以使多选的，这时候信号 itemSelectionChanged() 就能派上用场：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTreeWidget::itemSelectionChanged()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        多选状态变化时会触发该信号（单选模式也触发，只是不需要用这个信号），可以关联该信号，监视当前所有选中的条目：</p>
<pre class="line-numbers language-none"><code class="language-none">QList&lt;QTreeWidgetItem *&gt; QTreeWidget::selectedItems() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        注意，<strong>这里的选中条目仅仅是指实际显示的直接选中的条目，不包括折叠隐藏的子孙条目计数</strong>，因为选中父节点与选中其子孙节点没关系，不会递归选中所有子 孙：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/c216490e8c65baf4903b5093b2deddcc.png?lastModify=1685936981" alt="c216490e8c65baf4903b5093b2deddcc.png"></p>
<p>​        树形控件及其基类没有递归选中子条目的属性或函数，<strong>如果希望递归选中某个节点的所有子孙节点，那么需要自行编写递归函数。</strong>关于树形控件类本身的内容介 绍到这，因为 涉及到父子节点隶属关系、节点展开和折叠，树形控件还有很大一部分功能都是由其条目类 QTreeWidgetItem 的函数实现的.</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QListWidgetItem&gt;
#include&lt;QStringList&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
&#123;   
    ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt;&quot;卢本伟&quot;&lt;&lt;&quot;牛逼&quot;);
	QTreeWidgetItem* item &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐&quot;);
    QTreeWidgetItem* item2 &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐2&quot;);
    ui-&gt;treeWidget-&gt;addTopLevelItem(item);
    ui-&gt;treeWidget-&gt;addTopLevelItem(item2);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230526200623971.png?lastModify=1685936981" alt="image-20230526200623971"></p>
<h2 id="主要控件-1"><a href="#主要控件-1" class="headerlink" title="主要控件"></a>主要控件</h2><h3 id="QTableWidget"><a href="#QTableWidget" class="headerlink" title="QTableWidget"></a>QTableWidget</h3><p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230526200740443.png?lastModify=1685936981" alt="image-20230526200740443"></p>
<pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Table widgets provide standard table display facilities for applications. The items in a QTableWidget are provided by QTableWidgetItem.         If you want a table that uses your own data model you should use QTableView rather than this class.         Table widgets can be constructed with the required numbers of rows and columns:</p>
<pre class="line-numbers language-none"><code class="language-none">tableWidget &#x3D; new QTableWidget(12, 3, this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Alternatively, tables can be constructed without a given size and resized later:</p>
<pre class="line-numbers language-none"><code class="language-none">tableWidget &#x3D; new QTableWidget(this);
tableWidget-&gt;setRowCount(10);
tableWidget-&gt;setColumnCount(5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        Items are created outside the table (with no parent widget) and inserted into the table with setItem():</p>
<pre class="line-numbers language-none"><code class="language-none">QTableWidgetItem *newItem &#x3D; new QTableWidgetItem(tr(&quot;%1&quot;).arg(\
        								 (row+1)*(column+1)));
tableWidget-&gt;setItem(row, column, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        If you want to enable sorting in your table widget, do so after you have populated it with items, otherwise sorting may interfere with the insertion order (see setItem() for details). Tables can be given both horizontal and vertical headers. The simplest way to create the headers is to supply a list of strings to the setHorizontalHeaderLabels() and setVerticalHeaderLabels() functions. These will provide simple textual headers for the table’s columns and rows. More sophisticated headers can be created from existing table items that are usually constructed outside the table. For example, we can construct a table item with an icon and aligned text, and use it as the header for a particular column:</p>
<pre class="line-numbers language-none"><code class="language-none">QTableWidgetItem *cubesHeaderItem &#x3D; new QTableWidgetItem(tr(&quot;Cubes&quot;));
cubesHeaderItem-&gt;setIcon(QIcon(QPixmap(&quot;:&#x2F;Images&#x2F;cubed.png&quot;)));
cubesHeaderItem-&gt;setTextAlignment(Qt::AlignVCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        The number of rows in the table can be found with rowCount(), and the number of columns with columnCount(). The table can be cleared with the clear() function.</p>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>​        原博客：</p>
<p>​        <a target="_blank" rel="noopener" href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p>
<h2 id="8-2-2-QTableWidgetItem"><a href="#8-2-2-QTableWidgetItem" class="headerlink" title="8.2.2 QTableWidgetItem"></a>8.2.2 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QTableWidgetItem&amp;spm=1001.2101.3001.7020">QTableWidgetItem</a></h2><p>​        表格控件条目 QTableWidgetItem 与 8.1.2 节 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 有很多相似的地方， QTableWidgetItem 也是一个纯数据类，不是控件，没有基类，也就没有信号和槽函数。QTableWidgetItem 可以直接用数据流 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QDataStream&amp;spm=1001.2101.3001.7020">QDataStream</a> 读写，表格条目不单单有文本，还可以有自己的图标、复选框等特性，表格控件会根据条目对象的丰富特性来呈现数据并进行交互操作。</p>
<h3 id="（1）首先来看看条目的构造函数："><a href="#（1）首先来看看条目的构造函数：" class="headerlink" title="（1）首先来看看条目的构造函数："></a>（1）<strong>首先来看看条目的构造函数：</strong></h3><pre class="line-numbers language-none"><code class="language-none">QTableWidgetItem(int type &#x3D; Type)
QTableWidgetItem(const QString &amp; text, int type &#x3D; Type)
QTableWidgetItem(const QIcon &amp; icon, const QString &amp; text, int type &#x3D; Type)
QTableWidgetItem(const QTableWidgetItem &amp; other) &#x2F;&#x2F;复制构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        参数里的 type 一般用于派生类，指定条目独特的分类，对于普通的表格控件条目，通常用默认的数值即可。第二个构造函数是指定了条目的文本，第三个构造函数同 时指定了条目图标和文本。         在构造函数里不能直接指定所属的表格控件，因为表格控件有行号、列号所以不能简单追加到表格里，而只能用表格控件的 QTableWidget::setItem() 函数把条目设置到指定单元格里。注意一个条目只能设置给表格控件唯一的一个单元格，不能把一个条目设置给多个单元格。如果希望为多个单元格设置相似的条目数据内容，那么可 以用后面介绍的 clone() 函数制造大量新的复制体条目。         复制构造函数不会复制旧条目的 type() 类型值和tableWidget() 所属表格控件指针，条目其他的内部数据和条目标志都会复制。</p>
<h3 id="（2）复制函数和运算符函数"><a href="#（2）复制函数和运算符函数" class="headerlink" title="（2）复制函数和运算符函数"></a>（2）<strong>复制函数和运算符函数</strong></h3><p>​        除了复制构造函数，还有专门的克隆函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QTableWidgetItem * QTableWidgetItem::clone() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        克隆函数会新建一个当前条目的复制体，然后返回新复制体条目的指针，如果要构造并添加大量重复内容的条目，这个函数就比较实用。clone() 函数内部会调用复制构造函数创建新条目并返回。         条目复制还可以用等于号函数：</p>
<pre class="line-numbers language-none"><code class="language-none">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        等于号函数复制的内容与复制构造函数差不多，type() 类型值和 tableWidget() 所属表格控件指针也不复制。         还有个小于号函数，可以比较条目文本的字典序：</p>
<pre class="line-numbers language-none"><code class="language-none">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果希望使用更多的比较函数，可以直接用 QString 的比较函数。</p>
<h3 id="（3）QTableWidgetItem-的功能函数与内部数据"><a href="#（3）QTableWidgetItem-的功能函数与内部数据" class="headerlink" title="（3）QTableWidgetItem 的功能函数与内部数据"></a>（3）<strong>QTableWidgetItem 的功能函数与内部数据</strong></h3><p>​        QTableWidgetItem 内部的数据也大致分为两类：第一类是以数据角色形式管理的通用数据，这些数据自动参与 QDataStream 数据流的读写；第二类是非通用数据，不参与数据流读写，与 QListWidgetItem 和 QListWidget 自身特性有关。QTableWidgetItem 主要的功能函数也是围绕这两类内部数据展开的。</p>
<p>​        ● <strong>第一类：通用数据及其处理函数</strong>         通用数据是以数据角色与数据变量一一对应的形式存储管理，比如设置文本 setText()、设置图标 setIcon() 等函数，其本质都是根据各自的角色调用通用设置数据的函数：</p>
<pre class="line-numbers language-none"><code class="language-none">virtual void setData(int role, const QVariant &amp; value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        也可以根据角色来获取各个数据变量：</p>
<pre class="line-numbers language-none"><code class="language-none">virtual QVariant data(int role) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        查看表格控件的源代码文件可以看到关于图标操作函数的源码：</p>
<pre class="line-numbers language-none"><code class="language-none">inline QIcon icon() const
&#123; 
    return qvariant_cast&lt;QIcon&gt;(data(Qt::DecorationRole)); 
&#125;
inline void QTableWidgetItem::setIcon(const QIcon &amp;aicon)
&#123;
    setData(Qt::DecorationRole, aicon); 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        QTableWidgetItem 的通用数据与 QListWidgetItem 的通用数据一模一样，函数名也一样，列表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>获取函数</strong></th>
<th><strong>设置函数</strong></th>
<th><strong>数据角色</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>text()</td>
<td>setText(const QString &amp;text)</td>
<td>Qt::DisplayRole</td>
<td>条目显示的文本。</td>
</tr>
<tr>
<td>icon()</td>
<td>setIcon(const QIcon &amp;icon)</td>
<td>Qt::DecorationRole</td>
<td>条目显示的图标。</td>
</tr>
<tr>
<td>statusTip()</td>
<td>setStatusTip(const QString &amp;statusTip)</td>
<td>Qt::StatusTipRole</td>
<td>如果主界面有状态栏，鼠标悬停在该条目上时显示该状态信息到状态栏。</td>
</tr>
<tr>
<td>toolTip()</td>
<td>setToolTip(const QString &amp;toolTip)</td>
<td>Qt::ToolTipRole</td>
<td>鼠标悬停在该条目上时显示的工具提示信息。</td>
</tr>
<tr>
<td>whatsThis()</td>
<td>setWhatsThis(const QString &amp;whatsThis)</td>
<td>Qt::WhatsThisRole</td>
<td>如果主界面窗口标题栏有？帮助按钮，点击帮助按钮再点击该条目会显示该帮助信息。</td>
</tr>
<tr>
<td>font()</td>
<td>setFont(const QFont &amp;font)</td>
<td>Qt::FontRole</td>
<td>显示条目文本用的字体。</td>
</tr>
<tr>
<td>textAlignment()</td>
<td>setTextAlignment(int alignment)</td>
<td>Qt::TextAlignmentRole</td>
<td>文本的对齐方式。</td>
</tr>
<tr>
<td>backgroundColor()</td>
<td>setBackgroundColor(const QColor &amp;color)</td>
<td>Qt::BackgroundColorRole</td>
<td>文本背景色。</td>
</tr>
<tr>
<td>textColor()</td>
<td>setTextColor(const QColor &amp;color)</td>
<td>Qt::TextColorRole</td>
<td>文字颜色。</td>
</tr>
<tr>
<td>background()</td>
<td>setBackground(const QBrush &amp;brush)</td>
<td>Qt::BackgroundRole</td>
<td>条目的背景画刷。</td>
</tr>
<tr>
<td>foreground()</td>
<td>setForeground(const QBrush &amp;brush)</td>
<td>Qt::ForegroundRole</td>
<td>条目的前景画刷。</td>
</tr>
<tr>
<td>checkState()</td>
<td>setCheckState(Qt::CheckState state)</td>
<td>Qt::CheckStateRole</td>
<td>条目自带的复选框选中状态，可以是三态复选框。</td>
</tr>
<tr>
<td>sizeHint()</td>
<td>setSizeHint(const QSize &amp;size)</td>
<td>Qt::SizeHintRole</td>
<td>条目显示的建议尺寸。</td>
</tr>
</tbody>
</table>
</div>
<p>​        表格条目 QTableWidgetItem 可以直接用数据流 QDataStream 读写，是通过下面运算符重载函数实现的：</p>
<pre class="line-numbers language-none"><code class="language-none">QDataStream &amp;    operator&lt;&lt;(QDataStream &amp; out, const QTableWidgetItem &amp; item)
QDataStream &amp;    operator&gt;&gt;(QDataStream &amp; in, QTableWidgetItem &amp; item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        使用 &gt;&gt; 和 &lt;&lt; 运算符进行流输入输出比较常见，当然也可以用 QTableWidgetItem 类内部的读写函数进行输入输出：</p>
<pre class="line-numbers language-none"><code class="language-none">void QTableWidgetItem::read(QDataStream &amp; in)
void QTableWidgetItem::write(QDataStream &amp; out) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​         <strong>第二类：非通用数据及其操作函数</strong> 表格控件的条目也是在构造函数一次性指定条目类型，然后这个类型是只读的：</p>
<pre class="line-numbers language-none"><code class="language-none">int QTableWidgetItem::type() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        类型值一般用于派生类区分不同的条目类型，自定义的条目类型值需要大于等于 QTableWidgetItem::UserType 。         新条目通过表格控件 QTableWidget::setItem() 函数设置给表格控件之后，条<strong>目会自动保存所属的表格控件指针，</strong>可以用如下函数获取：</p>
<pre class="line-numbers language-none"><code class="language-none">QTableWidget * QTableWidgetItem::tableWidget() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        程序运行时，除了可以通过表格控件的 QTableWidget::selectedItems() 获取用户选中的条目列表，每个单元格条目自身也会记录是否 被用户选中，并且能设置自身是否被选中：</p>
<pre class="line-numbers language-none"><code class="language-none">bool QTableWidgetItem::isSelected() const &#x2F;&#x2F;判断条目自身是否高亮选中
void QTableWidgetItem::setSelected(bool select) &#x2F;&#x2F;设置条目自身是 否被选中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>表格控件条目初始化时也有默认的标志位，并且运行时可以修改条目的特性标志：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">Qt::ItemFlags QTableWidgetItem::flags() const &#x2F;&#x2F;获取特性标志位
void QTableWidgetItem::setFlags(Qt::ItemFlags flags) &#x2F;&#x2F;设置特性标志位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        QTableWidgetItem 构造<strong>时默认的标志位为</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>QT宏</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::ItemIsSelectable</td>
</tr>
<tr>
<td>Qt::ItemIsUserCheckable</td>
</tr>
<tr>
<td>Qt::ItemIsEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsDragEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsDropEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsEditable</td>
</tr>
</tbody>
</table>
</div>
<p>​        因此程序代码生成的所有表格条目默认都是可编辑的，程序运行时用户双击空的单元格时，表格控件会自动创建新条目保存用户编辑内容，这些自动创建的条目也都是可编辑的。如果希望条目是只读的，那么把标志位设置不带Qt::ItemIsEditable 的新标志位即可。</p>
<p>​        Qt::ItemFlags 所有的枚举常量在 8.1.2 节末尾有详细的表格描述，这里不重复贴了。表格条目默认就是支持复选状态的，只是默认没有显示出来，要让表格控件显示条目对应的复选框，可以用下面一句代码实现：</p>
<pre class="line-numbers language-none"><code class="language-none">item-&gt;setCheckState( Qt::Unchecked );  &#x2F;&#x2F;显示复选框<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        对于表格控件和表格条目，自带单行编辑器和复选框功能，因此不需要为单元格添加自定义的单行编辑器或复选框，如果要用到其他更多的输入控件，那才需要定制单元格。         表格控件条目与 QListWidgetItem 最大的一个区别就是表格条目既有行号，也有列号：</p>
<pre class="line-numbers language-none"><code class="language-none">int QTableWidgetItem::row() const &#x2F;&#x2F;获取行号
int QTableWidgetItem::column() const &#x2F;&#x2F;获取列号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        行号和列号也是在 QTableWidget::setItem() 函数里指定的，条目自身并不能修改行号或列号。表格控件条目与 QListWidgetItem 另一个区别是，<strong>表格控件条目没有隐藏函数，所有表格条目都是显示的（只要不被单元格控件QTableWidget::cellWidget() 遮挡）。</strong></p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;设函数列数
    ui-&gt;tableWidget-&gt;setColumnCount(3);

    &#x2F;&#x2F;设置表头
    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;&quot;姓名&quot;&lt;&lt;&quot;性别&quot;&lt;&lt;&quot;年龄&quot;);

    ui-&gt;tableWidget-&gt;setRowCount(10);
    ui-&gt;tableWidget-&gt;setItem(0,0,new QTableWidgetItem(&quot;泰勒&quot;));


&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230526202457563.png?lastModify=1685936981" alt="image-20230526202457563"></p>
<h2 id="其他常见的控件一览"><a href="#其他常见的控件一览" class="headerlink" title="其他常见的控件一览"></a>其他常见的控件一览</h2><h3 id="滚动条控件"><a href="#滚动条控件" class="headerlink" title="滚动条控件"></a>滚动条控件</h3><p>​        我们可以在UI界面中找到滚动条控件——Scroll Widget，将大量的控件扔到里面之后，可以得到：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230527100557180.png?lastModify=1685936981" alt="image-20230527100557180"></p>
<p>​        可以上下拖拽的那种！</p>
<h3 id="ToolBox"><a href="#ToolBox" class="headerlink" title="ToolBox"></a>ToolBox</h3><p>​        回忆一下，我们的ToolBox，就跟QQ的好友栏一样的</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230527100815303.png?lastModify=1685936981" alt="image-20230527100815303"></p>
<p>​        这里的Page1 和 Page2单击一下在属性栏的CurrrentPageName里更改就好了</p>
<h3 id="Tab-Widget"><a href="#Tab-Widget" class="headerlink" title="Tab Widget"></a>Tab Widget</h3><p>​        有点像网页那样的东西!</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230527101102584.png?lastModify=1685936981" alt="image-20230527101102584"></p>
<p>​        当然,我们切换就带上按钮就好了!,使用信号与槽即可</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230527101328100.png?lastModify=1685936981" alt="image-20230527101328100"></p>
<p>​        等等…</p>
<h3 id="利用QLable显示图片"><a href="#利用QLable显示图片" class="headerlink" title="利用QLable显示图片"></a>利用QLable显示图片</h3><p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230527101714658.png?lastModify=1685936981" alt="image-20230527101714658"></p>
<h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><p>​                可以在工程中新建一个QT文件_自定义设计师类&gt;默认的Widget类中!设计好空间之后返回主窗口的UI, 随后点击提升为(本质是换成子对象),将之提升为设计好的Widget的名称后点击提升,运行就可看到效果</p>
<p>​        点击全局提升口语下一次直接提升为.</p>
<p># </p>
<h2 id="QEvent"><a href="#QEvent" class="headerlink" title="QEvent"></a>QEvent</h2><p>​        下面我们自己写一个Lable，来学习自定义的事件这个模块。</p>
<p>​        首先，我们选择新建一个Widget：回忆下，就是在添加新文件下面——选择QWidget类型后include进来！</p>
<p>​        先不要着急include控件到UI界面下，我们修改几个地方：</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef MYLABEL_H
#define MYLABEL_H

#include &lt;QLabel&gt;

class MyLabel : public QLabel &#x2F;&#x2F; here
&#123;
    Q_OBJECT
public:
    explicit MyLabel(QWidget *parent &#x3D; nullptr);

    void enterEvent(QEnterEvent*); &#x2F;&#x2F; add this
    void leaveEvent(QEvent*); &#x2F;&#x2F;add this
signals:

&#125;;

#endif &#x2F;&#x2F; MYLABEL_H
#include &quot;mylabel.h&quot;
#include&lt;QDebug&gt;
MyLabel::MyLabel(QWidget *parent)
    : QLabel&#123;parent&#125;
&#123;

&#125;
void MyLabel::enterEvent(QEnterEvent* event)&#123;
    qDebug()&lt;&lt;&quot;111&quot;;
&#125;
void MyLabel::leaveEvent(QEvent*)&#123;
      qDebug()&lt;&lt;&quot;222&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​         然后在UI界面中添加Label控件，提升为MyLabel。现在：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230528171240039.png?lastModify=1685936981" alt="image-20230528171240039"></p>
<p>​        现在，进入正题——鼠标事件的改写。</p>
<p>​        我们添加如下的事件函数：</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef MYLABEL_H
#define MYLABEL_H

#include &lt;QLabel&gt;

class MyLabel : public QLabel
&#123;
    Q_OBJECT
public:
    explicit MyLabel(QWidget *parent &#x3D; nullptr);

    void enterEvent(QEnterEvent*);
    void leaveEvent(QEvent*);

    virtual void mousePressEvent(QMouseEvent* ev);
    virtual void mouseReleaseEvent(QMouseEvent* ev);
    virtual void mouseMoveEvent(QMouseEvent* ev);
signals:

&#125;;

#endif &#x2F;&#x2F; MYLABEL_H
#include &quot;mylabel.h&quot;
#include&lt;QDebug&gt;
MyLabel::MyLabel(QWidget *parent)
    : QLabel&#123;parent&#125;
&#123;

&#125;
void MyLabel::enterEvent(QEnterEvent* event)&#123;
    qDebug()&lt;&lt;&quot;111&quot;;
&#125;
void MyLabel::leaveEvent(QEvent*)&#123;
      qDebug()&lt;&lt;&quot;222&quot;;
&#125;

void MyLabel::mousePressEvent(QMouseEvent* ev)&#123;
      qDebug()&lt;&lt;&quot;You press your mouse&quot;;
&#125;
void MyLabel::mouseReleaseEvent(QMouseEvent* ev)&#123;
      qDebug() &lt;&lt; &quot;yes, you depress the mouse&quot;;
&#125;
void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;
      qDebug() &lt;&lt; &quot;yes, you move mouse&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230528171807801.png?lastModify=1685936981" alt="image-20230528171807801"></p>
<p>​        我们的ev实际上就返回了所有的信息：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;mylabel.h&quot;
#include&lt;QDebug&gt;
#include&lt;QMouseEvent&gt;
MyLabel::MyLabel(QWidget *parent)
    : QLabel&#123;parent&#125;
&#123;

&#125;
void MyLabel::enterEvent(QEnterEvent* event)&#123;
    qDebug()&lt;&lt;&quot;111&quot;;
&#125;
void MyLabel::leaveEvent(QEvent*)&#123;
      qDebug()&lt;&lt;&quot;222&quot;;
&#125;

void MyLabel::mousePressEvent(QMouseEvent* ev)&#123;
      qDebug()&lt;&lt;&quot;You press your mouse&quot;;
&#125;
void MyLabel::mouseReleaseEvent(QMouseEvent* ev)&#123;
      qDebug() &lt;&lt; &quot;yes, you depress the mouse&quot;;
&#125;
void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;
      QString str &#x3D; QString(&quot;yes, you move mouse x &#x3D; %1 y &#x3D; %2&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()); &#x2F;&#x2F; QString的格式化
      qDebug() &lt;&lt;str;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230528172343019.png?lastModify=1685936981" alt="image-20230528172343019"></p>
<p>​        还有globle的，表明是相对于屏幕的为止！</p>
<p>​        如果是检测是不是：</p>
<pre class="line-numbers language-none"><code class="language-none">void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;
    if(ev-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;
        QString str &#x3D; QString(&quot;yes, you move mouse x &#x3D; %1 y &#x3D; %2&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()); &#x2F;&#x2F; QString的格式化
      	qDebug() &lt;&lt;str;   
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Qt-Event事件详解"><a href="#Qt-Event事件详解" class="headerlink" title="Qt Event事件详解"></a>Qt Event事件详解</h2><p>​        传送门：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/48f007c2de09">https://www.jianshu.com/p/48f007c2de09</a></p>
<p>​        <strong>在与用户交互时发生</strong>。比如按下鼠标（mousePressEvent），敲击键盘（keyPressEvent）等。         <strong>系统自动发生</strong>，比如计时器事件（timerEvent）等。 在发生事件时（比如说上面说的按下鼠标），就会产生一个QEvent对象（这里是QMouseEvent，为QEvent的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=子类&amp;spm=1001.2101.3001.7020">子类</a>），这个QEvent对象会传给当前组件的event函数。如果当前组件没有安装事件过滤器（这个下文会提到），则会被event函数发放到相应的xxxEvent函数中（这里是mousePressEvent函数）。</p>
<p>​        Qt中所有的事件类都继承于QEvent类</p>
<p>​        这个QEvent对象会有各种各样的属性，这是由用户与界面交互时产生的。xxxEvent函数可以对其进行不同的处理（比如说是鼠标左键按下还是右键？）。查看帮助文档，可以看到QMouseEvent类有以下枚举。 在QtCreator中查看帮助文档 那么就可以在mousePressEvent中根据这个QEvent对象的这些枚举值来进行不同的处理，比如</p>
<pre class="line-numbers language-none"><code class="language-none">class myLabel : public QLabel
&#123;
protected:
    void mousePressEvent(QMouseEvent *event);
&#125;;

void myLabel::mousePressEvent(QMouseEvent *event)
&#123;
    if(event-&gt;Buttons &#x3D;&#x3D; LeftButton)
    &#123;
        &#x2F;&#x2F;do sth
    &#125;
    else if(event-&gt;Buttons &#x3D;&#x3D; RightButton)
    &#123;
        &#x2F;&#x2F;do sth
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        可以看到，我们首先需要先创建一个自己的QLabel类，并继承于Qt的QLabel类，然后并重写相应的xxxEvent函数（这些事件处理函数都是虚函数）。</p>
<p>​        Qt程序的main函数中需要创建一个QApplication对象，然后调用exec函数。这将令程序进入一个死循环，并不断监听应用程序的事件，发生事件时就生成一个QEvent对象。这又称为事件循环。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;QApplication&gt;
#include &quot;mainwindow.h&quot;

int main(int argc, char *argv[])
&#123;
    QApplication app(argc, argv);
    MainWindow window;
    window.show();

    return app.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="二、事件的分发：event函数"><a href="#二、事件的分发：event函数" class="headerlink" title="二、事件的分发：event函数"></a>二、事件的分发：event函数</h3><p>​        上面提到的xxxEvent函数，称为事件处理器（event handler）。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听某个按键的按下。</p>
<pre class="line-numbers language-none"><code class="language-none">bool myWidget::event(QEvent *e)
&#123;
    if (e-&gt;type() &#x3D;&#x3D; QEvent::KeyPress) 
    &#123;
        &#x2F;&#x2F;将QEvent对象转换为真正的QKeyEvent对象
        QKeyEvent *keyEvent &#x3D; static_cast&lt;QKeyEvent *&gt;(e);
        if (keyEvent-&gt;key() &#x3D;&#x3D; Qt::Key_Tab) 
        &#123;
            qDebug() &lt;&lt; &quot;You press tab.&quot;;
            return true;
        &#125;
    &#125;
    &#x2F;&#x2F;按照原来的流程来进行事件的分发
    return QWidget::event(e);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在上面的程序中，myWidget是QWidget的子类。同样的，它的event函数是一个虚函数，带有一个QEvent类型的参数。当系统产生QEvent对象时，就会传入这个函数并调用。函数的返回值是bool类型，返回值不同有不同的意义。</p>
<p>​        如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。 <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODczOTU5OA==,size_16,color_FFFFFF,t_70.png?lastModify=1685936981" alt="在这里插入图片描述"></p>
<p>​        Qt系统在处理事件时，有一种机制叫事件传播机制。也就是说，在子组件（比如说一个QButton）中发生的事件，调用了子组件的event函数之后，还会调用父组件（比如说QWidget）的event函数。event函数的返回值就用于控制这样的一个过程。</p>
<p>​        需要注意的是，重写event函数之后最好返回父类的event函数来处理其他的事件分发，不然就只能处理自己定义的事件。</p>
<pre class="line-numbers language-none"><code class="language-none">bool myTextEdit::event(QEvent *e)
&#123;
    if (e-&gt;type() &#x3D;&#x3D; QEvent::KeyPress) 
    &#123;
        &#x2F;&#x2F;将QEvent对象转换为真正的QKeyEvent对象
        QKeyEvent *keyEvent &#x3D; static_cast&lt;QKeyEvent *&gt;(e);
        if (keyEvent-&gt;key() &#x3D;&#x3D; Qt::Key_Tab) 
        &#123;
            qDebug() &lt;&lt; &quot;You press tab.&quot;;
            return true;
        &#125;
    &#125;
    &#x2F;&#x2F;直接返回false
    return false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在这个例子中，因为没有调用父类QTextEdit的event函数，所以只能处理Tab的情况，你再按其他按键就啥反应都没有了。同样，事件也不能进行传播。</p>
<h3 id="三、事件过滤器（Even-Filter）"><a href="#三、事件过滤器（Even-Filter）" class="headerlink" title="三、事件过滤器（Even Filter）"></a>三、事件过滤器（Even Filter）</h3><p>​        某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器（evenFilter）。</p>
<p>​        QObject有一个虚函数，原型如下</p>
<pre class="line-numbers language-none"><code class="language-none">virtual bool QObject::eventFilter ( QObject * watched, QEvent * event );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件（产生的QEvent对象）。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p>
<p>​        实际使用中，我们需要对QObject组件调用installEvenFilter函数，即为组件安装过滤器，才能使用事件过滤器这个机制。这样，该组件及其子组件的事件就会被监听。这个机制的好处在于不用像重写QEvent和xxxEvent函数一样需要继承Qt的内置类。</p>
<pre class="line-numbers language-none"><code class="language-none">void QObject::installEventFilter ( QObject * filterObj );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        下面举一个例子。MainWindow中有一个QTextEdit控件，我们拦截它的键盘按下的事件。这样处理之后，会在输出窗口打印出按下的键位，但不会在控件上显示。这表明事件已被拦截，不会去调用even函数。</p>
<pre class="line-numbers language-none"><code class="language-none">class MainWindow : public QMainWindow
&#123;
public:
    MainWindow();
protected:
    bool eventFilter(QObject *obj, QEvent *event);
private:
    QTextEdit *textEdit;
&#125;;
 
MainWindow::MainWindow()
&#123;
    textEdit &#x3D; new QTextEdit;
    setCentralWidget(textEdit);
    
    textEdit-&gt;installEventFilter(this);
&#125;
 
bool MainWindow::eventFilter(QObject *obj, QEvent *event)
&#123;
    if (obj &#x3D;&#x3D; textEdit) 
    &#123;
        if (event-&gt;type() &#x3D;&#x3D; QEvent::KeyPress) 
        &#123;
            QKeyEvent *keyEvent &#x3D; static_cast&lt;QKeyEvent *&gt;(event);
            qDebug() &lt;&lt; &quot;you press&quot; &lt;&lt; keyEvent-&gt;key();
            &#x2F;&#x2F;事件不再进行传播，拦截
            return true;
        &#125; 
        else
        &#123;
            return false;&#x2F;&#x2F;继续传播
        &#125;
    &#125; 
    else 
    &#123;
        &#x2F;&#x2F;当不确定是否继续传播时，按照父类的方法来处理
        &#x2F;&#x2F;即调用父类的evenFilter函数
        return QMainWindow::eventFilter(obj, event);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样的，even函数能干的事情，evenFilter也能干。比如说上面的处理键盘按下Tab键。</p>
<pre class="line-numbers language-none"><code class="language-none">bool myObject::eventFilter(QObject *object, QEvent *event)
&#123;
    if (object &#x3D;&#x3D; target &amp;&amp; event-&gt;type() &#x3D;&#x3D; QEvent::KeyPress) 
    &#123;
        QKeyEvent *keyEvent &#x3D; static_cast&lt;QKeyEvent *&gt;(event);
        if (keyEvent-&gt;key() &#x3D;&#x3D; Qt::Key_Tab) 
        &#123;
            qDebug() &lt;&lt; &quot;You press tab.&quot;;
            &#x2F;&#x2F;拦截
            return true;
        &#125; 
        else 
        &#123;
            &#x2F;&#x2F;不进行拦截
            return false;
        &#125;
    &#125;
    &#x2F;&#x2F;不进行拦截
    return false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们可以对QApplication或者QCoreApplication对象添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。这种行为会严重降低整个应用程序的事件分发效率，要看具体情况使用。</p>
<p>​        事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>Qt中使用事件机制，每一种事件对应一个事件处理器，比如：</p>
<ul>
<li>mouseEvent()</li>
<li>keyPressEvent()</li>
<li>etc… 发生事件时会生成一个QEvent对象，则需要even函数进行分发，来调用相应的事件处理器</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">switch (event-&gt;type()) 
&#123;
    case QEvent::MouseMove:
        mouseMoveEvent((QMouseEvent*)event);
        break;
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        事件过滤器（evenFilter）可以令事件进行拦截，阻止其传播，从而实现某些功能。</p>
<p>另外，有一种一般很少使用的方法，即去重写这么一个函数</p>
<pre class="line-numbers language-none"><code class="language-none">virtual bool QCoreApplication::notify ( QObject * receiver, QEvent * event );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该函数原实现相当于让组件调用even函数，即receiver-&gt;event(event)。这相当于全局的事件过滤器，且不会受到多线程的限制。</p>
<p>那么，在使用Qt的事件机制时，应该按照以下思路进行</p>
<ul>
<li>重写paintEvent、mousePressEvent等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</li>
<li>重写event函数。event函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</li>
<li>在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</li>
<li>在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，但会有多线程问题。</li>
<li>重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。</li>
</ul>
<h2 id="鼠标事件（QMouseEvent）"><a href="#鼠标事件（QMouseEvent）" class="headerlink" title="鼠标事件（QMouseEvent）"></a>鼠标事件（QMouseEvent）</h2><p>传送门：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44386034/article/details/125637737">https://blog.csdn.net/qq_44386034/article/details/125637737</a></p>
<p>​        常用的鼠标事件：(本篇处理事件用的是方法一：重写鼠标事件)</p>
<pre class="line-numbers language-none"><code class="language-none">void mousePressEvent(QMouseEvent *event);           &#x2F;&#x2F;单击
void mouseReleaseEvent(QMouseEvent *event);       &#x2F;&#x2F;释放
void mouseDoubleClickEvent(QMouseEvent *event); &#x2F;&#x2F;双击
void mouseMoveEvent(QMouseEvent *event);           &#x2F;&#x2F;移动
void wheelEvent(QWheelEvent *event);                      &#x2F;&#x2F;滑轮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        鼠标事件使用的时候，加头文件：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;QMouseEvent&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>重写事件框架：</p>
<pre class="line-numbers language-none"><code class="language-none">鼠标按下事件
void Widget::mousePressEvent(QMouseEvent *event)
&#123;
    &#x2F;&#x2F; 如果是鼠标左键按下   
    if(event-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;
        ···
    &#125;
    &#x2F;&#x2F; 如果是鼠标右键按下
    else if(event-&gt;button() &#x3D;&#x3D; Qt::RightButton)&#123;
       ···
    &#125;
&#125;

鼠标移动事件

void Widget::mouseMoveEvent(QMouseEvent *event)
&#123;
    &#x2F;&#x2F; 这里必须使用buttons()
    if(event-&gt;buttons() &amp; Qt::LeftButton)&#123;  &#x2F;&#x2F;进行的按位与
       ···
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        默认情况下，触发事件需要点击一下，才能触发。可设置为自动触发:</p>
<pre class="line-numbers language-none"><code class="language-none">setMouseTracking(true); 
鼠标释放事件

void Widget::mouseReleaseEvent(QMouseEvent *event)
&#123;
   ···
&#125;

鼠标双击事件

void Widget::mouseDoubleClickEvent(QMouseEvent *event)
&#123;
    &#x2F;&#x2F; 如果是鼠标左键按下
    if(event-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;
      

        ···
    &#125;

&#125;

滚轮事件

void Widget::wheelEvent(QWheelEvent *event)
&#123;
    &#x2F;&#x2F; 当滚轮远离使用者时
    if(event-&gt;delta() &gt; 0)&#123;
        ···
    &#125;else&#123;&#x2F;&#x2F;当滚轮向使用者方向旋转时
        ···
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实例演示-在label控件中，移动鼠标获取实时位置，并显示在界面上"><a href="#实例演示-在label控件中，移动鼠标获取实时位置，并显示在界面上" class="headerlink" title="实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)"></a>实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)</h3><p>​        创建mylabel类，基类设置为QLabel <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/b63f2e133baf5913fe5393dc477bfe20.png?lastModify=1685936981" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">这里用了类似自定义控件的方法，对Mylabel类进行封装。设置基类QLabel 是为了在ui界面中提升label控件(即将label控件和Mylabel关联，提升时候必须二者基类相同)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在mylabel.h中声明鼠标事件</p>
<pre class="line-numbers language-none"><code class="language-none">#pragma once
#include &lt;qlabel.h&gt;

class mylabel : public QLabel
&#123;
public:
    mylabel(QWidget* parent &#x3D; 0);
    ~mylabel();
public:
    &#x2F;&#x2F;鼠标移动事件
    void mouseMoveEvent(QMouseEvent* event);
    &#x2F;&#x2F;鼠标按下事件
    void mousePressEvent(QMouseEvent* event);
    &#x2F;&#x2F;鼠标释放事件
    void mouseReleaseEvent(QMouseEvent* event);
&#125;;

在mylabel.cpp中重写事件
#include &quot;mylabel.h&quot;
#include&quot;QMouseEvent&quot;


mylabel::mylabel(QWidget* parent) :QLabel(parent)
&#123;
    
&#125;
mylabel::~mylabel()
&#123;

&#125;
&#x2F;&#x2F;鼠标移动显示坐标
void mylabel::mouseMoveEvent(QMouseEvent* event)
&#123;
    if (event-&gt;buttons() &amp; Qt::LeftButton)  &#x2F;&#x2F;进行的按位与(只有左键点击移动才满足)
    &#123; 
        QString str &#x3D; QString(&quot;Move:(X:%1,Y:%2)&quot;).arg(event-&gt;x()).arg(event-&gt;y());
         this-&gt;setText(str);
         

    &#125;

&#125;
&#x2F;&#x2F;鼠标按下显示“ok，mouse is press”
void mylabel::mousePressEvent(QMouseEvent* event)
&#123;
    setText(&quot;Ok, mouse is press&quot;);

&#125;
&#x2F;&#x2F;鼠标释放清除显示
void mylabel::mouseReleaseEvent(QMouseEvent* event)
&#123;
    setText(&quot; &quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在主函数(QTest.cpp)中声明mylabel的类对象(即声明一个mylabel类的label控件)</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;qtest.h&quot;

QTest::QTest(QWidget *parent)
    : QWidget(parent)
&#123;
    ui.setupUi(this);
    &#x2F;&#x2F;声明mylabel类的控件
    mylabel* label1 &#x3D; new mylabel(this);
    label1-&gt;setGeometry(QRect(130, 100, 271, 161));
    &#x2F;&#x2F;设置边框
    label1-&gt;setFrameShape(QFrame::Panel);
&#125;
	![img](D:\My notebook project\Program language\C++\QT\QT new 13\2b78bd5ca82261a28798c809af0ef282.gif)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        另外，当调用setMouseTracking(true);时(即设置鼠标状态为自动触发)，需要将鼠标移动事件的if语句去掉(因为不需要点击触发了)</p>
<p>​        修改maylabel.cpp事件：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;mylabel.h&quot;
#include&quot;QMouseEvent&quot;


mylabel::mylabel(QWidget* parent) :QLabel(parent)
&#123;
    &#x2F;&#x2F;设置鼠标状态(自动触发)
    setMouseTracking(true);
&#125;
mylabel::~mylabel()
&#123;

&#125;
&#x2F;&#x2F;鼠标移动显示坐标
void mylabel::mouseMoveEvent(QMouseEvent* event)
&#123;
   QString str &#x3D; QString(&quot;Move:(X:%1,Y:%2)&quot;).arg(event-&gt;x()).arg(event-&gt;y());
   this-&gt;setText(str);
&#125;
&#x2F;&#x2F;鼠标按下显示“ok，mouse is press”
void mylabel::mousePressEvent(QMouseEvent* event)
&#123;
    setText(&quot;Ok, mouse is press&quot;);

&#125;
&#x2F;&#x2F;鼠标释放清除显示
void mylabel::mouseReleaseEvent(QMouseEvent* event)
&#123;
    setText(&quot; &quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>效果展示：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/0c83943e6ee8c74e39d09db4a899b2c6.gif?lastModify=1685936981" alt="img"></p>
<p>​        这里用的是代码创建label控件，那么能不能用ui界面编辑然后在对label控件提升呢？</p>
<p>答案是可以的，但是需要注意的是：此处不能选择全局包含</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/4cb8112d483f6e94c8fe196258871445.png?lastModify=1685936981" alt="img"></p>
<p> 否则会出现：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/e7df65e65f36ed436c5ec6ab7c41f417.png?lastModify=1685936981" alt="img"></p>
<p>​        我想其中的原因主要是因为：</p>
<p>​        本实例是新建了一个mylabel类，而不是像QT常用控件(三)——自定义控件封装 - 唯有自己强大 - 博客园 (cnblogs.com)这篇博文中直接新添加了一个设计师界面类(即包含ui .h .cpp)。当选择全局包含时，就包含了主类。</p>
<p>​        其实也有解决的办法：需要在提升界面的头文件处，将工程目录下自定义控件的地址放于此处(本篇地址：C:/Users/WFD/Desktop/QTest/QTest/mylabel.h)</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/c3a41a90d53c14e6f9e28ea56aa4c497.png?lastModify=1685936981" alt="img"></p>
<p> 二，事件的分发：event函数     上面提到的xxxEvent函数，称为事件处理器(event handler)。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听(阻塞)鼠标按下事件。</p>
<pre class="line-numbers language-none"><code class="language-none">如果希望在事件分发之前做一些操作，就可以重写这个 event()函数了。比如我们希望阻塞鼠标按下事件，那么我们就在新建的Mylabel类中重写event()函数(该类的父类是QLabel)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在Mylabel.h中声明event事件</p>
<pre class="line-numbers language-none"><code class="language-none">#include&quot;qlabel.h&quot;
class Mylabel : public QLabel
&#123;
public:
    explicit Mylabel(QWidget* parent &#x3D; 0);

    &#x2F;&#x2F;鼠标按下事件
    void mousePressEvent(QMouseEvent* event); 
    &#x2F;&#x2F;鼠标释放事件
    void mouseReleaseEvent(QMouseEvent* event);
    &#x2F;&#x2F;声明event事件
    bool event(QEvent* e);

&#125;;

在Mylabel.cpp中重写event事件。
#include &quot;Mylabel.h&quot;
#include&quot;QMouseEvent&quot;

Mylabel::Mylabel(QWidget* parent) :QLabel(parent)
&#123;

&#125;

&#x2F;&#x2F;重写鼠标按下事件
void Mylabel::mousePressEvent(QMouseEvent* event)
&#123;
    this-&gt;setText(QString(&quot;mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
&#125;
&#x2F;&#x2F;重写鼠标释放事件
void Mylabel::mouseReleaseEvent(QMouseEvent* event)
&#123;
    this-&gt;setText(&quot;mouse is release &quot;);
&#125;
&#x2F;&#x2F;重写event事件
bool Mylabel::event(QEvent* e)
&#123;
    &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截
    if (e-&gt;type()&#x3D;&#x3D;QEvent::MouseButtonPress)
    &#123;
        &#x2F;&#x2F;静态转换(将QEvent的对象转换为QMouseEvent对象)
        QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);
        this-&gt;setText(QString(&quot;event mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
        return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)
    &#125;
    return QLabel::event(e);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/06ef2891b59dcc3d4f1953b7e3404c5e.png?lastModify=1685936981" alt="img"></p>
<p>​        点击鼠标可以看到，触发的是event的事件(即阻塞了mousePressEvent的事件)。特别需要注意的是：在将不需要阻塞分发的时候，需要分发给父类的event函数处理。即(return QLable::event(e)；)</p>
<p>​        由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个 event()函数，通过 QEvent::type()判断不同的事件。鉴于重写 event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器(当然，也必须记得是不是应该调用父类的同名处理器)。</p>
<h3 id="三，事件过滤器-Even-Filter"><a href="#三，事件过滤器-Even-Filter" class="headerlink" title="三，事件过滤器(Even Filter)"></a>三，事件过滤器(Even Filter)</h3><p>​         某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器，该过滤器在event分发之前进行拦截。</p>
<p>事件的过滤有两个步骤：</p>
<p>​        对QObject组件安装过滤器(调用installEvenFilter函数)</p>
<pre class="line-numbers language-none"><code class="language-none">void QObject::installEventFilter ( QObject * filterObj );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数filterobj 是指谁为组件安装过滤器(一般是父类)</p>
<p>​        这个函数接受一个 QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是 QObject 的一个成员函数，因此，任意 QObject 都可以作为事件过滤器(问题在于，如果你没有重写 eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤)。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。  我们可以向一个对象上面安装多个事件处理器 ，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。         事件过滤器的重写(evenFilter函数)</p>
<pre class="line-numbers language-none"><code class="language-none">virtual bool QObject::eventFilter ( QObject * watched, QEvent * event );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件(产生的QEvent对象)。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p>
<p>​        实例：通过事件过滤器阻塞上面代码中的鼠标按下事件</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;qtest.h&quot;
#include&quot;qmouseevent&quot;

QTest::QTest(QWidget *parent)
    : QWidget(parent)
&#123;
    ui.setupUi(this);
    &#x2F;&#x2F;第一步：给label添加过滤器
    ui.label-&gt;installEventFilter(this);


&#125;
&#x2F;&#x2F;第二步：重写过滤事件
bool QTest::eventFilter(QObject* obj, QEvent* e)
&#123;
    if (obj &#x3D;&#x3D; ui.label)
    &#123;
        &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截
        if (e-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress)
        &#123;
            QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);
            ui.label-&gt;setText(QString(&quot;eventfilter mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
            return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)
        &#125;
    &#125;
    return QWidget::eventFilter(obj, e);
&#125;

&#x2F;&#x2F;重写鼠标按下事件
void QTest::mousePressEvent(QMouseEvent* event)
&#123;
    ui.label-&gt;setText(QString(&quot;mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
&#125;

&#x2F;&#x2F;重写事件分发
bool QTest::event(QEvent* e)
&#123;
    &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截
    if (e-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress)
    &#123;
        QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);
        ui.label-&gt;setText(QString(&quot;event mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
        return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)
    &#125;
    return QWidget::event(e);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：<img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/09dd8a5f89d61fa32b9e3800fe5fff9a.png?lastModify=1685936981" alt="img"></p>
<p>​    可以看到在过滤器事件中就监听了鼠标按压(即阻塞了后面的事件分发和鼠标按压)</p>
<p># </p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>​        我们的定时器可以做到随着事件的事件流逝触发事件。</p>
<p>​        我们的办法是：添加窗口的代码，从而实现计时器。</p>
<p>​        在窗口中添加两个label:</p>
<p>​        随后改写事件：</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef WIDGET_H
#define WIDGET_H

#include &lt;QWidget&gt;

QT_BEGIN_NAMESPACE
namespace Ui &#123; class Widget; &#125;
QT_END_NAMESPACE

class Widget : public QWidget
&#123;
    Q_OBJECT

public:
    Widget(QWidget *parent &#x3D; nullptr);
    ~Widget();
    void timerEvent(QTimerEvent*);

    int id1;
    int id2;
private:
    Ui::Widget *ui;
&#125;;
#endif &#x2F;&#x2F; WIDGET_H
#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;启动定时器
    id1  &#x3D; startTimer(1000);&#x2F;&#x2F;1,间隔, 单位是毫秒

    id2 &#x3D; startTimer(2000);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;

void Widget::timerEvent(QTimerEvent* ev)&#123;
    if(ev-&gt;timerId() &#x3D;&#x3D; id1)&#123;

        static int num &#x3D; 1;
        ui-&gt;label_2-&gt;setText(QString::number(num++));

    &#125;
     if(ev-&gt;timerId() &#x3D;&#x3D; id2)
    &#123;
        static int num2 &#x3D; 1;
        ui-&gt;label_3-&gt;setText(QString::number(num2++));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意到，对于多个计时器需要接受返回ID并加之以判断才好！</p>
<h2 id="类的形式"><a href="#类的形式" class="headerlink" title="类的形式"></a>类的形式</h2><p>​        这个形式简单的多!直接一个类解决所有的问题!</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include&lt;QTimer&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;启动定时器
    id1  &#x3D; startTimer(1000);&#x2F;&#x2F;1,间隔, 单位是毫秒

    id2 &#x3D; startTimer(2000);

    QTimer* timer &#x3D; new QTimer(this);

    timer-&gt;start(500); &#x2F;&#x2F; 到0.5秒发出信号

    connect(timer,&amp;QTimer::timeout,[&#x3D;]()&#123;
        static int num &#x3D; 1;
        ui-&gt;label_4-&gt;setText(QString::number(num++));

    &#125;);

    &#x2F;&#x2F;

    connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[&#x3D;]()&#123;
        timer-&gt;stop();

    &#125;);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;

void Widget::timerEvent(QTimerEvent* ev)&#123;
    if(ev-&gt;timerId() &#x3D;&#x3D; id1)&#123;

        static int num &#x3D; 1;
        ui-&gt;label_2-&gt;setText(QString::number(num++));

    &#125;
     if(ev-&gt;timerId() &#x3D;&#x3D; id2)
    &#123;
        static int num2 &#x3D; 1;
        ui-&gt;label_3-&gt;setText(QString::number(num2++));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Extensive-Reading"><a href="#Extensive-Reading" class="headerlink" title="Extensive Reading"></a>Extensive Reading</h2><p>​        传送门：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Mountain_tai_li/article/details/130529628">https://blog.csdn.net/Mountain_tai_li/article/details/130529628</a></p>
<p>​        QTimer 类提供重复和单次计时器。</p>
<p>​        QTimer 类为计时器提供了一个高级编程接口。要使用它，首先创建一个 QTimer实例，将其 timeout() 信号连接到相应的插槽，然后调用 start()。从那时起，它将以恒定的间隔发出 timeout() 信号。</p>
<p>​        一秒（1000毫秒）计时器的示例（来自模拟时钟示例）：</p>
<pre class="line-numbers language-none"><code class="language-none">QTimer *timer &#x3D; new QTimer(this);
connect(timer, SIGNAL(timeout()), this, SLOT(update()));
timer-&gt;start(1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        从那时起，每秒调用一次 update() 槽函数。</p>
<p>​        也可以通过调用 setSingleShot（true） 将计时器设置为仅超时一次。您还可以使用静态 QTimer::singleShot() 函数在指定的时间间隔后调用槽函数：</p>
<p>​        QTimer::singleShot(200, this, SLOT(updateCaption()));         在多线程应用程序中，可以在任何具有事件循环的线程中使用 QTimer。要从非 GUI 线程启动事件循环，使用 QThread::exec()。Qt使用计时器的线程亲和力来确定哪个线程将发出timeout()信号。因此，您必须在其线程中启动和停止计时器;无法从另一个线程启动计时器。作为特殊情况timeout 为 0 的 QTimer 将在窗口系统的事件队列中的所有事件都得到处理后立即timeout。这可用于完成繁重的工作，同时提供活泼的用户界面：</p>
<pre class="line-numbers language-none"><code class="language-none">QTimer *timer &#x3D; new QTimer(this);
connect(timer, SIGNAL(timeout()), this, SLOT(processOneThing()));
timer-&gt;start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        从那时起，processOneThing()槽函数将被重复调用。它应该以这样一种方式编写，即它总是快速返回（通常在处理一个数据项之后），以便Qt可以将事件传递到用户界面，并在完成所有工作后立即停止计时器。这是在GUI应用程序中实现繁重工作的传统方式，但随着多线程在越来越多的平台上变得可用，我们预计零毫秒QTimer对象将逐渐被QThreads取代。</p>
<p>​        定时器精度和分辨率         计时器的准确性取决于底层操作系统和硬件。大多数平台都支持 1 毫秒的分辨率，尽管在许多现实情况下，计时器的精度不会等于此分辨率。</p>
<p>​        精度还取决于计时器类型。对于Qt::PreciseTimer，QTimer将尝试将精度保持在1毫秒。精确的计时器也不会比预期早超时。对于 Qt::CoarseTimer 和 Qt::VeryCoarseTimer 类型，QTimer 可能会比预期更早timeout，在这些类型的范围内：Qt::CoarseTimer 的间隔为 5%，Qt::VeryCoarseTimer 的间隔为 500 毫秒。如果系统繁忙或无法提供请求的准确性，则所有计时器类型都可能晚于预期超时。在timeout 溢出的情况下，Qt只会发出一次active()，即使多个超时已经过期，然后恢复原始间隔。 </p>
<p># </p>
<h2 id="事件过滤器"><a href="#事件过滤器" class="headerlink" title="事件过滤器"></a>事件过滤器</h2><p>​        通过事件过滤器，可以在程序分发到event事件之前做一次高级的拦截。</p>
<p>​        使用：</p>
<p>​        1）给空间加上事件过滤器</p>
<p>​        2）重写eventFilter事件。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/goforwardtostep/article/details/124824749">https://blog.csdn.net/goforwardtostep/article/details/124824749</a></p>
<h2 id="Extensive-Reading-1"><a href="#Extensive-Reading-1" class="headerlink" title="Extensive Reading"></a>Extensive Reading</h2><h3 id="一、Qt中事件过滤器详解"><a href="#一、Qt中事件过滤器详解" class="headerlink" title="一、Qt中事件过滤器详解"></a>一、Qt中事件过滤器详解</h3><p>​        我们先看下另外两个相关的方法，一个是给对象安装某个事件过滤器，一个是移除对应的事件过滤器。</p>
<pre class="line-numbers language-none"><code class="language-none">void QObject::installEventFilter(QObject *filterObj)
void QObject::removeEventFilter(QObject *obj)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        下方代码使用 installEventFilter方法 给对象objA安装objB的事件过滤器，这样objB对象的eventFilter方法中就可以接收到objA对象的所有事件了，如果objA对象不想objB对象再监听自己的事件了就使用 removeEventFilter方法移除objB对象对事件的监听。</p>
<pre class="line-numbers language-none"><code class="language-none">QObject* objA &#x3D; new MyQObjectA;
QObject* objB &#x3D; new MyQObjectB;
&#x2F;&#x2F; 安装事件过滤器;    
objA-&gt;installEventFilter(objB);
&#x2F;&#x2F; 移除事件过滤器;
objA-&gt;removeEventFilter(objB);
bool QObject::eventFilter(QObject *watched, QEvent *event)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        事件过滤器我们听到这个名字可能就会理解为对事件进行过滤，但是实际上，事件过滤器并不只是过滤事件，也可以对事件进行捕捉、并做出相应的处理操作。对象A只有安装了对象B的事件过滤器，才会在对象B的eventFilter方法中进行监控对象A的所有事件。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/10777f04175f4ada80742d16b7bd4ae9.png?lastModify=1685936981" alt="在这里插入图片描述"></p>
<h3 id="事件过滤器使用的三种方式："><a href="#事件过滤器使用的三种方式：" class="headerlink" title="事件过滤器使用的三种方式："></a>事件过滤器使用的三种方式：</h3><p>1、父窗口类通过重写eventFilter方法来监听子控件的相关事件进行处理。     使用这种方式的好处是不需要通过重写控件的方式获取某些事件，对于安装了事件过滤器的对象，他们所有的事件都会经过这个事件过滤器，所以就可以直接在父窗口中进行监测。比如某个窗口中有个QLabel对象，我们想要监听他的鼠标点击事件，那我们就需要继承QLabel类，然后重写mousePressEvent事件，如果有其他类型的控件也需要获取某个事件，那是不是都需要继续控件并重写某个事件了，所以我们通过事件过滤器就可以很方便获取某个对象的某个事件。</p>
<p>​        下面这个例子中MyLineEdit和MyBtn继承了QLineEdit和QPushButton，分别重写了两者的键盘按下（keyPressEvent）和鼠标按下事件（mousePressEvent），然后在他们的父窗口EventTestWgt中重写了事件过滤器（eventFilter），并给MyLineEdit和MyBtn对象及本身都安装了事件过滤器。         在此过滤器中捕捉到相应的事件，通过返回true，过滤输入框的键盘按下事件、过滤按钮的鼠标按下事件，过滤本身的鼠标按下事件，通过返回false，让本身的键盘按下事件继续传递，所以我们看到MyLineEdit的keyPressEvent方法、MyBtn的mousePressEvent以及EventTestWgt的mousePressEvent都不会被调用，只有EventTestWgt的keyPressEvent会被调用。</p>
<p>​        通过这个例子，我们看到事件过滤器可以对本身以及其他类的对象捕捉事件进行处理/过滤，同时也验证了第一种方式中的说法，可以不继承QLineEdit或者QPushButton就可以捕获子部件的相关事件进行处理，不需要对此类进行重写。</p>
<pre class="line-numbers language-none"><code class="language-none">EventTestWgt.h
class MyLineEdit : public QLineEdit
&#123;
public:
	MyLineEdit(QWidget* parent &#x3D; nullptr);

private:
	void keyPressEvent(QKeyEvent *event);
&#125;;

class MyBtn : public QPushButton
&#123;
	Q_OBJECT

public:
	MyBtn(QWidget* parent &#x3D; nullptr);

private:
	void mousePressEvent(QMouseEvent *event);
&#125;;

class EventTestWgt : public QWidget
&#123;
	Q_OBJECT

public:
	EventTestWgt(QWidget *parent &#x3D; nullptr);
	~EventTestWgt();

private:
	void initWgt();
	void initConnections();

private:
	void keyPressEvent(QKeyEvent *event);
	void mousePressEvent(QMouseEvent *event);

private:
	bool eventFilter(QObject *watched, QEvent *event);

private slots:
	void onBtnClicked();

private:
	MyLineEdit* m_lineEdit;
	MyBtn* m_pBtn;
&#125;;

EventTestWgt.cpp
#include &quot;EventTestWgt.h&quot;
#include &lt;QDebug&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QKeyEvent&gt;
#include &lt;QMouseEvent&gt;
#include &lt;QEvent&gt;

MyLineEdit::MyLineEdit(QWidget* parent &#x2F;*&#x3D; nullptr*&#x2F;)
	: QLineEdit(parent)
&#123;
&#125;

void MyLineEdit::keyPressEvent(QKeyEvent *event)
&#123;
	qDebug() &lt;&lt; &quot;MyLineEdit::keyPressEvent&quot; &lt;&lt; event-&gt;key();

	return QLineEdit::keyPressEvent(event);

&#125;

MyBtn::MyBtn(QWidget* parent &#x2F;*&#x3D; nullptr*&#x2F;)
&#123;
&#125;

void MyBtn::mousePressEvent(QMouseEvent *event)
&#123;
	qDebug() &lt;&lt; &quot;MyBtn::mousePressEvent&quot;;

	return QPushButton::mousePressEvent(event);

&#125;

EventTestWgt::EventTestWgt(QWidget *parent)
	: QWidget(parent)
&#123;
	initWgt();
	initConnections();
	

	this-&gt;resize(300, 200);

&#125;

EventTestWgt::~EventTestWgt()
&#123;
&#125;

void EventTestWgt::initWgt()
&#123;
    &#x2F;&#x2F; 给自己安装事件过滤器;
    this-&gt;installEventFilter(this);

	&#x2F;&#x2F; 给输入框和按钮都安装上事件过滤器;
	m_lineEdit &#x3D; new MyLineEdit;
	m_lineEdit-&gt;installEventFilter(this);
	
	m_pBtn &#x3D; new MyBtn;
	m_pBtn-&gt;setText(&quot;MyBtn&quot;);
	m_pBtn-&gt;installEventFilter(this);
	
	QHBoxLayout* hLayout &#x3D; new QHBoxLayout(this);
	hLayout-&gt;addStretch();
	hLayout-&gt;addWidget(m_lineEdit);
	hLayout-&gt;addStretch();
	hLayout-&gt;addWidget(m_pBtn);

&#125;

void EventTestWgt::initConnections()
&#123;
    connect(m_pBtn, &amp;QPushButton::clicked, this, &amp;EventTestWgt::onBtnClicked);
&#125;

void EventTestWgt::keyPressEvent(QKeyEvent *event)
&#123;
    qDebug() &lt;&lt; &quot;EventTestWgt::keyPressEvent&quot;;
    

    return QWidget::keyPressEvent(event);

&#125;

void EventTestWgt::mousePressEvent(QMouseEvent *event)
&#123;
    qDebug() &lt;&lt; &quot;EventTestWgt::mousePressEvent&quot;;
    

    return QWidget::mousePressEvent(event);

&#125;

bool EventTestWgt::eventFilter(QObject *watched, QEvent *event)
&#123;
    if (watched &#x3D;&#x3D; m_lineEdit)
    &#123;
        &#x2F;&#x2F; 过滤处理输入框键盘按下事件;
        if (QEvent::KeyPress &#x3D;&#x3D; event-&gt;type())
        &#123;
            &#x2F;&#x2F; todo;
            return true;
        &#125;
    &#125;
    

    if (watched &#x3D;&#x3D; m_pBtn)
    &#123;
        &#x2F;&#x2F; 过滤处理MyBtn的鼠标按下事件;
        if (QEvent::MouseButtonPress &#x3D;&#x3D; event-&gt;type())
        &#123;
            &#x2F;&#x2F; todo;
            return true;
        &#125;
    &#125;
    
    if (watched &#x3D;&#x3D; this)
    &#123;
        &#x2F;&#x2F; 过滤处理自己的鼠标按下事件;
        if (QEvent::MouseButtonPress &#x3D;&#x3D; event-&gt;type())
        &#123;
            &#x2F;&#x2F; todo;
            return true;
        &#125;
        
        &#x2F;&#x2F; 对自己的键盘按下事件不处理;
        if (QEvent::KeyPress &#x3D;&#x3D; event-&gt;type())
        &#123;
            &#x2F;&#x2F; todo;
            return false;
        &#125;
    &#125;
    
    return QWidget::eventFilter(watched, event);

&#125;

void EventTestWgt::onBtnClicked()
&#123;
    qDebug() &lt;&lt; &quot;EventTestWgt::onBtnClicked&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下方是本示例的事件传递图，通过此图我们可以很清晰地看到事件传递的顺序、不同类之间事件的传递以及事件过滤器的作用。         在本例中我们过滤了按钮的鼠标按下事件（mousePressEvent），我特意在代码中加了此按钮点击的信号槽连接，实际因为鼠标事件被过滤，槽函数未被触发，因为Qt在按钮控件的内部也是通过事件的捕捉来发送clicked信号的，我们这里过滤了按下事件，影响了信号的发送，所以在重写或者过滤事件的时候需要注意。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/8307486201964a5da22bc5ee533bc5ba.png?lastModify=1685936981" alt="在这里插入图片描述"></p>
<p>​        2、专门的事件过滤器类，对特定的对象/特定的事件进行处理。         事件过滤器类只需对当前安装的对象进行处理，无需关心其他操作，且一个事件过滤器类可以被多个对象使用，例如Qt文档中的按键过滤示例，KeyPressEater类中的eventFilter过滤了所有的键盘按下事件，只要安装此事件过滤器的控件，都接收不到键盘按键按下的事件，这种就是对某个通用的事件进行过滤，可以进行多次复用。</p>
<pre class="line-numbers language-none"><code class="language-none">  class KeyPressEater : public QObject
  &#123;
      Q_OBJECT
      ...

  protected:
      bool eventFilter(QObject *obj, QEvent *event) override;
  &#125;;

  bool KeyPressEater::eventFilter(QObject *obj, QEvent *event)
  &#123;
      if (event-&gt;type() &#x3D;&#x3D; QEvent::KeyPress) &#123;
          QKeyEvent *keyEvent &#x3D; static_cast&lt;QKeyEvent *&gt;(event);
          qDebug(&quot;Ate key press %d&quot;, keyEvent-&gt;key());
          return true;
      &#125; else &#123;
          &#x2F;&#x2F; standard event processing
          return QObject::eventFilter(obj, event);
      &#125;
  &#125;
void test()
&#123;
    KeyPressEater *keyPressEater &#x3D; new KeyPressEater(this);
    QPushButton *pushButton &#x3D; new QPushButton(this);
    QListView *listView &#x3D; new QListView(this);
    
    pushButton-&gt;installEventFilter(keyPressEater);
    listView-&gt;installEventFilter(keyPressEater);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        3、给QApplication安装事件过滤器，达到全局事件监听的效果。 在notify方法下发事件的时候，QApplication对象可以拿到第一控制权，对某些事件优先进行处理，比如全局的快捷键操作。</p>
<p>​        使用上方的KeyPressEater类对全局的键盘按下事件进行过滤.</p>
<pre class="line-numbers language-none"><code class="language-none">QApplication a(argc, argv);
KeyPressEater *keyPressEater &#x3D; new KeyPressEater(&amp;a);
a.installEventFilter(keyPressEater);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        再提一点：         当一个对象安装多个事件过滤器的时候，我们通过文章上方提到，先安装的后调用，下方代码中EventFilterObjA和EventFilterObjB都实现了对鼠标按下事件的过滤，而EventFilterObjB类对象的事件过滤器是后安装的，所以先调用，我们运行代码发现，在EventFilterObjB中过滤完之后EventFilterObjA中的eventFilter就接收不到了，所以只要在一处先过滤，后面就都接收不到了，所以大家在实际运用过程中一定要注意，就算同是事件过滤器也分先后，先过滤了的事件，后面就再也收不到了。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 事件过滤器对象;
class EventFilterObjA : public QObject
&#123;
public:
    EventFilterObjA(QObject* parent &#x3D; nullptr)
    &#123;&#125;

private:
    bool eventFilter(QObject *watched, QEvent *event)
    &#123;
        if (QEvent::MouseButtonPress &#x3D;&#x3D; event-&gt;type())
        &#123;
            qDebug() &lt;&lt; &quot;EventFilterObjA::eventFilter&quot;
            	&lt;&lt; &quot;Class Name:&quot; &lt;&lt; watched-&gt;metaObject()-&gt;className()
            	&lt;&lt; &quot;Event:&quot; &lt;&lt; event-&gt;type();
            

            return true;
        &#125;
    
    	return QObject::eventFilter(watched, event);
    &#125;

&#125;;

class EventFilterObjB : public QObject
&#123;
public:
    EventFilterObjB(QObject* parent &#x3D; nullptr)
    &#123;&#125;

private:
    bool eventFilter(QObject *watched, QEvent *event)
    &#123;
        if (QEvent::MouseButtonPress &#x3D;&#x3D; event-&gt;type())
        &#123;
            qDebug() &lt;&lt; &quot;EventFilterObjB::eventFilter&quot;
            	&lt;&lt; &quot;Class Name:&quot; &lt;&lt; watched-&gt;metaObject()-&gt;className()
            	&lt;&lt; &quot;Event:&quot; &lt;&lt; event-&gt;type();
            

            return true;
        &#125;
    
    	return QObject::eventFilter(watched, event);
    &#125;

&#125;;

void test()
&#123;
    QWidget* myWgt &#x3D; new QWidget;
    &#x2F;&#x2F; 创建事件过滤器对象;
	EventFilterObjA* eFilterObjA &#x3D; new EventFilterObjA(myWgt);
	EventFilterObjB* eFilterObjB &#x3D; new EventFilterObjB(myWgt);
	

    &#x2F;&#x2F; 安装外部事件过滤器;
    myWgt-&gt;installEventFilter(eFilterObjA);
    myWgt-&gt;installEventFilter(eFilterObjB);
	&#x2F;&#x2F; 输出结果;
	EventFilterObjB::eventFilter Class Name: QWidget Event: 				QEvent::MouseButtonPress
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/12293109069542c8b50ff366bb0fae88.png?lastModify=1685936981" alt="在这里插入图片描述"></p>
<h3 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h3><p>​        我们通过上篇文章的分析得知，eventFilter的优先级是比较高的，一般来说我们很少通过重写QApplication的notify方法来监测某个控件的某个事件，那样太小题大做了，如果都这样做会导致notify异常庞大，效率也有所降低，所以较常用的就是本篇文章中讲到的事件过滤器方法，既可以监听自己，又可以监听其他对象。</p>
<p>​        注意点:         1、事件过滤器可以安装在任何继承QObject的对象上，也可以安装在QApplication对象上（全局事件过滤器）；</p>
<p>​        2、事件过滤器(eventFilter方法)返回值为true，表示将当前事件进行过滤，不会发送到对象本身；如果返回false，表示对当前事件不做任何处理，会通过event()方法将事件分发给原来的对象。如果不知道怎么处理或者返回什么，那就返回父类的eventFilter方法（类似 return QObject::eventFilter(watched, event)）;</p>
<p>​        3、一个对象可以安装多个事件过滤器（也就是一个对象的事件可以被多个对象进行监控/处理/过滤）， 并且最先安装的事件过滤器是最后被调用的，类似于栈的操作，先进后出；</p>
<p>​        4、一个事件过滤器可以被多个对象安装，但是如果在事件过滤器(eventFilter方法)中把该对象删除了， 一定要将返回值设为true。否则 Qt会将事件继续分发给这个对象，从而导致程序崩溃。</p>
<h1 id="简单学习Windows-API（入门）"><a href="#简单学习Windows-API（入门）" class="headerlink" title="简单学习Windows API（入门）"></a>简单学习Windows API（入门）</h1><h2 id="前导1"><a href="#前导1" class="headerlink" title="前导1"></a>前导1</h2><p>写在前面：这是本菜鸟首次对一个大的topic有巨大的兴趣，正好，本人对桌面应用开发有动力研究，这里就以Windows API　编程作为自己串起来操作系统，并发编程，C++基本程序设计应用，以及底层QT开发的一个Application demo了！</p>
<h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><p>​        还记得你在实验课上使用老古董 VS2010，当你选择了空项目开发后必须手动使用</p>
<pre class="line-numbers language-none"><code class="language-none">system(&quot;pause&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这个函数嘛？不错，他就是我们Windows API的一个。目的是让程序暂停在此句！我们应用的头文件是：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们的主角来了哈哈哈</p>
<h2 id="小试一手"><a href="#小试一手" class="headerlink" title="小试一手"></a>小试一手</h2><p>​        创建你的一个项目，不够今天，我们创建的是一个桌面向导项目，随后，我们选择空项目创建，将：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230504215411467.png?lastModify=1685936981" alt="image-20230504215411467"></p>
<p>改成：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230504215354973.png?lastModify=1685936981" alt="image-20230504215354973"></p>
<p>​    以及转到：（右键项目选择属性）</p>
<p>​    把控制台改成窗口输出！不然编译器会在下面的程序中报错！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230504215458663.png?lastModify=1685936981" alt="image-20230504215458663"></p>
<p>​        我们书写一个简单的C++程序！</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)
&#123;
	MessageBox(NULL, TEXT(&quot;Hello, World&quot;), TEXT(&quot;Captions&quot;), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);

	return 0;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        F5一下：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230504215640299.png?lastModify=1685936981" alt="image-20230504215640299"></p>
<p>​        6！</p>
<h2 id="逐一解释"><a href="#逐一解释" class="headerlink" title="逐一解释"></a>逐一解释</h2><h3 id="include-lt-Windows-h-gt"><a href="#include-lt-Windows-h-gt" class="headerlink" title="#include&lt; Windows.h &gt;"></a>#include&lt; Windows.h &gt;</h3><p>​        我们老规矩，先来看看Windows.h装了啥：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230504220523073.png?lastModify=1685936981" alt="image-20230504220523073"></p>
<p>​        反正一大堆，但是核心就这些，这是我们需要注意的！</p>
<h3 id="int-WINAPI-WinMain-HINSTANCE-hInstance-HINSTANCE-hPrevInstance-LPSTR-ipCmdLine-int-nCmdShow"><a href="#int-WINAPI-WinMain-HINSTANCE-hInstance-HINSTANCE-hPrevInstance-LPSTR-ipCmdLine-int-nCmdShow" class="headerlink" title="int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)"></a>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)</h3><p>​        </p>
<p>​        一个函数！有些人奇怪了，什么玩意？C++程序没有int main(), 就像西方没有耶路撒冷一样！不是的！</p>
<p>​        在Windows桌面开发下，他就是我们的main函数。在Microsoft API Platform SDK下，我们查阅到：</p>
<pre class="line-numbers language-none"><code class="language-none">int WINAPI WinMain(  
HINSTANCE hInstance,      
&#x2F;&#x2F; handle to current instance   
HINSTANCE hPrevInstance,  
&#x2F;&#x2F; handle to previous instance   
LPSTR lpCmdLine,        
&#x2F;&#x2F; command line  
int nCmdShow        
&#x2F;&#x2F;  show stat
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230504222032978.png?lastModify=1685936981" alt="image-20230504222032978"></p>
<h4 id="What-is-WINAPI"><a href="#What-is-WINAPI" class="headerlink" title="What is WINAPI"></a>What is WINAPI</h4><p>​        光标移动到上面： __stdcall 这是啥呢？标准调用！</p>
<p>​        被这个关键字修饰的函数，其参数都是从右向左通过堆栈传递的(__fastcall 的前面部分由ecx,edx传)， 函数调用在返回前要由被调用者清理堆栈。</p>
<p>​        啥？你不相信？反汇编我们产生的EXE文件就OK了：在MessageW处打一个断点，运行之找到</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230504231052021.png?lastModify=1685936981" alt="image-20230504231052021"></p>
<p>​        大多数电脑采用的是大端法，也就是说可以理解为：参数在右边的，先被推送进函数里去</p>
<h4 id="批注？"><a href="#批注？" class="headerlink" title="批注？"></a>批注？</h4><p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230504231254737.png?lastModify=1685936981" alt="image-20230504231254737"></p>
<p>​        什么是批注呢请看我们函数和头文件下的：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230504231338650.png?lastModify=1685936981" alt="image-20230504231338650"></p>
<p>​        看看_ In _这个宏，他就是一个说明参数性质的宏！</p>
<pre class="line-numbers language-none"><code class="language-none"> &#x2F;&#x2F; from sal.h
_In_     : input parameter to a function, unmodified by called function
      _Out_    : output parameter, written to by called function, pointed-to
                 location not expected to be initialized prior to call
      _Outptr_ : like _Out_ when returned variable is a pointer type
                 (so param is pointer-to-pointer type). Called function
                 provides&#x2F;allocated space.
      _Outref_ : like _Outptr_, except param is reference-to-pointer type.
      _Inout_  : inout parameter, read from and potentially modified by
                 called function.
      _Ret_    : for return values
      _Field_  : class&#x2F;struct field invariants<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        In 表明他是一个输入参数，有点像const 一样，函数读取值但是不可以修改它！</p>
<p>​        InOut就是表示这是一个这样的值：传入又传出，值会被修改</p>
<p>​        Out表示这个值会被这个函数设置</p>
<p>​        OutPtr 表示返回这个值的指针</p>
<p>​        Microsoft对参数合理性做出了更多的解释：类似于main函数一样</p>
<pre class="line-numbers language-none"><code class="language-none">[in] hInstance

类型： HINSTANCE

应用程序的当前实例的句柄。

[in] hPrevInstance

类型： HINSTANCE

应用程序的上一个实例的句柄。 此参数始终为 NULL。 如果需要检测另一个实例是否已存在，请使用 CreateMutex 函数创建唯一命名的互斥体。 即使互斥体已存在，CreateMutex 也会成功，但函数将返回ERROR_ALREADY_EXISTS。 这表示应用程序的另一个实例存在，因为它首先创建了互斥体。 但是，恶意用户可以在执行之前创建此互斥体，并阻止应用程序启动。 为防止这种情况，请创建一个随机命名的互斥体并存储名称，以便它只能由授权用户获取。 或者，可以使用文件进行此目的。 若要将应用程序限制为每个用户的一个实例，请在用户配置文件目录中创建锁定的文件。

[in] lpCmdLine

类型： LPSTR

应用程序的命令行，不包括程序名称。 若要检索整个命令行，请使用 GetCommandLine 函数。

[in] nShowCmd

类型： int

控制窗口的显示方式。 此参数可以是可在 ShowWindow 函数的 nCmdShow 参数中指定的任何值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示一个模式对话框，其中包含系统图标、一组按钮和一条简短的应用程序特定消息，例如状态或错误信息。 消息框返回一个整数值，该值指示用户单击的按钮。</p>
<h3 id="MessageBox函数"><a href="#MessageBox函数" class="headerlink" title="MessageBox函数"></a>MessageBox函数</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">int MessageBox(
  [in, optional] HWND    hWnd,
  [in, optional] LPCTSTR lpText,
  [in, optional] LPCTSTR lpCaption,
  [in]           UINT    uType
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] hWnd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型：<strong>HWND</strong></p>
<p>要创建的消息框的所有者窗口的句柄。 如果此参数为 <strong>NULL</strong>，则消息框没有所有者窗口。</p>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] lpText<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>LPCTSTR</strong></p>
<p>要显示的消息。 如果字符串包含多个行，则可以使用回车符和/或换行符分隔每行之间的行。</p>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] lpCaption<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>LPCTSTR</strong></p>
<p>对话框标题。 如果此参数为 <strong>NULL</strong>，则默认标题为 <strong>Error</strong>。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] uType<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>UINT</strong></p>
<p>对话框的内容和行为。 此参数可以是以下标志组中的标志的组合。</p>
<p>若要指示消息框中显示的按钮，请指定以下值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_ABORTRETRYIGNORE</strong>0x00000002L</td>
<td style="text-align:left">消息框包含三个推送按钮： <strong>中止</strong>、 <strong>重试</strong>和 <strong>忽略</strong>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_CANCELTRYCONTINUE</strong>0x00000006L</td>
<td style="text-align:left">消息框包含三个按下按钮： <strong>“取消</strong>”、“ <strong>重试</strong>”、“ <strong>继续</strong>”。 使用此消息框类型，而不是MB_ABORTRETRYIGNORE。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_HELP</strong>0x00004000L</td>
<td style="text-align:left">向消息框添加 <strong>“帮助</strong> ”按钮。 当用户单击 <strong>“帮助</strong> ”按钮或按 F1 时，系统会向所有者发送 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/shell/wm-help">WM_HELP</a> 消息。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_OK</strong>0x00000000L</td>
<td style="text-align:left">消息框包含一个按钮： <strong>确定</strong>。 这是默认值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_OKCANCEL</strong>0x00000001L</td>
<td style="text-align:left">消息框包含两个推送按钮： <strong>“确定</strong> ”和 <strong>“取消</strong>”。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_RETRYCANCEL</strong>0x00000005L</td>
<td style="text-align:left">消息框包含两个按下按钮： <strong>重试</strong> 和 <strong>取消</strong>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_YESNO</strong>0x00000004L</td>
<td style="text-align:left">消息框包含两个按下按钮： <strong>是</strong> 和 <strong>否</strong>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_YESNOCANCEL</strong>0x00000003L</td>
<td style="text-align:left">消息框包含三个按钮： <strong>是</strong>、 <strong>否</strong>和 <strong>取消</strong>。</td>
</tr>
</tbody>
</table>
</div>
<p>若要在消息框中显示图标，请指定以下值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_ICONEXCLAMATION</strong>0x00000030L</td>
<td style="text-align:left">消息框中会显示一个感叹号图标。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONWARNING</strong>0x00000030L</td>
<td style="text-align:left">消息框中会显示一个感叹号图标。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONINFORMATION</strong>0x00000040L</td>
<td style="text-align:left">图标由圆圈中的小写字母 <em>i</em> 组成，显示在消息框中。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONASTERISK</strong>0x00000040L</td>
<td style="text-align:left">图标由圆圈中的小写字母 <em>i</em> 组成，显示在消息框中。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONQUESTION</strong>0x00000020L</td>
<td style="text-align:left">消息框中会显示一个问号图标。 不再建议使用问号消息图标，因为这种图标无法清楚地表示特定类型的消息，并且作为问题的消息表述可应用于任何消息类型。 此外，用户可能会将问号消息符号与帮助信息混淆。 因此，不要在消息框中使用问号消息符号。 系统继续支持它包含的内容，只为满足反向兼容性。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONSTOP</strong>0x00000010L</td>
<td style="text-align:left">消息框中会显示一个停止符号图标。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONERROR</strong>0x00000010L</td>
<td style="text-align:left">消息框中会显示一个停止符号图标。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONHAND</strong>0x00000010L</td>
<td style="text-align:left">消息框中会显示一个停止符号图标。</td>
</tr>
</tbody>
</table>
</div>
<p>若要指示默认按钮，请指定以下值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_DEFBUTTON1</strong>0x00000000L</td>
<td style="text-align:left">第一个按钮是默认按钮。除非指定<strong>了MB_DEFBUTTON2</strong>、MB_DEFBUTTON3或<strong>MB_DEFBUTTON4</strong>，<strong>否则</strong>MB_DEFBUTTON1<strong>是默认值</strong>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_DEFBUTTON2</strong>0x00000100L</td>
<td style="text-align:left">第二个按钮是默认按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_DEFBUTTON3</strong>0x00000200L</td>
<td style="text-align:left">第三个按钮是默认按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_DEFBUTTON4</strong>0x00000300L</td>
<td style="text-align:left">第四个按钮是默认按钮。</td>
</tr>
</tbody>
</table>
</div>
<p>若要指示对话框的形式，请指定以下值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_APPLMODAL</strong>0x00000000L</td>
<td style="text-align:left">在 <em>hWnd</em> 参数标识的窗口中继续工作之前，用户必须响应消息框。 但是，用户可以移动到其他线程的窗口，并在这些窗口中工作。根据应用程序中的窗口层次结构，用户可能能够移动到线程中的其他窗口。 消息框父级的所有子窗口都将自动禁用，但弹出窗口不是。如果未指定<strong>MB_SYSTEMMODAL</strong>或<strong>MB_TASKMODAL</strong>，<strong>则MB_APPLMODAL</strong>为默认值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_SYSTEMMODAL</strong>0x00001000L</td>
<td style="text-align:left">与MB_APPLMODAL相同，消息框具有 <strong>WS_EX_TOPMOST</strong> 样式。 使用系统模式消息框通知用户严重、潜在的破坏性错误，例如， (立即引起注意，) 内存不足。 此标志不会影响用户与 <em>与 hWnd</em> 关联的窗口以外的窗口交互的能力。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_TASKMODAL</strong>0x00002000L</td>
<td style="text-align:left">与 <strong>MB_APPLMODAL</strong> 相同，如果 <em>hWnd</em> 参数为 <strong>NULL</strong>，则禁用属于当前线程的所有顶级窗口。 当调用应用程序或库没有可用的窗口句柄时，请使用此标志，但仍需要防止输入到调用线程中的其他窗口，而不会挂起其他线程。</td>
</tr>
</tbody>
</table>
</div>
<p>若要指定其他选项，请使用以下一个或多个值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_DEFAULT_DESKTOP_ONLY</strong>0x00020000L</td>
<td style="text-align:left">与交互式窗口工作站的桌面相同。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/winstation/window-stations">窗口工作站</a>。如果当前输入桌面不是默认桌面，则在用户切换到默认桌面之前， <strong>MessageBox</strong> 不会返回。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_RIGHT</strong>0x00080000L</td>
<td style="text-align:left">文本是右对齐的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_RTLREADING</strong>0x00100000L</td>
<td style="text-align:left">在希伯来语和阿拉伯语系统上使用从右到左阅读顺序显示消息和标题文本。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_SETFOREGROUND</strong>0x00010000L</td>
<td style="text-align:left">消息框将成为前台窗口。 在内部，系统调用消息框的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> 函数。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_TOPMOST</strong>0x00040000L</td>
<td style="text-align:left">消息框是使用 <strong>WS_EX_TOPMOST</strong> 窗口样式创建的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_SERVICE_NOTIFICATION</strong>0x00200000L</td>
<td style="text-align:left">调用方是通知用户某个事件的服务。 该函数在当前活动桌面上显示一个消息框，即使没有用户登录到计算机也是如此。<strong>终端服务：</strong> 如果调用线程具有模拟令牌，该函数会将消息框定向到模拟令牌中指定的会话。如果设置了此标志， <em>则 hWnd</em> 参数必须为 <strong>NULL</strong>。 这样，消息框可以出现在桌面上，而不是与 <em>hWnd</em> 对应的桌面。有关使用此标志的安全注意事项的信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Services/interactive-services">Interactive Services</a>。 具体而言，请注意，此标志可以在锁定的桌面上生成交互式内容，因此应仅用于一组非常有限的方案，例如资源耗尽。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>类型： <strong>int</strong></p>
<p>如果消息框有 <strong>“取消</strong> ”按钮，则函数返回 <strong>IDCANCEL</strong> 值（如果按下 ESC 键或选中 <strong>“取消</strong> ”按钮）。 如果消息框没有 <strong>“取消</strong> ”按钮，则按 ESC 将不起作用 -除非存在MB_OK按钮。 如果显示MB_OK按钮，并且用户按 ESC，则返回值为 <strong>IDOK</strong>。</p>
<p>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<p>如果函数成功，则返回值为以下菜单项值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">返回代码/值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>IDABORT</strong>3</td>
<td style="text-align:left">已选择 <strong>“中止</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDCANCEL</strong>2</td>
<td style="text-align:left">已选择“ <strong>取消</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDCONTINUE</strong>11</td>
<td style="text-align:left">已选择 <strong>“继续</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDIGNORE</strong>5</td>
<td style="text-align:left">已选择 <strong>“忽略</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDNO</strong>7</td>
<td style="text-align:left">已选择 <strong>“无</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDOK</strong>1</td>
<td style="text-align:left">已选择 <strong>“确定</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDRETRY</strong>4</td>
<td style="text-align:left">已选择 <strong>“重试</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDTRYAGAIN</strong>10</td>
<td style="text-align:left">已选择 <strong>“重试</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDYES</strong>6</td>
<td style="text-align:left">已选择 <strong>“是</strong> ”按钮。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>通过将 <em>uType</em> 参数设置为相应的标志值，可以在消息框中使用以下系统图标。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">图标</th>
<th style="text-align:left">标志值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/mb_iconhand.png?lastModify=1685936981" alt="MB_ICONHAND、MB_ICONSTOP和MB_ICONERROR图标"></td>
<td style="text-align:left"><strong>MB_ICONHAND</strong>、 <strong>MB_ICONSTOP</strong>或 <strong>MB_ICONERROR</strong></td>
</tr>
<tr>
<td style="text-align:left"><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/mb_iconquestion.png?lastModify=1685936981" alt="MB_ICONQUESTION图标"></td>
<td style="text-align:left"><strong>MB_ICONQUESTION</strong></td>
</tr>
<tr>
<td style="text-align:left"><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/mb_iconexclamation.png?lastModify=1685936981" alt="MB_ICONEXCLAMATION和MB_ICONWARNING图标"></td>
<td style="text-align:left"><strong>MB_ICONEXCLAMATION</strong> 或 <strong>MB_ICONWARNING</strong></td>
</tr>
<tr>
<td style="text-align:left"><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/mb_iconasterisk.png?lastModify=1685936981" alt="MB_ICONASTERISK和MB_ICONINFORMATION图标"></td>
<td style="text-align:left"><strong>MB_ICONASTERISK</strong> 或 <strong>MB_ICONINFORMATION</strong></td>
</tr>
</tbody>
</table>
</div>
<p>在 MessageBox 显示字符串开头的 Unicode 格式字符 U+200F 表示 (RL) M 添加两个从右到左标记，以便使 MessageBox 的读取顺序呈现为从右到左 (RTL) 。</p>
<p>使用系统模式消息框指示系统内存不足时， <em>lpText</em> 和 <em>lpCaption</em> 参数指向的字符串不应从资源文件中获取，因为尝试加载资源可能会失败。</p>
<p>如果在对话框存在时创建消息框，请使用对话框的句柄作为 <em>hWnd</em> 参数。 <em>hWnd</em> 参数不应标识子窗口，如对话框中的控件。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在以下示例中，应用程序显示一个消息框，该消息框在出现错误条件后提示用户执行操作。 消息框显示描述错误条件以及如何解决错误条件的消息。 <strong>MB_CANCELTRYCONTINUE</strong>样式指示 <strong>MessageBox</strong> 提供三个按钮，用户可以选择如何继续操作。 <strong>MB_DEFBUTTON2</strong>样式将默认焦点设置为消息框的第二个按钮，在本例中为<strong>“重试”</strong>按钮。</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;

void WINAPI doSomethingHalt() &#123;

	int usrChoice &#x3D; MessageBox(NULL, TEXT(&quot;Are you sure to move forward? That is supposed to be invalid... I convinced!&quot;)\
	,TEXT(&quot;Warning&quot;),MB_ICONWARNING|MB_CANCELTRYCONTINUE|MB_DEFBUTTON2);

	switch (usrChoice)
	&#123;
	case IDCANCEL:
		MessageBox(NULL, TEXT(&quot;good&quot;), TEXT(&quot;afterWard&quot;), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);
		break;
	case IDRETRY:
		MessageBox(NULL, TEXT(&quot;I mean: that is not good!&quot;), TEXT(&quot;afterWard&quot;), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);
		break;
	case IDCONTINUE:
		MessageBox(NULL, TEXT(&quot;I mean: that is not good!&quot;), TEXT(&quot;afterWard&quot;), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);
		break;
	default:
		break;
	&#125;

	return;
&#125;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)
&#123;
	&#x2F;&#x2F;MessageBox(NULL, TEXT(&quot;Hello, World&quot;), TEXT(&quot;Captions&quot;), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);
	doSomethingHalt();
	return 0;

&#125;

&#x2F;&#x2F; design by CharlieChen<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="前导2"><a href="#前导2" class="headerlink" title="前导2"></a>前导2</h2><h2 id="字符串主题"><a href="#字符串主题" class="headerlink" title="字符串主题"></a>字符串主题</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>​        下面我们开始入门简单的字符串主题：啥意思呢？回顾我们C语言的API。我们是如下声明一个char类型或基于char类型的数组</p>
<pre class="line-numbers language-none"><code class="language-none">char typicalChar &#x3D; &#39;A&#39;;
char* TCPtr &#x3D; &quot;Hello!My friend~&quot;;
char arrayCPtr &#x3D; &quot;hello,my frined~&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        我们马上可以看到，char是一份字节大小，那么下面的arrayCPtr就指明需要17个字节来存储。</p>
<h3 id="wchar-t类型"><a href="#wchar-t类型" class="headerlink" title="wchar_t类型"></a>wchar_t类型</h3><p>​        可是，仅仅使用char可能存储不下如今丰富的字符。所以，转向扩展char是必要的，wchar,也就是widechar应运而生。在Windows 2000之后所有的Windows系统都在底层上支持Unicode字符集。</p>
<p>​        我们这样声明与初始化一个wchar变量：</p>
<pre class="line-numbers language-none"><code class="language-none">wchar_t wideChar &#x3D; L&#39;A&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230505135217906.png?lastModify=1685936981" alt="image-20230505135217906"></p>
<p>​        类似的：</p>
<pre class="line-numbers language-none"><code class="language-none">wchar* ptrW &#x3D; &quot;Hello&quot;;
wchar ptr[7] &#x3D; &quot;Hello!&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        但是注意：如果我们还是选择</p>
<pre class="line-numbers language-none"><code class="language-none">printf(&quot;%s&quot;, ptrW);
printf(&quot;%s&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        则只会打印首元素，这是因为字符串类型不匹配，人话讲就是：wchar字符串不用%s打印，而是ls</p>
<pre class="line-numbers language-none"><code class="language-none">printf(&quot;%ls&quot;, ptrW);
printf(&quot;%ls&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        或者是</p>
<pre class="line-numbers language-none"><code class="language-none">wchar_t* WPTR &#x3D; &#123;&#39;a&#39;,&#39;\0&#39;&#125;; 
wprintf(&quot;%s&quot;,WPTR);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        或是直接调用setlocal函数做默认的设置！</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;
int main()
&#123;
	&#x2F;&#x2F;使用系统默认的设置调用setlocale(LC_ALL, &quot;&quot;);
	setlocale(LC_ALL, &quot;&quot;);
	const wchar_t * chWord &#x3D; L&quot;疯狂程序人—码农哈哥&quot;;
	printf(&quot;%s&quot;,chWord);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Windows下的字符和宽字符"><a href="#Windows下的字符和宽字符" class="headerlink" title="Windows下的字符和宽字符"></a>Windows下的字符和宽字符</h3><p>​        Windows整理自己的活：他们定义了他们自己的字符类型：在winnt.h文件下可以找到：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;
&#x2F;&#x2F; Basics
&#x2F;&#x2F;

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#if !defined(MIDL_PASS)
typedef int INT;
#endif
#endif

&#x2F;&#x2F;
&#x2F;&#x2F; UNICODE (Wide Character) types
&#x2F;&#x2F;

#ifndef _MAC
typedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#else
&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;

typedef _Null_terminated_ WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef _Null_terminated_ PWSTR *PZPWSTR;
typedef _Null_terminated_ CONST PWSTR *PCZPWSTR;
typedef _Null_terminated_ WCHAR UNALIGNED *LPUWSTR, *PUWSTR;
typedef _Null_terminated_ CONST WCHAR *LPCWSTR, *PCWSTR;
typedef _Null_terminated_ PCWSTR *PZPCWSTR;
typedef _Null_terminated_ CONST PCWSTR *PCZPCWSTR;
typedef _Null_terminated_ CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;

typedef _NullNull_terminated_ WCHAR *PZZWSTR;
typedef _NullNull_terminated_ CONST WCHAR *PCZZWSTR;
typedef _NullNull_terminated_ WCHAR UNALIGNED *PUZZWSTR;
typedef _NullNull_terminated_ CONST WCHAR UNALIGNED *PCUZZWSTR;

typedef  WCHAR *PNZWCH;
typedef  CONST WCHAR *PCNZWCH;
typedef  WCHAR UNALIGNED *PUNZWCH;
typedef  CONST WCHAR UNALIGNED *PCUNZWCH;

#if _WIN32_WINNT &gt;&#x3D; 0x0600 || (defined(__cplusplus) &amp;&amp; defined(WINDOWS_ENABLE_CPLUSPLUS))

typedef CONST WCHAR *LPCWCHAR, *PCWCHAR;
typedef CONST WCHAR UNALIGNED *LPCUWCHAR, *PCUWCHAR;

&#x2F;&#x2F;
&#x2F;&#x2F;  UCS (Universal Character Set) types
&#x2F;&#x2F;

typedef unsigned long UCSCHAR;

&#x2F;&#x2F;
&#x2F;&#x2F;  Even pre-Unicode agreement, UCS values are always in the
&#x2F;&#x2F;  range U+00000000 to U+7FFFFFFF, so we&#39;ll pick an obvious
&#x2F;&#x2F;  value.

#define UCSCHAR_INVALID_CHARACTER (0xffffffff)

#define MIN_UCSCHAR (0)

&#x2F;&#x2F;
&#x2F;&#x2F;  We&#39;ll assume here that the ISO-10646 &#x2F; Unicode agreement
&#x2F;&#x2F;  not to assign code points after U+0010FFFF holds so that
&#x2F;&#x2F;  we do not have to have separate &quot;UCSCHAR&quot; and &quot;UNICODECHAR&quot;
&#x2F;&#x2F;  types.
&#x2F;&#x2F;

#define MAX_UCSCHAR (0x0010FFFF)

typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR UNALIGNED *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR UNALIGNED *PCUUCSSTR;

typedef UCSCHAR UNALIGNED *PUUCSCHAR;
typedef const UCSCHAR UNALIGNED *PCUUCSCHAR;

#endif &#x2F;&#x2F; _WIN32_WINNT &gt;&#x3D; 0x0600


&#x2F;&#x2F;
&#x2F;&#x2F; ANSI (Multi-byte Character) types
&#x2F;&#x2F;
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef CONST CHAR *LPCCH, *PCCH;

typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;
typedef _Null_terminated_ PSTR *PZPSTR;
typedef _Null_terminated_ CONST PSTR *PCZPSTR;
typedef _Null_terminated_ CONST CHAR *LPCSTR, *PCSTR;
typedef _Null_terminated_ PCSTR *PZPCSTR;
typedef _Null_terminated_ CONST PCSTR *PCZPCSTR;

typedef _NullNull_terminated_ CHAR *PZZSTR;
typedef _NullNull_terminated_ CONST CHAR *PCZZSTR;

typedef  CHAR *PNZCH;
typedef  CONST CHAR *PCNZCH;

&#x2F;&#x2F;
&#x2F;&#x2F; Neutral ANSI&#x2F;UNICODE types and macros
&#x2F;&#x2F;
#ifdef  UNICODE                     &#x2F;&#x2F; r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TBYTE , *PTBYTE ;
#define _TCHAR_DEFINED
#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;

typedef LPWCH LPTCH, PTCH;
typedef LPCWCH LPCTCH, PCTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
typedef PZZWSTR PZZTSTR;
typedef PCZZWSTR PCZZTSTR;
typedef PUZZWSTR PUZZTSTR;
typedef PCUZZWSTR PCUZZTSTR;
typedef PZPWSTR PZPTSTR;
typedef PNZWCH PNZTCH;
typedef PCNZWCH PCNZTCH;
typedef PUNZWCH PUNZTCH;
typedef PCUNZWCH PCUNZTCH;
#define __TEXT(quote) L##quote      &#x2F;&#x2F; r_winnt

#else   &#x2F;* UNICODE *&#x2F;               &#x2F;&#x2F; r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;
#define _TCHAR_DEFINED
#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;

typedef LPCH LPTCH, PTCH;
typedef LPCCH LPCTCH, PCTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
typedef PZZSTR PZZTSTR, PUZZTSTR;
typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
typedef PZPSTR PZPTSTR;
typedef PNZCH PNZTCH, PUNZTCH;
typedef PCNZCH PCNZTCH, PCUNZTCH;
#define __TEXT(quote) quote         &#x2F;&#x2F; r_winnt

#endif &#x2F;* UNICODE *&#x2F;                &#x2F;&#x2F; r_winnt
#define TEXT(quote) __TEXT(quote)   &#x2F;&#x2F; r_winnt


typedef SHORT *PSHORT;  
typedef LONG *PLONG;    

#define ALL_PROCESSOR_GROUPS        0xffff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在这里我们找到了两个东西：</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef _MAC
typedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#else
&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        首先是wchar_t被重写位WCHAR。对于一些甚至没有wchar的编译器直接对unsigned short起别名。</p>
<p>​        其次是TEXT宏，这个宏便捷的帮助我们直接将普通的字符串升级为宽字符串，其做法不是强制转换，而是：</p>
<pre class="line-numbers language-none"><code class="language-none">#define __TEXT(quote) L##quote
#define TEXT(quote) __TEXT(quote)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        ##是令牌粘贴，就是直接把L和字符串连接在一起返回，比若说：</p>
<pre class="line-numbers language-none"><code class="language-none">TEXT(&quot;Hello&quot;)--- Compiler----&gt; L&quot;Hello&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们看到，上面的定义给出了：PSTR和LPSTR的小东西。他们都是CHAR（本质上就是Char），而P C STR 和 LP C STR则是Const类型的字符串。也就是常字符串！</p>
<p>​        那对于TCHAR这样Windows自己给出了字符串，我们应该怎么处理呢了，答案是万能的WIndows又帮我们干好了。使用P T STR和LP T STR就可以胜任这些工作！</p>
<h2 id="常见的字符串处理工作"><a href="#常见的字符串处理工作" class="headerlink" title="常见的字符串处理工作"></a>常见的字符串处理工作</h2><h3 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h3><p>​        下面我们要说的是如何获取字符串的长度，请看strlen和wstrlen.</p>
<pre class="line-numbers language-none"><code class="language-none">size_t strlen(const char* str);
size_t wstrlen(const wchar_t* str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        size_t，如其所说的那样，衡量的是大小的类型。其定义查看建议自行搜索，这里做阐述。因为不是重点我想说的！</p>
<p>​        来试试看：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;tchar.h&gt;
int main() &#123;

	CHAR str[] &#x3D; &quot;C语言\0&quot;; &#x2F;&#x2F; 这个函数返回占比字节的大小
	WCHAR wstr[] &#x3D; L&quot;C语言&quot;; &#x2F;&#x2F; 这个函数返回的是宽字符的个数

	_tprintf(TEXT(&quot;strlen(str) &#x3D; %d\n wcslen(wstr) &#x3D; %d&quot;), strlen(str), wcslen(wstr));

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230505235033338.png?lastModify=1685936981" alt="image-20230505235033338"></p>
<p>​        注意到_tprintf是一个随系统环境而改变的宏函数，在支持UNICODE字符集的情况下，系统将会自动的转化之成为wprintf！</p>
<p>​        类似的：我们还有一个叫做tcslen这个函数，他是这样被定义的：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230505235214903.png?lastModify=1685936981" alt="image-20230505235214903"></p>
<p>​        好鸡肋啊，那如果我们改一下不支持Unicode子集呢？仍然是右键项目——属性，转到这个地方：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230505235414875.png?lastModify=1685936981" alt="image-20230505235414875"></p>
<p>​        改成</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230505235429080.png?lastModify=1685936981" alt="image-20230505235429080"></p>
<p>​        发现变灰了！转向再看发现跳转到了：&gt;</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230505235350688.png?lastModify=1685936981" alt="image-20230505235350688"></p>
<h2 id="前导3"><a href="#前导3" class="headerlink" title="前导3"></a>前导3</h2><h2 id="1-认识Windows窗口"><a href="#1-认识Windows窗口" class="headerlink" title="1.认识Windows窗口"></a>1.认识Windows窗口</h2><p>windows窗口的组成有：</p>
<p>（1）标题栏。窗口上方的蓝条区域，标题栏左边有控制菜单图表和窗口中程序的名称。</p>
<p>显示当前应用程序名、文件名等，在许多窗口中，标题栏也包含程序图标、“最小化”、“最大化”、“还原”和“关闭”按钮以及“帮助”的按钮，可以简单地对窗口进行操作。工程制图中，为方便读图及查询相关信息，图纸中一般会配置标题栏，其位置一般位于图纸的右下角，看图方向一般应与标题栏的方向一致。</p>
<p>（2）菜单栏。位于标题栏的下边，包含很多菜单。</p>
<p>菜单栏实际是一种树型结构，为软件的大多数功能提供功能入口。点击以后，即可显示出菜单项。</p>
<p>（3）工具栏。顾名思义，就是在一个软件程序中，综合各种工具，让用户方便使用的一个区域。</p>
<p>工具栏位于菜单栏下方，它以按扭的形式给出了用户最经常使用的一些命令，比如，复制，粘贴等。</p>
<p>（4）工作区域。窗口中间的区域，窗口的输入输出都在它里面进行。</p>
<p>（5）状态栏。位于窗口底部，显示运行程序的当前状态，通过它用户可以了解到程序运行的情况。</p>
<p>（6）滚动条。如果窗口中显示的内容过多，当前可见的部分不够显示时，窗口就会出现滚动条，分为水平与垂直两种。</p>
<p>（7）窗口缩放按纽。即最大化、最小化、关闭按纽。</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;
#include&lt;iostream&gt;
#include&lt;tchar.h&gt;
#pragma comment(lib,&quot;Winmm.lib&quot;)
LRESULT CALLBACK WindowsProc(HWND hwd, UINT uMsg, WPARAM wParam, LPARAM lParam);

WNDCLASSEX&amp; WINAPI getWindowsHandle(HINSTANCE hInstance,TCHAR name[]) &#123;

	WNDCLASSEX wndclass;

	wndclass.cbSize &#x3D; sizeof(WNDCLASSEX);

	wndclass.style &#x3D; CS_HREDRAW | CS_VREDRAW;

	wndclass.lpfnWndProc &#x3D; WindowsProc;

	wndclass.cbClsExtra &#x3D; 0;
	wndclass.cbWndExtra &#x3D; 0;
	wndclass.hInstance &#x3D; hInstance;
	wndclass.hIcon &#x3D; LoadIcon(NULL, IDI_APPLICATION);
	wndclass.hCursor &#x3D; LoadCursor(NULL, IDC_ARROW);
	wndclass.hbrBackground &#x3D; static_cast&lt;HBRUSH&gt;(GetStockObject(WHITE_BRUSH));
	wndclass.lpszMenuName &#x3D; NULL;
	wndclass.lpszClassName &#x3D; name;
	wndclass.hIconSm &#x3D; NULL;

	return wndclass;
&#125;

int WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance, LPSTR lpCmdLine,int nCmdShow) &#123;
	TCHAR szName[] &#x3D; L&quot;MyWindows&quot;;
	TCHAR szAppName[] &#x3D; L&quot;HelloWindows&quot;;
	HWND hwnd;
	MSG msg;

	WNDCLASSEX wndclass &#x3D; getWindowsHandle(hInstance,szName);
	RegisterClassEx(&amp;wndclass);

	hwnd &#x3D; CreateWindowEx(0, szName, szAppName, WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT, 600, 360, NULL, NULL, hInstance, NULL);

	ShowWindow(hwnd, nCmdShow);
	UpdateWindow(hwnd);

	while (GetMessage(&amp;msg, NULL, 0, 0) !&#x3D; 0) &#123;
		TranslateMessage(&amp;msg);
		DispatchMessage(&amp;msg);
	&#125;


	return msg.wParam;
&#125;

LRESULT CALLBACK WindowsProc(HWND hwd, UINT uMsg, WPARAM wParam, LPARAM lParam) &#123;
	HDC hdc;
	PAINTSTRUCT ps;
	TCHAR szStr[] &#x3D; TEXT(&quot;hello windows&quot;);

	switch (uMsg) &#123;
	case WM_CREATE:
		PlaySound(TEXT(&quot;666.wav&quot;), NULL, SND_FILENAME | SND_ASYNC);
		return 0;
	case WM_PAINT:
		hdc &#x3D; BeginPaint(hwd, &amp;ps);
		TextOut(hdc, 10, 10, szStr, _tcslen(szStr));
		EndPaint(hwd, &amp;ps);
		return 0;

	case WM_DESTROY:
		PostQuitMessage(0);
		return 0;
	&#125;

	return DefWindowProc(hwd, uMsg, wParam, lParam);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="系统入门1"><a href="#系统入门1" class="headerlink" title="系统入门1"></a>系统入门1</h2><h2 id="数据类型一看"><a href="#数据类型一看" class="headerlink" title="数据类型一看"></a>数据类型一看</h2><p>​        原生C数据类型</p>
<pre class="line-numbers language-none"><code class="language-none">int float double ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Windows自己的：</p>
<pre class="line-numbers language-none"><code class="language-none">BOOL BYTE CHAR CONST DWORD DOWRD32 DWORD64 FLOAT HANDLE HICON HINSTANCE
HKEY HMODULE HWND INT INT_PTR INT32 INT64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        看看这个：</p>
<pre class="line-numbers language-none"><code class="language-none">LPSTR szString &#x3D; L&quot;this is a long pointer to string.&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        跳转得到：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;
&#x2F;&#x2F; ANSI (Multi-byte Character) types
&#x2F;&#x2F;
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef CONST CHAR *LPCCH, *PCCH;

typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        进一步针对CHAR类型跳转</p>
<pre class="line-numbers language-none"><code class="language-none">typedef char CHAR;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        微软搞那么多宏，一方面是历史遗留，另一方面是方便他们的工程师更容易区分</p>
<p>​        Dword是这个东西：一个四个字节的数据类型</p>
<pre class="line-numbers language-none"><code class="language-none">DWORD dwMax &#x3D; 0xFFFFFFFF
typedef unsigned long       DWORD;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        于是INT就是有符号的，DWORD是无符号的。</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#include&lt;Windows.h&gt;

int main()
&#123;

	LPSTR szString &#x3D; L&quot;this is a long pointer to string.&quot;;

	INT a &#x3D; 10;

	DWORD dwMax &#x3D; 0xFFFFFFFF;

	MessageBox(NULL, szString, TEXT(&quot;LPSTR&quot;), MB_OK);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在C中我们有：memcpy</p>
<p>​        在Windows下，有一个函数叫CopyMemory()</p>
<pre class="line-numbers language-none"><code class="language-none">CopyMemory(IpStr, szString, lstrlen(szString) + 1); &#x2F;&#x2F; add one to include the \0.
#define CopyMemory RtlCopyMemory
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        Handle,也就是句柄，是这样被定义的：</p>
<p>​        他有如下的句柄：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef void *HANDLE;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        HICON图标</p>
<pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE(HICON);
#define DECLARE_HANDLE(name) struct name##__&#123;int unused;&#125;; typedef struct name##__ *name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        HInstance实例句柄</p>
<pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE(HINSTANCE);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        HKey注册表的句柄</p>
<pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE(HKEY);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Hmodule模块句柄</p>
<pre class="line-numbers language-none"><code class="language-none">typedef HINSTANCE HMODULE;      &#x2F;* HMODULEs can be used in place of HINSTANCEs *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        HWND窗口句柄</p>
<pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE            (HWND);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="API基础函数"><a href="#API基础函数" class="headerlink" title="API基础函数"></a>API基础函数</h2><p>​        WindowAPI大量的使用了Windows的数据类型！所有的API都有W版和A版，分别表示的是支持Unicode字符集和ASCII多字节字符集。下面我们来看一个Windows自己创建的demo，选择Win32项目创建。看到主文件下：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; WindowsProject1.cpp : 定义应用程序的入口点。
&#x2F;&#x2F;

#include &quot;framework.h&quot;
#include &quot;WindowsProject1.h&quot;

#define MAX_LOADSTRING 100

&#x2F;&#x2F; 全局变量:
HINSTANCE hInst;                                &#x2F;&#x2F; 当前实例
WCHAR szTitle[MAX_LOADSTRING];                  &#x2F;&#x2F; 标题栏文本
WCHAR szWindowClass[MAX_LOADSTRING];            &#x2F;&#x2F; 主窗口类名

&#x2F;&#x2F; 此代码模块中包含的函数的前向声明:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
&#123;
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    &#x2F;&#x2F; TODO: 在此处放置代码。

    &#x2F;&#x2F; 初始化全局字符串
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_WINDOWSPROJECT1, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    &#x2F;&#x2F; 执行应用程序初始化:
    if (!InitInstance (hInstance, nCmdShow))
    &#123;
        return FALSE;
    &#125;

    HACCEL hAccelTable &#x3D; LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSPROJECT1));

    MSG msg;

    &#x2F;&#x2F; 主消息循环:
    while (GetMessage(&amp;msg, nullptr, 0, 0))
    &#123;
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))
        &#123;
            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
        &#125;
    &#125;

    return (int) msg.wParam;
&#125;



&#x2F;&#x2F;
&#x2F;&#x2F;  函数: MyRegisterClass()
&#x2F;&#x2F;
&#x2F;&#x2F;  目标: 注册窗口类。
&#x2F;&#x2F;
ATOM MyRegisterClass(HINSTANCE hInstance)
&#123;
    WNDCLASSEXW wcex;

    wcex.cbSize &#x3D; sizeof(WNDCLASSEX);

    wcex.style          &#x3D; CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    &#x3D; WndProc;
    wcex.cbClsExtra     &#x3D; 0;
    wcex.cbWndExtra     &#x3D; 0;
    wcex.hInstance      &#x3D; hInstance;
    wcex.hIcon          &#x3D; LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));
    wcex.hCursor        &#x3D; LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  &#x3D; (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   &#x3D; MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1);
    wcex.lpszClassName  &#x3D; szWindowClass;
    wcex.hIconSm        &#x3D; LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassExW(&amp;wcex);
&#125;

&#x2F;&#x2F;
&#x2F;&#x2F;   函数: InitInstance(HINSTANCE, int)
&#x2F;&#x2F;
&#x2F;&#x2F;   目标: 保存实例句柄并创建主窗口
&#x2F;&#x2F;
&#x2F;&#x2F;   注释:
&#x2F;&#x2F;
&#x2F;&#x2F;        在此函数中，我们在全局变量中保存实例句柄并
&#x2F;&#x2F;        创建和显示主程序窗口。
&#x2F;&#x2F;
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
&#123;
   hInst &#x3D; hInstance; &#x2F;&#x2F; 将实例句柄存储在全局变量中

   HWND hWnd &#x3D; CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   &#123;
      return FALSE;
   &#125;

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
&#125;

&#x2F;&#x2F;
&#x2F;&#x2F;  函数: WndProc(HWND, UINT, WPARAM, LPARAM)
&#x2F;&#x2F;
&#x2F;&#x2F;  目标: 处理主窗口的消息。
&#x2F;&#x2F;
&#x2F;&#x2F;  WM_COMMAND  - 处理应用程序菜单
&#x2F;&#x2F;  WM_PAINT    - 绘制主窗口
&#x2F;&#x2F;  WM_DESTROY  - 发送退出消息并返回
&#x2F;&#x2F;
&#x2F;&#x2F;
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
&#123;
    switch (message)
    &#123;
    case WM_COMMAND:
        &#123;
            int wmId &#x3D; LOWORD(wParam);
            &#x2F;&#x2F; 分析菜单选择:
            switch (wmId)
            &#123;
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            &#125;
        &#125;
        break;
    case WM_PAINT:
        &#123;
            PAINTSTRUCT ps;
            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);
            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...
            EndPaint(hWnd, &amp;ps);
        &#125;
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    &#125;
    return 0;
&#125;

&#x2F;&#x2F; “关于”框的消息处理程序。
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
&#123;
    UNREFERENCED_PARAMETER(lParam);
    switch (message)
    &#123;
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) &#x3D;&#x3D; IDOK || LOWORD(wParam) &#x3D;&#x3D; IDCANCEL)
        &#123;
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        &#125;
        break;
    &#125;
    return (INT_PTR)FALSE;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们尝试加点东西，留心到</p>
<pre class="line-numbers language-none"><code class="language-none">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在switch语句下面添加点东西（有注释//）:</p>
<pre class="line-numbers language-none"><code class="language-none">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
&#123;

    LPCWSTR msg_str1 &#x3D; L&quot;你单击了左键（乐）&quot;;&#x2F;&#x2F;
    LPCWSTR msg_str2 &#x3D; L&quot;你单击了右键（乐）&quot;;&#x2F;&#x2F;
    LPCWSTR title_str &#x3D; L&quot;这是一个标题&quot;;&#x2F;&#x2F;

    switch (message)
    &#123;
    case WM_COMMAND:
        &#123;
            int wmId &#x3D; LOWORD(wParam);
            &#x2F;&#x2F; 分析菜单选择:
            switch (wmId)
            &#123;
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            &#125;
        &#125;
        break;
    case WM_PAINT:
        &#123;
            PAINTSTRUCT ps;
            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);
            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...
            EndPaint(hWnd, &amp;ps);
        &#125;
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    case WM_LBUTTONDOWN:&#x2F;&#x2F;
        MessageBoxW(NULL,msg_str1,title_str, MB_OKCANCEL);&#x2F;&#x2F;
        break;&#x2F;&#x2F;
    case WM_RBUTTONDOWN:&#x2F;&#x2F;
        MessageBoxW(NULL, msg_str2, title_str, MB_OKCANCEL);&#x2F;&#x2F;
        break;&#x2F;&#x2F;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是我们频繁点击会产生大量的窗口！那就更改父窗口就好了，传入一个句柄！</p>
<pre class="line-numbers language-none"><code class="language-none">case WM_LBUTTONDOWN:
    MessageBoxW(hWnd,msg_str1,title_str, MB_OKCANCEL);
    break;
case WM_RBUTTONDOWN:
    MessageBoxW(hWnd, msg_str2, title_str, MB_OKCANCEL);
    break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在就好了！</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230514113233694.png?lastModify=1685936981" alt="image-20230514113233694"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230514113445737.png?lastModify=1685936981" alt="image-20230514113445737"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230514113504873.png?lastModify=1685936981" alt="image-20230514113504873"></p>
<h2 id="读取文件demo"><a href="#读取文件demo" class="headerlink" title="读取文件demo"></a>读取文件demo</h2><p>​        在Windows下，使用</p>
<pre class="line-numbers language-none"><code class="language-none">CreateFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        宏来打开并创建一个文件句柄！</p>
<blockquote>
<p>from Microsoft API</p>
</blockquote>
<h2 id="read-file"><a href="#read-file" class="headerlink" title="read file"></a>read file</h2><p>​        我们使用readFile来读取文件：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#define BUFSIZE 256
#include&lt;tchar.h&gt;11

int main()
&#123;
	setlocale(LC_ALL, &quot;zh_CN.UTF-8&quot;); &#x2F;&#x2F; 设置正确的编码环境，防止读取乱码！

	HANDLE hFileRead;
	&#x2F;&#x2F; 创建文件句柄
	hFileRead &#x3D; CreateFile(L&quot;1.txt&quot;, GENERIC_READ, FILE_SHARE_READ, \
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFileRead &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;

		printf(&quot;Error in open the file:%x&quot;,GetLastError());

	&#125;

	DWORD nIn &#x3D; 0;

	CHAR buffer[BUFSIZE];

	while (ReadFile(hFileRead, buffer, BUFSIZE, &amp;nIn, NULL) &amp;&amp; nIn &gt; 0) &#123;
		printf(&quot;%s\n&quot;, buffer);
	&#125;

	CloseHandle(hFileRead);
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230514113206643.png?lastModify=1685936981" alt="image-20230514113206643"></p>
<h3 id="createFileW-函数-fileapi-h"><a href="#createFileW-函数-fileapi-h" class="headerlink" title="createFileW 函数 (fileapi.h)"></a>createFileW 函数 (fileapi.h)</h3><p>​        创建或打开文件或 I/O 设备。 最常用的 I/O 设备如下所示：文件、文件流、目录、物理磁盘、卷、控制台缓冲区、磁带驱动器、通信资源、mailslot 和管道。 该函数返回一个句柄，该句柄可用于访问不同类型的 I/O 的文件或设备，具体取决于文件或设备以及指定的标志和属性。</p>
<p>若要将此操作作为事务处理操作执行，这会导致可用于事务处理 I/O 的句柄，请使用 CreateFileTransacted 函数。</p>
<pre class="line-numbers language-none"><code class="language-none">HANDLE CreateFileW(
  [in]           LPCWSTR               lpFileName,
  [in]           DWORD                 dwDesiredAccess,
  [in]           DWORD                 dwShareMode,
  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  [in]           DWORD                 dwCreationDisposition,
  [in]           DWORD                 dwFlagsAndAttributes,
  [in, optional] HANDLE                hTemplateFile
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参数     [in] lpFileName</p>
<p>​        要创建或打开的文件或设备的名称。 可以在此名称中使用正斜杠 (/) 或反斜杠 () 。</p>
<p>​        在此函数的 ANSI 版本中，名称限制为 MAX_PATH 个字符。 若要将此限制扩展到 32，767 宽字符，请使用此 Unicode 版本的函数，并将“\？\”前面附加到路径。 有关详细信息，请参阅命名文件、路径和命名空间。</p>
<p>​        有关特殊设备名称的信息，请参阅 定义 MS-DOS 设备名称。</p>
<p>​        若要创建文件流，请指定文件的名称、冒号，然后指定流的名称。 有关详细信息，请参阅 文件流。</p>
<p>​        提示从Windows 10版本 1607 开始，对于此函数的 unicode 版本 (CreateFileW) ，你可以选择加入以删除MAX_PATH限制，而无需附加“\？\”。 有关详细信息，请参阅 命名文件、路径和命名空间 的“最大路径长度限制”部分。 [in] dwDesiredAccess</p>
<p>​        请求对文件或设备的访问权限，可汇总为读取、写入或两者均不) 。</p>
<p>​        最常用的值是 GENERIC_READ、 GENERIC_WRITE或两者 () GENERIC_READ | GENERIC_WRITE 。 有关详细信息，请参阅 通用访问权限、 文件安全性和访问权限、 文件访问权限常量和 ACCESS_MASK。</p>
<p>​        如果此参数为零，则应用程序可以在不访问该文件或设备的情况下查询某些元数据，例如文件、目录或设备属性，即使 拒绝了GENERIC_READ 访问。</p>
<p>​        不能请求与已打开句柄的打开请求中 dwShareMode 参数指定的共享模式冲突的访问模式。</p>
<p>​        有关详细信息，请参阅本主题的“备注”部分和 “创建和打开文件”。</p>
<p>​        [in] dwShareMode</p>
<p>​        文件或设备请求的共享模式，可以读取、写入、删除、所有这些或无 (引用下表) 。 对属性或扩展属性的访问请求不受此标志的影响。</p>
<p>​        如果此参数为零且 CreateFile 成功，则文件或设备无法共享，并且无法在文件或设备的句柄关闭之前再次打开。 有关详细信息，请参见“备注”部分。</p>
<p>​        无法请求与具有打开句柄的现有请求中指定的访问模式冲突的共享模式。 CreateFile 将失败， GetLastError 函数将返回 ERROR_SHARING_VIOLATION。</p>
<p>​        若要启用进程在打开文件或设备时共享文件或设备，请使用以下一个或多个值的兼容组合。 有关此参数与 dwDesiredAccess 参数的有效组合的详细信息，请参阅 创建和打开文件。</p>
<p>​        <strong>注意</strong> 无论进程上下文如何，每个打开句柄的共享选项都将有效，直到该句柄关闭。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>0</strong>0x00000000</td>
<td style="text-align:left">如果文件或设备请求删除、读取或写入访问权限，则阻止对文件或设备上的后续打开操作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SHARE_DELETE</strong>0x00000004</td>
<td style="text-align:left">在文件或设备上启用后续打开操作以请求删除访问权限。否则，如果文件或设备请求删除访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开以删除访问权限，则函数将失败。<strong>注意</strong> 删除访问权限允许删除和重命名操作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SHARE_READ</strong>0x00000001</td>
<td style="text-align:left">在文件或设备上启用后续打开操作以请求读取访问权限。否则，如果文件或设备请求读取访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开以供读取访问，则函数将失败。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SHARE_WRITE</strong>0x00000002</td>
<td style="text-align:left">在文件或设备上启用后续打开操作以请求写入访问权限。否则，如果文件或设备请求写入访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开进行写入访问或具有写入访问权限的文件映射，则函数将失败。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] lpSecurityAttributes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向包含两个独立但相关数据成员的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85">SECURITY_ATTRIBUTES</a>) 结构的指针：可选的安全描述符，以及一个布尔值，该值确定返回的句柄是否可以由子进程继承。</p>
<p>​        此参数可以为 NULL。</p>
<p>​        如果此参数为 <strong>NULL</strong>，则 <strong>由 CreateFile</strong> 返回的句柄不能由应用程序可能创建的任何子进程继承，并且与返回的句柄关联的文件或设备获取默认的安全描述符。</p>
<p>​        结构的 <strong>lpSecurityDescriptor</strong> 成员指定文件或设备的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> 。 如果此成员为 <strong>NULL</strong>，则会为与返回的句柄关联的文件或设备分配一个默认的安全描述符。</p>
<p>​        <strong>CreateFile</strong> 在打开现有文件或设备时忽略 <strong>lpSecurityDescriptor</strong> 成员，但继续使用 <strong>bInheritHandle</strong> 成员。</p>
<p>​        结构的 <strong>bInheritHandle</strong> 成员指定是否可以继承返回的句柄。</p>
<p>​        有关详细信息，请参见“备注”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] dwCreationDisposition<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        对存在或不存在的文件或设备执行的操作。</p>
<p>​        对于文件以外的设备，此参数通常设置为 <strong>OPEN_EXISTING</strong>。</p>
<p>​        有关详细信息，请参见“备注”部分。</p>
<p>​        此参数必须是以下值之一，不能合并：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>CREATE_ALWAYS</strong>2</td>
<td style="text-align:left">始终创建新文件。如果指定的文件存在且可写，则函数将覆盖文件、函数成功，最后错误代码设置为 <strong>ERROR_ALREADY_EXISTS</strong> (183) 。如果指定的文件不存在且路径有效，则会创建一个新文件，该函数成功，最后一个错误代码设置为零。有关详细信息，请参阅本主题的“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CREATE_NEW</strong>1</td>
<td style="text-align:left">仅当该文件尚不存在时才创建一个新文件。如果指定的文件存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_EXISTS (</strong> 80) 。如果指定的文件不存在并且是可写位置的有效路径，则会创建新文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>OPEN_ALWAYS</strong>4</td>
<td style="text-align:left">始终打开文件。如果指定文件存在，则函数成功，最后一个错误代码设置为 <strong>ERROR_ALREADY_EXISTS (</strong> 183) 。如果指定的文件不存在并且是可写位置的有效路径，则函数将创建一个文件，最后一个错误代码设置为零。</td>
</tr>
<tr>
<td style="text-align:left"><strong>OPEN_EXISTING</strong>3</td>
<td style="text-align:left">仅当文件或设备存在时，才打开该文件或设备。如果指定的文件或设备不存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_NOT_FOUND (</strong> 2) 。有关设备的详细信息，请参阅“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>TRUNCATE_EXISTING</strong>5</td>
<td style="text-align:left">打开文件并截断该文件，使其大小为零字节，仅当它存在时。如果指定的文件不存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_NOT_FOUND</strong> (2) 。调用过程必须打开文件，并将 <strong>GENERIC_WRITE</strong> 位设置为 <em>dwDesiredAccess</em> 参数的一部分。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[in] dwFlagsAndAttributes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        文件或设备属性和标志， <strong>FILE_ATTRIBUTE_NORMAL</strong> 是文件最常见的默认值。</p>
<p>​        此参数可以包含可用文件属性的任意组合， <strong>(FILE_ATTRIBUTE_*</strong>) 。 所有其他文件属性都替代 <strong>FILE_ATTRIBUTE_NORMAL</strong>。</p>
<p>​        此参数还可以包含标志组合 <strong>， (FILE_FLAG_)</strong> <em>来控制文件或设备缓存行为、访问模式和其他特殊用途标志。 这些值与任何 <strong>FILE_ATTRIBUTE_</strong></em> 值结合使用。</p>
<p>​        此参数还可以通过指定 <strong>SECURITY_SQOS_PRESENT</strong> 标志来包含安全服务质量 (SQOS) 信息。 下表显示了其他与 SQOS 相关的标志信息，这些属性和标志表如下。</p>
<p>​        <strong>注意当CreateFile</strong> 打开现有文件时，它通常将文件标志与现有文件的文件属性组合在一起，并忽略作为 <em>dwFlagsAndAttributes</em> 的一部分提供的任何文件属性。 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”中详细介绍了特殊情况。</p>
<p>​        以下某些文件属性和标志只能应用于文件，不一定是 <strong>CreateFile</strong> 可以打开的所有其他类型的设备。 有关详细信息，请参阅本主题的“备注”部分和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”。    </p>
<p>​        有关对文件属性的更高级访问，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>。 有关所有文件属性及其值和说明的完整列表，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-attribute-constants">文件属性常量</a>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Attribute</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_ARCHIVE</strong>32 (0x20)</td>
<td style="text-align:left">该文件应存档。 应用程序使用此属性来标记要备份或删除的文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_ENCRYPTED</strong>16384 (0x4000)</td>
<td style="text-align:left">此文件或目录已加密。 对于文件来说，表示文件中的所有数据都是加密的。 对于目录，这意味着加密是新创建的文件和子目录的默认值。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。如果还指定 <strong>了FILE_ATTRIBUTE_SYSTEM</strong> ，则此标志无效。家庭版、家庭高级版、初学者版或 ARM 版 Windows 不支持此标志。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_HIDDEN</strong>2 (0x2)</td>
<td style="text-align:left">文件被隐藏。 不要将其包含在普通目录列表中。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_NORMAL</strong>128 (0x80)</td>
<td style="text-align:left">该文件没有设置其他属性。 此属性仅在单独使用时有效。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_OFFLINE</strong>4096 (0x1000)</td>
<td style="text-align:left">文件的数据不能立即可用。 此属性指示文件数据以物理方式移动到脱机存储。 此属性由远程存储（分层存储管理软件）使用。 应用程序不应随意更改此属性。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_READONLY</strong>1 (0x1)</td>
<td style="text-align:left">文件为只读文件。 应用程序可以读取文件，但无法写入或删除该文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_SYSTEM</strong>4 (0x4)</td>
<td style="text-align:left">该文件是操作系统的一部分或完全使用的文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_TEMPORARY</strong>256 (0x100)</td>
<td style="text-align:left">该文件用于临时存储。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">标志</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_BACKUP_SEMANTICS</strong>0x02000000</td>
<td style="text-align:left">正在为备份或还原操作打开或创建该文件。 系统确保调用进程在进程具有 <strong>SE_BACKUP_NAME</strong> 和 <strong>SE_RESTORE_NAME</strong> 特权时替代文件安全检查。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecBP/changing-privileges-in-a-token">更改令牌中的特权</a>。必须设置此标志才能获取目录的句柄。 目录句柄可以传递给某些函数，而不是文件句柄。 有关详细信息，请参见“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_DELETE_ON_CLOSE</strong>0x04000000</td>
<td style="text-align:left">文件在其所有句柄都关闭后立即被删除，其中包括指定的句柄和任何其他打开或重复的句柄。如果文件存在现有的打开句柄，则调用会失败，除非这些句柄都使用 <strong>FILE_SHARE_DELETE</strong> 共享模式打开。针对文件的后续打开请求将失败，除非指定 FILE_SHARE_DELETE 共享模式。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_NO_BUFFERING</strong>0x20000000</td>
<td style="text-align:left">文件或设备正在打开，没有系统缓存来读取和写入数据。 此标志不会影响硬盘缓存或内存映射文件。使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志成功使用 <strong>CreateFile</strong> 打开的文件有严格的要求，有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_OPEN_NO_RECALL</strong>0x00100000</td>
<td style="text-align:left">请求文件数据，但它应继续位于远程存储中。 不应将其传输回本地存储。 此标志供远程存储系统使用。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>0x00200000</td>
<td style="text-align:left">不会进行正常的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/reparse-points">重新分析点</a> 处理; <strong>CreateFile</strong> 将尝试打开重新分析点。 打开文件时，将返回文件句柄，无论控制重新分析点的筛选器是否正常运行。此标志不能与 <strong>CREATE_ALWAYS</strong> 标志一起使用。如果文件不是重新分析点，则忽略此标志。有关详细信息，请参见“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_OVERLAPPED</strong>0x40000000</td>
<td style="text-align:left">文件或设备正在为异步 I/O 打开或创建。在此句柄上完成后续 I/O 操作时， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件将设置为信号状态。如果指定了此标志，则该文件可用于同时读取和写入操作。如果未指定此标志，则即使对读取和写入函数的调用指定 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">了 OVERLAPPED</a> 结构，I/O 操作也会序列化。有关使用此标志创建的文件句柄时的注意事项，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#synchronous_and_asynchronous_i_o_handles">同步和异步 I/O 句柄</a> 部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_POSIX_SEMANTICS</strong>0x01000000</td>
<td style="text-align:left">访问将根据 POSIX 规则进行。 这包括允许具有名称的多个文件，仅在支持该命名的文件系统时有所不同。 使用此选项时应小心，因为使用此标志创建的文件可能无法由为 MS-DOS 或 16 位 Windows 编写的应用程序访问。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_RANDOM_ACCESS</strong>0x10000000</td>
<td style="text-align:left">访问是随机的。 系统可将此选项用作优化文件缓存的提示。如果文件系统不支持缓存的 I/O 和 <strong>FILE_FLAG_NO_BUFFERING</strong>，则此标志无效。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_SESSION_AWARE</strong>0x00800000</td>
<td style="text-align:left">文件或设备正在使用会话感知打开。 如果未指定此标志，则会话中的每个会话设备 (（例如使用 RemoteFX USB 重定向的设备) ）无法由会话 0 中运行的进程打开。 对于不在会话 0 中的调用方，此标志无效。 此标志仅在 Windows 的服务器版本上受支持。<strong>Windows Server 2008 R2 和 Windows Server 2008：</strong> Windows Server 2012之前不支持此标志。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_SEQUENTIAL_SCAN</strong>0x08000000</td>
<td style="text-align:left">访问旨在从头到尾的顺序。 系统可将此选项用作优化文件缓存的提示。如果读取隐藏 (（即使用反向扫描) ），则不应使用此标志。如果文件系统不支持缓存的 I/O 和 <strong>FILE_FLAG_NO_BUFFERING</strong>，则此标志无效。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_WRITE_THROUGH</strong>0x80000000</td>
<td style="text-align:left">写入操作不会经历任何中间缓存，它们将直接转到磁盘。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
</tbody>
</table>
</div>
<p><em>dwFlagsAndAttributes</em> 参数还可以指定 SQOS 信息。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/impersonation-levels">模拟级别</a>。 当调用应用程序将 <strong>SECURITY_SQOS_PRESENT</strong> 标志指定为 <em>dwFlagsAndAttributes</em> 的一部分时，它还可以包含以下一个或多个值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">安全标志</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>SECURITY_ANONYMOUS</strong></td>
<td style="text-align:left">模拟匿名模拟级别的客户端。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_CONTEXT_TRACKING</strong></td>
<td style="text-align:left">安全跟踪模式是动态的。 如果未指定此标志，则安全跟踪模式是静态的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_DELEGATION</strong></td>
<td style="text-align:left">模拟委托模拟级别的客户端。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_EFFECTIVE_ONLY</strong></td>
<td style="text-align:left">只有客户端安全上下文的已启用方面可供服务器使用。 如果未指定此标志，则客户端安全上下文的所有方面都可用。这允许客户端限制服务器在模拟客户端时可以使用的组和特权。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_IDENTIFICATION</strong></td>
<td style="text-align:left">模拟标识模拟级别的客户端。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_IMPERSONATION</strong></td>
<td style="text-align:left">模拟模拟级别的客户端。 如果未指定其他标志以及 <strong>SECURITY_SQOS_PRESENT</strong> 标志，则这是默认行为。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] hTemplateFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        具有 <strong>GENERIC_READ</strong> 访问权限的模板文件的有效句柄。 模板文件为正在创建的文件提供文件属性和扩展属性。</p>
<p>​        此参数可以为 NULL。</p>
<p>​        打开现有文件时， <strong>CreateFile</strong> 将忽略此参数。</p>
<p>​        打开新的加密文件时，该文件将从其父目录继承任意访问控制列表。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。</p>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是指定文件、设备、命名管道或邮件槽的打开句柄。</p>
<p>​        如果函数失败，则返回值为 INVALID_HANDLE_VALUE。 要获得更多的错误信息，请调用 GetLastError。</p>
<h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><p>​        <strong>CreateFile</strong> 最初专为文件交互而开发，但此后已扩展和增强，以包括 Windows 开发人员可用的大多数其他类型的 I/O 设备和机制。 本部分尝试介绍开发人员在不同上下文中使用不同的 I/O 类型使用 <strong>CreateFile</strong> 时可能遇到的各种问题。 仅当专门引用存储在文件系统上实际文件中的数据时，文本才会尝试使用单词 <em>文件</em> 。 但是，某些文件用法可能更普遍地引用支持类似 <em>文件的</em> I/O 对象。 由于前面提到的历史原因，这种自由使用术语 <em>文件</em> 在常量名称和参数名称中尤其普遍。</p>
<p>​        使用 <strong>CreateFile</strong> 返回的对象句柄完成应用程序后，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 函数关闭句柄。 这不仅释放了系统资源，而且可以对共享文件或设备以及将数据提交到磁盘等内容产生更广泛的影响。 本主题中会相应地说明具体内容。</p>
<p>​        <strong>Windows Server 2003 和 Windows XP：</strong> 如果尝试打开文件或目录以在远程计算机上删除，则发生共享冲突，当 <em>dwDesiredAccess</em> 参数的值是使用任何其他访问标志 (0x00010000) <strong>OR’ed</strong> 的 <strong>DELETE</strong> 访问标志，并且远程文件或目录尚未使用<strong>FILE_SHARE_DELETE</strong>打开。 为了避免此方案中的共享冲突，请仅打开具有 <strong>DELETE</strong> 访问权限的远程文件或目录，或者调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> ，而无需首先打开文件或目录进行删除。</p>
<p>​        某些文件系统（如 NTFS 文件系统）支持单个文件和目录的压缩或加密。 对于具有此支持的装载文件系统的卷，新文件继承其目录的压缩和加密属性。</p>
<p>​        不能使用 <strong>CreateFile</strong> 来控制文件或目录上的压缩、解压缩或解密。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">创建和打开文件</a>、 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-compression-and-decompression">文件压缩和解压缩</a>以及 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。</p>
<p>​        <strong>Windows Server 2003 和 Windows XP：</strong> 出于向后兼容性目的，在 <em>lpSecurityAttributes</em> 中指定安全描述符时，<strong>CreateFile</strong> 不会应用继承规则。 为了支持继承，以后查询此文件的安全描述符的函数可能会启发性地确定并报告继承是否有效。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">可继承 ACE 的自动传播</a>。</p>
<p>​        如前所述，如果 <em>lpSecurityAttributes</em> 参数为 <strong>NULL</strong>，则应用程序可能创建的任何子进程都无法继承 <strong>CreateFile</strong> 返回的句柄。 有关此参数的以下信息也适用：</p>
<ul>
<li>如果 <strong>bInheritHandle</strong> 成员变量不是 <strong>FALSE</strong>，这是任何非零值，则可以继承句柄。 因此，如果不希望句柄可继承，则此结构成员必须正确初始化为 <strong>FALSE</strong> 。</li>
<li>访问控制列表 (文件或目录的默认安全描述符中的 ACL) 继承自其父目录。</li>
<li>目标文件系统必须支持 <strong>lpSecurityDescriptor</strong> 成员对文件和目录的安全性，才能对其产生影响，这可以通过 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">使用 GetVolumeInformation</a> 来确定。</li>
</ul>
<p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">技术</th>
<th style="text-align:left">支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td>
<td style="text-align:left">请参阅备注</td>
</tr>
<tr>
<td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td>
<td style="text-align:left">请参阅备注</td>
</tr>
<tr>
<td style="text-align:left">群集共享卷文件系统 (CsvFS)</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">弹性文件系统 (ReFS)</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
</div>
<p>​        请注意，如果对已打开的备用数据流的文件执行，具有取代处置的 <strong>CreateFile</strong> 将失败。</p>
<h4 id="符号链接行为"><a href="#符号链接行为" class="headerlink" title="符号链接行为"></a>符号链接行为</h4><p>​        如果对此函数的调用创建文件，则行为没有变化。 此外，请考虑有关 <strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>的以下信息：</p>
<ul>
<li>如果指定了FILE_FLAG_OPEN_REPARSE_POINT<ul>
<li>如果打开现有文件并且它是符号链接，则返回的句柄是符号链接的句柄。</li>
<li>如果指定 <strong>了TRUNCATE_EXISTING</strong> 或 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> ，则受影响的文件是符号链接。</li>
</ul>
</li>
<li>如果未指定FILE_FLAG_OPEN_REPARSE_POINT：<ul>
<li>如果打开现有文件并且它是符号链接，则返回的句柄是目标句柄。</li>
<li>如果指定 <strong>CREATE_ALWAYS</strong>、 <strong>TRUNCATE_EXISTING</strong>或 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> ，则受影响的文件是目标。</li>
</ul>
</li>
</ul>
<h4 id="缓存行为"><a href="#缓存行为" class="headerlink" title="缓存行为"></a>缓存行为</h4><p><strong>CreateFile</strong> 使用 <em>dwFlagsAndAttributes</em> 参数的多个可能值来控制或影响系统缓存与句柄关联的数据的方式。 它们是：</p>
<ul>
<li><strong>FILE_FLAG_NO_BUFFERING</strong></li>
<li><strong>FILE_FLAG_RANDOM_ACCESS</strong></li>
<li><strong>FILE_FLAG_SEQUENTIAL_SCAN</strong></li>
<li><strong>FILE_FLAG_WRITE_THROUGH</strong></li>
<li><strong>FILE_ATTRIBUTE_TEMPORARY</strong></li>
</ul>
<p>如果未指定这些标志，系统将使用默认的常规用途缓存方案。 否则，系统缓存的行为与为每个标志指定。</p>
<p>不应合并其中一些标志。 例如，将 <strong>FILE_FLAG_RANDOM_ACCESS</strong> 与 <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong> 相结合是自败。</p>
<p>指定 <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong> 标志可以提高使用顺序访问读取大型文件的应用程序的性能。 对于主要按顺序读取大型文件的应用程序，性能提升可能更加明显，但偶尔会跳过小范围的字节。 如果应用程序移动文件指针进行随机访问，则很可能不会发生最佳缓存性能。 但是，仍可以保证正确的操作。</p>
<p><strong>标志FILE_FLAG_WRITE_THROUGH</strong>和<strong>FILE_FLAG_NO_BUFFERING</strong>是独立的，可以组合在一起。</p>
<p>如果使用 <strong>FILE_FLAG_WRITE_THROUGH</strong> 但 <strong>未指定FILE_FLAG_NO_BUFFERING</strong> ，以便系统缓存生效，则数据会写入系统缓存，但不会延迟地刷新到磁盘。</p>
<p>如果 <strong>同时指定了FILE_FLAG_WRITE_THROUGH</strong> 和 <strong>FILE_FLAG_NO_BUFFERING</strong> ，以便系统缓存无效，则数据会立即刷新到磁盘，而无需通过 Windows 系统缓存。 操作系统还会向永久性媒体请求硬盘本地硬件缓存的写入。</p>
<p><strong>注意</strong> 并非所有硬盘硬件都支持此写通功能。</p>
<p>正确使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志需要特殊的应用程序注意事项。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</p>
<p>通过 <strong>FILE_FLAG_WRITE_THROUGH</strong> 的写通请求还会导致 NTFS 刷新任何元数据更改，例如时间戳更新或重命名操作，这会导致处理请求。 因此， <strong>FILE_FLAG_WRITE_THROUGH</strong> 标志通常与 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志一起使用，作为每次写入后调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 函数的替代项，这可能会导致不必要的性能损失。 将这些标志一起使用可避免这些处罚。 有关文件和元数据缓存的一般信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-caching">文件缓存</a>。</p>
<p><strong>当FILE_FLAG_NO_BUFFERING</strong>与<strong>FILE_FLAG_OVERLAPPED</strong>结合使用时，标志提供最大的异步性能，因为 I/O 不依赖于内存管理器的同步操作。 但是，某些 I/O 操作需要更多时间，因为缓存中未保留数据。 此外，在创建空文件) 时，文件元数据仍可能 (缓存。 若要确保元数据刷新到磁盘，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 函数。</p>
<p>如果有足够的缓存内存可用，则指定 <strong>FILE_ATTRIBUTE_TEMPORARY</strong> 属性会导致文件系统避免将数据写回到大容量存储，因为应用程序在关闭句柄后删除临时文件。 在这种情况下，系统可以完全避免写入数据。 尽管它不直接控制数据缓存的方式与前面提到的标志相同， <strong>但FILE_ATTRIBUTE_TEMPORARY</strong> 属性确实会告知系统在系统缓存中尽可能多地保留，而无需写入，因此可能对某些应用程序感到担忧。</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>如果重命名或删除文件，然后在不久后还原该文件，系统将在缓存中搜索要还原的文件信息。 缓存信息包括其短/长名称对和创建时间。</p>
<p>如果在之前调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> 时挂起删除的文件上调用 <strong>CreateFile</strong>，该函数将失败。 操作系统会延迟文件删除，直到文件的所有句柄都关闭。 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_ACCESS_DENIED</strong>。</p>
<p><em>dwDesiredAccess</em> 参数可以是零，允许应用程序在不访问文件的情况下查询文件属性（如果应用程序正在运行且具有足够的安全设置）。 这可用于测试文件是否存在，而无需打开该文件进行读取和/或写入访问，或获取有关文件或目录的其他统计信息。 请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/obtaining-and-setting-file-information">获取和设置文件信息和</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a>。</p>
<p>如果指定 <strong>了CREATE_ALWAYS</strong> 和 <strong>FILE_ATTRIBUTE_NORMAL</strong> ， <strong>则 CreateFile</strong> 将失败，并将最后一个错误设置为 <strong>ERROR_ACCESS_DENIED</strong> （如果文件存在并且具有 <strong>FILE_ATTRIBUTE_HIDDEN</strong> 或 <strong>FILE_ATTRIBUTE_SYSTEM</strong> 属性）。 若要避免此错误，请指定与现有文件相同的属性。</p>
<p>当应用程序跨网络创建文件时，最好将 <em>dwDesiredAccess 用于 dwDesiredAccess</em>，而不是单独使用 <strong>GENERIC_WRITE</strong>。<code>GENERIC_READ | GENERIC_WRITE</code> 生成的代码速度更快，因为重定向程序可以使用缓存管理器，并发送更少的 SMB 和更多数据。 这种组合还避免了写入网络中的文件偶尔会返回 <strong>ERROR_ACCESS_DENIED</strong>的问题。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”。</p>
<h4 id="同步和异步-I-O-句柄"><a href="#同步和异步-I-O-句柄" class="headerlink" title="同步和异步 I/O 句柄"></a>同步和异步 I/O 句柄</h4><p><strong>CreateFile</strong> 用于创建同步或异步的文件或设备句柄。 同步句柄的行为使使用该句柄的 I/O 函数调用被阻止，直到它们完成，而异步文件句柄使系统能够立即从 I/O 函数调用返回，无论它们是否完成了 I/O 操作。 如前所述，此同步与异步行为通过指定 <em>dwFlagsAndAttributes</em> 参数中的<strong>FILE_FLAG_OVERLAPPED</strong>来确定。 使用异步 I/O 时存在多种复杂性和潜在缺陷;有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">同步和异步 I/O</a>。</p>
<h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><p>在 NTFS 文件系统上，可以使用 <strong>CreateFile</strong> 在文件中创建单独的流。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-streams">文件流</a>。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>应用程序无法使用 <strong>CreateFile</strong> 创建目录，因此对于此用例，只有 <strong>OPEN_EXISTING</strong> 值对 <em>dwCreationDisposition</em> 有效。 若要创建目录，应用程序必须调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a>。</p>
<p>若要使用 <strong>CreateFile</strong> 打开目录，请将 <strong>FILE_FLAG_BACKUP_SEMANTICS</strong> 标志指定为 <em>dwFlagsAndAttributes</em> 的一部分。 在没有 <strong>SE_BACKUP_NAME</strong> 和 <strong>SE_RESTORE_NAME</strong> 特权的情况下使用此标志时，仍适用适当的安全检查。</p>
<p>使用 <strong>CreateFile</strong> 在对 FAT 或 FAT32 文件系统卷进行碎片整理期间打开目录时，请不要指定 <strong>MAXIMUM_ALLOWED</strong> 访问权限。 如果这样做，则拒绝对目录的访问。 请改为指定 <strong>GENERIC_READ</strong> 访问权限。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/about-directory-management">“关于目录管理</a>”。</p>
<h4 id="物理磁盘和卷"><a href="#物理磁盘和卷" class="headerlink" title="物理磁盘和卷"></a>物理磁盘和卷</h4><p>对磁盘或卷的直接访问受到限制。</p>
<p><strong>Windows Server 2003 和 Windows XP：</strong> 以这种方式不限制对磁盘或卷的直接访问。</p>
<p>可以使用 <strong>CreateFile</strong> 函数打开物理磁盘驱动器或卷，该驱动器返回直接访问存储设备 (DASD) 句柄，该句柄可与 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 函数一起使用。 这样，便可以直接访问磁盘或卷，例如分区表等磁盘元数据。 但是，这种类型的访问也会向潜在的数据丢失公开磁盘驱动器或卷，因为使用此机制对磁盘进行不正确的写入可能会使其内容无法访问操作系统。 为了确保数据完整性，请务必熟悉 <strong>DeviceIoControl</strong> ，以及其他 API 的行为方式与直接访问句柄不同，而不是文件系统句柄。</p>
<p>必须满足以下要求才能成功进行此类调用：</p>
<ul>
<li>调用方必须具有管理权限。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecBP/running-with-special-privileges">使用特殊特权运行</a>。</li>
<li><em>dwCreationDisposition</em> 参数必须具有<strong>OPEN_EXISTING</strong>标志。</li>
<li>打开卷或软盘时， <em>dwShareMode</em> 参数必须具有 <strong>FILE_SHARE_WRITE</strong> 标志。</li>
</ul>
<p><strong>注意*</strong>dwDesiredAccess* 参数可以是零，允许应用程序在不访问设备的情况下查询设备属性。 这适用于应用程序来确定软盘驱动器的大小及其支持的格式，而无需驱动器中的软盘磁盘，例如。 它还可用于读取统计信息，而无需更高级别的数据读取/写入权限。</p>
<p>打开物理驱动器 <em>x</em>：时， <em>lpFileName</em> 字符串应采用以下形式：“.\PhysicalDrive<em>X</em>”。 硬盘编号从零开始。 下表显示了物理驱动器字符串的一些示例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">String</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“.\PhysicalDrive0”</td>
<td style="text-align:left">打开第一个物理驱动器。</td>
</tr>
<tr>
<td style="text-align:left">“.\PhysicalDrive2”</td>
<td style="text-align:left">打开第三个物理驱动器。</td>
</tr>
</tbody>
</table>
</div>
<p>若要获取卷的物理驱动器标识符，请打开卷的句柄，并使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-ioctl_volume_get_volume_disk_extents">IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS</a> 调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 函数。 此控制代码返回每个卷的一个或多个盘区的磁盘数和偏移量;卷可以跨越多个物理磁盘。</p>
<p>有关打开物理驱动器的示例，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/calling-deviceiocontrol">调用 DeviceIoControl</a>。</p>
<p>例如，打开卷或可移动媒体驱动器 (时，软盘驱动器或闪存内存拇指驱动器) ， <em>lpFileName</em> 字符串应采用以下形式：“.<em>X</em>：”。 请勿使用尾随反斜杠 () ，指示驱动器的根目录。 下表显示了驱动器字符串的一些示例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">String</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“.\A：”</td>
<td style="text-align:left">打开软盘驱动器 A。</td>
</tr>
<tr>
<td style="text-align:left">“.\C：”</td>
<td style="text-align:left">打开 C： 卷。</td>
</tr>
<tr>
<td style="text-align:left">“.\C：\”</td>
<td style="text-align:left">打开 C： 卷的文件系统。</td>
</tr>
</tbody>
</table>
</div>
<p>还可以通过引用其卷名称打开卷。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-volume">命名卷</a>。</p>
<p>卷包含一个或多个装载的文件系统。 即使 <strong>CreateFile</strong> 中未指定非缓存选项，也可以按特定文件系统的任意方式打开卷句柄。 应假定所有 Microsoft 文件系统都以非缓存的形式打开卷句柄。 对文件的非缓存 I/O 的限制也适用于卷。</p>
<p>即使数据未缓存，文件系统也可能不需要缓冲区对齐。 但是，如果在打开卷时指定了非缓存选项，则会强制实施缓冲区对齐方式，而不管卷上的文件系统如何。 建议在所有文件系统上以非缓存方式打开卷句柄，并遵循非缓存 I/O 限制。</p>
<p><strong>注意</strong> 若要读取或写入卷的最后几个扇区，必须调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 并指定 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-fsctl_allow_extended_dasd_io">FSCTL_ALLOW_EXTENDED_DASD_IO</a>。 这表示文件系统驱动程序不会对分区读取或写入调用执行任何 I/O 边界检查。 相反，边界检查由设备驱动程序执行。</p>
<h4 id="更改器设备"><a href="#更改器设备" class="headerlink" title="更改器设备"></a>更改器设备</h4><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 的 <strong>IOCTL_CHANGER_*</strong> 控制代码接受变更器设备的句柄。 若要打开变更器设备，请使用以下格式的文件名：“.\Changer<em>x</em>”，其中 <em>x</em> 是一个数字，指示要打开的设备，从零开始。 若要在用 C 或 C++ 编写的应用程序中打开变更器设备零，请使用以下文件名：“.\Changer0”。</p>
<h4 id="磁带驱动器"><a href="#磁带驱动器" class="headerlink" title="磁带驱动器"></a>磁带驱动器</h4><p>可以使用以下格式的文件名打开磁带驱动器：“.\TAPE<em>x</em>”，其中 <em>x</em> 是一个数字，指示要打开的驱动器，从磁带驱动器零开始。 若要在以 C 或 C++ 编写的应用程序中打开磁带驱动器零，请使用以下文件名：“.\TAPE0”。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Backup/backup">备份</a>。</p>
<h4 id="通信资源"><a href="#通信资源" class="headerlink" title="通信资源"></a>通信资源</h4><p><strong>CreateFile</strong> 函数可以创建通信资源的句柄，例如串行端口 COM1。 对于通信资源， <em>dwCreationDisposition</em> 参数必须 <strong>OPEN_EXISTING</strong>， <em>dwShareMode</em> 参数必须是零 (独占访问) ， <em>并且 hTemplateFile</em> 参数必须为 <strong>NULL</strong>。 可以指定读取、写入或读/写访问权限，并且可以为重叠 I/O 打开句柄。</p>
<p>若要指定大于 9 的 COM 端口号，请使用以下语法：“.\COM10”。 此语法适用于允许指定 COM 端口号的所有端口号和硬件。</p>
<p>有关通信的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/communications-resources">通信</a>。</p>
<h4 id="机"><a href="#机" class="headerlink" title="机"></a>机</h4><p><strong>CreateFile</strong> 函数可以创建控制台输入 (CONIN$) 句柄。 如果进程由于继承或重复而具有打开的句柄，则它还可以创建活动屏幕缓冲区 (CONOUT$) 的句柄。 调用进程必须附加到继承的控制台或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/allocconsole">由 AllocConsole</a> 函数分配的控制台。 对于控制台句柄，请按如下所示设置 <strong>CreateFile</strong> 参数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">lpFileName</td>
<td style="text-align:left">使用 CONIN值指定控制台输入。使用值指定控制台输入。使用CONOUT 值指定控制台输出。CONIN获取控制台输入缓冲区的句柄，即使函数重定向标准输入句柄。若要获取标准输入句柄，请使用函数。获取控制台输入缓冲区的句柄，即使<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh−cn/windows/console/setstdhandle">SetStdHandle</a>函数重定向标准输入句柄。若要获取标准输入句柄，请使用<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh−cn/windows/console/getstdhandle">GetStdHandle</a>函数。CONOUT 获取活动屏幕缓冲区的句柄，即使 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/setstdhandle">SetStdHandle</a> 重定向标准输出句柄。 若要获取标准输出句柄，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/getstdhandle">GetStdHandle</a>。</td>
</tr>
<tr>
<td style="text-align:left">dwDesiredAccess</td>
<td style="text-align:left">`GENERIC_READ</td>
<td>GENERIC_WRITE` 首选，但任一限制访问。</td>
</tr>
<tr>
<td style="text-align:left">dwShareMode</td>
<td style="text-align:left">打开 CONIN时，请指定。打开时，请指定∗∗FILESHAREREAD∗∗。打开CONOUT时，请指定 <strong>FILE_SHARE_WRITE</strong>。如果调用进程继承控制台，或者子进程应能够访问控制台，则必须是 `FILE_SHARE_READ</td>
<td>FILE_SHARE_WRITE`此参数。</td>
</tr>
<tr>
<td style="text-align:left">lpSecurityAttributes</td>
<td style="text-align:left">如果希望继承控制台，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85">SECURITY_ATTRIBUTES结构的</a>)<strong>bInheritHandle</strong> 成员必须为 <strong>TRUE</strong>。</td>
</tr>
<tr>
<td style="text-align:left">dwCreationDisposition</td>
<td style="text-align:left">使用 <strong>CreateFile</strong> 打开控制台时，应指定<strong>OPEN_EXISTING</strong>。</td>
</tr>
<tr>
<td style="text-align:left">dwFlagsAndAttributes</td>
<td style="text-align:left">已忽略。</td>
</tr>
<tr>
<td style="text-align:left">hTemplateFile</td>
<td style="text-align:left">已忽略。</td>
</tr>
</tbody>
</table>
</div>
<p>下表显示了 <em>dwDesiredAccess</em> 和 <em>lpFileName</em> 的各种设置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">lpFileName</th>
<th style="text-align:left">dwDesiredAccess</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“CON”</td>
<td style="text-align:left"><strong>GENERIC_READ</strong></td>
<td style="text-align:left">打开用于输入的控制台。</td>
</tr>
<tr>
<td style="text-align:left">“CON”</td>
<td style="text-align:left"><strong>GENERIC_WRITE</strong></td>
<td style="text-align:left">打开用于输出的控制台。</td>
</tr>
<tr>
<td style="text-align:left">“CON”</td>
<td style="text-align:left">`GENERIC_READ</td>
<td style="text-align:left">GENERIC_WRITE`</td>
<td>导致 <strong>CreateFile</strong> 失败; <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_FILE_NOT_FOUND</strong>。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Mailslots"><a href="#Mailslots" class="headerlink" title="Mailslots"></a>Mailslots</h4><p>如果 <strong>CreateFile</strong> 打开 mailslot 的客户端端，则函数将返回 <strong>INVALID_HANDLE_VALUE</strong> 如果 mailslot 客户端尝试在 mailslot 服务器使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createmailslota">CreateMailSlot 函数创建本地 mailslot 之前打开本地 mailslot</a> 。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/mailslots">Mailslots</a>。</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>如果 <strong>CreateFile</strong> 打开命名管道的客户端端，该函数将使用处于侦听状态的命名管道的任何实例。 打开过程可以根据需要多次复制句柄，但在打开该句柄之后，另一个客户端无法打开命名管道实例。 打开管道时指定的访问必须与 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> 函数的 <em>dwOpenMode</em> 参数中指定的访问兼容。</p>
<p>如果在此操作之前未在服务器上成功调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> 函数，则管道将不存在， <strong>并且 CreateFile</strong> 将失败 <strong>并出现ERROR_FILE_NOT_FOUND</strong>。</p>
<p>如果至少有一个活动管道实例，但服务器上没有可用的侦听器管道，这意味着所有管道实例当前都已连接， <strong>则 CreateFile</strong> 会失败 <strong>并ERROR_PIPE_BUSY</strong>。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/pipes">管道</a>。</p>
<h3 id="ReadFile-函数-fileapi-h"><a href="#ReadFile-函数-fileapi-h" class="headerlink" title="ReadFile 函数 (fileapi.h)"></a>ReadFile 函数 (fileapi.h)</h3><p>从指定的文件或输入/输出 (I/O) 设备读取数据。 如果设备支持，则读取发生在文件指针指定的位置。</p>
<p>此函数适用于同步操作和异步操作。 有关专为异步操作设计的类似函数，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a>。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">BOOL ReadFile(
  [in]                HANDLE       hFile,
  [out]               LPVOID       lpBuffer,
  [in]                DWORD        nNumberOfBytesToRead,
  [out, optional]     LPDWORD      lpNumberOfBytesRead,
  [in, out, optional] LPOVERLAPPED lpOverlapped
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] hFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设备句柄 (例如文件、文件流、物理磁盘、卷、控制台缓冲区、磁带驱动器、套接字、通信资源、mailslot 或管道) 。</p>
<p>必须使用读取访问权限创建 <em>hFile</em> 参数。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/generic-access-rights">通用访问权限</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-security-and-access-rights">文件安全性和访问权限</a>。</p>
<p>对于异步读取操作，<em>hFile</em> 可以是使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 函数的<strong>FILE_FLAG_OVERLAPPED</strong>标志打开的任何句柄，也可以是套接字或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> 函数返回的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock2/nf-winsock2-socket">套接字</a>句柄。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>指向接收从文件或设备读取数据的缓冲区的指针。</p>
<p>此缓冲区必须在读取操作期间保持有效。 在读取操作完成之前，调用方不得使用此缓冲区。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] nNumberOfBytesToRead<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要读取的最多字节数。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpNumberOfBytesRead<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>指向使用同步 <em>hFile</em> 参数时接收读取的字节数的变量的指针。 <strong>ReadFile</strong> 将此值设置为零，然后再执行任何工作或错误检查。 如果这是一个异步操作，请对此参数使用 <strong>NULL</strong> ，以避免潜在的错误结果。</p>
<p>仅当 <em>lpOverlapped</em> 参数不为 <strong>NULL</strong> 时，此参数才可为 <strong>NULL</strong>。</p>
<p><strong>Windows 7：</strong> 此参数不能为 <strong>NULL</strong>。</p>
<p>有关详细信息，请参见“备注”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in, out, optional] lpOverlapped<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong> 打开 <em>hFile</em> 参数，则需要指向 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的指针，否则可为 <strong>NULL</strong>。</p>
<p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong>打开 <em>hFile</em>，<em>则 lpOverlapped</em> 参数必须指向有效且唯一的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构，否则该函数无法错误地报告读取操作已完成。</p>
<p>对于支持字节偏移量的 <em>hFile</em> ，如果使用此参数，则必须指定从文件或设备开始读取的字节偏移量。 通过设置 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的 <strong>Offset</strong> 和 <strong>OffsetHigh</strong> 成员来指定此偏移量。 对于不支持字节偏移量的 <em>hFile</em>，将忽略 <strong>Offset 和 OffsetHigh</strong>。</p>
<p>有关 <em>lpOverlapped</em> 和 <strong>FILE_FLAG_OVERLAPPED</strong>的不同组合的详细信息，请参阅“备注”部分和 <strong>“同步和文件位置</strong> ”部分。</p>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>如果函数成功，则返回值为非零 (<strong>TRUE</strong>) 。</p>
<p>如果函数失败或异步完成，则返回值为零， (<strong>FALSE</strong>) 。 若要获取扩展的错误信息，请调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数。</p>
<p><strong>注意</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 代码<strong>ERROR_IO_PENDING</strong>不是失败;它指定读取操作正在异步等待完成。 有关详细信息，请参阅“备注”。</p>
<h4 id="注解-2"><a href="#注解-2" class="headerlink" title="注解"></a>注解</h4><p>发生以下情况之一时， <strong>ReadFile</strong> 函数将返回：</p>
<ul>
<li></li>
<li>读取请求的字节数。</li>
<li>写入操作在管道的写入端完成。</li>
<li>正在使用异步句柄，读取正在异步发生。</li>
<li>发生错误。</li>
</ul>
<p>每当有过多未完成的异步 I/O 请求时，<strong>ReadFile</strong> 函数可能会失败<strong>，**</strong>ERROR_INVALID_USER_BUFFER或ERROR_NOT_ENOUGH_MEMORY**。</p>
<p>若要取消所有挂起的异步 I/O 操作，请使用以下任一操作：</p>
<ul>
<li></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelio">CancelIo</a> - 此函数仅取消由指定文件句柄的调用线程发出的操作。</li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelioex-func">CancelIoEx</a> - 此函数取消指定文件句柄的线程发出的所有操作。</li>
</ul>
<p>使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</a> 取消挂起的同步 I/O 操作。</p>
<p>取消的 I/O 操作已完成，错误 <strong>ERROR_OPERATION_ABORTED</strong>。</p>
<p><strong>ReadFile</strong> 函数可能会失败<strong>，ERROR_NOT_ENOUGH_QUOTA</strong>，这意味着调用进程的缓冲区无法锁定页。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-setprocessworkingsetsize">SetProcessWorkingSetSize</a>。</p>
<p>如果某个文件的一部分被另一个进程锁定，并且读取操作与锁定部分重叠，则此函数将失败。</p>
<p>读取操作使用缓冲区时访问输入缓冲区可能会导致读取到该缓冲区的数据损坏。 在读取操作完成之前，应用程序不得读取、写入、重新分配或释放读取操作使用的输入缓冲区。 使用异步文件句柄时，这尤其有问题。 有关同步与异步文件句柄的其他信息，可以在 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/">“同步和文件位置</a> ”部分以及 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 参考主题中找到。</p>
<p>可以使用具有控制台输入句柄的 <strong>ReadFile</strong> 从控制台输入缓冲区读取字符。 控制台模式确定 <strong>ReadFile</strong> 函数的确切行为。 默认情况下，控制台模式 <strong>ENABLE_LINE_INPUT</strong>，指示 <strong>ReadFile</strong> 应在到达回车前读取。 如果按 Ctrl+C，则调用成功，但 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_OPERATION_ABORTED</strong>。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>。</p>
<p>从通信设备读取时， <strong>ReadFile</strong> 的行为由当前通信超时确定为集，并使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-setcommtimeouts">SetCommTimeouts</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-getcommtimeouts">GetCommTimeouts</a> 函数进行检索。 如果无法设置超时值，则可能会出现不可预知的结果。 有关通信超时的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/ns-winbase-commtimeouts">COMMTIMEOUTS</a>。</p>
<p>如果 <strong>ReadFile</strong> 尝试从具有太小缓冲区的邮件图中读取，则函数返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_INSUFFICIENT_BUFFER</strong>。</p>
<p>使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志成功使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 打开的文件有严格的要求。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</p>
<p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong> 打开 <em>hFile</em>，则以下条件有效：</p>
<ul>
<li></li>
<li><em>lpOverlapped</em> 参数必须指向有效且唯一的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构，否则该函数可以错误地报告读取操作已完成。</li>
<li><em>lpNumberOfBytesRead</em> 参数应设置为 <strong>NULL</strong>。 使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> 函数获取读取的实际字节数。 如果 <em>hFile</em> 参数与 I/O 完成端口相关联，则还可以通过调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> 函数获取读取的字节数。</li>
</ul>
<h4 id="同步和文件位置"><a href="#同步和文件位置" class="headerlink" title="同步和文件位置"></a>同步和文件位置</h4><p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong>打开 <em>hFile</em>，则它是异步文件句柄;否则为同步。 使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的规则对每个结构略有不同，如前所述。</p>
<p><strong>注意</strong> 如果为异步 I/O 打开文件或设备，则使用该句柄对 <strong>ReadFile</strong> 等函数的后续调用通常会立即返回，但对于被阻止的执行，也可以同步执行。 有关更多信息，请参见<a target="_blank" rel="noopener" href="https://support.microsoft.com/kb/156932">http://support.microsoft.com/kb/156932</a>。</p>
<p>使用异步文件句柄的注意事项：</p>
<ul>
<li><p><strong>ReadFile</strong> 可能会在读取操作完成之前返回。 在此方案中， <strong>ReadFile</strong> 返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数返回 <strong>ERROR_IO_PENDING</strong>，这允许调用进程在系统完成读取操作时继续。</p>
</li>
<li><p>lpOverlapped</p>
</li>
</ul>
<p>  参数不得为</p>
<p>  NULL</p>
<p>  ，应与以下事实一起使用：</p>
<ul>
<li>尽管 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件由系统自动设置和重置，但 <strong>在 OVERLAPPED</strong> 结构中指定的偏移量不会自动更新。</li>
<li><strong>ReadFile</strong> 在开始 I/O 操作时将事件重置为非对齐状态。</li>
<li>在 READ 操作完成时， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件设置为信号状态;直到该时间，读取操作被视为挂起。</li>
<li>由于读取操作从 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的偏移量开始，并且 <strong>ReadFile</strong> 可能会在系统级读取操作完成 (读取挂起) 之前返回，因此，应用程序不应修改、释放或重用结构的任何其他部分，直到向事件发出信号 (（即） 读取完成) 。</li>
<li>如果在异步操作期间检测到文件结束 (EOF) ，则对该操作的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> 的调用将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_HANDLE_EOF</strong>。</li>
</ul>
<p>使用同步文件句柄的注意事项：</p>
<ul>
<li>如果 <em>lpOverlapped</em> 为 <strong>NULL</strong>，则读取操作从当前文件位置开始， <strong>ReadFile</strong> 在操作完成之前不会返回，并且系统会在 <strong>ReadFile</strong> 返回之前更新文件指针。</li>
<li>如果 <em>lpOverlapped</em> 不是 <strong>NULL</strong>，则读取操作从 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的偏移量开始， <strong>ReadFile</strong> 在读取操作完成之前不会返回。 系统在 <strong>ReadFile</strong> 返回之前更新 <strong>OVERLAPPED</strong> 偏移量和文件指针。</li>
<li>如果 <em>lpOverlapped</em> 为 <strong>NULL</strong>，则当同步读取操作到达文件末尾时， <strong>ReadFile</strong> 将返回 <strong>TRUE</strong> 并将设置为 <code>*lpNumberOfBytesRead</code> 零。</li>
<li>如果 <em>lpOverlapped</em> 不是 <strong>NULL</strong>，则当同步读取操作到达文件末尾时， <strong>ReadFile</strong> 将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_HANDLE_EOF</strong>。</li>
</ul>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">同步和异步 I/O</a>。</p>
<h4 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a>管道</h4><p>如果使用匿名管道并且写入句柄已关闭，则 <strong>当 ReadFile</strong> 尝试使用管道的相应读取句柄进行读取时，函数将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_BROKEN_PIPE</strong>。</p>
<p>如果在消息模式下读取命名管道，并且下一条消息的长度超过 <em>nNumberOfBytesToRead</em> 参数指定， <strong>ReadFile</strong> 将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_MORE_DATA</strong>。 后续调用 <strong>ReadFile</strong> 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe">PeekNamedPipe</a> 函数可以读取消息的其余部分。</p>
<p>如果 <strong>ReadFile</strong> 在管道上返回 <strong>TRUE</strong> 时<em>，lpNumberOfBytesRead</em> 参数为零，则管道的另一端称为 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> 函数，<em>nNumberOfBytesToWrite</em> 设置为零。</p>
<p>有关管道的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/pipes">管道</a>。</p>
<h4 id="事务处理的操作"><a href="#事务处理的操作" class="headerlink" title="事务处理的操作"></a>事务处理的操作</h4><p>如果存在绑定到文件句柄的事务，则该函数将从文件的事务处理视图中返回数据。 保证事务处理读取句柄在句柄期间显示文件的相同视图。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/about-transactional-ntfs">关于事务 NTFS</a>。</p>
<p>在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
<h2 id="系统2"><a href="#系统2" class="headerlink" title="系统2"></a>系统2</h2><h2 id="Windows数据结构"><a href="#Windows数据结构" class="headerlink" title="Windows数据结构"></a>Windows数据结构</h2><p>​        这里的数据结构指的是Windows文件体系的结构。</p>
<p>​        这里的结构是用老式的C定义与实现的，为了与之对应，我们采取打开一个文件的属性查看作为可视化的理解。</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct _WIN32_FILE_ATTRIBUTE_DATA &#123;
    DWORD dwFileAttributes;&#x2F;&#x2F; 文件属性
    FILETIME ftCreationTime;&#x2F;&#x2F; 创建时间
    FILETIME ftLastAccessTime;&#x2F;&#x2F; 最后访问时间
    FILETIME ftLastWriteTime;&#x2F;&#x2F; 最后修改
    DWORD nFileSizeHigh;&#x2F;&#x2F; 文件长度
    DWORD nFileSizeLow; &#x2F;&#x2F; 文件长度
&#125; WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230516204344506.png?lastModify=1685936981" alt="image-20230516204344506"></p>
<p>​        下面我们来看怎样使用这样的结构. </p>
<h2 id="一些函数的讲解"><a href="#一些函数的讲解" class="headerlink" title="一些函数的讲解"></a>一些函数的讲解</h2><p>​        我们获取文件属性使用Windows的<code>GetFileAttributesEx</code>函数宏,他需要参数文件地址,获取方式和<code>WIN32_FILE_ATTRIBUTE_DATA</code>结构体.这个函数跟我们熟悉的C变成一样,以参数的参数进入返回初始化后的参数.</p>
<h3 id="GetFileAttributesEx"><a href="#GetFileAttributesEx" class="headerlink" title="GetFileAttributesEx()"></a>GetFileAttributesEx()</h3><h4 id="GetFileAttributesExW-函数-fileapi-h"><a href="#GetFileAttributesExW-函数-fileapi-h" class="headerlink" title="GetFileAttributesExW 函数 (fileapi.h)"></a>GetFileAttributesExW 函数 (fileapi.h)</h4><p>反馈</p>
<p>检索指定文件或目录的属性。</p>
<p>若要将此操作作为事务处理操作执行，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-getfileattributestransacteda">GetFileAttributesTransacted</a> 函数。</p>
<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><pre class="line-numbers language-none"><code class="language-none">BOOL GetFileAttributesExW(
  [in]  LPCWSTR                lpFileName,
  [in]  GET_FILEEX_INFO_LEVELS fInfoLevelId,
  [out] LPVOID                 lpFileInformation
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h5><pre class="line-numbers language-none"><code class="language-none">[in] lpFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        文件或目录的名称。</p>
<p>​        在此函数的 ANSI 版本中，名称限制为 <strong>MAX_PATH</strong> 个字符。 若要将此限制扩展到 32，767 宽字符，请调用函数的 Unicode 版本 (<strong>GetFileAttributesExW</strong>) ，并将“\？\”追加到路径。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-file">命名文件</a>。</p>
<p><strong>提示</strong></p>
<p>从 Windows 10 版本 1607 开始，对于此函数的 unicode 版本， (<strong>GetFileAttributesExW</strong>) ，可以选择加入以删除<strong>MAX_PATH</strong>字符限制，而无需追加“\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径限制”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] fInfoLevelId<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        要检索的属性信息的类。</p>
<p>​        此参数可以是 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> 枚举中的以下值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>GetFileExInfoStandard</strong></td>
<td style="text-align:left"><em>lpFileInformation</em> 参数是<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">一个WIN32_FILE_ATTRIBUTE_DATA</a>结构。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[out] lpFileInformation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收属性信息的缓冲区的指针。</p>
<p>​        存储在此缓冲区中的属性信息类型由 fInfoLevelId 的值决定。</p>
<h2 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为 0 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p>
<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><p>​        现在我们拿到了初始化结束的结构体,我们想看看时间.要知道,显示时间是可以多样化的,意味着微软希望我们自己书写函数来展示之.</p>
<p>​        为了提高效率,时间被压缩在几个字节,需要我们自己来转化.这个也是一个结构体<code>FileTime</code>.</p>
<pre class="line-numbers language-none"><code class="language-none">void showFileTime(PFILETIME aTime)
&#123;

&#125;
#include&lt;Windows.h&gt;
#include&lt;iostream&gt;
using namespace std;

void showFileTime(PFILETIME aTime)
&#123;
	FILETIME filetimeLocal;
	SYSTEMTIME sysFileTime;
	FileTimeToLocalFileTime(aTime, &amp;filetimeLocal);&#x2F;&#x2F; 转换成系统时区时间
	FileTimeToSystemTime(&amp;filetimeLocal, &amp;sysFileTime);

	cout &lt;&lt; sysFileTime.wYear &lt;&lt; &quot; 年 &quot; &lt;&lt; sysFileTime.wMonth &lt;&lt; &quot; 月 &quot; &lt;&lt; \
		sysFileTime.wDay &lt;&lt; &quot; 日 &quot; &lt;&lt; sysFileTime.wHour&lt;&lt;&quot;时&quot; &lt;&lt; sysFileTime.wMinute &lt;&lt; &quot; 分 &quot; &lt;&lt; sysFileTime.wSecond &lt;&lt; &quot; 秒&quot; &lt;&lt; endl;

	return;
&#125;



void showInfo(LPWIN32_FILE_ATTRIBUTE_DATA pWfad)
&#123;
	if (pWfad &#x3D;&#x3D; NULL) &#123;
		cout &lt;&lt; &quot;Failed to get the file&quot;;
		return;
	&#125;

	showFileTime(&amp;pWfad-&gt;ftCreationTime);
	showFileTime(&amp;pWfad-&gt;ftLastAccessTime);
&#125;


int main()&#123;

	WIN32_FILE_ATTRIBUTE_DATA wfad;

	if (!GetFileAttributesEx(L&quot;1.cpp&quot;, GetFileExInfoStandard, &amp;wfad))
	&#123;

		cout &lt;&lt; &quot;Failed to get the file&quot;;
		return 1;
	&#125;

	
	showInfo(&amp;wfad);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230516211817965.png?lastModify=1685936981" alt="image-20230516211817965"></p>
<h2 id="获取系统目录"><a href="#获取系统目录" class="headerlink" title="获取系统目录"></a>获取系统目录</h2><p>​        为了获取系统目录信息，需要使用函数来完成这项工作！这个函数是<code>GetSystemDirectory()</code></p>
<p>​        使用它很简单：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;locale.h&gt;
int main() &#123;

	setlocale(LC_ALL,&quot;&quot;);

	TCHAR szSystemDir[MAX_PATH];

	GetSystemDirectory(szSystemDir, MAX_PATH);

	printf(&quot;%ls&quot;, szSystemDir);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="GetSystemDirectoryW-函数-sysinfoapi-h"><a href="#GetSystemDirectoryW-函数-sysinfoapi-h" class="headerlink" title="GetSystemDirectoryW 函数 (sysinfoapi.h)"></a>GetSystemDirectoryW 函数 (sysinfoapi.h)</h3><p>​        检索系统目录的路径。 系统目录包含系统文件，如动态链接库和驱动程序。</p>
<p>​        此函数主要用于兼容性。 应用程序应将代码存储在 Program Files 文件夹中，并将持久数据存储在用户配置文件的 Application Data 文件夹中。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">ShGetFolderPath</a>。</p>
<h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">UINT GetSystemDirectoryW(
  [out] LPWSTR lpBuffer,
  [in]  UINT   uSize
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向要接收路径的缓冲区的指针。 除非系统目录是根目录，否则此路径不会以反斜杠结尾。 例如，如果系统目录在驱动器 C 上命名为 Windows\System32，则此函数检索的系统目录的路径为 C：\Windows\System32。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] uSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        缓冲区的最大大小（以 <strong>TCHAR</strong> 为单位）。</p>
<h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值为复制到缓冲区的字符串的长度（以 <strong>TCHAR</strong> 为单位），不包括终止 null 字符。 如果长度大于缓冲区的大小，则返回值是保存路径所需的缓冲区大小，包括终止 null 字符。</p>
<p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<p>​        </p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230518231050866.png?lastModify=1685936981" alt="image-20230518231050866"></p>
<p>​        下面写之进入一个文件！</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;locale.h&gt;
int main() &#123;

	setlocale(LC_ALL,&quot;&quot;);

	TCHAR szSystemDir[MAX_PATH];

	GetSystemDirectory(szSystemDir, MAX_PATH);

	printf(&quot;%ls&quot;, szSystemDir);
	DWORD dwWritten;
	HANDLE hFile;
	hFile &#x3D; CreateFile(L&quot;SystemRoot.txt&quot;, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFile !&#x3D; INVALID_HANDLE_VALUE) &#123;
		if (!WriteFile(hFile, szSystemDir, 2*lstrlen(szSystemDir), &amp;dwWritten, NULL)) &#123;
			return GetLastError();
		&#125;
	&#125;

	CloseHandle(hFile);
	printf(&quot;OK&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="创建窗口和消息处理"><a href="#创建窗口和消息处理" class="headerlink" title="创建窗口和消息处理"></a>创建窗口和消息处理</h2><p>​        两大方法：使用向导来创建窗口，或者是手写代码自己来写</p>
<p>​        我们来创建一个Windows应用程序。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; WindowsProject1.cpp : 定义应用程序的入口点。
&#x2F;&#x2F;

#include &quot;framework.h&quot;
#include &quot;WindowsProject1.h&quot;

#define MAX_LOADSTRING 100

&#x2F;&#x2F; 全局变量:
HINSTANCE hInst;                                &#x2F;&#x2F; 当前实例
WCHAR szTitle[MAX_LOADSTRING];                  &#x2F;&#x2F; 标题栏文本
WCHAR szWindowClass[MAX_LOADSTRING];            &#x2F;&#x2F; 主窗口类名

&#x2F;&#x2F; 此代码模块中包含的函数的前向声明:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
&#123;
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    &#x2F;&#x2F; TODO: 在此处放置代码。

    &#x2F;&#x2F; 初始化全局字符串
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_WINDOWSPROJECT1, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    &#x2F;&#x2F; 执行应用程序初始化:
    if (!InitInstance (hInstance, nCmdShow))
    &#123;
        return FALSE;
    &#125;

    HACCEL hAccelTable &#x3D; LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSPROJECT1));

    MSG msg;

    &#x2F;&#x2F; 主消息循环:
    while (GetMessage(&amp;msg, nullptr, 0, 0))
    &#123;
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))
        &#123;
            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
        &#125;
    &#125;

    return (int) msg.wParam;
&#125;



&#x2F;&#x2F;
&#x2F;&#x2F;  函数: MyRegisterClass()
&#x2F;&#x2F;
&#x2F;&#x2F;  目标: 注册窗口类。
&#x2F;&#x2F;
ATOM MyRegisterClass(HINSTANCE hInstance)
&#123;
    WNDCLASSEXW wcex;

    wcex.cbSize &#x3D; sizeof(WNDCLASSEX);

    wcex.style          &#x3D; CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    &#x3D; WndProc;
    wcex.cbClsExtra     &#x3D; 0;
    wcex.cbWndExtra     &#x3D; 0;
    wcex.hInstance      &#x3D; hInstance;
    wcex.hIcon          &#x3D; LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));
    wcex.hCursor        &#x3D; LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  &#x3D; (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   &#x3D; MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1);
    wcex.lpszClassName  &#x3D; szWindowClass;
    wcex.hIconSm        &#x3D; LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassExW(&amp;wcex);
&#125;

&#x2F;&#x2F;
&#x2F;&#x2F;   函数: InitInstance(HINSTANCE, int)
&#x2F;&#x2F;
&#x2F;&#x2F;   目标: 保存实例句柄并创建主窗口
&#x2F;&#x2F;
&#x2F;&#x2F;   注释:
&#x2F;&#x2F;
&#x2F;&#x2F;        在此函数中，我们在全局变量中保存实例句柄并
&#x2F;&#x2F;        创建和显示主程序窗口。
&#x2F;&#x2F;
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
&#123;
   hInst &#x3D; hInstance; &#x2F;&#x2F; 将实例句柄存储在全局变量中

   HWND hWnd &#x3D; CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   &#123;
      return FALSE;
   &#125;

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
&#125;

&#x2F;&#x2F;
&#x2F;&#x2F;  函数: WndProc(HWND, UINT, WPARAM, LPARAM)
&#x2F;&#x2F;
&#x2F;&#x2F;  目标: 处理主窗口的消息。
&#x2F;&#x2F;
&#x2F;&#x2F;  WM_COMMAND  - 处理应用程序菜单
&#x2F;&#x2F;  WM_PAINT    - 绘制主窗口
&#x2F;&#x2F;  WM_DESTROY  - 发送退出消息并返回
&#x2F;&#x2F;
&#x2F;&#x2F;
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
&#123;
    switch (message)
    &#123;
    case WM_COMMAND:
        &#123;
            int wmId &#x3D; LOWORD(wParam);
            &#x2F;&#x2F; 分析菜单选择:
            switch (wmId)
            &#123;
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            &#125;
        &#125;
        break;
    case WM_PAINT:
        &#123;
            PAINTSTRUCT ps;
            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);
            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...
            EndPaint(hWnd, &amp;ps);
        &#125;
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    &#125;
    return 0;
&#125;

&#x2F;&#x2F; “关于”框的消息处理程序。
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
&#123;
    UNREFERENCED_PARAMETER(lParam);
    switch (message)
    &#123;
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) &#x3D;&#x3D; IDOK || LOWORD(wParam) &#x3D;&#x3D; IDCANCEL)
        &#123;
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        &#125;
        break;
    &#125;
    return (INT_PTR)FALSE;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这就是一个demo,下面我们使用手写的办法来写一个超级简化版本</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230519142819377.png?lastModify=1685936981" alt="image-20230519142819377"></p>
<p>​        基本原理</p>
<p>​        先看窗口：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct tagWNDCLASSEXW &#123;
    UINT        cbSize;
    &#x2F;* Win 3.x *&#x2F;
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
    &#x2F;* Win 4.0 *&#x2F;
    HICON       hIconSm;
&#125; WNDCLASSEXW, *PWNDCLASSEXW, NEAR *NPWNDCLASSEXW, FAR *LPWNDCLASSEXW;
#include&lt;Windows.h&gt;
#include&lt;tchar.h&gt;
HWND hwnd;
HINSTANCE hInst;
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) &#123;

	&#x2F;&#x2F;窗口
	WNDCLASSEX wcx;
	
	&#x2F;&#x2F;消息
	MSG msg;
	BOOL fGotMsg;
	wcx.cbSize &#x3D; sizeof(wcx);
	wcx.style &#x3D; CS_HREDRAW | CS_VREDRAW; &#x2F;&#x2F; 发生大小改变时再次绘制窗口
	wcx.lpszClassName &#x3D; L&quot;MainWndProc&quot;;
	wcx.lpfnWndProc &#x3D; MainWndProc;
	wcx.cbClsExtra &#x3D; 0;&#x2F;&#x2F; 不使用额外内存
	wcx.cbWndExtra &#x3D; 0;
	wcx.hInstance &#x3D; hInstance;
	wcx.hIcon &#x3D; LoadIcon(NULL,IDI_APPLICATION);
	wcx.hCursor &#x3D; LoadCursor(NULL, IDC_ARROW);
	wcx.hbrBackground &#x3D; (HBRUSH)GetStockObject(WHITE_BRUSH);
	wcx.lpszMenuName &#x3D; NULL;
	wcx.hIconSm &#x3D; (HICON)LoadImage(hInstance, 
		MAKEINTRESOURCE(5),
		IMAGE_ICON, 
		GetSystemMetrics(SM_CXSMICON),
		GetSystemMetrics(SM_CXSMICON),
		LR_DEFAULTCOLOR
	);
	&#x2F;&#x2F; 注册！在创建
	if (!RegisterClassEx(&amp;wcx)) &#123;
		return -1;
	&#125;
	TCHAR h1[] &#x3D; L&quot;hello&quot;;
	TCHAR h2[] &#x3D; L&quot;hello&quot;;
	hwnd &#x3D; CreateWindowEx(0, h1, h2, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, \
		CW_USEDEFAULT, 300, 180, NULL, NULL, hInstance, NULL);

	if (!hwnd) &#123;
		return GetLastError();
	&#125;

	ShowWindow(hwnd, nCmdShow);
	UpdateWindow(hwnd);&#x2F;&#x2F;提升优先级到最先

	&#x2F;&#x2F; 消息队列取消息
	while ((fGotMsg &#x3D; GetMessage(&amp;msg, (HWND)NULL, 0, 0))!&#x3D;0) &#123;
		TranslateMessage(&amp;msg); &#x2F;&#x2F; 一些消息需要翻译
		DispatchMessage(&amp;msg); &#x2F;&#x2F;转发消息给窗口过程
	&#125;

	return msg.wParam;
&#125;


&#x2F;&#x2F;
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
&#123;

	switch (uMsg) &#123;

	case WM_DESTROY:
		PostQuitMessage(0); &#x2F;&#x2F; 退出线程
		return 0;

	case WM_LBUTTONDOWN:
		MessageBox(hwnd, L&quot;hello&quot;, L&quot;hello&quot;, MB_OK);
		return 0;
	default:
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	&#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="系统3"><a href="#系统3" class="headerlink" title="系统3"></a>系统3</h2><p>在QT中，我们已经看到了生成一个对话框是容易的——但是现在，让我们把目光聚焦在基于Windows API的MFC下如何召唤一个对话框。</p>
<p>​        跟QT类似的——我们找到资源文件 》添加新建项 》 对话框，添加即可。</p>
<p>​        我们随后设计也界面 </p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230523195326640.png?lastModify=1685936981" alt="image-20230523195326640"></p>
<p>​        随便整点。</p>
<p>​        现在看看你的resource.h，多了四个宏：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;&#123;&#123;NO_DEPENDENCIES&#125;&#125;
&#x2F;&#x2F; Microsoft Visual C++ 生成的包含文件。
&#x2F;&#x2F; 供 Project2.rc 使用
&#x2F;&#x2F;
#define IDD_DIALOG1                     101
#define IDC_BUTTON1                     1001
#define IDC_BUTTON2                     1002
#define IDC_BUTTON3                     1003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        他们是我们操作之的接口。</p>
<p>​        下面开始写主函数的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">int APIENTRY WinMain(_In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nShowCmd) 
&#123;
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, MainDlgProc);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="APIEntry"><a href="#APIEntry" class="headerlink" title="APIEntry:"></a>APIEntry:</h2><pre class="line-numbers language-none"><code class="language-none">APIENTRY	系统函数的调用约定。
此类型在 WinDef.h 中声明，如下所示：
#define APIENTRY WINAPI<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        也就是说，它本质上时WINAPI的重定义与重命名。</p>
<h2 id="DialogBox"><a href="#DialogBox" class="headerlink" title="DialogBox"></a>DialogBox</h2><p>​        从对话框模板资源创建模式对话框。 在指定的回调函数通过调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> 函数终止模式对话框之前，<strong>DialogBox</strong> 不会返回控件。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">void DialogBoxA(
  [in, optional]  hInstance,
  [in]            lpTemplate,
  [in, optional]  hWndParent,
  [in, optional]  lpDialogFunc
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in, optional] hInstance<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>HINSTANCE</strong></p>
<p>包含对话框模板的模块的句柄。 如果此参数为 NULL，则使用当前可执行文件。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] lpTemplate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>LPCTSTR</strong></p>
<p>对话框模板。 此参数是指向指定对话框模板名称的以空字符结尾的字符串的指针，或者是指定对话框模板的资源标识符的整数值。 如果参数指定了资源标识符，则其高位字必须为零，其低位字必须包含该标识符。 你可以使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> 宏来创建此值。</p>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] hWndParent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型：<strong>HWND</strong></p>
<p>拥有对话框的窗口的句柄。</p>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] lpDialogFunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>DLGPROC</strong></p>
<p>指向对话框过程的指针。 有关对话框过程的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>。</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p><strong>DialogBox</strong> 宏使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> 函数创建对话框。 然后，如果模板指定对话框过程DS_SETFONT<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/dlgbox/about-dialog-boxes">或DS_SHELLFONT</a>样式) ，<strong>则 DialogBox</strong> 会发送<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/wm-setfont">消息 (</a>和WM_SETFONT消息。 该函数显示对话框 (，无论模板是否指定 <strong>WS_VISIBLE</strong> 样式) ，禁用所有者窗口，并启动其自己的消息循环来检索和调度对话框的消息。</p>
<p>当对话框过程调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> 函数时，<strong>DialogBox</strong> 将销毁对话框，结束消息循环，如果以前启用) ，则启用所有者窗口 (，并在调用 <strong>EndDialog</strong> 时返回对话框过程指定的 <em>nResult</em> 参数。</p>
<h2 id="MAKEINTERSOURCE"><a href="#MAKEINTERSOURCE" class="headerlink" title="MAKEINTERSOURCE"></a>MAKEINTERSOURCE</h2><p>VC的定义是(winuser.h):</p>
<pre class="line-numbers language-none"><code class="language-none">#define MAKEINTRESOURCEA(i) ([LPSTR](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;LPSTR&#x2F;9782867?fromModule&#x3D;lemma_inlink))((ULONG_PTR)((WORD)(i)))

#define MAKEINTRESOURCEW(i) (LPWSTR)((ULONG_PTR)((WORD)(i)))

#define MAKEINTRESOURCE MAKEINTRESOURCEW

#else

#define MAKEINTRESOURCE MAKEINTRESOURCEA

[#endif](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;%23endif&#x2F;2834688?fromModule&#x3D;lemma_inlink) &#x2F;&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用这个宏的主要原因是有的资源是用序号定义的,而不是字符串.所以要把数字转换成字符串<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/指针?fromModule=lemma_inlink">指针</a>,然后再传递给<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LoadResource/530202?fromModule=lemma_inlink">LoadResource</a>之类的函数,这样才加载了资源.</p>
<p>要释放资源(用LoadResource加载的)可以调用FreeResource函数把LoadResource返回的指针传递给FreeResource.</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>​        是把一个”数字形ID”,转化为”字符串”.但是执行前后,输入的数据的内容和长度是不变的!它只不过就是C语言里面”<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/强制类型转换/1580197?fromModule=lemma_inlink">强制类型转换</a>“而已.</p>
<p>​        请看 Winuser.h 代码:</p>
<pre class="line-numbers language-none"><code class="language-none">#define MAKEINTRESOURCEA(i) ([LPSTR](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;LPSTR&#x2F;9782867?fromModule&#x3D;lemma_inlink))(([DWORD](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;DWORD&#x2F;5043783?fromModule&#x3D;lemma_inlink))((WORD)(i)))

#define MAKEINTRESOURCEW(i) (LPWSTR)((DWORD)((WORD)(i)))

#define MAKEINTRESOURCE MAKEINTRESOURCEW

#else

#define MAKEINTRESOURCE MAKEINTRESOURCEA

[#endif](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;%23endif&#x2F;2834688?fromModule&#x3D;lemma_inlink) &#x2F;&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        的用法.就用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/FindResource/6375062?fromModule=lemma_inlink">FindResource</a>来说明.</p>
<pre class="line-numbers language-none"><code class="language-none">HRSRC FindResource(

HMODULE hModule, &#x2F;&#x2F; module handle

LPCTSTR lpName, &#x2F;&#x2F; resource name

LPCTSTR lpType &#x2F;&#x2F; resource type

);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        就是lpName参数需要使用MAKEINTRESOURCE ,因为它需要<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LPCTSTR/6495202?fromModule=lemma_inlink">LPCTSTR</a>类型的参数输入.那么,情况就很清楚了.凡涉及”资源”的API或者MFC类,在参数类型为LPCTSTR时,就应该使用 MAKEINTRESOURCE.这是针对”资源名字”为”数字类型”时的情况.</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;Windows.h&gt;
#include&quot;resource.h&quot;

INT_PTR CALLBACK MainDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) &#123;
    BOOL bRet &#x3D; TRUE;
    int usrChoice;
    switch (uMsg)
    &#123;

    case WM_LBUTTONDOWN:
        MessageBox(hDlg, L&quot;Hello!&quot;, L&quot;A Greeting&quot;, MB_OK);
    case WM_COMMAND:
        switch (LOWORD(wParam)) &#123;
        case IDC_BUTTON1:
            usrChoice &#x3D; MessageBox(hDlg, L&quot;I convinced that you push the button1&quot;, L&quot;A greeting&quot;, MB_OK);
            if (usrChoice &#x3D;&#x3D; MB_OK) &#123;
                bRet &#x3D; FALSE;
                break;
            &#125;
            break;

        case IDC_BUTTON2:
            usrChoice &#x3D; MessageBox(hDlg, L&quot;I convinced that you push the button2&quot;, L&quot;A greeting&quot;, MB_OK);
            if (usrChoice &#x3D;&#x3D; MB_OK) &#123;
                bRet &#x3D; FALSE;
                break;
            &#125;
            break;
        case IDC_BUTTON3:
            EndDialog(hDlg, 0);
            bRet &#x3D; FALSE;
            break;
        default:
            bRet &#x3D; FALSE;
            break;
        &#125;
        break;
    default:
        bRet &#x3D; FALSE;
        break;
    &#125;


    return bRet;
&#125;

int APIENTRY WinMain(_In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nShowCmd) 
&#123;
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, MainDlgProc);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个demo生成一个有趣的对话框，可以试试看。</p>
<h2 id="系统4"><a href="#系统4" class="headerlink" title="系统4"></a>系统4</h2><p>​        下面专门讲授<code>wchar_t</code>，他是宽字符的意思。</p>
<p>​        因为我们需要大量的输出中文，为了适配，我们常常使用<code>wchar_t</code></p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;

int main() &#123;

	char c &#x3D; &#39;A&#39;; &#x2F;&#x2F; 此类型在默认下只可以保存一个字节
	wchar_t c2 &#x3D; L&#39;牛&#39;; &#x2F;&#x2F; 现在就可以存下了。
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是这样还是会不认识，原因在于。。。</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;locale.h&gt;
int main() &#123;
	setlocale(LC_ALL, &quot;&quot;); &#x2F;&#x2F; 设置windows本地的编码

	char c &#x3D; &#39;A&#39;; &#x2F;&#x2F; 此类型在默认下只可以保存一个字节
	wchar_t c2 &#x3D; L&#39;牛&#39;; &#x2F;&#x2F; 现在就可以存下了。

	wprintf(L&quot;%c&quot;, c2);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230526205326835.png?lastModify=1685936981" alt="image-20230526205326835"></p>
<p>​        那如何查看当前的地域呢？</p>
<pre class="line-numbers language-none"><code class="language-none">printf(&quot;%s\n&quot;, setlocale(LC_ALL, NULL));
setlocale(LC_ALL, &quot;&quot;);
printf(&quot;%s\n&quot;, setlocale(LC_ALL, NULL));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230526205514732.png?lastModify=1685936981" alt="image-20230526205514732"></p>
<p>​        对于宽字符，我们有跟char一样配饰的各式各样的函数。这里不再做什么介绍了！</p>
<h2 id="三大版本的char类型"><a href="#三大版本的char类型" class="headerlink" title="三大版本的char类型"></a>三大版本的char类型</h2><p>​        在微软中，有三大类型——CHAR , WCHAR, TCHAR（ASCII，Unicode和通用版本）</p>
<p>​        随后还有字符串版本的PSTR PWSTR, PTSTR, PC(onst)STR PCWSTR, PCTSTR…</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;

int WINAPI WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nShowCmd
) 
&#123;
    CHAR a &#x3D; &#39;a&#39;;
    WCHAR b &#x3D; &#39;b&#39;;
    TCHAR c &#x3D; &#39;c&#39;;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        看到TCHAR是根据平台的字符集选择而发生变动！建议我们的编程使用Unicode字符集。</p>
<h2 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h2><p>​        下面来看字符转换——将多字节字符和宽字符。为了使得转换方便，我们需要使用：</p>
<h3 id="MultiByteToWideChar"><a href="#MultiByteToWideChar" class="headerlink" title="MultiByteToWideChar();"></a>MultiByteToWideChar();</h3><p>​        这个函数将字符串映射到 UTF-16 (宽字符) 字符串。 字符串不一定来自多字节字符集。</p>
<p>​        注意！错误地使用 <strong>MultiByteToWideChar</strong> 函数可能会损害应用程序的安全性。 调用此函数很容易导致缓冲区溢出，因为 <em>lpMultiByteStr</em> 指示的输入缓冲区的大小等于字符串中的字节数，而 <em>lpWideCharStr</em> 指示的输出缓冲区的大小等于字符数。 为了避免缓冲区溢出，应用程序必须指定适合缓冲区接收的数据类型的缓冲区大小。</p>
<p>​        ANSI 代码页在不同计算机上可能不同，也可以更改单个计算机，从而导致数据损坏。 为了获得最一致的结果，应用程序应使用 Unicode（如 UTF-8 或 UTF-16），而不是特定代码页，除非旧标准或数据格式阻止使用 Unicode。 如果无法使用 Unicode，应用程序应在协议允许时使用适当的编码名称标记数据流。 HTML 和 XML 文件允许标记，但文本文件不会。</p>
<h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">int MultiByteToWideChar(
  [in]            UINT                              CodePage,
  [in]            DWORD                             dwFlags,
  [in]            _In_NLS_string_(cbMultiByte)LPCCH lpMultiByteStr,
  [in]            int                               cbMultiByte,
  [out, optional] LPWSTR                            lpWideCharStr,
  [in]            int                               cchWideChar
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] CodePage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        用于执行转换的代码页。 此参数可以设置为在操作系统中安装或可用的任何代码页的值。 有关代码页的列表，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Intl/code-page-identifiers">代码页标识符</a>。 应用程序还可以指定下表中显示的值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>CP_ACP</strong></td>
<td style="text-align:left">系统默认的 Windows ANSI 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_MACCP</strong></td>
<td style="text-align:left">当前系统 Macintosh 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。 <strong>注意</strong> 此值主要用于旧代码，通常不需要，因为新式 Macintosh 计算机使用 Unicode 进行编码。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_OEMCP</strong></td>
<td style="text-align:left">当前系统 OEM 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_SYMBOL</strong></td>
<td style="text-align:left">符号代码页 (42) 。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_THREAD_ACP</strong></td>
<td style="text-align:left">当前线程的 Windows ANSI 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_UTF7</strong></td>
<td style="text-align:left">UTF-7。 仅当 7 位传输机制强制使用此值。 首选使用 UTF-8。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_UTF8</strong></td>
<td style="text-align:left">UTF-8。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[in] dwFlags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指示转换类型的标志。 应用程序可以指定以下值的组合，MB_PRECOMPOSED为默认值。 MB_PRECOMPOSED和MB_COMPOSITE互斥。 无论其他标志的状态如何，都可以设置MB_USEGLYPHCHARS和MB_ERR_INVALID_CHARS。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_COMPOSITE</strong></td>
<td style="text-align:left">始终使用分解字符，即基字符和一个或多个非分步字符各具有不同的代码点值。 例如，Ä 由 A + ー 表示：拉丁文大写字母 A (U+0041) + 组合 DIAERESIS (U+0308) 。 请注意，此标志不能与MB_PRECOMPOSED一起使用。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ERR_INVALID_CHARS</strong></td>
<td style="text-align:left">如果遇到无效的输入字符，则失败。从 Windows Vista 开始，如果应用程序未设置此标志，函数不会删除非法代码点，而是将非法序列替换为根据指定的代码页) 编码的 U+FFFD (。<strong>Windows 2000 SP4 及更高版本，Windows XP：</strong> 如果未设置此标志，函数将无提示删除非法代码点。 对 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 的调用返回ERROR_NO_UNICODE_TRANSLATION。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_PRECOMPOSED</strong></td>
<td style="text-align:left">默认;请勿与MB_COMPOSITE一起使用。 始终使用预编译字符，即具有基字符或非加速度字符组合的单个字符值。 例如，在字符 è 中，e 是基字符，重音符严重标记是非节奏字符。 如果为字符定义了单个 Unicode 码位，则应用程序应使用它而不是单独的基字符和非节奏字符。 例如，Ä 由单一 Unicode 码位 LATIN 大写字母 A WITH DIAERESIS (U+00C4) 表示。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_USEGLYPHCHARS</strong></td>
<td style="text-align:left">使用字形字符而不是控制字符。</td>
</tr>
</tbody>
</table>
</div>
<p>​        对于下面列出的代码页， <em>dwFlags</em> 必须设置为 0。 否则，函数将失败并ERROR_INVALID_FLAGS。50220，50221，50222，50225，50227，，50229，57002 到 57011，65000 (UTF-7)，42 (符号)</p>
<p>​        对于 UTF-8 或代码页 54936 (GB18030，从 Windows Vista) 开始， <em>dwFlags</em> 必须设置为 0 或MB_ERR_INVALID_CHARS。 否则，函数将失败并ERROR_INVALID_FLAGS。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] lpMultiByteStr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向要转换的字符串的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] cbMultiByte<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <em>lpMultiByteStr</em> 参数指示的字符串的大小（以字节为单位）。 或者，如果字符串以 null 结尾，则可以将此参数设置为 -1。 请注意，如果 <em>cbMultiByte</em> 为 0，函数将失败。</p>
<p>​        如果此参数为 -1，则该函数将处理整个输入字符串，包括终止 null 字符。 因此，生成的 Unicode 字符串具有终止 null 字符，函数返回的长度包括此字符。</p>
<p>​        如果此参数设置为正整数，则函数将完全处理指定的字节数。 如果提供的大小不包括终止 null 字符，则生成的 Unicode 字符串不会以 null 结尾，并且返回的长度不包括此字符。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpWideCharStr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收转换后的字符串的缓冲区的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] cchWideChar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <em>lpWideCharStr</em> 指示的缓冲区的大小（以字符为单位）。 如果此值为 0，则该函数将返回所需的缓冲区大小（以字符为单位，包括任何终止 null 字符）并且不使用 <em>lpWideCharStr</em> 缓冲区。</p>
<h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>​        返回写入缓冲区的字符数，如果成功，则返回 <em>由 lpWideCharStr</em> 指示的字符数。 如果函数成功且 <em>cchWideChar</em> 为 0，则返回值是 <em>lpWideCharStr</em> 指示的缓冲区所需的大小（以字符为单位）。 另请参阅 <em>dwFlags</em> ，了解输入无效序列时MB_ERR_INVALID_CHARS标志如何影响返回值的信息。</p>
<p>​        如果函数不成功，则返回 0。 若要获取扩展的错误信息，应用程序可以调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>，后者可以返回以下错误代码之一：</p>
<ul>
<li>ERROR_INSUFFICIENT_BUFFER。 提供的缓冲区大小不够大，或者错误地设置为 <strong>NULL</strong>。</li>
<li>ERROR_INVALID_FLAGS。 为标志提供的值无效。</li>
<li>ERROR_INVALID_PARAMETER。 任何参数值都无效。</li>
<li>ERROR_NO_UNICODE_TRANSLATION。 在字符串中找到无效的 Unicode。</li>
</ul>
<h4 id="注解-3"><a href="#注解-3" class="headerlink" title="注解"></a>注解</h4><p>​        此函数的默认行为是转换为输入字符串的预编译形式。 如果预编译的窗体不存在，该函数将尝试转换为复合窗体。</p>
<p>​        使用MB_PRECOMPOSED标志对大多数代码页的影响很小，因为大多数输入数据已经组成。 考虑使用 <strong>MultiByteToWideChar</strong> 进行转换后调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnls/nf-winnls-normalizestring">NormalizeString</a>。 <strong>NormalizeString</strong> 提供更准确、标准和一致的数据，还可以更快。 请注意，对于传递给 <strong>NormalizeString</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnls/ne-winnls-norm_form">的NORM_FORM</a>枚举，NormalizationC 对应于MB_PRECOMPOSED，NormalizationD 对应于MB_COMPOSITE。</p>
<p>​        如上述警告中所述，如果未首先使用 <em>cchWideChar</em> 设置为 0 调用此函数，则输出缓冲区很容易溢出，以获取所需的大小。 如果使用MB_COMPOSITE标志，则每个输入字符的输出长度可以为三个或多个字符。</p>
<p>​        <em>lpMultiByteStr</em> 和 <em>lpWideCharStr</em> 指针不能相同。 如果它们相同，函数将失败， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回值ERROR_INVALID_PARAMETER。</p>
<p>​        如果显式指定输入字符串长度而不终止 null 字符，<strong>则 MultiByteToWideChar</strong> 不会终止输出字符串。 若要为此函数终止输出字符串，应用程序应传入 -1 或显式计算输入字符串的终止 null 字符。</p>
<p>​        如果设置了MB_ERR_INVALID_CHARS并且源字符串中遇到无效字符，则函数将失败。 无效字符为下列字符之一：</p>
<ul>
<li>不是源字符串中默认字符的字符，但在未设置MB_ERR_INVALID_CHARS时转换为默认字符</li>
<li>对于 DBCS 字符串，具有前导字节但没有有效尾随字节的字符</li>
</ul>
<p>​        从 Windows Vista 开始，此函数完全符合 UTF-8 和 UTF-16 的 Unicode 4.1 规范。 在早期操作系统上使用的函数编码或解码孤独 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Intl/surrogates-and-supplementary-characters">代理项半</a> 部分或不匹配的代理项对。 在早期版本的 Windows 中编写的代码，这些代码依赖于此行为对随机非文本二进制数据进行编码可能会遇到问题。 但是，在有效的 UTF-8 字符串上使用此函数的代码的行为方式与早期 Windows 操作系统相同。</p>
<p>​        <strong>Windowsxp：</strong> 为了防止 UTF-8 字符的非最短格式版本的安全问题， <strong>MultiByteToWideChar</strong> 会删除这些字符。</p>
<p>​        <strong>从 Windows 8 开始：</strong>MultiByteToWideChar 在 Stringapiset.h 中声明。 在Windows 8之前，它在 Winnls.h 中声明。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-none"><code class="language-none">catch (std::exception e)
&#123;
    &#x2F;&#x2F; Save in-memory logging buffer to a log file on error.

    ::std::wstring wideWhat;
    if (e.what() !&#x3D; nullptr)
    &#123;
        int convertResult &#x3D; MultiByteToWideChar(CP_UTF8, 0, e.what(), (int)strlen(e.what()), NULL, 0);
        if (convertResult &lt;&#x3D; 0)
        &#123;
            wideWhat &#x3D; L&quot;Exception occurred: Failure to convert its message text using MultiByteToWideChar: convertResult&#x3D;&quot;;
            wideWhat +&#x3D; convertResult.ToString()-&gt;Data();
            wideWhat +&#x3D; L&quot;  GetLastError()&#x3D;&quot;;
            wideWhat +&#x3D; GetLastError().ToString()-&gt;Data();
        &#125;
        else
        &#123;
            wideWhat.resize(convertResult + 10);
            convertResult &#x3D; MultiByteToWideChar(CP_UTF8, 0, e.what(), (int)strlen(e.what()), &amp;wideWhat[0], (int)wideWhat.size());
            if (convertResult &lt;&#x3D; 0)
            &#123;
                wideWhat &#x3D; L&quot;Exception occurred: Failure to convert its message text using MultiByteToWideChar: convertResult&#x3D;&quot;;
                wideWhat +&#x3D; convertResult.ToString()-&gt;Data();
                wideWhat +&#x3D; L&quot;  GetLastError()&#x3D;&quot;;
                wideWhat +&#x3D; GetLastError().ToString()-&gt;Data();
            &#125;
            else
            &#123;
                wideWhat.insert(0, L&quot;Exception occurred: &quot;);
            &#125;
        &#125;
    &#125;
    else
    &#123;
        wideWhat &#x3D; L&quot;Exception occurred: Unknown.&quot;;
    &#125;

    Platform::String^ errorMessage &#x3D; ref new Platform::String(wideWhat.c_str());
    &#x2F;&#x2F; The session added the channel at level Warning. Log the message at
    &#x2F;&#x2F; level Error which is above (more critical than) Warning, which
    &#x2F;&#x2F; means it will actually get logged.
    _channel-&gt;LogMessage(errorMessage, LoggingLevel::Error);
    SaveLogInMemoryToFileAsync().then([&#x3D;](StorageFile^ logFile) &#123;
        _logFileGeneratedCount++;
        StatusChanged(this, ref new LoggingScenarioEventArgs(LoggingScenarioEventType::LogFileGenerated, logFile-&gt;Path-&gt;Data()));
    &#125;).wait();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="WideCharToMultiByte"><a href="#WideCharToMultiByte" class="headerlink" title="WideCharToMultiByte"></a>WideCharToMultiByte</h3><p>传送门：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/vranger/p/3793123.html">函数WideCharToMultiByte（） 详解 - vranger - 博客园 (cnblogs.com)</a></p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><pre class="line-numbers language-none"><code class="language-none">int WideCharToMultiByte( 

UINT CodePage,  

DWORD dwFlags,  

LPWSTR lpWideCharStr,  

int cchWideChar,  

LPCSTR lpMultiByteStr,  

int cchMultiByte,  

LPCSTR lpDefaultChar,  

PBOOL pfUsedDefaultChar 

);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>函数功能：</strong></p>
<p>此函数把宽字符串转换成指定的新的字符串，如ANSI，UTF8等，新字符串不必是多字节字符集。 </p>
<p>(—-Unicode 转 ANSI(GB2312)，UTF8) </p>
<p><strong>参数：</strong></p>
<ul>
<li>CodePage：指定执行转换的代码页，这个参数可以为系统已安装或有效的任何代码页所给定的值。</li>
</ul>
<p>你也可以指定其为下面的任意一值：</p>
<p> (我想最常用的应该是CP_ACP和CP_UTF8了，前者将宽字符转 换为ANSI，后者转换为UTF8。 ) </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>CP_ACP</th>
<th>当前系统ANSI代码页</th>
</tr>
</thead>
<tbody>
<tr>
<td>CP_MACCP</td>
<td>当前系统Macintosh代码页</td>
</tr>
<tr>
<td>CP_OEMCP</td>
<td>当前系统OEM代码页，一种原始设备制造商硬件扫描码</td>
</tr>
<tr>
<td>CP_SYMBOL</td>
<td>符号代码页（42）</td>
</tr>
<tr>
<td>CP_THREAD_ACP</td>
<td>当前线程ANSI代码页</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>dwFlags：指定如何处理没有转换的字符，但不设此参数函数会运行的更快一些，我都是把它设为0。</li>
</ul>
<p>可设的值如下表所示：</p>
<pre class="line-numbers language-none"><code class="language-none">WC_NO_BEST_FIT_CHARS 
把不能直接转换成相应多字节字符的Unicode字符转换成lpDefaultChar指定的默认字符。也就是说，如果把Unicode转换成多字节字符，然后再转换回来，你并不一定得到相同的Unicode字符，因为这期间可能使用了默认字符。此选项可以单独使用，也可以和其他选项一起使用。

WC_COMPOSITECHECK 
把合成字符转换成预制的字符。它可以与后三个选项中的任何一个组合使用，如果没有与他们中的任何一个组合，则与选项WC_SEPCHARS相同。

WC_ERR_INVALID_CHARS 
此选项会致使函数遇到无效字符时失败返回，并且GetLastError会返回错误码ERROR_NO_UNICODE_TRANSLATION。否则函数会自动丢弃非法字符。此选项只能用于UTF8。

WC_DISCARDNS    
  转换时丢弃不占空间的字符，与WC_COMPOSITECHECK 一起使用

WC_SEPCHARS
 转换时产生单独的字符，此是默认转换选项，WC_COMPOSITECHECK一起使用

WC_DEFAULTCHAR
 转换时使用默认字符代替例外的字符，(最常见的如’?’)，与WC_COMPOSITECHECK一起使用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <em>注意：当指定WC_COMPOSITECHECK时，函数会将合成字符转换成预制字符。合成字符由一个基字符和一个不占空间的字符(如欧洲国家及汉语拼音的音标)组成，</em></p>
<p><em>每一个都有不同的字符值。预制字符有一个用于表示基字符和不占空间字符的合成体的单一的字符值。</em></p>
<p><em>当指定WC_COMPOSITECHECK选项时，也可以使用上表列出的最后3个选项来定制预制字符的转换规则。这些选项决定了函数在遇到宽字符串的合成字符没有对</em></p>
<p><em>应的预制字符时的行为，他们与WC_COMPOSITECHECK一起使用，如果都没有指定，函数默认WC_SEPCHARS。</em> <em>对于下列代码页，dwFlags必须为0，否则函数返回错误码ERROR_INVALID_FLAGS。</em> <em>50220 50221 50222 50225 50227 50229 52936 54936 57002到57011 65000(UTF7) 42(Symbol)</em> <em>对于UTF8，dwFlags必须为0或WC_ERR_INVALID_CHARS，否则函数都将失败返回并设置错误码ERROR_INVALID_FLAGS，你可以调用GetLastError获得。</em></p>
<ul>
<li>lpWideCharStr： 待转换的宽字符串。</li>
</ul>
<ul>
<li>cchWideChar： 待转换宽字符串的长度，-1表示转换到字符串结尾。</li>
</ul>
<ul>
<li>lpMultiByteStr： 接收转换后输出新串的缓冲区。</li>
</ul>
<ul>
<li>cbMultiByte：输出缓冲区大小，如果为0，lpMultiByteStr将被忽略，函数将返回所需缓冲区大小而不使用lpMultiByteStr。</li>
</ul>
<ul>
<li>lpDefaultChar： 指向字符的指针， 在指定编码里找不到相应字符时使用此字符作为默认字符代替。如果为NULL则使用系统默认字符。对于要求此参数为NULL的dwFlags而使用此参数，函数将失败返回并设置错误码ERROR_INVALID_PARAMETER。</li>
</ul>
<ul>
<li>lpUsedDefaultChar：开关变量的指针，用以表明是否使用过默认字符。对于要求此参数为NULL的dwFlags而使用此参数，函数将失败返回并设置错误码ERROR_INVALID_PARAMETER。lpDefaultChar和lpUsedDefaultChar都设为NULL，函数会更快一些。</li>
</ul>
<ul>
<li>返回值：如果函数成功，且cbMultiByte非0，返回写入lpMultiByteStr的字节数(包括字符串结尾的null)；cbMultiByte为0，则返回转换所需字节数。函数失败，返回0。</li>
</ul>
<p>​        注意：函数WideCharToMultiByte使用不当，会给影响程序的安全。调用此函数会很容易导致内存泄漏，因为lpWideCharStr指向的输入缓冲区大小是宽字符数，而lpMultiByteStr指向的输出缓冲区大小是字节数。为了避免内存泄漏，应确保为输出缓冲区指定合适的大小。我的方法是先使cbMultiByte为0调用WideCharToMultiByte一次以获得所需缓冲区大小，为缓冲区分配空间，然后再次调用WideCharToMultiByte填充缓冲区，详见下面的代码。另外，从Unicode UTF16向非Unicode字符集转换可能会导致数据丢失，因为该字符集可能无法找到表示特定Unicode数据的字符。</p>
<h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><pre class="line-numbers language-none"><code class="language-none">wchar_t* pwszUnicode &#x3D; L&quot;Holle, word! 你好，中国！ &quot;;
int iSize;
char* pszMultiByte;

iSize &#x3D; WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, NULL, 0, NULL, NULL);
pszMultiByte &#x3D; (char*)malloc(iSize*sizeof(char));
WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, pszMultiByte, iSize, NULL, NULL);
#include&lt;stdio.h&gt;
#include&lt;Windows.h&gt;
#include&lt;locale.h&gt;

int main() &#123;

	DWORD dwNum &#x3D; 0;

	setlocale(LC_ALL, &quot;&quot;);

	char sText[] &#x3D; &quot;多字节转换为宽字符&quot;;

	&#x2F;&#x2F; 问题来了，我们给多少空间呢？
	&#x2F;*1. from ASCII 2. a control flag, we usually have no need of that3.what str 4. transform ALL 5.to where(here we don&#39;t want to get result), final: tha space that contain*&#x2F;
	dwNum &#x3D; MultiByteToWideChar(CP_ACP, 0, sText, -1, NULL, 0);

	WCHAR* pwText &#x3D; (WCHAR)malloc(sizeof(WCHAR) * dwNum*2);
	if (pwText &#x3D;&#x3D; NULL) &#123;
		free(pwText);
		return 1;
	&#125;
	MultiByteToWideChar(CP_ACP, 0, sText, -1, pwText, dwNum);
	wprintf(L&quot;M-&gt;W:%s&quot;, pwText);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="系统5"><a href="#系统5" class="headerlink" title="系统5"></a>系统5</h2><h2 id="遍历卷-GetLogicalDriveStrings"><a href="#遍历卷-GetLogicalDriveStrings" class="headerlink" title="遍历卷 GetLogicalDriveStrings"></a>遍历卷 GetLogicalDriveStrings</h2><p>​        一个卷也叫做逻辑驱动器，或者叫盘！这是一个基本的概念。</p>
<p>​        注意到它一次性返回的是若干的字字符串：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230528180359422.png?lastModify=1685936981" alt="image-20230528180359422"></p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define BFSIZE 1024

int main()
&#123;
	WCHAR szLogicalDriveString[BFSIZE];
	PWCHAR szDrive;
	ZeroMemory(szLogicalDriveString, BFSIZE);&#x2F;&#x2F;清空内存
	szDrive &#x3D; szLogicalDriveString;
	GetLogicalDriveStrings(BFSIZE - 1, szLogicalDriveString);

	do &#123;
		printf(&quot;%s\n&quot;, szDrive);
		szDrive +&#x3D; (lstrlen(szDrive)+1);
	&#125; while (*szDrive !&#x3D; &#39;\0&#39;);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="查看第一个卷"><a href="#查看第一个卷" class="headerlink" title="查看第一个卷"></a>查看第一个卷</h2><p>​        我们可以使用<code>FindFirstVolume</code>这个函数的设备名称</p>
<pre class="line-numbers language-none"><code class="language-none">TCHAR buf[BFSIZE];
	HANDLE hVol;
	BOOL bFlag; &#x2F;&#x2F; as to see if the function work well
	hVol &#x3D; FindFirstVolume(buf, BFSIZE);
	if (hVol &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;
		wprintf(TEXT(&quot;NO... Volumn has&#39;t been find!&quot;));
		return -1;
	&#125;

printf(&quot;%ls\n&quot;, buf);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230528181002554.png?lastModify=1685936981" alt="image-20230528181002554"></p>
<p>​        这是驱动设备的真正名称，他是唯一的标识符。</p>
<p>​        使用<code>FindNextVolume</code>来找到下一个：</p>
<pre class="line-numbers language-none"><code class="language-none">TCHAR buf[BFSIZE];
HANDLE hVol;
BOOL bFlag; &#x2F;&#x2F; as to see if the function work well
hVol &#x3D; FindFirstVolume(buf, BFSIZE);
if (hVol &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;
	wprintf(TEXT(&quot;NO... Volumn has&#39;t been find!&quot;));
	return -1;
&#125;
printf(&quot;%ls\n&quot;, buf);
while (FindNextVolume(hVol, buf, BFSIZE)) &#123;
	printf(&quot;%ls\n&quot;, buf);
&#125;

bFlag &#x3D; FindVolumeClose(hVol);

return bFlag;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230528181246288.png?lastModify=1685936981" alt="image-20230528181246288"></p>
<h2 id="Extensive-Reading-for-Microsoft-API"><a href="#Extensive-Reading-for-Microsoft-API" class="headerlink" title="Extensive Reading for Microsoft API"></a>Extensive Reading for Microsoft API</h2><h3 id="ZeroMemory-宏-wdm-h"><a href="#ZeroMemory-宏-wdm-h" class="headerlink" title="ZeroMemory 宏 (wdm.h)"></a>ZeroMemory 宏 (wdm.h)</h3><p>​        <strong>ZeroMemory</strong> 例程使用零填充内存块，给定指向块的指针和要填充的长度（以字节为单位）。</p>
<h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">void RtlZeroMemory(
   void*  Destination,
   size_t Length
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] Destination<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>指向要用零填充的内存块的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] Length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要用零填充的字节数。</p>
<h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>无</p>
<h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h4><p>​        若要将内存缓冲区归零以擦除安全敏感数据，请改用SecureZeroMemory</p>
<p>​        如果目标内存块位于非分页系统内存中， <strong>ZeroMemory</strong> 的调用方可以在任何 IRQL 上运行。 否则，调用方必须在 IRQL &lt;= APC_LEVEL 运行。</p>
<h4 id="本质上"><a href="#本质上" class="headerlink" title="本质上"></a>本质上</h4><pre class="line-numbers language-none"><code class="language-none">memset((Destination),0,(Length))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="getLogicalDriveStrings函数-fileapi-h"><a href="#getLogicalDriveStrings函数-fileapi-h" class="headerlink" title="getLogicalDriveStrings函数 (fileapi.h)"></a>getLogicalDriveStrings函数 (fileapi.h)</h3><p>​        用指定系统中有效驱动器的字符串填充缓冲区。</p>
<h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">DWORD GetLogicalDriveStrings(
  [in]  DWORD  nBufferLength,
  [out] LPWSTR lpBuffer
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] nBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>TCHAR</strong> 中<em>由 lpBuffer</em> 指向的缓冲区的最大大小。 此大小不包括终止 null 字符。 如果此参数为零，则不使用 <em>lpBuffer</em> 。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向一个缓冲区的指针，该缓冲区接收一系列以 null 结尾的字符串，一个用于系统中每个有效驱动器，另外还有一个 null 字符。 每个字符串都是设备名称。</p>
<h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是复制到缓冲区的字符串的长度（以字符为单位），不包括终止 null 字符。 请注意，ANSI-ASCII null 字符使用一个字节，但 Unicode (UTF-16) null 字符使用两个字节。</p>
<p>​        如果缓冲区不够大，则返回值大于 <em>nBufferLength</em>。 它是保存驱动器字符串所需的缓冲区大小。</p>
<p>​        如果函数失败，则返回值为零。 若要获取扩展的错误信息，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数。</p>
<h2 id="注解-4"><a href="#注解-4" class="headerlink" title="注解"></a>注解</h2><p>​        无论需要根目录（例如 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdrivetypea">GetDriveType</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> 函数），缓冲区中的每个字符串都可以使用。</p>
<p>​        此函数返回全局和本地 MS-DOS 设备命名空间中的驱动器串联。 如果这两个命名空间中都存在驱动器，此函数将返回本地 MS-DOS 设备命名空间中的条目。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/defining-an-ms-dos-device-name">定义 MS DOS 设备名称</a>。</p>
<p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">技术</th>
<th style="text-align:left">支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">群集共享卷文件系统 (CsvFS)</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">弹性文件系统 (ReFS)</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
</div>
<p>​        SMB 不支持卷管理功能。</p>
<h3 id="FindFirstVolume-函数-fileapi-h"><a href="#FindFirstVolume-函数-fileapi-h" class="headerlink" title="FindFirstVolume 函数 (fileapi.h)"></a>FindFirstVolume 函数 (fileapi.h)</h3><p>​        检索计算机上的卷的名称。 <strong>FindFirstVolume</strong> 用于开始扫描计算机的卷。</p>
<h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">HANDLE FindFirstVolume(
  [out] LPWSTR lpszVolumeName,
  [in]  DWORD  cchBufferLength
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] lpszVolumeName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收空终止字符串的缓冲区的指针，该字符串指定找到的第一个卷的卷 <strong>GUID</strong> 路径。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] cchBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        要在 <strong>TCHAR</strong> 中接收卷 <strong>GUID</strong> 路径的缓冲区的长度。</p>
<h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是随后调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数时使用的搜索句柄。</p>
<p>​        如果函数找不到任何卷，则返回值为 <strong>INVALID_HANDLE_VALUE</strong> 错误代码。 要获得更多的错误信息，请调用 GetLastError。</p>
<h4 id="注解-5"><a href="#注解-5" class="headerlink" title="注解"></a>注解</h4><p>​        <strong>FindFirstVolume</strong> 函数打开卷搜索句柄，并返回有关计算机上找到的第一个卷的信息。 建立搜索句柄后，可以使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> 函数搜索其他卷。 不再需要搜索句柄时，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数将其关闭。</p>
<p>​        不应假定这些函数返回的卷的顺序与计算机上的卷顺序之间存在任何关联。 具体而言，如果) 或磁盘管理员，则不要假定由 BIOS (分配的卷顺序和驱动器号之间的任何关联。</p>
<p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">技术</th>
<th style="text-align:left">支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">群集共享卷文件系统 (CsvFS)</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">弹性文件系统 (ReFS)</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
</div>
<p>​        SMB 不支持卷管理功能。</p>
<h3 id="FindNextVolume-函数-fileapi-h"><a href="#FindNextVolume-函数-fileapi-h" class="headerlink" title="FindNextVolume 函数 (fileapi.h)"></a>FindNextVolume 函数 (fileapi.h)</h3><p>继续通过调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 函数开始的卷搜索。 <strong>FindNextVolume</strong> 为每个调用查找一个卷。</p>
<h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">BOOL FindNextVolume(
  [in]  HANDLE hFindVolume,
  [out] LPWSTR lpszVolumeName,
  [in]  DWORD  cchBufferLength
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] hFindVolume<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        上一次调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 函数返回的卷搜索句柄。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpszVolumeName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收找到的卷 <strong>GUID</strong> 路径的字符串的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] cchBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        接收卷 <strong>GUID</strong> 路径的缓冲区的长度（以 <strong>TCHAR</strong> 为单位）。</p>
<h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。 如果未找到匹配的文件， <strong>GetLastError</strong> 函数将返回 <strong>ERROR_NO_MORE_FILES</strong> 错误代码。 在这种情况下，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数关闭搜索。</p>
<h4 id="注解-6"><a href="#注解-6" class="headerlink" title="注解"></a>注解</h4><p>​        通过调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 建立搜索句柄后，可以使用 <strong>FindNextVolume</strong> 函数搜索其他卷。</p>
<p>​        不应假定这些函数返回的卷的顺序与计算机上的卷顺序之间存在任何关联。 具体而言，如果存在任何) 或磁盘管理员，则不要假定 BIOS (分配的卷顺序和驱动器号之间的任何关联。</p>
<p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">技术</th>
<th style="text-align:left">支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">群集共享卷文件系统 (CsvFS)</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">弹性文件系统 (ReFS)</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
</div>
<p>​        SMB 不支持卷管理功能。</p>
<h2 id="查看驱动器属性-GetDriverType-amp-amp-GetVolumeInformation"><a href="#查看驱动器属性-GetDriverType-amp-amp-GetVolumeInformation" class="headerlink" title="查看驱动器属性 GetDriverType &amp;&amp; GetVolumeInformation"></a>查看驱动器属性 GetDriverType &amp;&amp; GetVolumeInformation</h2><p>​        我们在盘上右键查看属性。</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230528182104767.png?lastModify=1685936981" alt="image-20230528182104767"></p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
BOOL GetDriverInfo(LPSTR szDriver) &#123;

	UINT uDriverType &#x3D; GetDriveType(szDriver);
	printf(&quot;%u&quot;, uDriverType);

	return TRUE;
&#125;

int main()
&#123;
	GetDriverInfo(TEXT(&quot;c:\\&quot;));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230528182835061.png?lastModify=1685936981" alt="image-20230528182835061"></p>
<p>​        有自己的特殊含义！在<code>WinBase.h</code>文件下</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230528184406835.png?lastModify=1685936981" alt="image-20230528184406835"></p>
<pre class="line-numbers language-none"><code class="language-none">#define DRIVE_UNKNOWN     0
#define DRIVE_NO_ROOT_DIR 1
#define DRIVE_REMOVABLE   2
#define DRIVE_FIXED       3
#define DRIVE_REMOTE      4
#define DRIVE_CDROM       5
#define DRIVE_RAMDISK     6
	正是如此！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下面是给出详细信息的：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;

BOOL GetDriverInfo(LPSTR szDriver) &#123;

	UINT uDriverType &#x3D; GetDriveType(szDriver);
	printf(&quot;%ls,the type is %u\n&quot;,szDriver, uDriverType);
	switch (uDriverType) &#123;
	case DRIVE_UNKNOWN: &#123;
		printf(&quot;can&#39;t get the driver type&quot;);
		break;
	&#125;
	case DRIVE_NO_ROOT_DIR: &#123;
		printf(&quot;the root path is invalid&quot;);
		break;
	&#125;
	case DRIVE_REMOVABLE:
	&#123;
		printf(&quot;the driver can be removed!&quot;);
		break;
	&#125;
	case DRIVE_FIXED :
	&#123;
		printf(&quot;this is a type that cannot move!&quot;);
		break;
	&#125;
	case DRIVE_REMOTE:
	&#123;
		printf(&quot;the driver is a remote drive!&quot;);
		break;
	&#125;
	case DRIVE_CDROM:
	&#123;
		printf(&quot;the driver is a CD-ROM!&quot;);
		break;
	&#125;
	case DRIVE_RAMDISK:
	&#123;
		printf(&quot;The driver is a RAM disk!&quot;);
		break;
	&#125;
	default:
		break;
	&#125;
	printf(&quot;\n&quot;);

	&#x2F;&#x2F; For more Information
	&#x2F;&#x2F; 
	&#x2F;&#x2F; need to get Some val
	WCHAR szDriverName[MAX_PATH];
	DWORD dwVolumeSerialNumber;
	DWORD dwMaxComponentLength;
	DWORD dwFileSystemFlags;
	WCHAR szFileSystemNameBuffer[MAX_PATH];
	if (!GetVolumeInformation(
		szDriver,
		szDriverName,
		MAX_PATH,
		&amp;dwVolumeSerialNumber,
		&amp;dwMaxComponentLength,
		&amp;dwFileSystemFlags,
		szFileSystemNameBuffer,
		MAX_PATH
	)) &#123;
		return FALSE;
	&#125;

	if (lstrlen(szDriverName)) &#123;
		printf(&quot;\nDriverName is %ls\n&quot;, szDriverName);
	&#125;

	printf(&quot;Volumn Serial Number is %u\n&quot;, dwVolumeSerialNumber);
	printf(&quot;Maxinum Component Length is %u&quot;, dwMaxComponentLength);
	printf(&quot;Systems Type:%ls&quot;, szFileSystemNameBuffer);
	if (dwFileSystemFlags &amp; FILE_VOLUME_QUOTAS) &#123;&#x2F;&#x2F; 可以看到这是要求位判断
		printf(&quot;the file system does support the QUOTAS&quot;);
	&#125;
	&#x2F;&#x2F;...
	return TRUE;
&#125;



int main()
&#123;
	GetDriverInfo(TEXT(&quot;c:\\&quot;));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Extensive-Reading-for-Microsoft-API-1"><a href="#Extensive-Reading-for-Microsoft-API-1" class="headerlink" title="Extensive Reading for Microsoft API"></a>Extensive Reading for Microsoft API</h2><h3 id="getDriveType-函数-fileapi-h"><a href="#getDriveType-函数-fileapi-h" class="headerlink" title="getDriveType 函数 (fileapi.h)"></a>getDriveType 函数 (fileapi.h)</h3><p>​        确定磁盘驱动器是可移动的、固定的、CD-ROM、RAM 磁盘还是网络驱动器。</p>
<p>​        若要确定驱动器是否为 USB 类型驱动器，请调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceregistrypropertya">SetupDiGetDeviceRegistryProperty</a> 并指定 <strong>SPDRP_REMOVAL_POLICY</strong> 属性。</p>
<h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">UINT GetDriveTypeW(
  [in, optional] LPCWSTR lpRootPathName
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        驱动器的根目录。</p>
<p>​        需要尾随反斜杠。 如果此参数为 <strong>NULL</strong>，则该函数使用当前目录的根目录。</p>
<h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>​        返回值指定驱动器的类型，可以是下列值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">返回代码/值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>DRIVE_UNKNOWN</strong>0</td>
<td style="text-align:left">无法确定驱动器类型。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_NO_ROOT_DIR</strong>1</td>
<td style="text-align:left">根路径无效;例如，在指定路径上没有装载卷。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_REMOVABLE</strong>2</td>
<td style="text-align:left">驱动器具有可移动媒体;例如，软盘驱动器、拇指驱动器或闪存卡读取器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_FIXED</strong>3</td>
<td style="text-align:left">驱动器具有固定媒体;例如，硬盘驱动器或闪存驱动器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_REMOTE</strong>4</td>
<td style="text-align:left">驱动器是远程 (网络) 驱动器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_CDROM</strong>5</td>
<td style="text-align:left">驱动器是 CD-ROM 驱动器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_RAMDISK</strong>6</td>
<td style="text-align:left">驱动器是一个 RAM 磁盘。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="getVolumeInformationW-函数-fileapi-h"><a href="#getVolumeInformationW-函数-fileapi-h" class="headerlink" title="getVolumeInformationW 函数 (fileapi.h)"></a>getVolumeInformationW 函数 (fileapi.h)</h3><p>​        检索与指定根目录关联的文件系统和卷的相关信息。</p>
<p>​        若要在检索此信息时指定句柄，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationbyhandlew">GetVolumeInformationByHandleW</a> 函数。</p>
<p>​        若要检索文件或目录的当前压缩状态，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>。</p>
<h4 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">BOOL GetVolumeInformationW(
  [in, optional]  LPCWSTR lpRootPathName,
  [out, optional] LPWSTR  lpVolumeNameBuffer,
  [in]            DWORD   nVolumeNameSize,
  [out, optional] LPDWORD lpVolumeSerialNumber,
  [out, optional] LPDWORD lpMaximumComponentLength,
  [out, optional] LPDWORD lpFileSystemFlags,
  [out, optional] LPWSTR  lpFileSystemNameBuffer,
  [in]            DWORD   nFileSystemNameSize
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向包含要描述的卷的根目录的字符串的指针。</p>
<p>​        如果此参数为 <strong>NULL</strong>，则使用当前目录的根目录。 尾随反斜杠是必需的。 例如，将 \MyServer\MyShare 指定为“\MyServer\MyShare\”，或将 C 驱动器指定为“C：\”。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpVolumeNameBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收指定卷名称的缓冲区的指针。 缓冲区大小由 <em>nVolumeNameSize</em> 参数指定。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] nVolumeNameSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        卷名称缓冲区的长度（以 <strong>TCHAR 为单位</strong>）。 最大缓冲区大小为 <strong>MAX_PATH</strong>+1。</p>
<p>​        如果未提供卷名缓冲区，则忽略此参数。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpVolumeSerialNumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收卷序列号的变量的指针。</p>
<p>​        如果不需要序列号，此参数可以为 <strong>NULL</strong> 。</p>
<p>​        此函数返回格式化硬盘时操作系统分配的卷序列号。 若要以编程方式获取制造商分配的硬盘序列号，请使用 Windows Management Instrumentation (WMI) <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a> 属性 <strong>SerialNumber</strong>。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpMaximumComponentLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向变量的指针，该变量接收指定文件系统支持的文件名组件的最大长度（以 <strong>TCHAR 为单位</strong>）。</p>
<p>​        文件名组件是文件名在反斜杠之间的部分。</p>
<p>​        存储在 <em>*lpMaximumComponentLength</em> 指向的变量中的值用于指示指定的文件系统支持长名称。 例如，对于支持长名称的 FAT 文件系统，函数存储值 255，而不是以前的 8.3 指示器。 使用 NTFS 文件系统的系统上也支持长名称。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFileSystemFlags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收与指定文件系统关联的标志的变量的指针。</p>
<p>​        此参数可以是以下一个或多个标志。 但是， <strong>FILE_FILE_COMPRESSION</strong> 和 <strong>FILE_VOL_IS_COMPRESSED</strong> 是相互排斥的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>FILE_CASE_SENSITIVE_SEARCH</strong> 0x00000001</td>
<td style="text-align:left">指定的卷支持区分大小写的文件名。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_CASE_PRESERVED_NAMES</strong> 0x00000002</td>
<td style="text-align:left">指定的卷支持在磁盘上放置名称时保留文件名大小写。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_UNICODE_ON_DISK</strong> 0x00000004</td>
<td style="text-align:left">指定的卷支持在磁盘上显示的文件名中的 Unicode。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_PERSISTENT_ACLS</strong> 0x00000008</td>
<td style="text-align:left">指定的卷保留并强制实施访问控制列表 (ACL) 。 例如，NTFS 文件系统保留并强制实施 ACL，而 FAT 文件系统则不这样做。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FILE_COMPRESSION</strong> 0x00000010</td>
<td style="text-align:left">指定的卷支持基于文件的压缩。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_VOLUME_QUOTAS</strong> 0x00000020</td>
<td style="text-align:left">指定的卷支持磁盘配额。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_SPARSE_FILES</strong> 0x00000040</td>
<td style="text-align:left">指定的卷支持稀疏文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_REPARSE_POINTS</strong> 0x00000080</td>
<td style="text-align:left">指定的卷支持重新分析点。  <strong>裁判：</strong> ReFS 支持重新分析点，但不对其进行索引，因此 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> 将无法按预期工作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_REMOTE_STORAGE</strong> 0x00000100</td>
<td style="text-align:left">文件系统支持远程存储。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_RETURNS_CLEANUP_RESULT_INFO</strong> 0x00000200</td>
<td style="text-align:left">成功执行清理操作后，文件系统将返回描述清理期间执行的其他操作的信息，例如删除文件。 文件系统筛选器可以在清理后回调中检查此信息。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_POSIX_UNLINK_RENAME</strong> 0x00000400</td>
<td style="text-align:left">文件系统支持 POSIX 样式的删除和重命名操作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_VOLUME_IS_COMPRESSED</strong> 0x00008000</td>
<td style="text-align:left">指定的卷是压缩卷，例如 DoubleSpace 卷。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_OBJECT_IDS</strong> 0x00010000</td>
<td style="text-align:left">指定的卷支持对象标识符。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_ENCRYPTION</strong> 0x00020000</td>
<td style="text-align:left">指定的卷支持 EFS) 加密文件系统 (。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/FileIO/file-encryption">文件加密</a>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_NAMED_STREAMS</strong> 0x00040000</td>
<td style="text-align:left">指定的卷支持命名流。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_READ_ONLY_VOLUME</strong> 0x00080000</td>
<td style="text-align:left">指定的卷是只读的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SEQUENTIAL_WRITE_ONCE</strong> 0x00100000</td>
<td style="text-align:left">指定的卷支持单个顺序写入。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_TRANSACTIONS</strong> 0x00200000</td>
<td style="text-align:left">指定的卷支持事务。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/Ktm/about-ktm">关于 KTM</a>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_HARD_LINKS</strong> 0x00400000</td>
<td style="text-align:left">指定的卷支持硬链接。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/hard-links-and-junctions">硬链接和交接点</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前不支持此值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</strong> 0x00800000</td>
<td style="text-align:left">指定的卷支持扩展属性。 扩展属性是应用程序特定的元数据片段，应用程序可与文件关联，并且不属于文件数据。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_OPEN_BY_FILE_ID</strong> 0x01000000</td>
<td style="text-align:left">文件系统支持通过 FileID 打开。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_USN_JOURNAL</strong> 0x02000000</td>
<td style="text-align:left">指定的卷支持更新序列号 (USN) 日志。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/FileIO/change-journal-records">更改日记记录</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_INTEGRITY_STREAMS</strong> 0x04000000</td>
<td style="text-align:left">文件系统支持 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-server/storage/refs/integrity-streams">完整性流</a>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_BLOCK_REFCOUNTING</strong> 0x08000000</td>
<td style="text-align:left">指定的卷支持在同一卷上的文件之间共享逻辑群集。 文件系统在写入共享群集时重新分配。 指示 <strong>FSCTL_DUPLICATE_EXTENTS_TO_FILE</strong> 是受支持的操作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_SPARSE_VDL</strong> 0x10000000</td>
<td style="text-align:left">文件系统跟踪文件的每个群集是否包含来自显式文件写入或自动零的有效数据 () 或无效数据 (尚未写入或归零) 。 使用稀疏的有效数据长度 (VDL) 的文件系统不会存储有效的数据长度，也不需要有效数据在文件中连续。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_DAX_VOLUME</strong> 0x20000000</td>
<td style="text-align:left">指定的卷是 DAX) 卷 (直接访问。  <strong>注意：</strong>此标志是在 Windows 10 版本 1607 中引入的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_GHOSTING</strong> 0x40000000</td>
<td style="text-align:left">文件系统支持重影。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFileSystemNameBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收文件系统名称的缓冲区的指针，例如 FAT 文件系统或 NTFS 文件系统。 缓冲区大小由 <em>nFileSystemNameSize</em> 参数指定。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] nFileSystemNameSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        文件系统名称缓冲区的长度（以 <strong>TCHAR 为单位</strong>）。 最大缓冲区大小为 <strong>MAX_PATH</strong>+1。</p>
<p>​        如果未提供文件系统名称缓冲区，则忽略此参数。</p>
<h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果检索了所有请求的信息，则返回值为非零值。</p>
<p>​        如果未检索所有请求的信息，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<h4 id="注解-7"><a href="#注解-7" class="headerlink" title="注解"></a>注解</h4><p>​        当用户尝试获取有关没有软盘的软盘驱动器或没有光盘的 CD-ROM 驱动器的信息时，系统会显示一个消息框，供用户分别插入软盘或光盘。 若要防止系统显示此消息框，请使用 <strong>SEM_FAILCRITICALERRORS</strong>调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> 函数。</p>
<p>​        <strong>FILE_VOL_IS_COMPRESSED</strong>标志是基于卷的压缩的唯一指示器。 文件系统名称不会更改以指示压缩，例如，此标志在 DoubleSpace 卷上返回设置。 如果压缩是基于卷的，则会压缩或未压缩整个卷。</p>
<p>​        <strong>FILE_FILE_COMPRESSION</strong>标志指示文件系统是否支持基于文件的压缩。 当压缩基于文件时，可以压缩或不压缩单个文件。</p>
<p>​        <strong>FILE_FILE_COMPRESSION</strong>和<strong>FILE_VOL_IS_COMPRESSED</strong>标志互斥。 不能设置这两个位。</p>
<p>​        <em>存储在 lpMaximumComponentLength</em> 中的最大组件长度值是唯一指示卷支持长于正常 FAT 文件系统 (或其他文件系统) 文件名。 不会更改文件系统名称以指示对长文件名的支持。</p>
<p>​        <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getcompressedfilesizea">GetCompressedFileSize</a> 函数获取文件的压缩大小。 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a> 函数可以确定是否压缩单个文件。</p>
<h4 id="符号链接行为-1"><a href="#符号链接行为-1" class="headerlink" title="符号链接行为"></a>符号链接行为</h4><p>​        如果路径指向符号链接，则 函数将返回目标的卷信息。</p>
<p>​        从Windows 8和Windows Server 2012开始，以下技术支持此函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">技术</th>
<th style="text-align:left">支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">群集共享卷文件系统 (CsvFS)</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">弹性文件系统 (ReFS)</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
</div>
<p>​        SMB 不支持卷管理功能。</p>
<h4 id="事务处理操作"><a href="#事务处理操作" class="headerlink" title="事务处理操作"></a>事务处理操作</h4><p>​        如果卷支持文件系统事务，则函数返回 <em>lpFileSystemFlags</em> 中的<strong>FILE_SUPPORTS_TRANSACTIONS</strong>。</p>
<h5 id="备注-2"><a href="#备注-2" class="headerlink" title="备注"></a>备注</h5><p>​        标头 <code>fileapi.h</code> 将 <strong>GetVolumeInformation</strong> 定义为别名，该别名根据 UNICODE 预处理器常量的定义自动选择此函数的 ANSI 或 Unicode 版本。 将非特定编码别名的使用与非非特定编码的代码混合使用可能会导致不匹配，从而导致编译或运行时错误。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/intl/conventions-for-function-prototypes">函数原型的约定</a></p>
<h2 id="系统6"><a href="#系统6" class="headerlink" title="系统6"></a>系统6</h2><h2 id="查看磁盘容量"><a href="#查看磁盘容量" class="headerlink" title="查看磁盘容量"></a>查看磁盘容量</h2><h3 id="GetDiskFreeSpace-amp-amp-GetDiskFreeSpaceEx"><a href="#GetDiskFreeSpace-amp-amp-GetDiskFreeSpaceEx" class="headerlink" title="GetDiskFreeSpace &amp;&amp; GetDiskFreeSpaceEx"></a>GetDiskFreeSpace &amp;&amp; GetDiskFreeSpaceEx</h3><p>​        我们使用这些函数来得到我们想要的信息：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;


int main() &#123;
	BOOL isFine;

	&#x2F;&#x2F; 蔟
	DWORD dwTotlaClusters;
	DWORD dwFreeCluster;
	&#x2F;&#x2F; 扇区
	DWORD dwSectPerClust;
	&#x2F;&#x2F;字节
	DWORD dwBytesPerSect;

	isFine &#x3D; GetDiskFreeSpace(
		TEXT(&quot;C:&#x2F;&quot;),
		&amp;dwSectPerClust,
		&amp;dwBytesPerSect,
		&amp;dwFreeCluster,
		&amp;dwTotlaClusters
	);
	if (!isFine) &#123;
		printf(&quot;Error&quot;);
		return GetLastError();
	&#125;

	printf(&quot;\nGet:&gt;\n&quot;);
	printf(&quot;总蔟：%d\t每一蔟的扇区数:%d\t空闲的数量：%d\t每个扇区的字节数：%d\t&quot;, dwTotlaClusters, dwSectPerClust, dwFreeCluster, dwBytesPerSect);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230529162144848.png?lastModify=1685936981" alt="image-20230529162144848"></p>
<p>​        OK的！</p>
<p>​        那这个Ex版本的是啥呢：精简的版本的：</p>
<pre class="line-numbers language-none"><code class="language-none">DWORD64 qwFreeBytes, qwFreeBytesToCaller, qwTotalBytes;
isFine &#x3D; GetDiskFreeSpaceEx(
	TEXT(&quot;C:&quot;), 
	(PULARGE_INTEGER)&amp; qwFreeBytesToCaller,
	(PULARGE_INTEGER)&amp;qwTotalBytes, 
	(PULARGE_INTEGER)&amp;qwFreeBytes
);
if(!isFine) &#123;
	printf(&quot;Error&quot;);
	return GetLastError();
&#125;
printf(&quot;磁盘的总容量：%I64d\t磁盘的总空闲容量：%I64d\t&quot;, 
	qwTotalBytes, qwFreeBytes);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230529163015847.png?lastModify=1685936981" alt="image-20230529163015847"></p>
<h3 id="getDiskFreeSpace-函数-fileapi-h"><a href="#getDiskFreeSpace-函数-fileapi-h" class="headerlink" title="getDiskFreeSpace 函数 (fileapi.h)"></a>getDiskFreeSpace 函数 (fileapi.h)</h3><p>​        本文内容<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#syntax">语法</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#parameters">参数</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#return-value">返回值</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#remarks">注解</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#requirements">要求</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#see-also">另请参阅</a></p>
<p>​        检索有关指定磁盘的信息，包括磁盘上的可用空间量。</p>
<h4 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">BOOL GetDiskFreeSpace(
  [in]  LPCSTR  lpRootPathName,
  [out] LPDWORD lpSectorsPerCluster,
  [out] LPDWORD lpBytesPerSector,
  [out] LPDWORD lpNumberOfFreeClusters,
  [out] LPDWORD lpTotalNumberOfClusters
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        要为其返回信息的磁盘的根目录。 如果此参数为 <strong>NULL</strong>，则该函数使用当前磁盘的根目录。 如果此参数是 UNC 名称，则必须包含尾随反斜杠 (，例如“\MyServer\MyShare\”) 。 此外，驱动器规范必须具有尾随反斜杠 (，例如“C：\”) 。 调用应用程序必须具有此目录 <strong>FILE_LIST_DIRECTORY</strong> 访问权限。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpSectorsPerCluster<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收每个群集扇区数的变量的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpBytesPerSector<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收每个扇区字节数的变量的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpNumberOfFreeClusters<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收磁盘上可用可用群集总数的变量的指针，该群集可供与调用线程关联的用户使用。</p>
<p>​        如果使用每用户磁盘配额，此值可能小于磁盘上的可用群集总数。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpTotalNumberOfClusters<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向一个变量的指针，该变量接收磁盘上可用于与调用线程关联的用户的群集总数。</p>
<p>​        如果使用每用户磁盘配额，此值可能小于磁盘上的群集总数。</p>
<h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<h4 id="注解-8"><a href="#注解-8" class="headerlink" title="注解"></a>注解</h4><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespaceexa">        GetDiskFreeSpaceEx</a> 函数可避免 <strong>GetDiskFreeSpace</strong> 函数所需的一些算术。</p>
<p>​        符号链接行为 - 如果路径指向符号链接，则会对目标执行操作。</p>
<p> 备注</p>
<p>​        fileapi.h 标头将 GetDiskFreeSpace 定义为别名，该别名根据 UNICODE 预处理器常量的定义自动选择此函数的 ANSI 或 Unicode 版本。 将非中性编码别名与非非编码的代码混合使用可能会导致编译或运行时错误不匹配。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/intl/conventions-for-function-prototypes">函数原型的约定</a>。</p>
<h3 id="getDiskFreeSpaceEx函数-fileapi-h"><a href="#getDiskFreeSpaceEx函数-fileapi-h" class="headerlink" title="getDiskFreeSpaceEx函数 (fileapi.h)"></a>getDiskFreeSpaceEx函数 (fileapi.h)</h3><p>​        本文内容<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#syntax">语法</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#parameters">参数</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#return-value">返回值</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#remarks">注解</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#requirements">要求</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#see-also">另请参阅</a></p>
<p>​        检索有关磁盘卷上可用空间量的信息，即总空间量、可用空间总量以及与调用线程关联的用户可用的可用空间总量。</p>
<h4 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">BOOL GetDiskFreeSpaceEx(
  [in, optional]  LPCSTR          lpDirectoryName,
  [out, optional] PULARGE_INTEGER lpFreeBytesAvailableToCaller,
  [out, optional] PULARGE_INTEGER lpTotalNumberOfBytes,
  [out, optional] PULARGE_INTEGER lpTotalNumberOfFreeBytes
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-13"><a href="#参数-13" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpDirectoryName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        磁盘上的目录。</p>
<p>​        如果此参数为 <strong>NULL</strong>，则该函数使用当前磁盘的根目录。</p>
<p>​        如果此参数是 UNC 名称，则必须包含尾随反斜杠，例如“\MyServer\MyShare\”。</p>
<p>​        此参数不必在磁盘上指定根目录。 该函数接受磁盘上的任何目录。</p>
<p>​        调用应用程序必须对此具有 <strong>FILE_LIST_DIRECTORY</strong> 访问权限 “sample”目录中。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFreeBytesAvailableToCaller<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向一个变量的指针，该变量接收磁盘上的可用字节总数，这些字节可供与调用线程关联的用户使用。</p>
<p>​        此参数可以为 NULL。</p>
<p>​        如果使用每用户配额，此值可能小于磁盘上的可用字节总数。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpTotalNumberOfBytes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向一个变量的指针，该变量接收磁盘上可用于与调用线程关联的用户的字节总数。</p>
<p>​        此参数可以为 NULL。</p>
<p>​        如果使用每用户配额，此值可能小于磁盘上的字节总数。</p>
<p>​        若要确定磁盘或卷上的字节总数，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpTotalNumberOfFreeBytes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收磁盘上可用字节总数的变量的指针。</p>
<p>​        此参数可以为 NULL。</p>
<h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为 0 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p>
<h4 id="注解-9"><a href="#注解-9" class="headerlink" title="注解"></a>注解</h4><p>​        此函数获取的值的类型 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">为ULARGE_INTEGER</a>。 不要将这些值截断为 32 位。</p>
<p>​        <strong>GetDiskFreeSpaceEx</strong> 函数返回 <em>lpTotalNumberOfFreeBytes</em> 和 <em>lpFreeBytesAvailable</em> 的所有 CD 请求的零 (0) ，除非磁盘是 CD-RW 驱动器中的未写入 CD。</p>
<p>​        符号链接行为 - 如果路径指向符号链接，则会对目标执行操作。</p>
<h3 id="ULARGE-INTEGER-union-winnt-h"><a href="#ULARGE-INTEGER-union-winnt-h" class="headerlink" title="ULARGE_INTEGER union (winnt.h)"></a>ULARGE_INTEGER union (winnt.h)</h3><p>​        本文内容<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#syntax">语法</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#members">成员</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#remarks">备注</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#requirements">要求</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#see-also">另请参阅</a></p>
<p>表示 64 位无符号整数值。</p>
<p><strong>注意</strong> C 编译器可能本机支持 64 位整数。 例如，Microsoft Visual C++支持<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Midl/--int64">__int64</a>大小的整数类型。 有关详细信息，请参阅 C 编译器随附的文档。</p>
<h4 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">typedef union _ULARGE_INTEGER &#123;
  struct &#123;
    DWORD LowPart;
    DWORD HighPart;
  &#125; DUMMYSTRUCTNAME;
  struct &#123;
    DWORD LowPart;
    DWORD HighPart;
  &#125; u;
  ULONGLONG QuadPart;
&#125; ULARGE_INTEGER;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><pre class="line-numbers language-none"><code class="language-none">DUMMYSTRUCTNAME
DUMMYSTRUCTNAME.LowPart
DUMMYSTRUCTNAME.HighPart
u
u.LowPart
u.HighPart
QuadPart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>64 位无符号整数。</p>
<h4 id="备注-3"><a href="#备注-3" class="headerlink" title="备注"></a>备注</h4><p><strong>ULARGE_INTEGER</strong>结构实际上是一个联合体。 如果编译器内置了对 64 位整数的支持，请使用 <strong>QuadPart</strong> 成员存储 64 位整数。 否则，请使用 <strong>LowPart</strong> 和 <strong>HighPart</strong> 成员存储 64 位整数。</p>
<h2 id="系统7"><a href="#系统7" class="headerlink" title="系统7"></a>系统7</h2><h2 id="文件操作的四种方法"><a href="#文件操作的四种方法" class="headerlink" title="文件操作的四种方法"></a>文件操作的四种方法</h2><p>​        我们学习到现在，实质上有四种方法进行文件操作。<code>C++, C, Windows API, Windows MFC</code></p>
<p>​        合适的选取方法是十分重要的。下面，为了能够更好的演示，我们选择在Windows MFC下演示之。</p>
<h2 id="创建MFC"><a href="#创建MFC" class="headerlink" title="创建MFC"></a>创建MFC</h2><p>​        如果先前并没有勾选过VS桌面开发者，可以前往安装之。这里就不再多述了，创建一个MFC的基于对话框的应用程序即可！</p>
<p>​        用MFC工具集，我搭建一个演示平台：</p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230603090808135.png?lastModify=1685936981" alt="image-20230603090808135"></p>
<p>​        其中，事先准备好一个文本（我这里是随意的一个1.txt）放到工程文件目录下面去了。</p>
<h2 id="clear按钮"><a href="#clear按钮" class="headerlink" title="clear按钮"></a>clear按钮</h2><p>​        介绍一下函数：<code>SetDlgItemText</code></p>
<h3 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">BOOL SetDlgItemTextW(
  [in] HWND    hDlg,
  [in] int     nIDDlgItem,
  [in] LPCWSTR lpString
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="参数-14"><a href="#参数-14" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in] hDlg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型：<strong>HWND</strong></p>
<p>包含控件的对话框的句柄。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] nIDDlgItem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>int</strong></p>
<p>具有要设置的标题或文本的控件。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] lpString<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>LPCTSTR</strong></p>
<p>要复制到控件的文本。</p>
<h3 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h3><p>类型： <strong>BOOL</strong></p>
<p>如果该函数成功，则返回值为非零值。</p>
<p>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<h3 id="注解-10"><a href="#注解-10" class="headerlink" title="注解"></a>注解</h3><p><strong>SetDlgItemText</strong> 函数将<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a>消息发送到指定的控件。</p>
<p>​        而在MFC中，只需要给定指定的控件编号和文本即可：</p>
<pre class="line-numbers language-none"><code class="language-none">void CMFCApplication1Dlg::OnBnClickedButton5()
&#123;
	&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码
	SetDlgItemText(IDC_EDIT1, TEXT(&quot;&quot;));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="C-方式"><a href="#C-方式" class="headerlink" title="C  方式"></a>C  方式</h2><p>​        点击第一个按钮，书写响应函数：</p>
<pre class="line-numbers language-none"><code class="language-none">void CMFCApplication1Dlg::OnBnClickedButton1()
&#123;
	&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码
	CString s &#x3D; TEXT(&quot;************C*************\r\n&quot;); &#x2F;&#x2F;一个MFC类
	FILE* pF; &#x2F;&#x2F; 声明文件指针
	char line[256]; &#x2F;&#x2F;准备字符空间
	fopen_s(&amp;pF,&quot;1.txt&quot;, &quot;r&quot;); &#x2F;&#x2F; 阅读内容
	while (fgets(line, 256, pF) !&#x3D; NULL) &#123;
		s +&#x3D; line;			&#x2F;&#x2F; 使用Cstring的函数
		s +&#x3D; TEXT(&quot;\r\n&quot;);
	&#125;
	fclose(pF);
	SetDlgItemText(IDC_EDIT1, s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="C-方式-1"><a href="#C-方式-1" class="headerlink" title="C++ 方式"></a>C++ 方式</h2><pre class="line-numbers language-none"><code class="language-none">void CMFCApplication1Dlg::OnBnClickedButton2()
&#123;
	&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码
	CString s &#x3D; TEXT(&quot;************C++*************\r\n&quot;);
	char line[256];
	std::ifstream ifs(&quot;1.txt&quot;);
	while (ifs.getline(line, 256)) &#123;
		s +&#x3D; line;
		s +&#x3D; TEXT(&quot;\r\n&quot;);
	&#125;

	ifs.close();
	SetDlgItemText(IDC_EDIT1, s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><pre class="line-numbers language-none"><code class="language-none">void CMFCApplication1Dlg::OnBnClickedButton3()
&#123;
	&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码
	CString c &#x3D; TEXT(&quot;*****************API********************\r\n&quot;);
	CHAR lpFileDataBuffer[4096];
	ZeroMemory(lpFileDataBuffer, 4096);
	DWORD dwReadSize;
	HANDLE hfile;
	hfile &#x3D; CreateFile(
		TEXT(&quot;1.txt&quot;),
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);
	ReadFile(hfile, lpFileDataBuffer, 4096, &amp;dwReadSize, NULL);
	CloseHandle(hfile);
	c +&#x3D; lpFileDataBuffer;
	SetDlgItemText(IDC_EDIT1,c);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Windows-MFC"><a href="#Windows-MFC" class="headerlink" title="Windows MFC"></a>Windows MFC</h2><pre class="line-numbers language-none"><code class="language-none">void CMFCApplication1Dlg::OnBnClickedButton4()
&#123;
	&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码
	CString s &#x3D; TEXT(&quot;******************MFC*******************\r\n&quot;);
	CString line;
	CStdioFile file(TEXT(&quot;1.txt&quot;),CFile::modeRead);
	while (file.ReadString(line))
	&#123;
		s +&#x3D; line;
		s +&#x3D; TEXT(&quot;\r\n&quot;);
	&#125;
	SetDlgItemText(IDC_EDIT1, s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="系统8"><a href="#系统8" class="headerlink" title="系统8"></a>系统8</h2><p>首先，熟悉一下这个形式的main函数：</p>
<pre class="line-numbers language-none"><code class="language-none">int main(int argc, char* argv[])&#123;
	&#x2F;&#x2F;...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​                在这里，<code>argc</code>指出了命令行有几个，<code>argv</code>给出了具体的参数是什么，来个demo:</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;

int main(int argc, char* argv[]) &#123;
	printf(&quot;个数：%d\n&quot;, argc);
	printf(&quot;第一个:%s\n&quot;, argv[0]);
	printf(&quot;第二个:%s\n&quot;, argv[1]);
	printf(&quot;第三个:%s\n&quot;, argv[2]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在只是<code>生成工程</code>！随后，使用<code>PowerShell</code>切换到工程的debug目录下面，找到这个自己的可执行文件。由于此时<code>int main(int argc, char* argv[])</code>带上了命令行参数，它可以接受命令！</p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;mu.exe -d a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230603094626567.png?lastModify=1685936981" alt="image-20230603094626567"></p>
<p><img src="file://C:/Users/%E9%99%88%E5%86%A0%E8%B1%AA/Desktop/%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0/finally/Magazine%20of%20Programming%20I/image-20230603094646043.png?lastModify=1685936981" alt="image-20230603094646043"></p>
<p>​        这就是运行的结果。</p>
<h2 id="DeleteFile"><a href="#DeleteFile" class="headerlink" title="DeleteFile"></a>DeleteFile</h2><p>​        删除现有文件。</p>
<p>若要以事务处理操作的形式执行此操作，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-deletefiletransacteda">DeleteFileTransacted</a> 函数。</p>
<h3 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">BOOL DeleteFile(
  [in] LPCTSTR lpFileName
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="参数-15"><a href="#参数-15" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in] lpFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        要删除的文件的名称。</p>
<p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\？\”。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p>
<p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p>
<h2 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为零 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p>
<h2 id="注解-11"><a href="#注解-11" class="headerlink" title="注解"></a>注解</h2><p>​        如果应用程序尝试删除不存在的文件， <strong>DeleteFile</strong> 函数将失败并 <strong>ERROR_FILE_NOT_FOUND</strong>。 如果文件是只读文件，则函数将失败并 <strong>ERROR_ACCESS_DENIED</strong>。</p>
<p>​        以下列表标识了删除、删除或关闭文件的一些提示：</p>
<ul>
<li>若要删除只读文件，首先必须删除只读属性。</li>
<li>若要删除或重命名文件，必须对文件具有删除权限，或者具有父目录中的删除子权限。</li>
<li>若要以递归方式删除目录中的文件，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/shellapi/nf-shellapi-shfileoperationa">SHFileOperation</a> 函数。</li>
<li>若要删除空目录，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-removedirectorya">RemoveDirectory</a> 函数。</li>
<li>若要关闭打开的文件，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 函数。</li>
</ul>
<p>​        如果设置了除 delete 和 delete child 以外的所有访问权限的目录，并且访问控制列表 (ACL) 继承了新文件，则可以创建一个文件，但无法将其删除。 但是，你可以创建一个文件，然后获取在创建文件时返回给你的句柄上请求的所有访问权限。</p>
<p>​        如果在创建文件时请求删除权限，则可以使用该句柄删除或重命名文件，但不能使用任何其他句柄。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-security-and-access-rights">文件安全和访问权限</a>。</p>
<p>​        如果应用程序尝试删除具有打开正常 I/O 的其他句柄的文件或作为内存映射文件的文件 (<strong>FILE_SHARE_DELETE</strong>必须在打开其他句柄) 时指定，<strong>DeleteFile</strong> 函数将失败。</p>
<p>​        <strong>DeleteFile</strong> 函数在关闭时标记要删除的文件。 因此，在关闭文件的最后一个句柄之前，不会删除文件。 后续调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 以打开文件失败， <strong>并显示ERROR_ACCESS_DENIED</strong>。</p>
<p>​        符号链接行为 —</p>
<p>​        如果路径指向符号链接，则删除符号链接，而不是目标。 若要删除目标，必须调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 并指定 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong>。</p>
<h2 id="CopyFile"><a href="#CopyFile" class="headerlink" title="CopyFile"></a>CopyFile</h2><p>​        将现有文件复制到新文件。</p>
<p>​        <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-copyfileexa">CopyFileEx</a> 函数提供两个附加功能。 每次完成复制操作的一部分时，<strong>CopyFileEx</strong> 都可以调用指定的回调函数，并且可以在复制操作期间取消 <strong>CopyFileEx</strong>。</p>
<p>​        若要以事务处理操作的形式执行此操作，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-copyfiletransacteda">CopyFileTransacted</a> 函数。</p>
<h3 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">BOOL CopyFile(
  [in] LPCTSTR lpExistingFileName,
  [in] LPCTSTR lpNewFileName,
  [in] BOOL    bFailIfExists
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="参数-16"><a href="#参数-16" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-none"><code class="language-none">[in] lpExistingFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        现有文件的名称。</p>
<p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\？\”。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p>
<p> 提示</p>
<p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p>
<p>​        如果 <em>lpExistingFileName</em> 不存在， <strong>则 CopyFile</strong> 将失败， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 将返回 <strong>ERROR_FILE_NOT_FOUND</strong>。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] lpNewFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        新文件的名称。</p>
<p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\？\”。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p>
<p> 提示</p>
<p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] bFailIfExists<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果此参数为 <strong>TRUE</strong> 并且 <em>lpNewFileName</em> 指定的新文件已存在，则函数将失败。 如果此参数为 <strong>FALSE</strong> 且新文件已存在，则函数将覆盖现有文件并成功。</p>
<h2 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<h2 id="注解-12"><a href="#注解-12" class="headerlink" title="注解"></a>注解</h2><p>​        现有文件 (<strong>ATTRIBUTE_SECURITY_INFORMATION</strong>) 的安全资源属性将复制到新文件。</p>
<p>​        <strong>Windows 7、Windows Server 2008 R2、Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在Windows 8和Windows Server 2012之前，现有文件的安全资源属性不会复制到新文件。</p>
<p>​        现有文件的文件属性将复制到新文件。 例如，如果现有文件具有 <strong>FILE_ATTRIBUTE_READONLY</strong> 文件属性，则通过调用 <strong>CopyFile</strong> 创建的副本也将具有 <strong>FILE_ATTRIBUTE_READONLY</strong> 文件属性。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/retrieving-and-changing-file-attributes">检索和更改文件属性</a>。</p>
<p>​        如果目标文件已存在并且设置了<strong>FILE_ATTRIBUTE_HIDDEN或FILE_ATTRIBUTE_READONLY</strong>属性，则此函数将失败<strong>并ERROR_ACCESS_DENIED</strong>。</p>
<p>​        当 <strong>CopyFile</strong> 用于复制加密的文件时，它会尝试使用源文件加密中使用的密钥来加密目标文件。 如果无法执行此操作，此函数将尝试使用默认密钥加密目标文件。 如果这两种方法都无法完成， <strong>则 CopyFile</strong> 将失败并 <strong>显示ERROR_ENCRYPTION_FAILED</strong> 错误代码。</p>
<p>​        符号链接行为 - 如果源文件是符号链接，则复制的实际文件是符号链接的目标。</p>
<p>​        如果目标文件已存在并且是符号链接，则符号链接的目标将被源文件覆盖。</p>
<h2 id="MoveFile"><a href="#MoveFile" class="headerlink" title="MoveFile"></a>MoveFile</h2><p>​        移动现有文件或目录，包括其子级。</p>
<p>​        若要指定如何移动文件，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefileexa">MoveFileEx</a> 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefilewithprogressa">MoveFileWithProgress</a> 函数。</p>
<p>​        若要以事务处理操作的形式执行此操作，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefiletransacteda">MoveFileTransacted</a> 函数。</p>
<h3 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">BOOL MoveFile(
  [in] LPCTSTR lpExistingFileName,
  [in] LPCTSTR lpNewFileName
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="参数-17"><a href="#参数-17" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-none"><code class="language-none">[in] lpExistingFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        本地计算机上文件或目录的当前名称。</p>
<p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\？\”。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p>
<p> 提示</p>
<p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] lpNewFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        文件或目录的新名称。 新名称不得已存在。 新文件可能位于不同的文件系统或驱动器上。 新目录必须位于同一驱动器上。</p>
<p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\？\”。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p>
<p> 提示</p>
<p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p>
<h2 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<h2 id="注解-13"><a href="#注解-13" class="headerlink" title="注解"></a>注解</h2><p>​        <strong>MoveFile</strong> 函数将移动 (重命名) 文件或目录 (包括其子级) 在同一目录中或跨目录。 需要注意的是，当目标位于其他卷上时，移动目录时 <strong>，MoveFile</strong> 函数将失败。</p>
<p>​        如果文件跨卷移动， <strong>MoveFile</strong> 不会随文件一起移动安全描述符。 将为文件分配目标目录中的默认安全描述符。</p>
<p>​        <strong>MoveFile</strong> 函数将其操作与链接跟踪服务协调，因此可以在移动链接源时对其进行跟踪。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/06/05/Semester1-updateOfWholeNotes/">http://charliechen114514.github.io/2023/06/05/Semester1-updateOfWholeNotes/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Semester-overall/">Semester_overall</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/06/Algorithm-in-C-1/" title="Algorithm_in_C(1)"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Algorithm_in_C(1)</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/01/Qt-Opencv-Config/" title="Qt &amp;&amp; Opencv Config"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Qt &amp;&amp; Opencv Config</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/09/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89string-h%E7%B3%BB%E5%88%97/" title="C语言常用函数（1）string.h系列"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="title">C语言常用函数（1）string.h系列</div></div></a></div><div><a href="/2023/04/17/High-Quality-of-C-Cpp-programming-in-formats-1/" title="High Quality of C_Cpp programming in formats(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-17</div><div class="title">High Quality of C_Cpp programming in formats(1)</div></div></a></div><div><a href="/2023/06/06/Algorithm-in-C-1/" title="Algorithm_in_C(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_in_C(1)</div></div></a></div><div><a href="/2023/06/06/Opencv-learning-CPP/" title="Opencv_learning_CPP"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Opencv_learning_CPP</div></div></a></div><div><a href="/2023/06/06/CPP-ExtensiveReadingNotes-1-EssentialCPP/" title="CPP_ExtensiveReadingNotes-1-EssentialCPP"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">CPP_ExtensiveReadingNotes-1-EssentialCPP</div></div></a></div><div><a href="/2023/06/06/CPP-ExtensiveReadingNotes-2-MoreEffectiveCPP/" title="CPP_ExtensiveReadingNotes-2-MoreEffectiveCPP"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">CPP_ExtensiveReadingNotes-2-MoreEffectiveCPP</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Magazine-of-Programming-I"><span class="toc-number">1.</span> <span class="toc-text">Magazine of Programming I</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sections-includes-gt"><span class="toc-number">1.1.</span> <span class="toc-text">Sections includes:&gt;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%AC%94%E8%AE%B0%E9%98%85%E8%AF%BB"><span class="toc-number">2.</span> <span class="toc-text">C++笔记阅读</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">C++基础编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E7%AE%80%E5%8D%95%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B9%A6%E5%86%99"><span class="toc-number">3.1.</span> <span class="toc-text">1.1简单程序的书写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.</span> <span class="toc-text">对象的定义和初始化问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A6%E5%86%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">书写表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.4.</span> <span class="toc-text">运算符优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.</span> <span class="toc-text">条件语句和循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.1.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.5.2.</span> <span class="toc-text">循环语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84array-%E5%92%8Cvector"><span class="toc-number">3.6.</span> <span class="toc-text">使用标准库的array 和vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%B0%8F%E8%AE%BA"><span class="toc-number">3.7.</span> <span class="toc-text">指针小论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81%E6%93%8D%E4%BD%9C"><span class="toc-number">3.8.</span> <span class="toc-text">文件流操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B"><span class="toc-number">3.9.</span> <span class="toc-text">面向过程的函数编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">3.10.</span> <span class="toc-text">如何编写一个函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82%E6%96%B9%E6%B3%95%EF%BC%9ApassByReference"><span class="toc-number">3.11.</span> <span class="toc-text">传参方法：passByReference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.12.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">3.13.</span> <span class="toc-text">动态内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E9%BB%98%E8%AE%A4%E7%9A%84%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">3.14.</span> <span class="toc-text">提供默认的参数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.15.</span> <span class="toc-text">使用局部静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91inline"><span class="toc-number">3.16.</span> <span class="toc-text">可以考虑inline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">3.17.</span> <span class="toc-text">提供重载函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.18.</span> <span class="toc-text">定义并使用模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">3.19.</span> <span class="toc-text">使用头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.20.</span> <span class="toc-text">泛型编程风格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E8%AE%B2%E8%B5%B7"><span class="toc-number">3.20.1.</span> <span class="toc-text">从指针运算讲起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E7%BA%AF%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE"><span class="toc-number">3.21.</span> <span class="toc-text">采用纯指针访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8C%87%E9%92%88-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">3.22.</span> <span class="toc-text">泛型指针:迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BA%94%E5%A4%A7%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.23.</span> <span class="toc-text">初始化一个容器的基本五大接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B4"><span class="toc-number">4.</span> <span class="toc-text">C++ 基础编程4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC"><span class="toc-number">4.1.</span> <span class="toc-text">基于对象的编程风格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAClass"><span class="toc-number">4.1.1.</span> <span class="toc-text">实现一个Class</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">构造函数和析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">初始化列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%90%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84"><span class="toc-number">4.3.</span> <span class="toc-text">逐一初始化的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIPS%EF%BC%9A%E5%B0%8F%E5%BF%83%E5%9D%91"><span class="toc-number">4.4.</span> <span class="toc-text">TIPS：小心坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutable-%E5%92%8C-const"><span class="toc-number">4.5.</span> <span class="toc-text">mutable 和 const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">4.6.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E6%88%90%E5%91%98%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">4.7.</span> <span class="toc-text">静态类成员与函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B5"><span class="toc-number">5.</span> <span class="toc-text">C++基础编程5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC"><span class="toc-number">5.1.</span> <span class="toc-text">面对对象的编程风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">面向对象的编程运作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%9F%BA%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">定义一个抽象的基类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">5.4.</span> <span class="toc-text">定义一个派生类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E6%9E%90%E6%9E%84%E5%92%8C%E5%A4%8D%E5%88%B6"><span class="toc-number">5.5.</span> <span class="toc-text">初始化，析构和复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%EF%BC%8C%E5%AE%9A%E4%B9%89%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">5.6.</span> <span class="toc-text">覆盖，定义虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%89%B4%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">5.7.</span> <span class="toc-text">运行时的类型鉴定机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Etemplate%E7%9A%84%E7%BC%96%E7%A8%8B"><span class="toc-number">5.8.</span> <span class="toc-text">基于template的编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A2%AB%E5%8F%82%E6%95%B0%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.9.</span> <span class="toc-text">被参数化的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#template%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">5.10.</span> <span class="toc-text">template类型参数的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">5.11.</span> <span class="toc-text">常量表达式和默认参数值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">5.12.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">5.12.1.</span> <span class="toc-text">抛出异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">5.13.</span> <span class="toc-text">捕获异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%82%BC%E5%BC%82%E5%B8%B8"><span class="toc-number">5.14.</span> <span class="toc-text">提炼异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#More-Effective-C-1"><span class="toc-number">6.</span> <span class="toc-text">More Effective C++ 1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Issues"><span class="toc-number">6.1.</span> <span class="toc-text">Basic Issues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE1-%E5%8C%BA%E5%88%86pointers-%E5%92%8C-reference"><span class="toc-number">6.1.1.</span> <span class="toc-text">条款1 区分pointers 和 reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE2%EF%BC%9A%E6%9C%80%E5%A5%BD%E4%BD%BF%E7%94%A8C-%E8%BD%AC%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">6.1.2.</span> <span class="toc-text">条款2：最好使用C++转型操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE3%EF%BC%9A%E4%B8%8D%E8%A6%81%E4%BB%A5%E5%A4%9A%E6%80%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84"><span class="toc-number">6.1.3.</span> <span class="toc-text">条款3：不要以多态的方式处理数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE%E5%9B%9B%EF%BC%9A%E9%9D%9E%E5%BF%85%E8%A6%81%E4%B8%8D%E6%8F%90%E4%BE%9B%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.4.</span> <span class="toc-text">条款四：非必要不提供默认构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE5%EF%BC%9A%E5%AF%B9%E5%AE%9A%E5%88%B6%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%AC%A6%E4%BF%9D%E6%8C%81%E8%AD%A6%E8%A7%89"><span class="toc-number">6.2.1.</span> <span class="toc-text">条款5：对定制的类型转换符保持警觉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE6%E5%8C%BA%E5%88%86%E5%89%8D%E7%BD%AE%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E5%90%8E%E7%BD%AE%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">6.2.2.</span> <span class="toc-text">条款6区分前置操作符和后置操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE7%EF%BC%9A%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E9%87%8D%E8%BD%BD-amp-amp-%E5%92%8C-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">6.2.3.</span> <span class="toc-text">条款7：千万不要重载&amp;&amp;,|| 和 , 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE8%EF%BC%9A%E4%BA%86%E8%A7%A3%E4%B8%8D%E5%90%8C%E5%90%AB%E4%B9%89%E7%9A%84new%E5%92%8Cdelete"><span class="toc-number">6.2.4.</span> <span class="toc-text">条款8：了解不同含义的new和delete</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Deletion-amp-amp-Deallocation"><span class="toc-number">6.2.4.1.</span> <span class="toc-text">Deletion &amp;&amp; Deallocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arrays%E6%95%B0%E7%BB%84"><span class="toc-number">6.2.4.2.</span> <span class="toc-text">Arrays数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-1"><span class="toc-number">6.3.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE9%EF%BC%9A%E4%BD%BF%E7%94%A8destructor%E6%9D%A5%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">6.3.1.</span> <span class="toc-text">条款9：使用destructor来防止内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E5%9C%A8constructor%E5%86%85%E9%83%A8%E9%98%BB%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">6.3.2.</span> <span class="toc-text">条款10：在constructor内部阻止内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE11-%E7%A6%81%E6%AD%A2%E5%BC%82%E5%B8%B8%E6%B5%81%E5%87%BAdestructor"><span class="toc-number">6.3.3.</span> <span class="toc-text">条款11 禁止异常流出destructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E4%BA%86%E8%A7%A3%E2%80%9C%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E2%80%9D%E4%B8%8E%E2%80%9C%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E2%80%9D%E6%88%96%E8%80%85%E6%98%AF%E2%80%9C%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E2%80%9D"><span class="toc-number">6.3.4.</span> <span class="toc-text">条款12：了解“抛出一个异常”与“传递一个参数”或者是“调用一个虚函数的区别”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE13-%E4%BB%A5%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8"><span class="toc-number">6.3.5.</span> <span class="toc-text">条款13 以引用传递捕捉异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E6%98%8E%E6%99%BA%E4%BD%BF%E7%94%A8exception-specification"><span class="toc-number">6.3.6.</span> <span class="toc-text">条款14：明智使用exception specification</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E4%BA%86%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">6.3.7.</span> <span class="toc-text">条款15：了解异常处理的代价</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E7%8E%87"><span class="toc-number">6.4.</span> <span class="toc-text">效率</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E8%B0%A8%E8%AE%B0-80-20-%E6%B3%95%E5%88%99"><span class="toc-number">6.4.1.</span> <span class="toc-text">条款16：谨记 80 - 20 法则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E7%BC%93%E5%BC%8F%E8%AF%84%E4%BC%B0"><span class="toc-number">6.4.2.</span> <span class="toc-text">条款17：考虑使用缓式评估</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">引用计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%BF%98%E6%98%AF%E5%86%99%EF%BC%9F"><span class="toc-number">6.4.2.2.</span> <span class="toc-text">读还是写？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%BC%8F%E8%AF%BB%E5%8F%96"><span class="toc-number">6.4.2.3.</span> <span class="toc-text">缓式读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%BC%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%84%E4%BC%B0"><span class="toc-number">6.4.2.4.</span> <span class="toc-text">缓式表达式的评估</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E5%88%86%E6%9C%9F%E6%91%8A%E8%BF%98%E9%A2%84%E6%9C%9F%E7%9A%84%E8%AE%A1%E7%AE%97%E6%88%90%E6%9C%AC"><span class="toc-number">6.4.3.</span> <span class="toc-text">条款18：分期摊还预期的计算成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E4%BA%86%E8%A7%A3%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">6.4.4.</span> <span class="toc-text">条款19：了解临时对象的产生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%8C%E6%88%90%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%E5%B7%A5%E4%BD%9C"><span class="toc-number">6.4.5.</span> <span class="toc-text">条款20：完成返回值优化工作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#More-effective-C-2"><span class="toc-number">7.</span> <span class="toc-text">More effective C++2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE22-%E8%80%83%E8%99%91%E4%BB%A5%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%A4%8D%E5%90%88%E5%BD%A2%E5%BC%8F%EF%BC%88op-%EF%BC%89%E6%9D%A5%E5%8F%96%E4%BB%A3%E7%8B%AC%E8%BA%AB%E5%BD%A2%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">条款22 考虑以操作符复合形式（op&#x3D;）来取代独身形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E5%BA%93"><span class="toc-number">7.2.</span> <span class="toc-text">条款23：考虑使用其他库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E4%BA%86%E8%A7%A3virtual-functions-multiple-functions-virtual-base-classes-runtime-type-identification%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-number">7.3.</span> <span class="toc-text">条款24：了解virtual functions, multiple functions, virtual base classes runtime type identification的成本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E5%B0%86%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%99%9A%E5%8C%96"><span class="toc-number">7.4.</span> <span class="toc-text">条款25：将构造函数和非成员函数虚化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE26-%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AAclass%E6%89%80%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F"><span class="toc-number">7.5.</span> <span class="toc-text">条款26 限制某个class所能产生的对象数量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%81%E8%AE%B80%E4%B8%AA%E6%88%96%E8%80%851-%E4%B8%AA%E5%AF%B9%E8%B1%A1%E4%BA%A7%E5%87%BA"><span class="toc-number">7.5.1.</span> <span class="toc-text">允许0个或者1 个对象产出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E5%AF%B9%E8%B1%A1%E7%94%9F%E7%94%9F%E7%81%AD%E7%81%AD"><span class="toc-number">7.5.2.</span> <span class="toc-text">允许对象生生灭灭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%88%E5%9C%A8%E4%B8%8D%E5%9C%A8heap-%EF%BC%89"><span class="toc-number">7.5.3.</span> <span class="toc-text">判断对象在哪里（在不在heap?）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%AD%A2%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E5%9C%A8heap%E4%B8%8A"><span class="toc-number">7.5.4.</span> <span class="toc-text">静止对象产生在heap上</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9Aauto-ptr"><span class="toc-number">7.6.</span> <span class="toc-text">条款27：auto_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E6%9E%84%E9%80%A0-%E8%B5%8B%E5%80%BC-%E6%9E%90%E6%9E%84"><span class="toc-number">7.6.1.</span> <span class="toc-text">智能指针的构造,赋值,析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Dereference-Operators-%E8%A7%A3%E5%BC%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">7.6.2.</span> <span class="toc-text">实现Dereference Operators(解引操作符)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95Smart-Pointers%E6%98%AF%E5%90%A6%E4%B8%BANull"><span class="toc-number">7.6.3.</span> <span class="toc-text">测试Smart Pointers是否为Null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86Smart-Pointers%E8%BD%AC%E6%8D%A2%E4%B8%BADumb-Pointers"><span class="toc-number">7.6.4.</span> <span class="toc-text">将Smart Pointers转换为Dumb Pointers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smart-Pointers%E5%92%8C%E2%80%9D%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%9C%89%E5%85%B3%E7%9A%84%E2%80%9D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.6.5.</span> <span class="toc-text">Smart Pointers和”与继承有关的”类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">7.7.</span> <span class="toc-text">条款28：引用计数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">8.</span> <span class="toc-text">C++智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPP%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.1.</span> <span class="toc-text">CPP智能指针类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%AE%BA"><span class="toc-number">8.2.</span> <span class="toc-text">概论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr"><span class="toc-number">8.3.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#demo-of-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA"><span class="toc-number">8.4.</span> <span class="toc-text">demo of 智能指针创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr%E5%92%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">8.5.</span> <span class="toc-text">unique_ptr和函数调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr-%E4%B8%8E%E8%AE%A1%E6%95%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">8.6.</span> <span class="toc-text">shared_ptr 与计数机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B%E7%9A%84shared-ptr"><span class="toc-number">8.6.1.</span> <span class="toc-text">常量类型的shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E7%9A%84shared-ptr"><span class="toc-number">8.6.2.</span> <span class="toc-text">自定义类型的shared_ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shared-ptr%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-number">8.7.</span> <span class="toc-text">shared_ptr与函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">8.7.1.</span> <span class="toc-text">值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">8.7.2.</span> <span class="toc-text">引用传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">8.7.3.</span> <span class="toc-text">做返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8Cunique-ptr%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.8.</span> <span class="toc-text">和unique_ptr的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weak-ptr"><span class="toc-number">8.9.</span> <span class="toc-text">weak_ ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">8.9.1.</span> <span class="toc-text">一个循环引用的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AAweak-ptr"><span class="toc-number">8.9.2.</span> <span class="toc-text">构造一个weak_ptr</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Section-1-%E7%AE%80%E5%8D%95%E7%9A%84%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92"><span class="toc-number">9.</span> <span class="toc-text">Section 1 简单的理解递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">9.1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%A0%88%E8%AE%B2%E8%B5%B7%EF%BC%81"><span class="toc-number">9.2.</span> <span class="toc-text">从栈讲起！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88"><span class="toc-number">9.3.</span> <span class="toc-text">系统函数调用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E5%85%A5%E6%AD%A3%E9%A2%98%EF%BC%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%87%AA%E5%B7%B1%EF%BC%81%EF%BC%88%E5%B0%B1%E6%98%AF%E9%80%92%E5%BD%92%EF%BC%89"><span class="toc-number">9.4.</span> <span class="toc-text">步入正题！函数调用自己！（就是递归）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%BD%E8%AF%B4%E9%80%92%E5%BD%92%E7%88%BD%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B3%A8%E6%84%8F%E5%88%B0%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%81"><span class="toc-number">9.5.</span> <span class="toc-text">虽说递归爽，但是注意到性能问题！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A01%EF%BC%9A%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%9A%E5%A6%82%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C"><span class="toc-number">9.6.</span> <span class="toc-text">练习1：递归求解线性表：如数组的和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Section-2-%E5%9F%BA%E4%BA%8EJava-%E7%9A%84%E5%9F%BA%E7%A1%80%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">Section 2 基于Java 的基础简单算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">10.0.0.0.0.1.</span> <span class="toc-text">认识时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">10.0.0.0.1.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">10.0.0.0.1.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%9A%84%E7%A6%BB%E5%A5%87%E5%86%99%E6%B3%95"><span class="toc-number">10.0.0.0.1.2.</span> <span class="toc-text">交换的离奇写法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">10.0.0.0.1.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">10.0.0.0.1.4.</span> <span class="toc-text">二分查找法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E5%99%A8"><span class="toc-number">10.0.0.0.1.5.</span> <span class="toc-text">对数器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%A1%8C%E4%B8%BA%E4%B8%8B%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">10.0.0.0.2.</span> <span class="toc-text">递归行为下时间复杂度的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B1%82%E5%8F%96%E4%B8%AD%E7%82%B9%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">10.0.0.0.2.1.</span> <span class="toc-text">求取中点的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E6%B1%82%E8%A7%A3%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%9A"><span class="toc-number">10.0.0.0.2.2.</span> <span class="toc-text">使用递归求解数组最大值：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Master%E5%85%AC%E5%BC%8F"><span class="toc-number">10.0.0.0.2.3.</span> <span class="toc-text">Master公式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%A5%E5%85%85Reading"><span class="toc-number">10.0.0.0.2.4.</span> <span class="toc-text">补充Reading</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88MergeSort%EF%BC%89"><span class="toc-number">10.0.0.0.2.5.</span> <span class="toc-text">归并排序（MergeSort）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%88%91%E4%BB%AC%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">10.0.0.0.2.6.</span> <span class="toc-text">扩展我们的归并排序问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">10.0.0.0.2.7.</span> <span class="toc-text">快速排序</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%BB%93%E6%9E%84"><span class="toc-number">10.0.1.</span> <span class="toc-text">堆结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">10.0.2.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">10.0.3.</span> <span class="toc-text">桶排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">10.0.4.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8"><span class="toc-number">10.0.5.</span> <span class="toc-text">有序表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">10.0.6.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84"><span class="toc-number">10.0.7.</span> <span class="toc-text">二叉树的节点结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">10.0.8.</span> <span class="toc-text">广度优先搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">10.0.9.</span> <span class="toc-text">判断二叉树是不是搜索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E4%B8%8D%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">10.0.9.1.</span> <span class="toc-text">判断一个二叉树是不是完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91-amp-amp-%E6%98%AF%E4%B8%8D%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-amp-amp-%E5%A5%97%E8%B7%AF"><span class="toc-number">10.0.9.2.</span> <span class="toc-text">判断是不是满二叉树 &amp;&amp; 是不是平衡二叉树&amp;&amp;套路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E9%87%8C%E6%89%BE%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9"><span class="toc-number">10.0.9.3.</span> <span class="toc-text">在二叉树里找自己的后继节点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">10.1.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">10.1.1.</span> <span class="toc-text">图的存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">10.1.2.</span> <span class="toc-text">图的宽度优先遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">10.1.3.</span> <span class="toc-text">图的深度优先遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">10.1.4.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kruskal%E7%AE%97%E6%B3%95%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">10.1.5.</span> <span class="toc-text">kruskal算法（无向图算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prim%E7%AE%97%E6%B3%95%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89"><span class="toc-number">10.1.6.</span> <span class="toc-text">prim算法（无向图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">10.1.7.</span> <span class="toc-text">Dijkstra算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Learn-Linux-%E5%85%A5%E9%97%A8"><span class="toc-number">11.</span> <span class="toc-text">Learn Linux 入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%85%A5%E9%97%A8"><span class="toc-number">12.</span> <span class="toc-text">Linux入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">12.1.</span> <span class="toc-text">操作系统概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%A6%82%E8%BF%B0"><span class="toc-number">12.2.</span> <span class="toc-text">Linux概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">12.3.</span> <span class="toc-text">Linux目录结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4%EF%BC%9Als"><span class="toc-number">12.4.</span> <span class="toc-text">第一个Linux命令：ls</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95"><span class="toc-number">12.5.</span> <span class="toc-text">什么是工作目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ls-%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-number">12.6.</span> <span class="toc-text">ls 参数详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cd-pwd%E6%8C%87%E4%BB%A4"><span class="toc-number">12.7.</span> <span class="toc-text">cd  -  pwd指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84-%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84-%E7%89%B9%E6%AE%8A%E8%B7%AF%E5%BE%84%E7%AC%A6"><span class="toc-number">12.8.</span> <span class="toc-text">相对路径&#x2F;绝对路径&#x2F;特殊路径符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mkdir-%E5%91%BD%E4%BB%A4"><span class="toc-number">12.9.</span> <span class="toc-text">mkdir 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#torch-cat-more"><span class="toc-number">12.10.</span> <span class="toc-text">torch cat more</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cp-mv-rm"><span class="toc-number">12.11.</span> <span class="toc-text">cp mv rm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#which%E5%92%8Cfind"><span class="toc-number">12.12.</span> <span class="toc-text">which和find</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#grep-%E4%B8%8E-wc"><span class="toc-number">12.13.</span> <span class="toc-text">grep 与 wc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E7%AC%A6"><span class="toc-number">12.14.</span> <span class="toc-text">管道符 |</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#echo%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9"><span class="toc-number">12.15.</span> <span class="toc-text">echo命令输出内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6%E5%8F%B7-gt-%E4%B8%8E-gt-gt"><span class="toc-number">12.16.</span> <span class="toc-text">重定向符号 &gt; 与&gt;&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tail%E5%91%BD%E4%BB%A4"><span class="toc-number">12.17.</span> <span class="toc-text">tail命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vim%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">12.18.</span> <span class="toc-text">vim编辑器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Root%E6%9D%83%E9%99%90"><span class="toc-number">12.19.</span> <span class="toc-text">Root权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">12.20.</span> <span class="toc-text">用户和用户组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">12.20.1.</span> <span class="toc-text">创建与删除用户组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">12.20.2.</span> <span class="toc-text">用户的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90%E5%B7%A5%E4%BD%9C"><span class="toc-number">12.21.</span> <span class="toc-text">查看权限工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">12.22.</span> <span class="toc-text">修改权限控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%BF%AB%E9%80%9F%E6%93%8D%E4%BD%9C%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">12.23.</span> <span class="toc-text">一些快速操作快捷键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9"><span class="toc-number">12.24.</span> <span class="toc-text">解压缩</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E5%AD%A6%E4%B9%A02"><span class="toc-number">13.</span> <span class="toc-text">Linux 学习2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#systemctl"><span class="toc-number">13.1.</span> <span class="toc-text">systemctl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-number">13.2.</span> <span class="toc-text">软链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%97%A5%E6%9C%9F%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.3.</span> <span class="toc-text">查看日期和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#date%E5%91%BD%E4%BB%A4"><span class="toc-number">13.3.1.</span> <span class="toc-text">date命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA"><span class="toc-number">13.3.2.</span> <span class="toc-text">使用命令行修改时区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%90%8D"><span class="toc-number">13.4.</span> <span class="toc-text">IP地址与主机名</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%AD%A6%E4%B9%A03"><span class="toc-number">14.</span> <span class="toc-text">Linux学习3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%9B%BA%E5%AE%9AIP"><span class="toc-number">14.1.</span> <span class="toc-text">虚拟机配置固定IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93"><span class="toc-number">14.2.</span> <span class="toc-text">网络传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E4%B8%8E%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="toc-number">14.2.1.</span> <span class="toc-text">下载与网络请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ping%E5%91%BD%E4%BB%A4"><span class="toc-number">14.2.1.1.</span> <span class="toc-text">Ping命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wget"><span class="toc-number">14.2.1.2.</span> <span class="toc-text">wget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#curl"><span class="toc-number">14.2.1.3.</span> <span class="toc-text">curl</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">14.3.</span> <span class="toc-text">端口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nmap%E6%8C%87%E4%BB%A4%E6%9D%A5%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3-netstat%E5%91%BD%E4%BB%A4%E5%8D%A0%E7%94%A8"><span class="toc-number">14.3.0.1.</span> <span class="toc-text">nmap指令来查看端口,netstat命令占用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">14.4.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E7%8A%B6%E6%80%81"><span class="toc-number">14.5.</span> <span class="toc-text">主机状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#df%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98"><span class="toc-number">14.6.</span> <span class="toc-text">df查看磁盘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">14.7.</span> <span class="toc-text">环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">14.7.1.</span> <span class="toc-text">$</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E8%A1%8C%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-number">14.7.2.</span> <span class="toc-text">自行设置变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B"><span class="toc-number">14.8.</span> <span class="toc-text">压缩和解压</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zip"><span class="toc-number">14.9.</span> <span class="toc-text">zip</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95CMake%E6%95%99%E7%A8%8B"><span class="toc-number">15.</span> <span class="toc-text">简单CMake教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B2%E5%98%9B%E7%9A%84%E8%BF%99%E4%B8%AA"><span class="toc-number">15.1.</span> <span class="toc-text">干嘛的这个</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%B8%8B%E8%BD%BD%EF%BC%9F"><span class="toc-number">15.2.</span> <span class="toc-text">怎么下载？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E7%86%9F%E6%82%89%E4%B8%80%E4%B8%8B%EF%BC%81"><span class="toc-number">15.3.</span> <span class="toc-text">先熟悉一下！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PROJECT%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">15.4.</span> <span class="toc-text">PROJECT关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SET%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">15.5.</span> <span class="toc-text">SET关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MESSAGE%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">15.6.</span> <span class="toc-text">MESSAGE关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADD-EXECUTABLE%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">15.7.</span> <span class="toc-text">ADD_EXECUTABLE关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">15.8.</span> <span class="toc-text">语法的基本原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">15.9.</span> <span class="toc-text">语法注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%9E%84%E5%BB%BA%E5%92%8C%E5%A4%96%E9%83%A8%E6%9E%84%E5%BB%BA"><span class="toc-number">15.10.</span> <span class="toc-text">内部构建和外部构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A9Hello-World%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%9B%B4%E5%83%8F%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B"><span class="toc-number">15.11.</span> <span class="toc-text">让Hello World看起来更像一个工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADD-SUBDIRECTORY-%E6%8C%87%E4%BB%A4"><span class="toc-number">15.12.</span> <span class="toc-text">ADD_SUBDIRECTORY 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E4%BF%9D%E5%AD%98%E8%B7%AF%E5%BE%84"><span class="toc-number">15.13.</span> <span class="toc-text">更改二进制的保存路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85HelloWord"><span class="toc-number">15.14.</span> <span class="toc-text">如何安装HelloWord</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6COPYRIGHT%E5%92%8CREADME"><span class="toc-number">15.15.</span> <span class="toc-text">安装文件COPYRIGHT和README</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%ACrunhello-sh"><span class="toc-number">15.16.</span> <span class="toc-text">安装脚本runhello.sh</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-doc-%E4%B8%AD%E7%9A%84-hello-txt"><span class="toc-number">15.17.</span> <span class="toc-text">安装 doc 中的 hello.txt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B"><span class="toc-number">15.18.</span> <span class="toc-text">安装过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">15.19.</span> <span class="toc-text">静态库和动态库的构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="toc-number">15.20.</span> <span class="toc-text">构建实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ADD-LIBRARY"><span class="toc-number">15.20.1.</span> <span class="toc-text">ADD_LIBRARY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-number">15.20.2.</span> <span class="toc-text">同时构建静态和动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SET-TARGET-PROPERTIES"><span class="toc-number">15.20.3.</span> <span class="toc-text">SET_TARGET_PROPERTIES</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">15.21.</span> <span class="toc-text">动态库的版本号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%85%B1%E4%BA%AB%E5%BA%93%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">15.22.</span> <span class="toc-text">安装共享库和头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%85%B1%E4%BA%AB%E5%BA%93%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">15.23.</span> <span class="toc-text">使用外部共享库和头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%EF%BC%9Amake%E5%90%8E%E5%A4%B4%E6%96%87%E4%BB%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">15.24.</span> <span class="toc-text">解决：make后头文件找不到的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%EF%BC%9A%E6%89%BE%E5%88%B0%E5%BC%95%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E9%97%AE%E9%A2%98"><span class="toc-number">15.25.</span> <span class="toc-text">解决：找到引用的函数问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-CMAKE-INCLUDE-PATH-%E5%92%8C-CMAKE-LIBRARY-PATH"><span class="toc-number">15.26.</span> <span class="toc-text">特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Opencv-With-VS"><span class="toc-number">16.</span> <span class="toc-text">Opencv With VS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Opencv-with-Visual-Studio"><span class="toc-number">17.</span> <span class="toc-text">Opencv with Visual Studio</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Version"><span class="toc-number">17.1.</span> <span class="toc-text">C++ Version</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98"><span class="toc-number">17.2.</span> <span class="toc-text">1.环境配置问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A81%EF%BC%9A"><span class="toc-number">17.3.</span> <span class="toc-text">项目入门1：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AA%E5%9B%BE%E5%83%8F"><span class="toc-number">17.3.1.</span> <span class="toc-text">显示一个图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E4%B8%80%E4%B8%AA%E8%A7%86%E9%A2%91"><span class="toc-number">17.3.2.</span> <span class="toc-text">显示一个视频</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A82%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86"><span class="toc-number">17.4.</span> <span class="toc-text">项目入门2：图像处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A%EF%BC%88%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%EF%BC%89"><span class="toc-number">17.5.</span> <span class="toc-text">图像模糊（高斯模糊）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="toc-number">17.5.1.</span> <span class="toc-text">图像边缘检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E8%86%A8%E8%83%80"><span class="toc-number">17.5.2.</span> <span class="toc-text">图像膨胀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E4%BE%B5%E8%9A%80"><span class="toc-number">17.5.3.</span> <span class="toc-text">图像侵蚀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%A4%A7%E5%B0%8F%E8%B0%83%E6%95%B4%E4%B8%8E%E5%8F%98%E6%8D%A2"><span class="toc-number">17.5.4.</span> <span class="toc-text">图像大小调整与变换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Opencv-with-Visual-Studio-1"><span class="toc-number">18.</span> <span class="toc-text">Opencv with Visual Studio</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E5%9B%BE%E5%83%8F%E5%BA%94%E7%94%A8"><span class="toc-number">18.1.</span> <span class="toc-text">纯图像应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Warp%E6%88%91%E4%BB%AC%E7%9A%84%E5%9B%BE%E5%83%8F%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A21"><span class="toc-number">18.2.</span> <span class="toc-text">Warp我们的图像：图像变换1</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Opencv-with-Visual-Studio3"><span class="toc-number">19.</span> <span class="toc-text">Opencv with Visual Studio3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%9C%E8%89%B2%E6%A3%80%E6%B5%8B"><span class="toc-number">19.1.</span> <span class="toc-text">颜色检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Opencv-with-Visual-Studio4"><span class="toc-number">20.</span> <span class="toc-text">Opencv with Visual Studio4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B"><span class="toc-number">20.1.</span> <span class="toc-text">轮廓检测</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Opencv-in-Visual-Studio-5"><span class="toc-number">21.</span> <span class="toc-text">Opencv in Visual Studio 5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB"><span class="toc-number">21.1.</span> <span class="toc-text">人脸识别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pro-1-%E7%94%BB%E7%AC%94%E7%94%BB%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%EF%BC%81"><span class="toc-number">21.2.</span> <span class="toc-text">Pro 1: 画笔画在屏幕上！</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8"><span class="toc-number">22.</span> <span class="toc-text">QT开发入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1"><span class="toc-number">22.1.</span> <span class="toc-text">1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E7%9C%8B%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6"><span class="toc-number">22.2.</span> <span class="toc-text">看看工程文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E7%9C%8B%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8Cwidget-cpp"><span class="toc-number">22.3.</span> <span class="toc-text">看看头文件和widget.cpp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">22.4.</span> <span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE"><span class="toc-number">22.5.</span> <span class="toc-text">创建一个按钮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">22.6.</span> <span class="toc-text">扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-1-%E6%8C%89%E9%92%AE%E7%B1%BB%E7%9A%84%E6%8E%A7%E4%BB%B6"><span class="toc-number">23.</span> <span class="toc-text">5.1 按钮类的控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-1-%E6%8C%89%E9%92%AE%E6%A6%82%E8%BF%B0"><span class="toc-number">23.1.</span> <span class="toc-text">5.1.1 按钮概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-2-QPushButton"><span class="toc-number">23.2.</span> <span class="toc-text">5.1.2 QPushButton</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-3-QRadioButton"><span class="toc-number">23.3.</span> <span class="toc-text">5.1.3 QRadioButton</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-4-QCheckBox"><span class="toc-number">23.4.</span> <span class="toc-text">5.1.4 QCheckBox</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-5-QCommandLinkButton"><span class="toc-number">23.5.</span> <span class="toc-text">5.1.5 QCommandLinkButton</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QT%E5%AF%B9%E8%B1%A1%E6%A0%91"><span class="toc-number">23.6.</span> <span class="toc-text">QT对象树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QT-%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">23.7.</span> <span class="toc-text">QT 坐标系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">23.8.</span> <span class="toc-text">信号与槽的基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A7%BD%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%E7%89%88%E6%9C%AC"><span class="toc-number">23.9.</span> <span class="toc-text">槽函数的重载版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A4%E4%BA%BA%E6%81%BC%E7%81%AB%E7%9A%84%E6%98%AF%EF%BC%9A"><span class="toc-number">23.10.</span> <span class="toc-text">令人恼火的是：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E4%B8%80%E7%82%B9%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD"><span class="toc-number">23.11.</span> <span class="toc-text">高级一点的信号与槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E9%93%BE%E6%8E%A5"><span class="toc-number">23.12.</span> <span class="toc-text">断开链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-1"><span class="toc-number">23.13.</span> <span class="toc-text">扩展阅读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">23.14.</span> <span class="toc-text">补充Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0"><span class="toc-number">23.14.1.</span> <span class="toc-text">1.函数对象参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="toc-number">23.15.</span> <span class="toc-text">工具栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A0%8F"><span class="toc-number">23.16.</span> <span class="toc-text">状态栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">23.17.</span> <span class="toc-text">添加资源文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">23.18.</span> <span class="toc-text">消息对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E7%AA%97%E5%8F%A3%E7%95%8C%E9%9D%A2%E5%B8%83%E5%B1%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">23.19.</span> <span class="toc-text">登录窗口界面布局介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QListWidget%E7%A9%BA%E9%97%B4"><span class="toc-number">23.20.</span> <span class="toc-text">QListWidget空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%8F%E5%85%B8%E5%AE%B9%E5%99%A8%E7%9A%84%E8%8B%A5%E5%B9%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">23.21.</span> <span class="toc-text">一些经典容器的若干操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QListWidget"><span class="toc-number">23.21.1.</span> <span class="toc-text">QListWidget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%9D%A1%E7%9B%AE%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">23.21.2.</span> <span class="toc-text">1）添加条目的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="toc-number">23.22.</span> <span class="toc-text">（2）删除函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9D%A1%E7%9B%AE%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0"><span class="toc-number">23.23.</span> <span class="toc-text">（3）条目访问函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%BD%93%E5%89%8D%E9%80%89%E4%B8%AD%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">23.24.</span> <span class="toc-text">（4）当前选中条目的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">23.25.</span> <span class="toc-text">（5）条目查找和排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%98%BE%E7%A4%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%A1%E7%9B%AE%E7%BC%96%E8%BE%91"><span class="toc-number">23.26.</span> <span class="toc-text">（6）条目显示和运行时条目编辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%85%B6%E4%BB%96%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E5%87%BD%E6%95%B0"><span class="toc-number">23.27.</span> <span class="toc-text">（7）其他信号和槽函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%8E%A7%E4%BB%B6"><span class="toc-number">23.28.</span> <span class="toc-text">主要控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QTreeWidget"><span class="toc-number">23.28.1.</span> <span class="toc-text">QTreeWidget</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="toc-number">23.29.</span> <span class="toc-text">一些详解：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-QTreeWidget"><span class="toc-number">23.29.1.</span> <span class="toc-text">8.3.1 QTreeWidget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%880%EF%BC%89%E6%A0%91%E5%BD%A2%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%9A"><span class="toc-number">23.29.2.</span> <span class="toc-text">（0）树形控件的构造函数很简单：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B7%BB%E5%8A%A0%E5%92%8C%E8%AE%BF%E9%97%AE%E9%A1%B6%E7%BA%A7%E6%9D%A1%E7%9B%AE"><span class="toc-number">23.29.3.</span> <span class="toc-text">（1）添加和访问顶级条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A7%BB%E9%99%A4%E9%A1%B6%E7%BA%A7%E6%9D%A1%E7%9B%AE"><span class="toc-number">23.29.4.</span> <span class="toc-text">（2）移除顶级条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9D%A1%E7%9B%AE%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0-1"><span class="toc-number">23.29.5.</span> <span class="toc-text">（3）条目访问函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%BD%93%E5%89%8D%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">23.29.6.</span> <span class="toc-text">（4）当前条目的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F-1"><span class="toc-number">23.29.7.</span> <span class="toc-text">（5）条目查找和排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%98%BE%E7%A4%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%A1%E7%9B%AE%E7%BC%96%E8%BE%91-1"><span class="toc-number">23.29.8.</span> <span class="toc-text">（6）条目显示和运行时条目编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E4%BF%A1%E5%8F%B7"><span class="toc-number">23.29.9.</span> <span class="toc-text">（7）信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E6%A7%BD%E5%87%BD%E6%95%B0"><span class="toc-number">23.29.10.</span> <span class="toc-text">（8）槽函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%889%EF%BC%89%E5%9F%BA%E7%B1%BB-QTreeView-%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">23.29.11.</span> <span class="toc-text">（9）基类 QTreeView 的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89%E6%A0%91%E5%A4%B4%E6%9D%A1%E7%9B%AE"><span class="toc-number">23.29.12.</span> <span class="toc-text">（10）树头条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89%E9%80%89%E4%B8%AD%E8%A1%8C%E4%B8%BA%E5%92%8C%E9%80%89%E4%B8%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.29.13.</span> <span class="toc-text">（11）选中行为和选中模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%8E%A7%E4%BB%B6-1"><span class="toc-number">23.30.</span> <span class="toc-text">主要控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QTableWidget"><span class="toc-number">23.30.1.</span> <span class="toc-text">QTableWidget</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3"><span class="toc-number">23.31.</span> <span class="toc-text">详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-2-QTableWidgetItem"><span class="toc-number">23.32.</span> <span class="toc-text">8.2.2 QTableWidgetItem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A6%96%E5%85%88%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">23.32.1.</span> <span class="toc-text">（1）首先来看看条目的构造函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A4%8D%E5%88%B6%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="toc-number">23.32.2.</span> <span class="toc-text">（2）复制函数和运算符函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89QTableWidgetItem-%E7%9A%84%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">23.32.3.</span> <span class="toc-text">（3）QTableWidgetItem 的功能函数与内部数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%80%E8%A7%88"><span class="toc-number">23.33.</span> <span class="toc-text">其他常见的控件一览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%8E%A7%E4%BB%B6"><span class="toc-number">23.33.1.</span> <span class="toc-text">滚动条控件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ToolBox"><span class="toc-number">23.33.2.</span> <span class="toc-text">ToolBox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tab-Widget"><span class="toc-number">23.33.3.</span> <span class="toc-text">Tab Widget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8QLable%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87"><span class="toc-number">23.33.4.</span> <span class="toc-text">利用QLable显示图片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6"><span class="toc-number">23.34.</span> <span class="toc-text">自定义控件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QEvent"><span class="toc-number">23.35.</span> <span class="toc-text">QEvent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt-Event%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">23.36.</span> <span class="toc-text">Qt Event事件详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91%EF%BC%9Aevent%E5%87%BD%E6%95%B0"><span class="toc-number">23.36.1.</span> <span class="toc-text">二、事件的分发：event函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Even-Filter%EF%BC%89"><span class="toc-number">23.36.2.</span> <span class="toc-text">三、事件过滤器（Even Filter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">23.36.3.</span> <span class="toc-text">四、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%EF%BC%88QMouseEvent%EF%BC%89"><span class="toc-number">23.37.</span> <span class="toc-text">鼠标事件（QMouseEvent）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA-%E5%9C%A8label%E6%8E%A7%E4%BB%B6%E4%B8%AD%EF%BC%8C%E7%A7%BB%E5%8A%A8%E9%BC%A0%E6%A0%87%E8%8E%B7%E5%8F%96%E5%AE%9E%E6%97%B6%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%B9%B6%E6%98%BE%E7%A4%BA%E5%9C%A8%E7%95%8C%E9%9D%A2%E4%B8%8A"><span class="toc-number">23.37.1.</span> <span class="toc-text">实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8-Even-Filter"><span class="toc-number">23.37.2.</span> <span class="toc-text">三，事件过滤器(Even Filter)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">23.38.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">23.39.</span> <span class="toc-text">类的形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extensive-Reading"><span class="toc-number">23.40.</span> <span class="toc-text">Extensive Reading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">23.41.</span> <span class="toc-text">事件过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extensive-Reading-1"><span class="toc-number">23.42.</span> <span class="toc-text">Extensive Reading</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Qt%E4%B8%AD%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%E8%AF%A6%E8%A7%A3"><span class="toc-number">23.42.1.</span> <span class="toc-text">一、Qt中事件过滤器详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">23.42.2.</span> <span class="toc-text">事件过滤器使用的三种方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE"><span class="toc-number">23.42.3.</span> <span class="toc-text">尾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0Windows-API%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89"><span class="toc-number">24.</span> <span class="toc-text">简单学习Windows API（入门）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%AF%BC1"><span class="toc-number">24.1.</span> <span class="toc-text">前导1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%AF%BC"><span class="toc-number">24.2.</span> <span class="toc-text">前导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E8%AF%95%E4%B8%80%E6%89%8B"><span class="toc-number">24.3.</span> <span class="toc-text">小试一手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%90%E4%B8%80%E8%A7%A3%E9%87%8A"><span class="toc-number">24.4.</span> <span class="toc-text">逐一解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#include-lt-Windows-h-gt"><span class="toc-number">24.4.1.</span> <span class="toc-text">#include&lt; Windows.h &gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-WINAPI-WinMain-HINSTANCE-hInstance-HINSTANCE-hPrevInstance-LPSTR-ipCmdLine-int-nCmdShow"><span class="toc-number">24.4.2.</span> <span class="toc-text">int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#What-is-WINAPI"><span class="toc-number">24.4.2.1.</span> <span class="toc-text">What is WINAPI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E6%B3%A8%EF%BC%9F"><span class="toc-number">24.4.2.2.</span> <span class="toc-text">批注？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MessageBox%E5%87%BD%E6%95%B0"><span class="toc-number">24.4.3.</span> <span class="toc-text">MessageBox函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">24.4.3.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">24.4.3.2.</span> <span class="toc-text">参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">24.5.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">24.6.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">24.6.0.1.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%AF%BC2"><span class="toc-number">24.7.</span> <span class="toc-text">前导2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BB%E9%A2%98"><span class="toc-number">24.8.</span> <span class="toc-text">字符串主题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">24.8.1.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wchar-t%E7%B1%BB%E5%9E%8B"><span class="toc-number">24.8.2.</span> <span class="toc-text">wchar_t类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E4%B8%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AE%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">24.8.3.</span> <span class="toc-text">Windows下的字符和宽字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%B7%A5%E4%BD%9C"><span class="toc-number">24.9.</span> <span class="toc-text">常见的字符串处理工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">24.9.1.</span> <span class="toc-text">获取字符串的长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%AF%BC3"><span class="toc-number">24.10.</span> <span class="toc-text">前导3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%A4%E8%AF%86Windows%E7%AA%97%E5%8F%A3"><span class="toc-number">24.11.</span> <span class="toc-text">1.认识Windows窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#demo"><span class="toc-number">24.12.</span> <span class="toc-text">demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A81"><span class="toc-number">24.13.</span> <span class="toc-text">系统入门1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%80%E7%9C%8B"><span class="toc-number">24.14.</span> <span class="toc-text">数据类型一看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"><span class="toc-number">24.15.</span> <span class="toc-text">API基础函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6demo"><span class="toc-number">24.16.</span> <span class="toc-text">读取文件demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read-file"><span class="toc-number">24.17.</span> <span class="toc-text">read file</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#createFileW-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">24.17.1.</span> <span class="toc-text">createFileW 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="toc-number">24.17.1.1.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-1"><span class="toc-number">24.17.1.2.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E8%A1%8C%E4%B8%BA"><span class="toc-number">24.17.1.3.</span> <span class="toc-text">符号链接行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A1%8C%E4%B8%BA"><span class="toc-number">24.17.1.4.</span> <span class="toc-text">缓存行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">24.17.1.5.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5-I-O-%E5%8F%A5%E6%9F%84"><span class="toc-number">24.17.1.6.</span> <span class="toc-text">同步和异步 I&#x2F;O 句柄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">24.17.1.7.</span> <span class="toc-text">文件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">24.17.1.8.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%A3%81%E7%9B%98%E5%92%8C%E5%8D%B7"><span class="toc-number">24.17.1.9.</span> <span class="toc-text">物理磁盘和卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%99%A8%E8%AE%BE%E5%A4%87"><span class="toc-number">24.17.1.10.</span> <span class="toc-text">更改器设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E5%B8%A6%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="toc-number">24.17.1.11.</span> <span class="toc-text">磁带驱动器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E8%B5%84%E6%BA%90"><span class="toc-number">24.17.1.12.</span> <span class="toc-text">通信资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA"><span class="toc-number">24.17.1.13.</span> <span class="toc-text">机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mailslots"><span class="toc-number">24.17.1.14.</span> <span class="toc-text">Mailslots</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">24.17.1.15.</span> <span class="toc-text">管道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadFile-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">24.17.2.</span> <span class="toc-text">ReadFile 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">24.17.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-1"><span class="toc-number">24.17.2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number">24.17.2.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-2"><span class="toc-number">24.17.2.4.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE"><span class="toc-number">24.17.2.5.</span> <span class="toc-text">同步和文件位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-1"><span class="toc-number">24.17.2.6.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">24.17.2.7.</span> <span class="toc-text">事务处理的操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F2"><span class="toc-number">24.18.</span> <span class="toc-text">系统2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">24.19.</span> <span class="toc-text">Windows数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%B2%E8%A7%A3"><span class="toc-number">24.20.</span> <span class="toc-text">一些函数的讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetFileAttributesEx"><span class="toc-number">24.20.1.</span> <span class="toc-text">GetFileAttributesEx()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GetFileAttributesExW-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">24.20.1.1.</span> <span class="toc-text">GetFileAttributesExW 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">24.20.1.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-2"><span class="toc-number">24.20.1.1.2.</span> <span class="toc-text">参数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="toc-number">24.21.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="toc-number">24.22.</span> <span class="toc-text">获取时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95"><span class="toc-number">24.23.</span> <span class="toc-text">获取系统目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetSystemDirectoryW-%E5%87%BD%E6%95%B0-sysinfoapi-h"><span class="toc-number">24.23.1.</span> <span class="toc-text">GetSystemDirectoryW 函数 (sysinfoapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-3"><span class="toc-number">24.23.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-3"><span class="toc-number">24.23.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-4"><span class="toc-number">24.23.1.3.</span> <span class="toc-text">返回值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="toc-number">24.24.</span> <span class="toc-text">创建窗口和消息处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F3"><span class="toc-number">24.25.</span> <span class="toc-text">系统3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APIEntry"><span class="toc-number">24.26.</span> <span class="toc-text">APIEntry:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DialogBox"><span class="toc-number">24.27.</span> <span class="toc-text">DialogBox</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-4"><span class="toc-number">24.27.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-4"><span class="toc-number">24.27.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8"><span class="toc-number">24.27.3.</span> <span class="toc-text">备注</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MAKEINTERSOURCE"><span class="toc-number">24.28.</span> <span class="toc-text">MAKEINTERSOURCE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">24.29.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F4"><span class="toc-number">24.30.</span> <span class="toc-text">系统4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%88%E6%9C%AC%E7%9A%84char%E7%B1%BB%E5%9E%8B"><span class="toc-number">24.31.</span> <span class="toc-text">三大版本的char类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2"><span class="toc-number">24.32.</span> <span class="toc-text">字符转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MultiByteToWideChar"><span class="toc-number">24.32.1.</span> <span class="toc-text">MultiByteToWideChar();</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-5"><span class="toc-number">24.32.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-5"><span class="toc-number">24.32.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-5"><span class="toc-number">24.32.1.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-3"><span class="toc-number">24.32.1.4.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">24.32.1.5.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WideCharToMultiByte"><span class="toc-number">24.32.2.</span> <span class="toc-text">WideCharToMultiByte</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">24.32.2.1.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E4%BE%8B"><span class="toc-number">24.32.2.2.</span> <span class="toc-text">范例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F5"><span class="toc-number">24.33.</span> <span class="toc-text">系统5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%8D%B7-GetLogicalDriveStrings"><span class="toc-number">24.34.</span> <span class="toc-text">遍历卷 GetLogicalDriveStrings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%B7"><span class="toc-number">24.35.</span> <span class="toc-text">查看第一个卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extensive-Reading-for-Microsoft-API"><span class="toc-number">24.36.</span> <span class="toc-text">Extensive Reading for Microsoft API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZeroMemory-%E5%AE%8F-wdm-h"><span class="toc-number">24.36.1.</span> <span class="toc-text">ZeroMemory 宏 (wdm.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-6"><span class="toc-number">24.36.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-6"><span class="toc-number">24.36.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-6"><span class="toc-number">24.36.1.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8-1"><span class="toc-number">24.36.1.4.</span> <span class="toc-text">备注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E4%B8%8A"><span class="toc-number">24.36.1.5.</span> <span class="toc-text">本质上</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getLogicalDriveStrings%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">24.36.2.</span> <span class="toc-text">getLogicalDriveStrings函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-7"><span class="toc-number">24.36.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-7"><span class="toc-number">24.36.2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-7"><span class="toc-number">24.36.2.3.</span> <span class="toc-text">返回值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-4"><span class="toc-number">24.37.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FindFirstVolume-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">24.37.1.</span> <span class="toc-text">FindFirstVolume 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-8"><span class="toc-number">24.37.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-8"><span class="toc-number">24.37.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-8"><span class="toc-number">24.37.1.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-5"><span class="toc-number">24.37.1.4.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FindNextVolume-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">24.37.2.</span> <span class="toc-text">FindNextVolume 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-9"><span class="toc-number">24.37.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-9"><span class="toc-number">24.37.2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-9"><span class="toc-number">24.37.2.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-6"><span class="toc-number">24.37.2.4.</span> <span class="toc-text">注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%A9%B1%E5%8A%A8%E5%99%A8%E5%B1%9E%E6%80%A7-GetDriverType-amp-amp-GetVolumeInformation"><span class="toc-number">24.38.</span> <span class="toc-text">查看驱动器属性 GetDriverType &amp;&amp; GetVolumeInformation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extensive-Reading-for-Microsoft-API-1"><span class="toc-number">24.39.</span> <span class="toc-text">Extensive Reading for Microsoft API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getDriveType-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">24.39.1.</span> <span class="toc-text">getDriveType 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-10"><span class="toc-number">24.39.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-10"><span class="toc-number">24.39.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-10"><span class="toc-number">24.39.1.3.</span> <span class="toc-text">返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getVolumeInformationW-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">24.39.2.</span> <span class="toc-text">getVolumeInformationW 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-11"><span class="toc-number">24.39.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-11"><span class="toc-number">24.39.2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-11"><span class="toc-number">24.39.2.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-7"><span class="toc-number">24.39.2.4.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E8%A1%8C%E4%B8%BA-1"><span class="toc-number">24.39.2.5.</span> <span class="toc-text">符号链接行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C"><span class="toc-number">24.39.2.6.</span> <span class="toc-text">事务处理操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8-2"><span class="toc-number">24.39.2.6.1.</span> <span class="toc-text">备注</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F6"><span class="toc-number">24.40.</span> <span class="toc-text">系统6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F"><span class="toc-number">24.41.</span> <span class="toc-text">查看磁盘容量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetDiskFreeSpace-amp-amp-GetDiskFreeSpaceEx"><span class="toc-number">24.41.1.</span> <span class="toc-text">GetDiskFreeSpace &amp;&amp; GetDiskFreeSpaceEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getDiskFreeSpace-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">24.41.2.</span> <span class="toc-text">getDiskFreeSpace 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-12"><span class="toc-number">24.41.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-12"><span class="toc-number">24.41.2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-12"><span class="toc-number">24.41.2.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-8"><span class="toc-number">24.41.2.4.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getDiskFreeSpaceEx%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">24.41.3.</span> <span class="toc-text">getDiskFreeSpaceEx函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-13"><span class="toc-number">24.41.3.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-13"><span class="toc-number">24.41.3.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-13"><span class="toc-number">24.41.3.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-9"><span class="toc-number">24.41.3.4.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ULARGE-INTEGER-union-winnt-h"><span class="toc-number">24.41.4.</span> <span class="toc-text">ULARGE_INTEGER union (winnt.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-14"><span class="toc-number">24.41.4.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98"><span class="toc-number">24.41.4.2.</span> <span class="toc-text">成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8-3"><span class="toc-number">24.41.4.3.</span> <span class="toc-text">备注</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F7"><span class="toc-number">24.42.</span> <span class="toc-text">系统7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">24.43.</span> <span class="toc-text">文件操作的四种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAMFC"><span class="toc-number">24.44.</span> <span class="toc-text">创建MFC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clear%E6%8C%89%E9%92%AE"><span class="toc-number">24.45.</span> <span class="toc-text">clear按钮</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-15"><span class="toc-number">24.45.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-14"><span class="toc-number">24.45.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-14"><span class="toc-number">24.45.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-10"><span class="toc-number">24.45.4.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%96%B9%E5%BC%8F"><span class="toc-number">24.46.</span> <span class="toc-text">C  方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%96%B9%E5%BC%8F-1"><span class="toc-number">24.47.</span> <span class="toc-text">C++ 方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-API"><span class="toc-number">24.48.</span> <span class="toc-text">Windows API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-MFC"><span class="toc-number">24.49.</span> <span class="toc-text">Windows MFC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F8"><span class="toc-number">24.50.</span> <span class="toc-text">系统8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DeleteFile"><span class="toc-number">24.51.</span> <span class="toc-text">DeleteFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-16"><span class="toc-number">24.51.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-15"><span class="toc-number">24.51.2.</span> <span class="toc-text">参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-15"><span class="toc-number">24.52.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-11"><span class="toc-number">24.53.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyFile"><span class="toc-number">24.54.</span> <span class="toc-text">CopyFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-17"><span class="toc-number">24.54.1.</span> <span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-16"><span class="toc-number">24.55.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-16"><span class="toc-number">24.56.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-12"><span class="toc-number">24.57.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MoveFile"><span class="toc-number">24.58.</span> <span class="toc-text">MoveFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-18"><span class="toc-number">24.58.1.</span> <span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-17"><span class="toc-number">24.59.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-17"><span class="toc-number">24.60.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-13"><span class="toc-number">24.61.</span> <span class="toc-text">注解</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/ModernCPP-SmartPointer/" title="ModernCPP-SmartPointer"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ModernCPP-SmartPointer"/></a><div class="content"><a class="title" href="/2023/06/06/ModernCPP-SmartPointer/" title="ModernCPP-SmartPointer">ModernCPP-SmartPointer</a><time datetime="2023-06-06T15:00:39.000Z" title="发表于 2023-06-06 23:00:39">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/Algorithm-RecursionSpecial/" title="Algorithm_RecursionSpecial"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Algorithm_RecursionSpecial"/></a><div class="content"><a class="title" href="/2023/06/06/Algorithm-RecursionSpecial/" title="Algorithm_RecursionSpecial">Algorithm_RecursionSpecial</a><time datetime="2023-06-06T14:55:23.000Z" title="发表于 2023-06-06 22:55:23">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/Learn-ROS-I/" title="Learn_ROS-I"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Learn_ROS-I"/></a><div class="content"><a class="title" href="/2023/06/06/Learn-ROS-I/" title="Learn_ROS-I">Learn_ROS-I</a><time datetime="2023-06-06T14:51:31.000Z" title="发表于 2023-06-06 22:51:31">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/Learn-Qt-I/" title="Learn_Qt-I"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Learn_Qt-I"/></a><div class="content"><a class="title" href="/2023/06/06/Learn-Qt-I/" title="Learn_Qt-I">Learn_Qt-I</a><time datetime="2023-06-06T14:45:12.000Z" title="发表于 2023-06-06 22:45:12">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/Learn-Windows-API-Semester-I/" title="Learn_Windows_API-Semester-I"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Learn_Windows_API-Semester-I"/></a><div class="content"><a class="title" href="/2023/06/06/Learn-Windows-API-Semester-I/" title="Learn_Windows_API-Semester-I">Learn_Windows_API-Semester-I</a><time datetime="2023-06-06T14:38:31.000Z" title="发表于 2023-06-06 22:38:31">2023-06-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>