<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Learn_Windows_API-Semester-I | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="系统学习Windows API初探​        写在前面：这是本菜鸟首次对一个大的topic有巨大的兴趣，正好，本人对桌面应用开发有动力研究，这里就以Windows API　编程作为自己串起来操作系统，并发编程，C++基本程序设计应用，以及底层QT开发的一个Application demo了！ 前导​        还记得你在实验课上使用老古董 VS2010，当你选择了空项目开发后必须手动使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Learn_Windows_API-Semester-I">
<meta property="og:url" content="http://charliechen114514.github.io/2023/06/06/Learn-Windows-API-Semester-I/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="系统学习Windows API初探​        写在前面：这是本菜鸟首次对一个大的topic有巨大的兴趣，正好，本人对桌面应用开发有动力研究，这里就以Windows API　编程作为自己串起来操作系统，并发编程，C++基本程序设计应用，以及底层QT开发的一个Application demo了！ 前导​        还记得你在实验课上使用老古董 VS2010，当你选择了空项目开发后必须手动使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-06-06T14:38:31.000Z">
<meta property="article:modified_time" content="2024-01-15T06:00:26.885Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Windows 32API">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/06/06/Learn-Windows-API-Semester-I/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Learn_Windows_API-Semester-I',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-15 14:00:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Learn_Windows_API-Semester-I</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-06T14:38:31.000Z" title="发表于 2023-06-06 22:38:31">2023-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-15T06:00:26.885Z" title="更新于 2024-01-15 14:00:26">2024-01-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">35k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>127分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Learn_Windows_API-Semester-I"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="系统学习Windows-API"><a href="#系统学习Windows-API" class="headerlink" title="系统学习Windows API"></a>系统学习Windows API</h1><h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>​        写在前面：这是本菜鸟首次对一个大的topic有巨大的兴趣，正好，本人对桌面应用开发有动力研究，这里就以Windows API　编程作为自己串起来操作系统，并发编程，C++基本程序设计应用，以及底层QT开发的一个Application demo了！</p>
<h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><p>​        还记得你在实验课上使用老古董 VS2010，当你选择了空项目开发后必须手动使用</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">system(&quot;pause&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这个函数嘛？不错，他就是我们Windows API的一个。目的是让程序暂停在此句！我们应用的头文件是：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们的主角来了哈哈哈</p>
<h2 id="小试一手"><a href="#小试一手" class="headerlink" title="小试一手"></a>小试一手</h2><p>​        创建你的一个项目，不够今天，我们创建的是一个桌面向导项目，随后，我们选择空项目创建，将：</p>
<p><img src="image-20230504215411467.png" alt="image-20230504215411467"></p>
<p>改成：</p>
<p><img src="image-20230504215354973.png" alt="image-20230504215354973"></p>
<p>​    以及转到：（右键项目选择属性）</p>
<p>​    把控制台改成窗口输出！不然编译器会在下面的程序中报错！</p>
<p><img src="image-20230504215458663.png" alt="image-20230504215458663"></p>
<p>​        我们书写一个简单的C++程序！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)
&#123;
	MessageBox(NULL, TEXT(&quot;Hello, World&quot;), TEXT(&quot;Captions&quot;), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);

	return 0;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        F5一下：</p>
<p><img src="image-20230504215640299.png" alt="image-20230504215640299"></p>
<p>​        6！</p>
<h2 id="逐一解释"><a href="#逐一解释" class="headerlink" title="逐一解释"></a>逐一解释</h2><h3 id="include-lt-Windows-h-gt"><a href="#include-lt-Windows-h-gt" class="headerlink" title="#include&lt; Windows.h &gt;"></a>#include&lt; Windows.h &gt;</h3><p>​        我们老规矩，先来看看Windows.h装了啥：</p>
<p><img src="image-20230504220523073.png" alt="image-20230504220523073"></p>
<p>​        反正一大堆，但是核心就这些，这是我们需要注意的！</p>
<h3 id="int-WINAPI-WinMain-HINSTANCE-hInstance-HINSTANCE-hPrevInstance-LPSTR-ipCmdLine-int-nCmdShow"><a href="#int-WINAPI-WinMain-HINSTANCE-hInstance-HINSTANCE-hPrevInstance-LPSTR-ipCmdLine-int-nCmdShow" class="headerlink" title="int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)"></a>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)</h3><p>​        </p>
<p>​        一个函数！有些人奇怪了，什么玩意？C++程序没有int main(), 就像西方没有耶路撒冷一样！不是的！</p>
<p>​        在Windows桌面开发下，他就是我们的main函数。在Microsoft API Platform SDK下，我们查阅到：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int WINAPI WinMain(  
HINSTANCE hInstance,      
&#x2F;&#x2F; handle to current instance   
HINSTANCE hPrevInstance,  
&#x2F;&#x2F; handle to previous instance   
LPSTR lpCmdLine,        
&#x2F;&#x2F; command line  
int nCmdShow        
&#x2F;&#x2F;  show stat
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230504222032978.png" alt="image-20230504222032978"></p>
<h4 id="What-is-WINAPI"><a href="#What-is-WINAPI" class="headerlink" title="What is WINAPI"></a>What is WINAPI</h4><p>​        光标移动到上面： __stdcall 这是啥呢？标准调用！</p>
<p>​        被这个关键字修饰的函数，其参数都是从右向左通过堆栈传递的(__fastcall 的前面部分由ecx,edx传)， 函数调用在返回前要由被调用者清理堆栈。</p>
<p>​        啥？你不相信？反汇编我们产生的EXE文件就OK了：在MessageW处打一个断点，运行之找到</p>
<p><img src="image-20230504231052021.png" alt="image-20230504231052021"></p>
<p>​        大多数电脑采用的是大端法，也就是说可以理解为：参数在右边的，先被推送进函数里去</p>
<h4 id="批注？"><a href="#批注？" class="headerlink" title="批注？"></a>批注？</h4><p><img src="image-20230504231254737.png" alt="image-20230504231254737"></p>
<p>​        什么是批注呢请看我们函数和头文件下的：</p>
<p><img src="image-20230504231338650.png" alt="image-20230504231338650"></p>
<p>​        看看_ In _这个宏，他就是一个说明参数性质的宏！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++"> &#x2F;&#x2F; from sal.h
_In_     : input parameter to a function, unmodified by called function
      _Out_    : output parameter, written to by called function, pointed-to
                 location not expected to be initialized prior to call
      _Outptr_ : like _Out_ when returned variable is a pointer type
                 (so param is pointer-to-pointer type). Called function
                 provides&#x2F;allocated space.
      _Outref_ : like _Outptr_, except param is reference-to-pointer type.
      _Inout_  : inout parameter, read from and potentially modified by
                 called function.
      _Ret_    : for return values
      _Field_  : class&#x2F;struct field invariants<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        In 表明他是一个输入参数，有点像const 一样，函数读取值但是不可以修改它！</p>
<p>​        InOut就是表示这是一个这样的值：传入又传出，值会被修改</p>
<p>​        Out表示这个值会被这个函数设置</p>
<p>​        OutPtr 表示返回这个值的指针</p>
<p>​        Microsoft对参数合理性做出了更多的解释：类似于main函数一样</p>
<pre class="line-numbers language-none"><code class="language-none">[in] hInstance

类型： HINSTANCE

应用程序的当前实例的句柄。

[in] hPrevInstance

类型： HINSTANCE

应用程序的上一个实例的句柄。 此参数始终为 NULL。 如果需要检测另一个实例是否已存在，请使用 CreateMutex 函数创建唯一命名的互斥体。 即使互斥体已存在，CreateMutex 也会成功，但函数将返回ERROR_ALREADY_EXISTS。 这表示应用程序的另一个实例存在，因为它首先创建了互斥体。 但是，恶意用户可以在执行之前创建此互斥体，并阻止应用程序启动。 为防止这种情况，请创建一个随机命名的互斥体并存储名称，以便它只能由授权用户获取。 或者，可以使用文件进行此目的。 若要将应用程序限制为每个用户的一个实例，请在用户配置文件目录中创建锁定的文件。

[in] lpCmdLine

类型： LPSTR

应用程序的命令行，不包括程序名称。 若要检索整个命令行，请使用 GetCommandLine 函数。

[in] nShowCmd

类型： int

控制窗口的显示方式。 此参数可以是可在 ShowWindow 函数的 nCmdShow 参数中指定的任何值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显示一个模式对话框，其中包含系统图标、一组按钮和一条简短的应用程序特定消息，例如状态或错误信息。 消息框返回一个整数值，该值指示用户单击的按钮。</p>
<h3 id="MessageBox函数"><a href="#MessageBox函数" class="headerlink" title="MessageBox函数"></a>MessageBox函数</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">MessageBox</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> HWND    hWnd<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPCTSTR lpText<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPCTSTR lpCaption<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>           UINT    uType
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] hWnd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型：<strong>HWND</strong></p>
<p>要创建的消息框的所有者窗口的句柄。 如果此参数为 <strong>NULL</strong>，则消息框没有所有者窗口。</p>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] lpText<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>LPCTSTR</strong></p>
<p>要显示的消息。 如果字符串包含多个行，则可以使用回车符和/或换行符分隔每行之间的行。</p>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] lpCaption<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>LPCTSTR</strong></p>
<p>对话框标题。 如果此参数为 <strong>NULL</strong>，则默认标题为 <strong>Error</strong>。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] uType<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>UINT</strong></p>
<p>对话框的内容和行为。 此参数可以是以下标志组中的标志的组合。</p>
<p>若要指示消息框中显示的按钮，请指定以下值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_ABORTRETRYIGNORE</strong>0x00000002L</td>
<td style="text-align:left">消息框包含三个推送按钮： <strong>中止</strong>、 <strong>重试</strong>和 <strong>忽略</strong>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_CANCELTRYCONTINUE</strong>0x00000006L</td>
<td style="text-align:left">消息框包含三个按下按钮： <strong>“取消</strong>”、“ <strong>重试</strong>”、“ <strong>继续</strong>”。 使用此消息框类型，而不是MB_ABORTRETRYIGNORE。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_HELP</strong>0x00004000L</td>
<td style="text-align:left">向消息框添加 <strong>“帮助</strong> ”按钮。 当用户单击 <strong>“帮助</strong> ”按钮或按 F1 时，系统会向所有者发送 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/shell/wm-help">WM_HELP</a> 消息。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_OK</strong>0x00000000L</td>
<td style="text-align:left">消息框包含一个按钮： <strong>确定</strong>。 这是默认值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_OKCANCEL</strong>0x00000001L</td>
<td style="text-align:left">消息框包含两个推送按钮： <strong>“确定</strong> ”和 <strong>“取消</strong>”。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_RETRYCANCEL</strong>0x00000005L</td>
<td style="text-align:left">消息框包含两个按下按钮： <strong>重试</strong> 和 <strong>取消</strong>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_YESNO</strong>0x00000004L</td>
<td style="text-align:left">消息框包含两个按下按钮： <strong>是</strong> 和 <strong>否</strong>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_YESNOCANCEL</strong>0x00000003L</td>
<td style="text-align:left">消息框包含三个按钮： <strong>是</strong>、 <strong>否</strong>和 <strong>取消</strong>。</td>
</tr>
</tbody>
</table>
</div>
<p>若要在消息框中显示图标，请指定以下值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_ICONEXCLAMATION</strong>0x00000030L</td>
<td style="text-align:left">消息框中会显示一个感叹号图标。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONWARNING</strong>0x00000030L</td>
<td style="text-align:left">消息框中会显示一个感叹号图标。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONINFORMATION</strong>0x00000040L</td>
<td style="text-align:left">图标由圆圈中的小写字母 <em>i</em> 组成，显示在消息框中。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONASTERISK</strong>0x00000040L</td>
<td style="text-align:left">图标由圆圈中的小写字母 <em>i</em> 组成，显示在消息框中。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONQUESTION</strong>0x00000020L</td>
<td style="text-align:left">消息框中会显示一个问号图标。 不再建议使用问号消息图标，因为这种图标无法清楚地表示特定类型的消息，并且作为问题的消息表述可应用于任何消息类型。 此外，用户可能会将问号消息符号与帮助信息混淆。 因此，不要在消息框中使用问号消息符号。 系统继续支持它包含的内容，只为满足反向兼容性。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONSTOP</strong>0x00000010L</td>
<td style="text-align:left">消息框中会显示一个停止符号图标。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONERROR</strong>0x00000010L</td>
<td style="text-align:left">消息框中会显示一个停止符号图标。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ICONHAND</strong>0x00000010L</td>
<td style="text-align:left">消息框中会显示一个停止符号图标。</td>
</tr>
</tbody>
</table>
</div>
<p>若要指示默认按钮，请指定以下值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_DEFBUTTON1</strong>0x00000000L</td>
<td style="text-align:left">第一个按钮是默认按钮。除非指定<strong>了MB_DEFBUTTON2</strong>、MB_DEFBUTTON3或<strong>MB_DEFBUTTON4</strong>，<strong>否则</strong>MB_DEFBUTTON1<strong>是默认值</strong>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_DEFBUTTON2</strong>0x00000100L</td>
<td style="text-align:left">第二个按钮是默认按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_DEFBUTTON3</strong>0x00000200L</td>
<td style="text-align:left">第三个按钮是默认按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_DEFBUTTON4</strong>0x00000300L</td>
<td style="text-align:left">第四个按钮是默认按钮。</td>
</tr>
</tbody>
</table>
</div>
<p>若要指示对话框的形式，请指定以下值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_APPLMODAL</strong>0x00000000L</td>
<td style="text-align:left">在 <em>hWnd</em> 参数标识的窗口中继续工作之前，用户必须响应消息框。 但是，用户可以移动到其他线程的窗口，并在这些窗口中工作。根据应用程序中的窗口层次结构，用户可能能够移动到线程中的其他窗口。 消息框父级的所有子窗口都将自动禁用，但弹出窗口不是。如果未指定<strong>MB_SYSTEMMODAL</strong>或<strong>MB_TASKMODAL</strong>，<strong>则MB_APPLMODAL</strong>为默认值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_SYSTEMMODAL</strong>0x00001000L</td>
<td style="text-align:left">与MB_APPLMODAL相同，消息框具有 <strong>WS_EX_TOPMOST</strong> 样式。 使用系统模式消息框通知用户严重、潜在的破坏性错误，例如， (立即引起注意，) 内存不足。 此标志不会影响用户与 <em>与 hWnd</em> 关联的窗口以外的窗口交互的能力。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_TASKMODAL</strong>0x00002000L</td>
<td style="text-align:left">与 <strong>MB_APPLMODAL</strong> 相同，如果 <em>hWnd</em> 参数为 <strong>NULL</strong>，则禁用属于当前线程的所有顶级窗口。 当调用应用程序或库没有可用的窗口句柄时，请使用此标志，但仍需要防止输入到调用线程中的其他窗口，而不会挂起其他线程。</td>
</tr>
</tbody>
</table>
</div>
<p>若要指定其他选项，请使用以下一个或多个值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_DEFAULT_DESKTOP_ONLY</strong>0x00020000L</td>
<td style="text-align:left">与交互式窗口工作站的桌面相同。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/winstation/window-stations">窗口工作站</a>。如果当前输入桌面不是默认桌面，则在用户切换到默认桌面之前， <strong>MessageBox</strong> 不会返回。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_RIGHT</strong>0x00080000L</td>
<td style="text-align:left">文本是右对齐的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_RTLREADING</strong>0x00100000L</td>
<td style="text-align:left">在希伯来语和阿拉伯语系统上使用从右到左阅读顺序显示消息和标题文本。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_SETFOREGROUND</strong>0x00010000L</td>
<td style="text-align:left">消息框将成为前台窗口。 在内部，系统调用消息框的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-setforegroundwindow">SetForegroundWindow</a> 函数。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_TOPMOST</strong>0x00040000L</td>
<td style="text-align:left">消息框是使用 <strong>WS_EX_TOPMOST</strong> 窗口样式创建的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_SERVICE_NOTIFICATION</strong>0x00200000L</td>
<td style="text-align:left">调用方是通知用户某个事件的服务。 该函数在当前活动桌面上显示一个消息框，即使没有用户登录到计算机也是如此。<strong>终端服务：</strong> 如果调用线程具有模拟令牌，该函数会将消息框定向到模拟令牌中指定的会话。如果设置了此标志， <em>则 hWnd</em> 参数必须为 <strong>NULL</strong>。 这样，消息框可以出现在桌面上，而不是与 <em>hWnd</em> 对应的桌面。有关使用此标志的安全注意事项的信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Services/interactive-services">Interactive Services</a>。 具体而言，请注意，此标志可以在锁定的桌面上生成交互式内容，因此应仅用于一组非常有限的方案，例如资源耗尽。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>类型： <strong>int</strong></p>
<p>如果消息框有 <strong>“取消</strong> ”按钮，则函数返回 <strong>IDCANCEL</strong> 值（如果按下 ESC 键或选中 <strong>“取消</strong> ”按钮）。 如果消息框没有 <strong>“取消</strong> ”按钮，则按 ESC 将不起作用 -除非存在MB_OK按钮。 如果显示MB_OK按钮，并且用户按 ESC，则返回值为 <strong>IDOK</strong>。</p>
<p>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<p>如果函数成功，则返回值为以下菜单项值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">返回代码/值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>IDABORT</strong>3</td>
<td style="text-align:left">已选择 <strong>“中止</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDCANCEL</strong>2</td>
<td style="text-align:left">已选择“ <strong>取消</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDCONTINUE</strong>11</td>
<td style="text-align:left">已选择 <strong>“继续</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDIGNORE</strong>5</td>
<td style="text-align:left">已选择 <strong>“忽略</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDNO</strong>7</td>
<td style="text-align:left">已选择 <strong>“无</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDOK</strong>1</td>
<td style="text-align:left">已选择 <strong>“确定</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDRETRY</strong>4</td>
<td style="text-align:left">已选择 <strong>“重试</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDTRYAGAIN</strong>10</td>
<td style="text-align:left">已选择 <strong>“重试</strong> ”按钮。</td>
</tr>
<tr>
<td style="text-align:left"><strong>IDYES</strong>6</td>
<td style="text-align:left">已选择 <strong>“是</strong> ”按钮。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>通过将 <em>uType</em> 参数设置为相应的标志值，可以在消息框中使用以下系统图标。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">图标</th>
<th style="text-align:left">标志值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><img src="mb_iconhand.png" alt="MB_ICONHAND、MB_ICONSTOP和MB_ICONERROR图标"></td>
<td style="text-align:left"><strong>MB_ICONHAND</strong>、 <strong>MB_ICONSTOP</strong>或 <strong>MB_ICONERROR</strong></td>
</tr>
<tr>
<td style="text-align:left"><img src="mb_iconquestion.png" alt="MB_ICONQUESTION图标"></td>
<td style="text-align:left"><strong>MB_ICONQUESTION</strong></td>
</tr>
<tr>
<td style="text-align:left"><img src="mb_iconexclamation.png" alt="MB_ICONEXCLAMATION和MB_ICONWARNING图标"></td>
<td style="text-align:left"><strong>MB_ICONEXCLAMATION</strong> 或 <strong>MB_ICONWARNING</strong></td>
</tr>
<tr>
<td style="text-align:left"><img src="mb_iconasterisk.png" alt="MB_ICONASTERISK和MB_ICONINFORMATION图标"></td>
<td style="text-align:left"><strong>MB_ICONASTERISK</strong> 或 <strong>MB_ICONINFORMATION</strong></td>
</tr>
</tbody>
</table>
</div>
<p>在 MessageBox 显示字符串开头的 Unicode 格式字符 U+200F 表示 (RL) M 添加两个从右到左标记，以便使 MessageBox 的读取顺序呈现为从右到左 (RTL) 。</p>
<p>使用系统模式消息框指示系统内存不足时， <em>lpText</em> 和 <em>lpCaption</em> 参数指向的字符串不应从资源文件中获取，因为尝试加载资源可能会失败。</p>
<p>如果在对话框存在时创建消息框，请使用对话框的句柄作为 <em>hWnd</em> 参数。 <em>hWnd</em> 参数不应标识子窗口，如对话框中的控件。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在以下示例中，应用程序显示一个消息框，该消息框在出现错误条件后提示用户执行操作。 消息框显示描述错误条件以及如何解决错误条件的消息。 <strong>MB_CANCELTRYCONTINUE</strong>样式指示 <strong>MessageBox</strong> 提供三个按钮，用户可以选择如何继续操作。 <strong>MB_DEFBUTTON2</strong>样式将默认焦点设置为消息框的第二个按钮，在本例中为<strong>“重试”</strong>按钮。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;Windows.h></span></span>

<span class="token keyword">void</span> WINAPI <span class="token function">doSomethingHalt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

	<span class="token keyword">int</span> usrChoice <span class="token operator">=</span> <span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"Are you sure to move forward? That is supposed to be invalid... I convinced!"</span><span class="token punctuation">)</span>\
	<span class="token punctuation">,</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"Warning"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>MB_ICONWARNING<span class="token operator">|</span>MB_CANCELTRYCONTINUE<span class="token operator">|</span>MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">switch</span> <span class="token punctuation">(</span>usrChoice<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> IDCANCEL<span class="token operator">:</span>
		<span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"good"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"afterWard"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MB_OKCANCEL <span class="token operator">|</span> MB_ICONINFORMATION <span class="token operator">|</span> MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">case</span> IDRETRY<span class="token operator">:</span>
		<span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"I mean: that is not good!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"afterWard"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MB_OKCANCEL <span class="token operator">|</span> MB_ICONINFORMATION <span class="token operator">|</span> MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">case</span> IDCONTINUE<span class="token operator">:</span>
		<span class="token function">MessageBox</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"I mean: that is not good!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"afterWard"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MB_OKCANCEL <span class="token operator">|</span> MB_ICONINFORMATION <span class="token operator">|</span> MB_DEFBUTTON2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">default</span><span class="token operator">:</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> WINAPI <span class="token function">WinMain</span><span class="token punctuation">(</span>HINSTANCE hInstance<span class="token punctuation">,</span> HINSTANCE hPrevInstance<span class="token punctuation">,</span> LPSTR ipCmdLine<span class="token punctuation">,</span> <span class="token keyword">int</span> nCmdShow<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">//MessageBox(NULL, TEXT("Hello, World"), TEXT("Captions"), MB_OKCANCEL | MB_ICONINFORMATION | MB_DEFBUTTON2);</span>
	<span class="token function">doSomethingHalt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span>

<span class="token comment">// design by CharlieChen</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="字符串主题"><a href="#字符串主题" class="headerlink" title="字符串主题"></a>字符串主题</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>​        下面我们开始入门简单的字符串主题：啥意思呢？回顾我们C语言的API。我们是如下声明一个char类型或基于char类型的数组</p>
<pre class="line-numbers language-none"><code class="language-none">char typicalChar &#x3D; &#39;A&#39;;
char* TCPtr &#x3D; &quot;Hello!My friend~&quot;;
char arrayCPtr &#x3D; &quot;hello,my frined~&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        我们马上可以看到，char是一份字节大小，那么下面的arrayCPtr就指明需要17个字节来存储。</p>
<h3 id="wchar-t类型"><a href="#wchar-t类型" class="headerlink" title="wchar_t类型"></a>wchar_t类型</h3><p>​        可是，仅仅使用char可能存储不下如今丰富的字符。所以，转向扩展char是必要的，wchar,也就是widechar应运而生。在Windows 2000之后所有的Windows系统都在底层上支持Unicode字符集。</p>
<p>​        我们这样声明与初始化一个wchar变量：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t wideChar &#x3D; L&#39;A&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230505135217906.png" alt="image-20230505135217906"></p>
<p>​        类似的：</p>
<pre class="line-numbers language-none"><code class="language-none">wchar* ptrW &#x3D; &quot;Hello&quot;;
wchar ptr[7] &#x3D; &quot;Hello!&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        但是注意：如果我们还是选择</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%s&quot;, ptrW);
printf(&quot;%s&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        则只会打印首元素，这是因为字符串类型不匹配，人话讲就是：wchar字符串不用%s打印，而是ls</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%ls&quot;, ptrW);
printf(&quot;%ls&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        或者是</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t* WPTR &#x3D; &#123;&#39;a&#39;,&#39;\0&#39;&#125;; 
wprintf(&quot;%s&quot;,WPTR);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        或是直接调用setlocal函数做默认的设置！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;
int main()
&#123;
	&#x2F;&#x2F;使用系统默认的设置调用setlocale(LC_ALL, &quot;&quot;);
	setlocale(LC_ALL, &quot;&quot;);
	const wchar_t * chWord &#x3D; L&quot;疯狂程序人—码农哈哥&quot;;
	printf(&quot;%s&quot;,chWord);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Windows下的字符和宽字符"><a href="#Windows下的字符和宽字符" class="headerlink" title="Windows下的字符和宽字符"></a>Windows下的字符和宽字符</h3><p>​        Windows整理自己的活：他们定义了他们自己的字符类型：在winnt.h文件下可以找到：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;
&#x2F;&#x2F; Basics
&#x2F;&#x2F;

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#if !defined(MIDL_PASS)
typedef int INT;
#endif
#endif

&#x2F;&#x2F;
&#x2F;&#x2F; UNICODE (Wide Character) types
&#x2F;&#x2F;

#ifndef _MAC
typedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#else
&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;

typedef _Null_terminated_ WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef _Null_terminated_ PWSTR *PZPWSTR;
typedef _Null_terminated_ CONST PWSTR *PCZPWSTR;
typedef _Null_terminated_ WCHAR UNALIGNED *LPUWSTR, *PUWSTR;
typedef _Null_terminated_ CONST WCHAR *LPCWSTR, *PCWSTR;
typedef _Null_terminated_ PCWSTR *PZPCWSTR;
typedef _Null_terminated_ CONST PCWSTR *PCZPCWSTR;
typedef _Null_terminated_ CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;

typedef _NullNull_terminated_ WCHAR *PZZWSTR;
typedef _NullNull_terminated_ CONST WCHAR *PCZZWSTR;
typedef _NullNull_terminated_ WCHAR UNALIGNED *PUZZWSTR;
typedef _NullNull_terminated_ CONST WCHAR UNALIGNED *PCUZZWSTR;

typedef  WCHAR *PNZWCH;
typedef  CONST WCHAR *PCNZWCH;
typedef  WCHAR UNALIGNED *PUNZWCH;
typedef  CONST WCHAR UNALIGNED *PCUNZWCH;

#if _WIN32_WINNT &gt;&#x3D; 0x0600 || (defined(__cplusplus) &amp;&amp; defined(WINDOWS_ENABLE_CPLUSPLUS))

typedef CONST WCHAR *LPCWCHAR, *PCWCHAR;
typedef CONST WCHAR UNALIGNED *LPCUWCHAR, *PCUWCHAR;

&#x2F;&#x2F;
&#x2F;&#x2F;  UCS (Universal Character Set) types
&#x2F;&#x2F;

typedef unsigned long UCSCHAR;

&#x2F;&#x2F;
&#x2F;&#x2F;  Even pre-Unicode agreement, UCS values are always in the
&#x2F;&#x2F;  range U+00000000 to U+7FFFFFFF, so we&#39;ll pick an obvious
&#x2F;&#x2F;  value.

#define UCSCHAR_INVALID_CHARACTER (0xffffffff)

#define MIN_UCSCHAR (0)

&#x2F;&#x2F;
&#x2F;&#x2F;  We&#39;ll assume here that the ISO-10646 &#x2F; Unicode agreement
&#x2F;&#x2F;  not to assign code points after U+0010FFFF holds so that
&#x2F;&#x2F;  we do not have to have separate &quot;UCSCHAR&quot; and &quot;UNICODECHAR&quot;
&#x2F;&#x2F;  types.
&#x2F;&#x2F;

#define MAX_UCSCHAR (0x0010FFFF)

typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR UNALIGNED *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR UNALIGNED *PCUUCSSTR;

typedef UCSCHAR UNALIGNED *PUUCSCHAR;
typedef const UCSCHAR UNALIGNED *PCUUCSCHAR;

#endif &#x2F;&#x2F; _WIN32_WINNT &gt;&#x3D; 0x0600


&#x2F;&#x2F;
&#x2F;&#x2F; ANSI (Multi-byte Character) types
&#x2F;&#x2F;
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef CONST CHAR *LPCCH, *PCCH;

typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;
typedef _Null_terminated_ PSTR *PZPSTR;
typedef _Null_terminated_ CONST PSTR *PCZPSTR;
typedef _Null_terminated_ CONST CHAR *LPCSTR, *PCSTR;
typedef _Null_terminated_ PCSTR *PZPCSTR;
typedef _Null_terminated_ CONST PCSTR *PCZPCSTR;

typedef _NullNull_terminated_ CHAR *PZZSTR;
typedef _NullNull_terminated_ CONST CHAR *PCZZSTR;

typedef  CHAR *PNZCH;
typedef  CONST CHAR *PCNZCH;

&#x2F;&#x2F;
&#x2F;&#x2F; Neutral ANSI&#x2F;UNICODE types and macros
&#x2F;&#x2F;
#ifdef  UNICODE                     &#x2F;&#x2F; r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TBYTE , *PTBYTE ;
#define _TCHAR_DEFINED
#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;

typedef LPWCH LPTCH, PTCH;
typedef LPCWCH LPCTCH, PCTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
typedef PZZWSTR PZZTSTR;
typedef PCZZWSTR PCZZTSTR;
typedef PUZZWSTR PUZZTSTR;
typedef PCUZZWSTR PCUZZTSTR;
typedef PZPWSTR PZPTSTR;
typedef PNZWCH PNZTCH;
typedef PCNZWCH PCNZTCH;
typedef PUNZWCH PUNZTCH;
typedef PCUNZWCH PCUNZTCH;
#define __TEXT(quote) L##quote      &#x2F;&#x2F; r_winnt

#else   &#x2F;* UNICODE *&#x2F;               &#x2F;&#x2F; r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;
#define _TCHAR_DEFINED
#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;

typedef LPCH LPTCH, PTCH;
typedef LPCCH LPCTCH, PCTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
typedef PZZSTR PZZTSTR, PUZZTSTR;
typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
typedef PZPSTR PZPTSTR;
typedef PNZCH PNZTCH, PUNZTCH;
typedef PCNZCH PCNZTCH, PCUNZTCH;
#define __TEXT(quote) quote         &#x2F;&#x2F; r_winnt

#endif &#x2F;* UNICODE *&#x2F;                &#x2F;&#x2F; r_winnt
#define TEXT(quote) __TEXT(quote)   &#x2F;&#x2F; r_winnt


typedef SHORT *PSHORT;  
typedef LONG *PLONG;    

#define ALL_PROCESSOR_GROUPS        0xffff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在这里我们找到了两个东西：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef _MAC
typedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#else
&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        首先是wchar_t被重写位WCHAR。对于一些甚至没有wchar的编译器直接对unsigned short起别名。</p>
<p>​        其次是TEXT宏，这个宏便捷的帮助我们直接将普通的字符串升级为宽字符串，其做法不是强制转换，而是：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define __TEXT(quote) L##quote
#define TEXT(quote) __TEXT(quote)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        ##是令牌粘贴，就是直接把L和字符串连接在一起返回，比若说：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TEXT(&quot;Hello&quot;)--- Compiler----&gt; L&quot;Hello&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们看到，上面的定义给出了：PSTR和LPSTR的小东西。他们都是CHAR（本质上就是Char），而P C STR 和 LP C STR则是Const类型的字符串。也就是常字符串！</p>
<p>​        那对于TCHAR这样Windows自己给出了字符串，我们应该怎么处理呢了，答案是万能的WIndows又帮我们干好了。使用P T STR和LP T STR就可以胜任这些工作！</p>
<h2 id="常见的字符串处理工作"><a href="#常见的字符串处理工作" class="headerlink" title="常见的字符串处理工作"></a>常见的字符串处理工作</h2><h3 id="获取字符串的长度"><a href="#获取字符串的长度" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h3><p>​        下面我们要说的是如何获取字符串的长度，请看strlen和wstrlen.</p>
<pre class="line-numbers language-none"><code class="language-none">size_t strlen(const char* str);
size_t wstrlen(const wchar_t* str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        size_t，如其所说的那样，衡量的是大小的类型。其定义查看建议自行搜索，这里做阐述。因为不是重点我想说的！</p>
<p>​        来试试看：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;tchar.h&gt;
int main() &#123;

	CHAR str[] &#x3D; &quot;C语言\0&quot;; &#x2F;&#x2F; 这个函数返回占比字节的大小
	WCHAR wstr[] &#x3D; L&quot;C语言&quot;; &#x2F;&#x2F; 这个函数返回的是宽字符的个数

	_tprintf(TEXT(&quot;strlen(str) &#x3D; %d\n wcslen(wstr) &#x3D; %d&quot;), strlen(str), wcslen(wstr));

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <img src="image-20230505235033338.png" alt="image-20230505235033338"></p>
<p>​        注意到_tprintf是一个随系统环境而改变的宏函数，在支持UNICODE字符集的情况下，系统将会自动的转化之成为wprintf！</p>
<p>​        类似的：我们还有一个叫做tcslen这个函数，他是这样被定义的：</p>
<p><img src="image-20230505235214903.png" alt="image-20230505235214903"></p>
<p>​        好鸡肋啊，那如果我们改一下不支持Unicode子集呢？仍然是右键项目——属性，转到这个地方：</p>
<p><img src="image-20230505235414875.png" alt="image-20230505235414875"></p>
<p>​        改成</p>
<p><img src="image-20230505235429080.png" alt="image-20230505235429080"></p>
<p>​        发现变灰了！转向再看发现跳转到了：&gt;</p>
<p><img src="image-20230505235350688.png" alt="image-20230505235350688"></p>
<h2 id="字符串主题-1"><a href="#字符串主题-1" class="headerlink" title="字符串主题"></a>字符串主题</h2><h3 id="入门-1"><a href="#入门-1" class="headerlink" title="入门"></a>入门</h3><p>​        下面我们开始入门简单的字符串主题：啥意思呢？回顾我们C语言的API。我们是如下声明一个char类型或基于char类型的数组</p>
<pre class="line-numbers language-none"><code class="language-none">char typicalChar &#x3D; &#39;A&#39;;
char* TCPtr &#x3D; &quot;Hello!My friend~&quot;;
char arrayCPtr &#x3D; &quot;hello,my frined~&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        我们马上可以看到，char是一份字节大小，那么下面的arrayCPtr就指明需要17个字节来存储。</p>
<h3 id="wchar-t类型-1"><a href="#wchar-t类型-1" class="headerlink" title="wchar_t类型"></a>wchar_t类型</h3><p>​        可是，仅仅使用char可能存储不下如今丰富的字符。所以，转向扩展char是必要的，wchar,也就是widechar应运而生。在Windows 2000之后所有的Windows系统都在底层上支持Unicode字符集。</p>
<p>​        我们这样声明与初始化一个wchar变量：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t wideChar &#x3D; L&#39;A&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230505135217906.png" alt="image-20230505135217906"></p>
<p>​        类似的：</p>
<pre class="line-numbers language-none"><code class="language-none">wchar* ptrW &#x3D; &quot;Hello&quot;;
wchar ptr[7] &#x3D; &quot;Hello!&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        但是注意：如果我们还是选择</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%s&quot;, ptrW);
printf(&quot;%s&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        则只会打印首元素，这是因为字符串类型不匹配，人话讲就是：wchar字符串不用%s打印，而是ls</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%ls&quot;, ptrW);
printf(&quot;%ls&quot;, ptr);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        或者是</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">wchar_t* WPTR &#x3D; &#123;&#39;a&#39;,&#39;\0&#39;&#125;; 
wprintf(&quot;%s&quot;,WPTR);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        或是直接调用setlocal函数做默认的设置！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;
int main()
&#123;
	&#x2F;&#x2F;使用系统默认的设置调用setlocale(LC_ALL, &quot;&quot;);
	setlocale(LC_ALL, &quot;&quot;);
	const wchar_t * chWord &#x3D; L&quot;疯狂程序人—码农哈哥&quot;;
	printf(&quot;%s&quot;,chWord);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Windows下的字符和宽字符-1"><a href="#Windows下的字符和宽字符-1" class="headerlink" title="Windows下的字符和宽字符"></a>Windows下的字符和宽字符</h3><p>​        Windows整理自己的活：他们定义了他们自己的字符类型：在winnt.h文件下可以找到：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;
&#x2F;&#x2F; Basics
&#x2F;&#x2F;

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#if !defined(MIDL_PASS)
typedef int INT;
#endif
#endif

&#x2F;&#x2F;
&#x2F;&#x2F; UNICODE (Wide Character) types
&#x2F;&#x2F;

#ifndef _MAC
typedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#else
&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;

typedef _Null_terminated_ WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef _Null_terminated_ PWSTR *PZPWSTR;
typedef _Null_terminated_ CONST PWSTR *PCZPWSTR;
typedef _Null_terminated_ WCHAR UNALIGNED *LPUWSTR, *PUWSTR;
typedef _Null_terminated_ CONST WCHAR *LPCWSTR, *PCWSTR;
typedef _Null_terminated_ PCWSTR *PZPCWSTR;
typedef _Null_terminated_ CONST PCWSTR *PCZPCWSTR;
typedef _Null_terminated_ CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;

typedef _NullNull_terminated_ WCHAR *PZZWSTR;
typedef _NullNull_terminated_ CONST WCHAR *PCZZWSTR;
typedef _NullNull_terminated_ WCHAR UNALIGNED *PUZZWSTR;
typedef _NullNull_terminated_ CONST WCHAR UNALIGNED *PCUZZWSTR;

typedef  WCHAR *PNZWCH;
typedef  CONST WCHAR *PCNZWCH;
typedef  WCHAR UNALIGNED *PUNZWCH;
typedef  CONST WCHAR UNALIGNED *PCUNZWCH;

#if _WIN32_WINNT &gt;&#x3D; 0x0600 || (defined(__cplusplus) &amp;&amp; defined(WINDOWS_ENABLE_CPLUSPLUS))

typedef CONST WCHAR *LPCWCHAR, *PCWCHAR;
typedef CONST WCHAR UNALIGNED *LPCUWCHAR, *PCUWCHAR;

&#x2F;&#x2F;
&#x2F;&#x2F;  UCS (Universal Character Set) types
&#x2F;&#x2F;

typedef unsigned long UCSCHAR;

&#x2F;&#x2F;
&#x2F;&#x2F;  Even pre-Unicode agreement, UCS values are always in the
&#x2F;&#x2F;  range U+00000000 to U+7FFFFFFF, so we&#39;ll pick an obvious
&#x2F;&#x2F;  value.

#define UCSCHAR_INVALID_CHARACTER (0xffffffff)

#define MIN_UCSCHAR (0)

&#x2F;&#x2F;
&#x2F;&#x2F;  We&#39;ll assume here that the ISO-10646 &#x2F; Unicode agreement
&#x2F;&#x2F;  not to assign code points after U+0010FFFF holds so that
&#x2F;&#x2F;  we do not have to have separate &quot;UCSCHAR&quot; and &quot;UNICODECHAR&quot;
&#x2F;&#x2F;  types.
&#x2F;&#x2F;

#define MAX_UCSCHAR (0x0010FFFF)

typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR UNALIGNED *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR UNALIGNED *PCUUCSSTR;

typedef UCSCHAR UNALIGNED *PUUCSCHAR;
typedef const UCSCHAR UNALIGNED *PCUUCSCHAR;

#endif &#x2F;&#x2F; _WIN32_WINNT &gt;&#x3D; 0x0600


&#x2F;&#x2F;
&#x2F;&#x2F; ANSI (Multi-byte Character) types
&#x2F;&#x2F;
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef CONST CHAR *LPCCH, *PCCH;

typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;
typedef _Null_terminated_ PSTR *PZPSTR;
typedef _Null_terminated_ CONST PSTR *PCZPSTR;
typedef _Null_terminated_ CONST CHAR *LPCSTR, *PCSTR;
typedef _Null_terminated_ PCSTR *PZPCSTR;
typedef _Null_terminated_ CONST PCSTR *PCZPCSTR;

typedef _NullNull_terminated_ CHAR *PZZSTR;
typedef _NullNull_terminated_ CONST CHAR *PCZZSTR;

typedef  CHAR *PNZCH;
typedef  CONST CHAR *PCNZCH;

&#x2F;&#x2F;
&#x2F;&#x2F; Neutral ANSI&#x2F;UNICODE types and macros
&#x2F;&#x2F;
#ifdef  UNICODE                     &#x2F;&#x2F; r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TBYTE , *PTBYTE ;
#define _TCHAR_DEFINED
#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;

typedef LPWCH LPTCH, PTCH;
typedef LPCWCH LPCTCH, PCTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
typedef PZZWSTR PZZTSTR;
typedef PCZZWSTR PCZZTSTR;
typedef PUZZWSTR PUZZTSTR;
typedef PCUZZWSTR PCUZZTSTR;
typedef PZPWSTR PZPTSTR;
typedef PNZWCH PNZTCH;
typedef PCNZWCH PCNZTCH;
typedef PUNZWCH PUNZTCH;
typedef PCUNZWCH PCUNZTCH;
#define __TEXT(quote) L##quote      &#x2F;&#x2F; r_winnt

#else   &#x2F;* UNICODE *&#x2F;               &#x2F;&#x2F; r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;
#define _TCHAR_DEFINED
#endif &#x2F;* !_TCHAR_DEFINED *&#x2F;

typedef LPCH LPTCH, PTCH;
typedef LPCCH LPCTCH, PCTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
typedef PZZSTR PZZTSTR, PUZZTSTR;
typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
typedef PZPSTR PZPTSTR;
typedef PNZCH PNZTCH, PUNZTCH;
typedef PCNZCH PCNZTCH, PCUNZTCH;
#define __TEXT(quote) quote         &#x2F;&#x2F; r_winnt

#endif &#x2F;* UNICODE *&#x2F;                &#x2F;&#x2F; r_winnt
#define TEXT(quote) __TEXT(quote)   &#x2F;&#x2F; r_winnt


typedef SHORT *PSHORT;  
typedef LONG *PLONG;    

#define ALL_PROCESSOR_GROUPS        0xffff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在这里我们找到了两个东西：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef _MAC
typedef wchar_t WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#else
&#x2F;&#x2F; some Macintosh compilers don&#39;t define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    &#x2F;&#x2F; wc,   16-bit UNICODE character
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        首先是wchar_t被重写位WCHAR。对于一些甚至没有wchar的编译器直接对unsigned short起别名。</p>
<p>​        其次是TEXT宏，这个宏便捷的帮助我们直接将普通的字符串升级为宽字符串，其做法不是强制转换，而是：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define __TEXT(quote) L##quote
#define TEXT(quote) __TEXT(quote)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        ##是令牌粘贴，就是直接把L和字符串连接在一起返回，比若说：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TEXT(&quot;Hello&quot;)--- Compiler----&gt; L&quot;Hello&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们看到，上面的定义给出了：PSTR和LPSTR的小东西。他们都是CHAR（本质上就是Char），而P C STR 和 LP C STR则是Const类型的字符串。也就是常字符串！</p>
<p>​        那对于TCHAR这样Windows自己给出了字符串，我们应该怎么处理呢了，答案是万能的WIndows又帮我们干好了。使用P T STR和LP T STR就可以胜任这些工作！</p>
<h2 id="常见的字符串处理工作-1"><a href="#常见的字符串处理工作-1" class="headerlink" title="常见的字符串处理工作"></a>常见的字符串处理工作</h2><h3 id="获取字符串的长度-1"><a href="#获取字符串的长度-1" class="headerlink" title="获取字符串的长度"></a>获取字符串的长度</h3><p>​        下面我们要说的是如何获取字符串的长度，请看strlen和wstrlen.</p>
<pre class="line-numbers language-none"><code class="language-none">size_t strlen(const char* str);
size_t wstrlen(const wchar_t* str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        size_t，如其所说的那样，衡量的是大小的类型。其定义查看建议自行搜索，这里做阐述。因为不是重点我想说的！</p>
<p>​        来试试看：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;tchar.h&gt;
int main() &#123;

	CHAR str[] &#x3D; &quot;C语言\0&quot;; &#x2F;&#x2F; 这个函数返回占比字节的大小
	WCHAR wstr[] &#x3D; L&quot;C语言&quot;; &#x2F;&#x2F; 这个函数返回的是宽字符的个数

	_tprintf(TEXT(&quot;strlen(str) &#x3D; %d\n wcslen(wstr) &#x3D; %d&quot;), strlen(str), wcslen(wstr));

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <img src="image-20230505235033338.png" alt="image-20230505235033338"></p>
<p>​        注意到_tprintf是一个随系统环境而改变的宏函数，在支持UNICODE字符集的情况下，系统将会自动的转化之成为wprintf！</p>
<p>​        类似的：我们还有一个叫做tcslen这个函数，他是这样被定义的：</p>
<p><img src="image-20230505235214903.png" alt="image-20230505235214903"></p>
<p>​        好鸡肋啊，那如果我们改一下不支持Unicode子集呢？仍然是右键项目——属性，转到这个地方：</p>
<p><img src="image-20230505235414875.png" alt="image-20230505235414875"></p>
<p>​        改成</p>
<p><img src="image-20230505235429080.png" alt="image-20230505235429080"></p>
<p>​        发现变灰了！转向再看发现跳转到了：&gt;</p>
<p><img src="image-20230505235350688.png" alt="image-20230505235350688"></p>
<h2 id="数据类型一看"><a href="#数据类型一看" class="headerlink" title="数据类型一看"></a>数据类型一看</h2><p>​        原生C数据类型</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int float double ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Windows自己的：</p>
<pre class="line-numbers language-none"><code class="language-none">BOOL BYTE CHAR CONST DWORD DOWRD32 DWORD64 FLOAT HANDLE HICON HINSTANCE
HKEY HMODULE HWND INT INT_PTR INT32 INT64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        看看这个：</p>
<pre class="line-numbers language-none"><code class="language-none">LPSTR szString &#x3D; L&quot;this is a long pointer to string.&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        跳转得到：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;
&#x2F;&#x2F; ANSI (Multi-byte Character) types
&#x2F;&#x2F;
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef CONST CHAR *LPCCH, *PCCH;

typedef _Null_terminated_ CHAR *NPSTR, *LPSTR, *PSTR;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        进一步针对CHAR类型跳转</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef char CHAR;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        微软搞那么多宏，一方面是历史遗留，另一方面是方便他们的工程师更容易区分</p>
<p>​        Dword是这个东西：一个四个字节的数据类型</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DWORD dwMax &#x3D; 0xFFFFFFFF<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef unsigned long       DWORD;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        于是INT就是有符号的，DWORD是无符号的。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;
#include&lt;Windows.h&gt;

int main()
&#123;

	LPSTR szString &#x3D; L&quot;this is a long pointer to string.&quot;;

	INT a &#x3D; 10;

	DWORD dwMax &#x3D; 0xFFFFFFFF;

	MessageBox(NULL, szString, TEXT(&quot;LPSTR&quot;), MB_OK);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在C中我们有：memcpy</p>
<p>​        在Windows下，有一个函数叫CopyMemory()</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">CopyMemory(IpStr, szString, lstrlen(szString) + 1); &#x2F;&#x2F; add one to include the \0.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define CopyMemory RtlCopyMemory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Handle,也就是句柄，是这样被定义的：</p>
<p>​        他有如下的句柄：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void *HANDLE;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        HICON图标</p>
<pre class="line-numbers language-X" data-language="X"><code class="language-X">DECLARE_HANDLE(HICON);
#define DECLARE_HANDLE(name) struct name##__&#123;int unused;&#125;; typedef struct name##__ *name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        HInstance实例句柄</p>
<pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE(HINSTANCE);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        HKey注册表的句柄</p>
<pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE(HKEY);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Hmodule模块句柄</p>
<pre class="line-numbers language-none"><code class="language-none">typedef HINSTANCE HMODULE;      &#x2F;* HMODULEs can be used in place of HINSTANCEs *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        HWND窗口句柄</p>
<pre class="line-numbers language-none"><code class="language-none">DECLARE_HANDLE            (HWND);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="API基础函数"><a href="#API基础函数" class="headerlink" title="API基础函数"></a>API基础函数</h2><p>​        WindowAPI大量的使用了Windows的数据类型！所有的API都有W版和A版，分别表示的是支持Unicode字符集和ASCII多字节字符集。下面我们来看一个Windows自己创建的demo，选择Win32项目创建。看到主文件下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; WindowsProject1.cpp : 定义应用程序的入口点。
&#x2F;&#x2F;

#include &quot;framework.h&quot;
#include &quot;WindowsProject1.h&quot;

#define MAX_LOADSTRING 100

&#x2F;&#x2F; 全局变量:
HINSTANCE hInst;                                &#x2F;&#x2F; 当前实例
WCHAR szTitle[MAX_LOADSTRING];                  &#x2F;&#x2F; 标题栏文本
WCHAR szWindowClass[MAX_LOADSTRING];            &#x2F;&#x2F; 主窗口类名

&#x2F;&#x2F; 此代码模块中包含的函数的前向声明:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
&#123;
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    &#x2F;&#x2F; TODO: 在此处放置代码。

    &#x2F;&#x2F; 初始化全局字符串
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_WINDOWSPROJECT1, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    &#x2F;&#x2F; 执行应用程序初始化:
    if (!InitInstance (hInstance, nCmdShow))
    &#123;
        return FALSE;
    &#125;

    HACCEL hAccelTable &#x3D; LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSPROJECT1));

    MSG msg;

    &#x2F;&#x2F; 主消息循环:
    while (GetMessage(&amp;msg, nullptr, 0, 0))
    &#123;
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))
        &#123;
            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
        &#125;
    &#125;

    return (int) msg.wParam;
&#125;



&#x2F;&#x2F;
&#x2F;&#x2F;  函数: MyRegisterClass()
&#x2F;&#x2F;
&#x2F;&#x2F;  目标: 注册窗口类。
&#x2F;&#x2F;
ATOM MyRegisterClass(HINSTANCE hInstance)
&#123;
    WNDCLASSEXW wcex;

    wcex.cbSize &#x3D; sizeof(WNDCLASSEX);

    wcex.style          &#x3D; CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    &#x3D; WndProc;
    wcex.cbClsExtra     &#x3D; 0;
    wcex.cbWndExtra     &#x3D; 0;
    wcex.hInstance      &#x3D; hInstance;
    wcex.hIcon          &#x3D; LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));
    wcex.hCursor        &#x3D; LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  &#x3D; (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   &#x3D; MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1);
    wcex.lpszClassName  &#x3D; szWindowClass;
    wcex.hIconSm        &#x3D; LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassExW(&amp;wcex);
&#125;

&#x2F;&#x2F;
&#x2F;&#x2F;   函数: InitInstance(HINSTANCE, int)
&#x2F;&#x2F;
&#x2F;&#x2F;   目标: 保存实例句柄并创建主窗口
&#x2F;&#x2F;
&#x2F;&#x2F;   注释:
&#x2F;&#x2F;
&#x2F;&#x2F;        在此函数中，我们在全局变量中保存实例句柄并
&#x2F;&#x2F;        创建和显示主程序窗口。
&#x2F;&#x2F;
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
&#123;
   hInst &#x3D; hInstance; &#x2F;&#x2F; 将实例句柄存储在全局变量中

   HWND hWnd &#x3D; CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   &#123;
      return FALSE;
   &#125;

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
&#125;

&#x2F;&#x2F;
&#x2F;&#x2F;  函数: WndProc(HWND, UINT, WPARAM, LPARAM)
&#x2F;&#x2F;
&#x2F;&#x2F;  目标: 处理主窗口的消息。
&#x2F;&#x2F;
&#x2F;&#x2F;  WM_COMMAND  - 处理应用程序菜单
&#x2F;&#x2F;  WM_PAINT    - 绘制主窗口
&#x2F;&#x2F;  WM_DESTROY  - 发送退出消息并返回
&#x2F;&#x2F;
&#x2F;&#x2F;
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
&#123;
    switch (message)
    &#123;
    case WM_COMMAND:
        &#123;
            int wmId &#x3D; LOWORD(wParam);
            &#x2F;&#x2F; 分析菜单选择:
            switch (wmId)
            &#123;
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            &#125;
        &#125;
        break;
    case WM_PAINT:
        &#123;
            PAINTSTRUCT ps;
            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);
            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...
            EndPaint(hWnd, &amp;ps);
        &#125;
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    &#125;
    return 0;
&#125;

&#x2F;&#x2F; “关于”框的消息处理程序。
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
&#123;
    UNREFERENCED_PARAMETER(lParam);
    switch (message)
    &#123;
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) &#x3D;&#x3D; IDOK || LOWORD(wParam) &#x3D;&#x3D; IDCANCEL)
        &#123;
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        &#125;
        break;
    &#125;
    return (INT_PTR)FALSE;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们尝试加点东西，留心到</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在switch语句下面添加点东西（有注释//）:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
&#123;

    LPCWSTR msg_str1 &#x3D; L&quot;你单击了左键（乐）&quot;;&#x2F;&#x2F;
    LPCWSTR msg_str2 &#x3D; L&quot;你单击了右键（乐）&quot;;&#x2F;&#x2F;
    LPCWSTR title_str &#x3D; L&quot;这是一个标题&quot;;&#x2F;&#x2F;

    switch (message)
    &#123;
    case WM_COMMAND:
        &#123;
            int wmId &#x3D; LOWORD(wParam);
            &#x2F;&#x2F; 分析菜单选择:
            switch (wmId)
            &#123;
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            &#125;
        &#125;
        break;
    case WM_PAINT:
        &#123;
            PAINTSTRUCT ps;
            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);
            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...
            EndPaint(hWnd, &amp;ps);
        &#125;
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    case WM_LBUTTONDOWN:&#x2F;&#x2F;
        MessageBoxW(NULL,msg_str1,title_str, MB_OKCANCEL);&#x2F;&#x2F;
        break;&#x2F;&#x2F;
    case WM_RBUTTONDOWN:&#x2F;&#x2F;
        MessageBoxW(NULL, msg_str2, title_str, MB_OKCANCEL);&#x2F;&#x2F;
        break;&#x2F;&#x2F;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是我们频繁点击会产生大量的窗口！那就更改父窗口就好了，传入一个句柄！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">case WM_LBUTTONDOWN:
    MessageBoxW(hWnd,msg_str1,title_str, MB_OKCANCEL);
    break;
case WM_RBUTTONDOWN:
    MessageBoxW(hWnd, msg_str2, title_str, MB_OKCANCEL);
    break;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在就好了！</p>
<p><img src="image-20230514113233694.png" alt="image-20230514113233694"></p>
<p><img src="image-20230514113445737.png" alt="image-20230514113445737"></p>
<p><img src="image-20230514113504873.png" alt="image-20230514113504873"></p>
<h2 id="读取文件demo"><a href="#读取文件demo" class="headerlink" title="读取文件demo"></a>读取文件demo</h2><p>​        在Windows下，使用</p>
<pre class="line-numbers language-none"><code class="language-none">CreateFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        宏来打开并创建一个文件句柄！</p>
<blockquote>
<p>from Microsoft API</p>
</blockquote>
<h2 id="read-file"><a href="#read-file" class="headerlink" title="read file"></a>read file</h2><p>​        我们使用readFile来读取文件：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#define BUFSIZE 256
#include&lt;tchar.h&gt;11

int main()
&#123;
	setlocale(LC_ALL, &quot;zh_CN.UTF-8&quot;); &#x2F;&#x2F; 设置正确的编码环境，防止读取乱码！

	HANDLE hFileRead;
	&#x2F;&#x2F; 创建文件句柄
	hFileRead &#x3D; CreateFile(L&quot;1.txt&quot;, GENERIC_READ, FILE_SHARE_READ, \
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFileRead &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;

		printf(&quot;Error in open the file:%x&quot;,GetLastError());

	&#125;

	DWORD nIn &#x3D; 0;

	CHAR buffer[BUFSIZE];

	while (ReadFile(hFileRead, buffer, BUFSIZE, &amp;nIn, NULL) &amp;&amp; nIn &gt; 0) &#123;
		printf(&quot;%s\n&quot;, buffer);
	&#125;

	CloseHandle(hFileRead);
	
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230514113206643.png" alt="image-20230514113206643"></p>
<h3 id="createFileW-函数-fileapi-h"><a href="#createFileW-函数-fileapi-h" class="headerlink" title="createFileW 函数 (fileapi.h)"></a>createFileW 函数 (fileapi.h)</h3><p>​        创建或打开文件或 I/O 设备。 最常用的 I/O 设备如下所示：文件、文件流、目录、物理磁盘、卷、控制台缓冲区、磁带驱动器、通信资源、mailslot 和管道。 该函数返回一个句柄，该句柄可用于访问不同类型的 I/O 的文件或设备，具体取决于文件或设备以及指定的标志和属性。</p>
<p>若要将此操作作为事务处理操作执行，这会导致可用于事务处理 I/O 的句柄，请使用 CreateFileTransacted 函数。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">HANDLE CreateFileW(
  [in]           LPCWSTR               lpFileName,
  [in]           DWORD                 dwDesiredAccess,
  [in]           DWORD                 dwShareMode,
  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  [in]           DWORD                 dwCreationDisposition,
  [in]           DWORD                 dwFlagsAndAttributes,
  [in, optional] HANDLE                hTemplateFile
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参数<br>        [in] lpFileName</p>
<p>​        要创建或打开的文件或设备的名称。 可以在此名称中使用正斜杠 (/) 或反斜杠 () 。</p>
<p>​        在此函数的 ANSI 版本中，名称限制为 MAX_PATH 个字符。 若要将此限制扩展到 32，767 宽字符，请使用此 Unicode 版本的函数，并将“\\？\”前面附加到路径。 有关详细信息，请参阅命名文件、路径和命名空间。</p>
<p>​        有关特殊设备名称的信息，请参阅 定义 MS-DOS 设备名称。</p>
<p>​        若要创建文件流，请指定文件的名称、冒号，然后指定流的名称。 有关详细信息，请参阅 文件流。</p>
<p>​        提示从Windows 10版本 1607 开始，对于此函数的 unicode 版本 (CreateFileW) ，你可以选择加入以删除MAX_PATH限制，而无需附加“\\？\”。 有关详细信息，请参阅 命名文件、路径和命名空间 的“最大路径长度限制”部分。<br>[in] dwDesiredAccess</p>
<p>​        请求对文件或设备的访问权限，可汇总为读取、写入或两者均不) 。</p>
<p>​        最常用的值是 GENERIC_READ、 GENERIC_WRITE或两者 () GENERIC_READ | GENERIC_WRITE 。 有关详细信息，请参阅 通用访问权限、 文件安全性和访问权限、 文件访问权限常量和 ACCESS_MASK。</p>
<p>​        如果此参数为零，则应用程序可以在不访问该文件或设备的情况下查询某些元数据，例如文件、目录或设备属性，即使 拒绝了GENERIC_READ 访问。</p>
<p>​        不能请求与已打开句柄的打开请求中 dwShareMode 参数指定的共享模式冲突的访问模式。</p>
<p>​        有关详细信息，请参阅本主题的“备注”部分和 “创建和打开文件”。</p>
<p>​        [in] dwShareMode</p>
<p>​        文件或设备请求的共享模式，可以读取、写入、删除、所有这些或无 (引用下表) 。 对属性或扩展属性的访问请求不受此标志的影响。</p>
<p>​        如果此参数为零且 CreateFile 成功，则文件或设备无法共享，并且无法在文件或设备的句柄关闭之前再次打开。 有关详细信息，请参见“备注”部分。</p>
<p>​        无法请求与具有打开句柄的现有请求中指定的访问模式冲突的共享模式。 CreateFile 将失败， GetLastError 函数将返回 ERROR_SHARING_VIOLATION。</p>
<p>​        若要启用进程在打开文件或设备时共享文件或设备，请使用以下一个或多个值的兼容组合。 有关此参数与 dwDesiredAccess 参数的有效组合的详细信息，请参阅 创建和打开文件。</p>
<p>​        <strong>注意</strong> 无论进程上下文如何，每个打开句柄的共享选项都将有效，直到该句柄关闭。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>0</strong>0x00000000</td>
<td style="text-align:left">如果文件或设备请求删除、读取或写入访问权限，则阻止对文件或设备上的后续打开操作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SHARE_DELETE</strong>0x00000004</td>
<td style="text-align:left">在文件或设备上启用后续打开操作以请求删除访问权限。否则，如果文件或设备请求删除访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开以删除访问权限，则函数将失败。<strong>注意</strong> 删除访问权限允许删除和重命名操作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SHARE_READ</strong>0x00000001</td>
<td style="text-align:left">在文件或设备上启用后续打开操作以请求读取访问权限。否则，如果文件或设备请求读取访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开以供读取访问，则函数将失败。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SHARE_WRITE</strong>0x00000002</td>
<td style="text-align:left">在文件或设备上启用后续打开操作以请求写入访问权限。否则，如果文件或设备请求写入访问权限，则无法打开该文件或设备。如果未指定此标志，但文件或设备已打开进行写入访问或具有写入访问权限的文件映射，则函数将失败。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] lpSecurityAttributes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向包含两个独立但相关数据成员的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85">SECURITY_ATTRIBUTES</a>) 结构的指针：可选的安全描述符，以及一个布尔值，该值确定返回的句柄是否可以由子进程继承。</p>
<p>​        此参数可以为 NULL。</p>
<p>​        如果此参数为 <strong>NULL</strong>，则 <strong>由 CreateFile</strong> 返回的句柄不能由应用程序可能创建的任何子进程继承，并且与返回的句柄关联的文件或设备获取默认的安全描述符。</p>
<p>​        结构的 <strong>lpSecurityDescriptor</strong> 成员指定文件或设备的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnt/ns-winnt-security_descriptor">SECURITY_DESCRIPTOR</a> 。 如果此成员为 <strong>NULL</strong>，则会为与返回的句柄关联的文件或设备分配一个默认的安全描述符。</p>
<p>​        <strong>CreateFile</strong> 在打开现有文件或设备时忽略 <strong>lpSecurityDescriptor</strong> 成员，但继续使用 <strong>bInheritHandle</strong> 成员。</p>
<p>​        结构的 <strong>bInheritHandle</strong> 成员指定是否可以继承返回的句柄。</p>
<p>​        有关详细信息，请参见“备注”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] dwCreationDisposition<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        对存在或不存在的文件或设备执行的操作。</p>
<p>​        对于文件以外的设备，此参数通常设置为 <strong>OPEN_EXISTING</strong>。</p>
<p>​        有关详细信息，请参见“备注”部分。</p>
<p>​        此参数必须是以下值之一，不能合并：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>CREATE_ALWAYS</strong>2</td>
<td style="text-align:left">始终创建新文件。如果指定的文件存在且可写，则函数将覆盖文件、函数成功，最后错误代码设置为 <strong>ERROR_ALREADY_EXISTS</strong> (183) 。如果指定的文件不存在且路径有效，则会创建一个新文件，该函数成功，最后一个错误代码设置为零。有关详细信息，请参阅本主题的“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CREATE_NEW</strong>1</td>
<td style="text-align:left">仅当该文件尚不存在时才创建一个新文件。如果指定的文件存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_EXISTS (</strong> 80) 。如果指定的文件不存在并且是可写位置的有效路径，则会创建新文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>OPEN_ALWAYS</strong>4</td>
<td style="text-align:left">始终打开文件。如果指定文件存在，则函数成功，最后一个错误代码设置为 <strong>ERROR_ALREADY_EXISTS (</strong> 183) 。如果指定的文件不存在并且是可写位置的有效路径，则函数将创建一个文件，最后一个错误代码设置为零。</td>
</tr>
<tr>
<td style="text-align:left"><strong>OPEN_EXISTING</strong>3</td>
<td style="text-align:left">仅当文件或设备存在时，才打开该文件或设备。如果指定的文件或设备不存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_NOT_FOUND (</strong> 2) 。有关设备的详细信息，请参阅“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>TRUNCATE_EXISTING</strong>5</td>
<td style="text-align:left">打开文件并截断该文件，使其大小为零字节，仅当它存在时。如果指定的文件不存在，函数将失败，最后一个错误代码设置为 <strong>ERROR_FILE_NOT_FOUND</strong> (2) 。调用过程必须打开文件，并将 <strong>GENERIC_WRITE</strong> 位设置为 <em>dwDesiredAccess</em> 参数的一部分。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[in] dwFlagsAndAttributes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        文件或设备属性和标志， <strong>FILE_ATTRIBUTE_NORMAL</strong> 是文件最常见的默认值。</p>
<p>​        此参数可以包含可用文件属性的任意组合， <strong>(FILE_ATTRIBUTE_*</strong>) 。 所有其他文件属性都替代 <strong>FILE_ATTRIBUTE_NORMAL</strong>。</p>
<p>​        此参数还可以包含标志组合 <strong>， (FILE_FLAG_)</strong> <em>来控制文件或设备缓存行为、访问模式和其他特殊用途标志。 这些值与任何 <strong>FILE_ATTRIBUTE_</strong></em> 值结合使用。</p>
<p>​        此参数还可以通过指定 <strong>SECURITY_SQOS_PRESENT</strong> 标志来包含安全服务质量 (SQOS) 信息。 下表显示了其他与 SQOS 相关的标志信息，这些属性和标志表如下。</p>
<p>​        <strong>注意当CreateFile</strong> 打开现有文件时，它通常将文件标志与现有文件的文件属性组合在一起，并忽略作为 <em>dwFlagsAndAttributes</em> 的一部分提供的任何文件属性。 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”中详细介绍了特殊情况。</p>
<p>​        以下某些文件属性和标志只能应用于文件，不一定是 <strong>CreateFile</strong> 可以打开的所有其他类型的设备。 有关详细信息，请参阅本主题的“备注”部分和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”。    </p>
<p>​        有关对文件属性的更高级访问，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-setfileattributesa">SetFileAttributes</a>。 有关所有文件属性及其值和说明的完整列表，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-attribute-constants">文件属性常量</a>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Attribute</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_ARCHIVE</strong>32 (0x20)</td>
<td style="text-align:left">该文件应存档。 应用程序使用此属性来标记要备份或删除的文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_ENCRYPTED</strong>16384 (0x4000)</td>
<td style="text-align:left">此文件或目录已加密。 对于文件来说，表示文件中的所有数据都是加密的。 对于目录，这意味着加密是新创建的文件和子目录的默认值。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。如果还指定 <strong>了FILE_ATTRIBUTE_SYSTEM</strong> ，则此标志无效。家庭版、家庭高级版、初学者版或 ARM 版 Windows 不支持此标志。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_HIDDEN</strong>2 (0x2)</td>
<td style="text-align:left">文件被隐藏。 不要将其包含在普通目录列表中。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_NORMAL</strong>128 (0x80)</td>
<td style="text-align:left">该文件没有设置其他属性。 此属性仅在单独使用时有效。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_OFFLINE</strong>4096 (0x1000)</td>
<td style="text-align:left">文件的数据不能立即可用。 此属性指示文件数据以物理方式移动到脱机存储。 此属性由远程存储（分层存储管理软件）使用。 应用程序不应随意更改此属性。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_READONLY</strong>1 (0x1)</td>
<td style="text-align:left">文件为只读文件。 应用程序可以读取文件，但无法写入或删除该文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_SYSTEM</strong>4 (0x4)</td>
<td style="text-align:left">该文件是操作系统的一部分或完全使用的文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_ATTRIBUTE_TEMPORARY</strong>256 (0x100)</td>
<td style="text-align:left">该文件用于临时存储。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">标志</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_BACKUP_SEMANTICS</strong>0x02000000</td>
<td style="text-align:left">正在为备份或还原操作打开或创建该文件。 系统确保调用进程在进程具有 <strong>SE_BACKUP_NAME</strong> 和 <strong>SE_RESTORE_NAME</strong> 特权时替代文件安全检查。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecBP/changing-privileges-in-a-token">更改令牌中的特权</a>。必须设置此标志才能获取目录的句柄。 目录句柄可以传递给某些函数，而不是文件句柄。 有关详细信息，请参见“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_DELETE_ON_CLOSE</strong>0x04000000</td>
<td style="text-align:left">文件在其所有句柄都关闭后立即被删除，其中包括指定的句柄和任何其他打开或重复的句柄。如果文件存在现有的打开句柄，则调用会失败，除非这些句柄都使用 <strong>FILE_SHARE_DELETE</strong> 共享模式打开。针对文件的后续打开请求将失败，除非指定 FILE_SHARE_DELETE 共享模式。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_NO_BUFFERING</strong>0x20000000</td>
<td style="text-align:left">文件或设备正在打开，没有系统缓存来读取和写入数据。 此标志不会影响硬盘缓存或内存映射文件。使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志成功使用 <strong>CreateFile</strong> 打开的文件有严格的要求，有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_OPEN_NO_RECALL</strong>0x00100000</td>
<td style="text-align:left">请求文件数据，但它应继续位于远程存储中。 不应将其传输回本地存储。 此标志供远程存储系统使用。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>0x00200000</td>
<td style="text-align:left">不会进行正常的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/reparse-points">重新分析点</a> 处理; <strong>CreateFile</strong> 将尝试打开重新分析点。 打开文件时，将返回文件句柄，无论控制重新分析点的筛选器是否正常运行。此标志不能与 <strong>CREATE_ALWAYS</strong> 标志一起使用。如果文件不是重新分析点，则忽略此标志。有关详细信息，请参见“备注”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_OVERLAPPED</strong>0x40000000</td>
<td style="text-align:left">文件或设备正在为异步 I/O 打开或创建。在此句柄上完成后续 I/O 操作时， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件将设置为信号状态。如果指定了此标志，则该文件可用于同时读取和写入操作。如果未指定此标志，则即使对读取和写入函数的调用指定 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">了 OVERLAPPED</a> 结构，I/O 操作也会序列化。有关使用此标志创建的文件句柄时的注意事项，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#synchronous_and_asynchronous_i_o_handles">同步和异步 I/O 句柄</a> 部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_POSIX_SEMANTICS</strong>0x01000000</td>
<td style="text-align:left">访问将根据 POSIX 规则进行。 这包括允许具有名称的多个文件，仅在支持该命名的文件系统时有所不同。 使用此选项时应小心，因为使用此标志创建的文件可能无法由为 MS-DOS 或 16 位 Windows 编写的应用程序访问。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_RANDOM_ACCESS</strong>0x10000000</td>
<td style="text-align:left">访问是随机的。 系统可将此选项用作优化文件缓存的提示。如果文件系统不支持缓存的 I/O 和 <strong>FILE_FLAG_NO_BUFFERING</strong>，则此标志无效。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_SESSION_AWARE</strong>0x00800000</td>
<td style="text-align:left">文件或设备正在使用会话感知打开。 如果未指定此标志，则会话中的每个会话设备 (（例如使用 RemoteFX USB 重定向的设备) ）无法由会话 0 中运行的进程打开。 对于不在会话 0 中的调用方，此标志无效。 此标志仅在 Windows 的服务器版本上受支持。<strong>Windows Server 2008 R2 和 Windows Server 2008：</strong> Windows Server 2012之前不支持此标志。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_SEQUENTIAL_SCAN</strong>0x08000000</td>
<td style="text-align:left">访问旨在从头到尾的顺序。 系统可将此选项用作优化文件缓存的提示。如果读取隐藏 (（即使用反向扫描) ），则不应使用此标志。如果文件系统不支持缓存的 I/O 和 <strong>FILE_FLAG_NO_BUFFERING</strong>，则此标志无效。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FLAG_WRITE_THROUGH</strong>0x80000000</td>
<td style="text-align:left">写入操作不会经历任何中间缓存，它们将直接转到磁盘。有关详细信息，请参阅本主题的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilew#caching_behavior">“缓存行为</a> ”部分。</td>
</tr>
</tbody>
</table>
</div>
<p><em>dwFlagsAndAttributes</em> 参数还可以指定 SQOS 信息。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/impersonation-levels">模拟级别</a>。 当调用应用程序将 <strong>SECURITY_SQOS_PRESENT</strong> 标志指定为 <em>dwFlagsAndAttributes</em> 的一部分时，它还可以包含以下一个或多个值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">安全标志</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>SECURITY_ANONYMOUS</strong></td>
<td style="text-align:left">模拟匿名模拟级别的客户端。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_CONTEXT_TRACKING</strong></td>
<td style="text-align:left">安全跟踪模式是动态的。 如果未指定此标志，则安全跟踪模式是静态的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_DELEGATION</strong></td>
<td style="text-align:left">模拟委托模拟级别的客户端。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_EFFECTIVE_ONLY</strong></td>
<td style="text-align:left">只有客户端安全上下文的已启用方面可供服务器使用。 如果未指定此标志，则客户端安全上下文的所有方面都可用。这允许客户端限制服务器在模拟客户端时可以使用的组和特权。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_IDENTIFICATION</strong></td>
<td style="text-align:left">模拟标识模拟级别的客户端。</td>
</tr>
<tr>
<td style="text-align:left"><strong>SECURITY_IMPERSONATION</strong></td>
<td style="text-align:left">模拟模拟级别的客户端。 如果未指定其他标志以及 <strong>SECURITY_SQOS_PRESENT</strong> 标志，则这是默认行为。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] hTemplateFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        具有 <strong>GENERIC_READ</strong> 访问权限的模板文件的有效句柄。 模板文件为正在创建的文件提供文件属性和扩展属性。</p>
<p>​        此参数可以为 NULL。</p>
<p>​        打开现有文件时， <strong>CreateFile</strong> 将忽略此参数。</p>
<p>​        打开新的加密文件时，该文件将从其父目录继承任意访问控制列表。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。</p>
<h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是指定文件、设备、命名管道或邮件槽的打开句柄。</p>
<p>​        如果函数失败，则返回值为 INVALID_HANDLE_VALUE。 要获得更多的错误信息，请调用 GetLastError。</p>
<h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><p>​        <strong>CreateFile</strong> 最初专为文件交互而开发，但此后已扩展和增强，以包括 Windows 开发人员可用的大多数其他类型的 I/O 设备和机制。 本部分尝试介绍开发人员在不同上下文中使用不同的 I/O 类型使用 <strong>CreateFile</strong> 时可能遇到的各种问题。 仅当专门引用存储在文件系统上实际文件中的数据时，文本才会尝试使用单词 <em>文件</em> 。 但是，某些文件用法可能更普遍地引用支持类似 <em>文件的</em> I/O 对象。 由于前面提到的历史原因，这种自由使用术语 <em>文件</em> 在常量名称和参数名称中尤其普遍。</p>
<p>​        使用 <strong>CreateFile</strong> 返回的对象句柄完成应用程序后，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 函数关闭句柄。 这不仅释放了系统资源，而且可以对共享文件或设备以及将数据提交到磁盘等内容产生更广泛的影响。 本主题中会相应地说明具体内容。</p>
<p>​        <strong>Windows Server 2003 和 Windows XP：</strong> 如果尝试打开文件或目录以在远程计算机上删除，则发生共享冲突，当 <em>dwDesiredAccess</em> 参数的值是使用任何其他访问标志 (0x00010000) <strong>OR’ed</strong> 的 <strong>DELETE</strong> 访问标志，并且远程文件或目录尚未使用<strong>FILE_SHARE_DELETE</strong>打开。 为了避免此方案中的共享冲突，请仅打开具有 <strong>DELETE</strong> 访问权限的远程文件或目录，或者调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> ，而无需首先打开文件或目录进行删除。</p>
<p>​        某些文件系统（如 NTFS 文件系统）支持单个文件和目录的压缩或加密。 对于具有此支持的装载文件系统的卷，新文件继承其目录的压缩和加密属性。</p>
<p>​        不能使用 <strong>CreateFile</strong> 来控制文件或目录上的压缩、解压缩或解密。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">创建和打开文件</a>、 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-compression-and-decompression">文件压缩和解压缩</a>以及 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-encryption">文件加密</a>。</p>
<p>​        <strong>Windows Server 2003 和 Windows XP：</strong> 出于向后兼容性目的，在 <em>lpSecurityAttributes</em> 中指定安全描述符时，<strong>CreateFile</strong> 不会应用继承规则。 为了支持继承，以后查询此文件的安全描述符的函数可能会启发性地确定并报告继承是否有效。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/automatic-propagation-of-inheritable-aces">可继承 ACE 的自动传播</a>。</p>
<p>​        如前所述，如果 <em>lpSecurityAttributes</em> 参数为 <strong>NULL</strong>，则应用程序可能创建的任何子进程都无法继承 <strong>CreateFile</strong> 返回的句柄。 有关此参数的以下信息也适用：</p>
<ul>
<li>如果 <strong>bInheritHandle</strong> 成员变量不是 <strong>FALSE</strong>，这是任何非零值，则可以继承句柄。 因此，如果不希望句柄可继承，则此结构成员必须正确初始化为 <strong>FALSE</strong> 。</li>
<li>访问控制列表 (文件或目录的默认安全描述符中的 ACL) 继承自其父目录。</li>
<li>目标文件系统必须支持 <strong>lpSecurityDescriptor</strong> 成员对文件和目录的安全性，才能对其产生影响，这可以通过 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getvolumeinformationa">使用 GetVolumeInformation</a> 来确定。</li>
</ul>
<p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">技术</th>
<th style="text-align:left">支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td>
<td style="text-align:left">请参阅备注</td>
</tr>
<tr>
<td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td>
<td style="text-align:left">请参阅备注</td>
</tr>
<tr>
<td style="text-align:left">群集共享卷文件系统 (CsvFS)</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">弹性文件系统 (ReFS)</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
</div>
<p>​        请注意，如果对已打开的备用数据流的文件执行，具有取代处置的 <strong>CreateFile</strong> 将失败。</p>
<h4 id="符号链接行为"><a href="#符号链接行为" class="headerlink" title="符号链接行为"></a>符号链接行为</h4><p>​        如果对此函数的调用创建文件，则行为没有变化。 此外，请考虑有关 <strong>FILE_FLAG_OPEN_REPARSE_POINT</strong>的以下信息：</p>
<ul>
<li>如果指定了FILE_FLAG_OPEN_REPARSE_POINT<ul>
<li>如果打开现有文件并且它是符号链接，则返回的句柄是符号链接的句柄。</li>
<li>如果指定 <strong>了TRUNCATE_EXISTING</strong> 或 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> ，则受影响的文件是符号链接。</li>
</ul>
</li>
<li>如果未指定FILE_FLAG_OPEN_REPARSE_POINT：<ul>
<li>如果打开现有文件并且它是符号链接，则返回的句柄是目标句柄。</li>
<li>如果指定 <strong>CREATE_ALWAYS</strong>、 <strong>TRUNCATE_EXISTING</strong>或 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong> ，则受影响的文件是目标。</li>
</ul>
</li>
</ul>
<h4 id="缓存行为"><a href="#缓存行为" class="headerlink" title="缓存行为"></a>缓存行为</h4><p><strong>CreateFile</strong> 使用 <em>dwFlagsAndAttributes</em> 参数的多个可能值来控制或影响系统缓存与句柄关联的数据的方式。 它们是：</p>
<ul>
<li><strong>FILE_FLAG_NO_BUFFERING</strong></li>
<li><strong>FILE_FLAG_RANDOM_ACCESS</strong></li>
<li><strong>FILE_FLAG_SEQUENTIAL_SCAN</strong></li>
<li><strong>FILE_FLAG_WRITE_THROUGH</strong></li>
<li><strong>FILE_ATTRIBUTE_TEMPORARY</strong></li>
</ul>
<p>如果未指定这些标志，系统将使用默认的常规用途缓存方案。 否则，系统缓存的行为与为每个标志指定。</p>
<p>不应合并其中一些标志。 例如，将 <strong>FILE_FLAG_RANDOM_ACCESS</strong> 与 <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong> 相结合是自败。</p>
<p>指定 <strong>FILE_FLAG_SEQUENTIAL_SCAN</strong> 标志可以提高使用顺序访问读取大型文件的应用程序的性能。 对于主要按顺序读取大型文件的应用程序，性能提升可能更加明显，但偶尔会跳过小范围的字节。 如果应用程序移动文件指针进行随机访问，则很可能不会发生最佳缓存性能。 但是，仍可以保证正确的操作。</p>
<p><strong>标志FILE_FLAG_WRITE_THROUGH</strong>和<strong>FILE_FLAG_NO_BUFFERING</strong>是独立的，可以组合在一起。</p>
<p>如果使用 <strong>FILE_FLAG_WRITE_THROUGH</strong> 但 <strong>未指定FILE_FLAG_NO_BUFFERING</strong> ，以便系统缓存生效，则数据会写入系统缓存，但不会延迟地刷新到磁盘。</p>
<p>如果 <strong>同时指定了FILE_FLAG_WRITE_THROUGH</strong> 和 <strong>FILE_FLAG_NO_BUFFERING</strong> ，以便系统缓存无效，则数据会立即刷新到磁盘，而无需通过 Windows 系统缓存。 操作系统还会向永久性媒体请求硬盘本地硬件缓存的写入。</p>
<p><strong>注意</strong> 并非所有硬盘硬件都支持此写通功能。</p>
<p>正确使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志需要特殊的应用程序注意事项。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</p>
<p>通过 <strong>FILE_FLAG_WRITE_THROUGH</strong> 的写通请求还会导致 NTFS 刷新任何元数据更改，例如时间戳更新或重命名操作，这会导致处理请求。 因此， <strong>FILE_FLAG_WRITE_THROUGH</strong> 标志通常与 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志一起使用，作为每次写入后调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 函数的替代项，这可能会导致不必要的性能损失。 将这些标志一起使用可避免这些处罚。 有关文件和元数据缓存的一般信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-caching">文件缓存</a>。</p>
<p><strong>当FILE_FLAG_NO_BUFFERING</strong>与<strong>FILE_FLAG_OVERLAPPED</strong>结合使用时，标志提供最大的异步性能，因为 I/O 不依赖于内存管理器的同步操作。 但是，某些 I/O 操作需要更多时间，因为缓存中未保留数据。 此外，在创建空文件) 时，文件元数据仍可能 (缓存。 若要确保元数据刷新到磁盘，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers">FlushFileBuffers</a> 函数。</p>
<p>如果有足够的缓存内存可用，则指定 <strong>FILE_ATTRIBUTE_TEMPORARY</strong> 属性会导致文件系统避免将数据写回到大容量存储，因为应用程序在关闭句柄后删除临时文件。 在这种情况下，系统可以完全避免写入数据。 尽管它不直接控制数据缓存的方式与前面提到的标志相同， <strong>但FILE_ATTRIBUTE_TEMPORARY</strong> 属性确实会告知系统在系统缓存中尽可能多地保留，而无需写入，因此可能对某些应用程序感到担忧。</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>如果重命名或删除文件，然后在不久后还原该文件，系统将在缓存中搜索要还原的文件信息。 缓存信息包括其短/长名称对和创建时间。</p>
<p>如果在之前调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-deletefilea">DeleteFile</a> 时挂起删除的文件上调用 <strong>CreateFile</strong>，该函数将失败。 操作系统会延迟文件删除，直到文件的所有句柄都关闭。 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_ACCESS_DENIED</strong>。</p>
<p><em>dwDesiredAccess</em> 参数可以是零，允许应用程序在不访问文件的情况下查询文件属性（如果应用程序正在运行且具有足够的安全设置）。 这可用于测试文件是否存在，而无需打开该文件进行读取和/或写入访问，或获取有关文件或目录的其他统计信息。 请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/obtaining-and-setting-file-information">获取和设置文件信息和</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getfileinformationbyhandle">GetFileInformationByHandle</a>。</p>
<p>如果指定 <strong>了CREATE_ALWAYS</strong> 和 <strong>FILE_ATTRIBUTE_NORMAL</strong> ， <strong>则 CreateFile</strong> 将失败，并将最后一个错误设置为 <strong>ERROR_ACCESS_DENIED</strong> （如果文件存在并且具有 <strong>FILE_ATTRIBUTE_HIDDEN</strong> 或 <strong>FILE_ATTRIBUTE_SYSTEM</strong> 属性）。 若要避免此错误，请指定与现有文件相同的属性。</p>
<p>当应用程序跨网络创建文件时，最好将 <em>dwDesiredAccess 用于 dwDesiredAccess</em>，而不是单独使用 <strong>GENERIC_WRITE</strong>。<code>GENERIC_READ | GENERIC_WRITE</code> 生成的代码速度更快，因为重定向程序可以使用缓存管理器，并发送更少的 SMB 和更多数据。 这种组合还避免了写入网络中的文件偶尔会返回 <strong>ERROR_ACCESS_DENIED</strong>的问题。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/creating-and-opening-files">“创建和打开文件</a>”。</p>
<h4 id="同步和异步-I-O-句柄"><a href="#同步和异步-I-O-句柄" class="headerlink" title="同步和异步 I/O 句柄"></a>同步和异步 I/O 句柄</h4><p><strong>CreateFile</strong> 用于创建同步或异步的文件或设备句柄。 同步句柄的行为使使用该句柄的 I/O 函数调用被阻止，直到它们完成，而异步文件句柄使系统能够立即从 I/O 函数调用返回，无论它们是否完成了 I/O 操作。 如前所述，此同步与异步行为通过指定 <em>dwFlagsAndAttributes</em> 参数中的<strong>FILE_FLAG_OVERLAPPED</strong>来确定。 使用异步 I/O 时存在多种复杂性和潜在缺陷;有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">同步和异步 I/O</a>。</p>
<h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><p>在 NTFS 文件系统上，可以使用 <strong>CreateFile</strong> 在文件中创建单独的流。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-streams">文件流</a>。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>应用程序无法使用 <strong>CreateFile</strong> 创建目录，因此对于此用例，只有 <strong>OPEN_EXISTING</strong> 值对 <em>dwCreationDisposition</em> 有效。 若要创建目录，应用程序必须调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createdirectorya">CreateDirectory</a> 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createdirectoryexa">CreateDirectoryEx</a>。</p>
<p>若要使用 <strong>CreateFile</strong> 打开目录，请将 <strong>FILE_FLAG_BACKUP_SEMANTICS</strong> 标志指定为 <em>dwFlagsAndAttributes</em> 的一部分。 在没有 <strong>SE_BACKUP_NAME</strong> 和 <strong>SE_RESTORE_NAME</strong> 特权的情况下使用此标志时，仍适用适当的安全检查。</p>
<p>使用 <strong>CreateFile</strong> 在对 FAT 或 FAT32 文件系统卷进行碎片整理期间打开目录时，请不要指定 <strong>MAXIMUM_ALLOWED</strong> 访问权限。 如果这样做，则拒绝对目录的访问。 请改为指定 <strong>GENERIC_READ</strong> 访问权限。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/about-directory-management">“关于目录管理</a>”。</p>
<h4 id="物理磁盘和卷"><a href="#物理磁盘和卷" class="headerlink" title="物理磁盘和卷"></a>物理磁盘和卷</h4><p>对磁盘或卷的直接访问受到限制。</p>
<p><strong>Windows Server 2003 和 Windows XP：</strong> 以这种方式不限制对磁盘或卷的直接访问。</p>
<p>可以使用 <strong>CreateFile</strong> 函数打开物理磁盘驱动器或卷，该驱动器返回直接访问存储设备 (DASD) 句柄，该句柄可与 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 函数一起使用。 这样，便可以直接访问磁盘或卷，例如分区表等磁盘元数据。 但是，这种类型的访问也会向潜在的数据丢失公开磁盘驱动器或卷，因为使用此机制对磁盘进行不正确的写入可能会使其内容无法访问操作系统。 为了确保数据完整性，请务必熟悉 <strong>DeviceIoControl</strong> ，以及其他 API 的行为方式与直接访问句柄不同，而不是文件系统句柄。</p>
<p>必须满足以下要求才能成功进行此类调用：</p>
<ul>
<li>调用方必须具有管理权限。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecBP/running-with-special-privileges">使用特殊特权运行</a>。</li>
<li><em>dwCreationDisposition</em> 参数必须具有<strong>OPEN_EXISTING</strong>标志。</li>
<li>打开卷或软盘时， <em>dwShareMode</em> 参数必须具有 <strong>FILE_SHARE_WRITE</strong> 标志。</li>
</ul>
<p><strong>注意*</strong>dwDesiredAccess* 参数可以是零，允许应用程序在不访问设备的情况下查询设备属性。 这适用于应用程序来确定软盘驱动器的大小及其支持的格式，而无需驱动器中的软盘磁盘，例如。 它还可用于读取统计信息，而无需更高级别的数据读取/写入权限。</p>
<p>打开物理驱动器 <em>x</em>：时， <em>lpFileName</em> 字符串应采用以下形式：“.\PhysicalDrive<em>X</em>”。 硬盘编号从零开始。 下表显示了物理驱动器字符串的一些示例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">String</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“\.\PhysicalDrive0”</td>
<td style="text-align:left">打开第一个物理驱动器。</td>
</tr>
<tr>
<td style="text-align:left">“\.\PhysicalDrive2”</td>
<td style="text-align:left">打开第三个物理驱动器。</td>
</tr>
</tbody>
</table>
</div>
<p>若要获取卷的物理驱动器标识符，请打开卷的句柄，并使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-ioctl_volume_get_volume_disk_extents">IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS</a> 调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 函数。 此控制代码返回每个卷的一个或多个盘区的磁盘数和偏移量;卷可以跨越多个物理磁盘。</p>
<p>有关打开物理驱动器的示例，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/calling-deviceiocontrol">调用 DeviceIoControl</a>。</p>
<p>例如，打开卷或可移动媒体驱动器 (时，软盘驱动器或闪存内存拇指驱动器) ， <em>lpFileName</em> 字符串应采用以下形式：“.*X*：”。 请勿使用尾随反斜杠 () ，指示驱动器的根目录。 下表显示了驱动器字符串的一些示例。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">String</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“\.\A：”</td>
<td style="text-align:left">打开软盘驱动器 A。</td>
</tr>
<tr>
<td style="text-align:left">“\.\C：”</td>
<td style="text-align:left">打开 C： 卷。</td>
</tr>
<tr>
<td style="text-align:left">“\.\C：\”</td>
<td style="text-align:left">打开 C： 卷的文件系统。</td>
</tr>
</tbody>
</table>
</div>
<p>还可以通过引用其卷名称打开卷。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-volume">命名卷</a>。</p>
<p>卷包含一个或多个装载的文件系统。 即使 <strong>CreateFile</strong> 中未指定非缓存选项，也可以按特定文件系统的任意方式打开卷句柄。 应假定所有 Microsoft 文件系统都以非缓存的形式打开卷句柄。 对文件的非缓存 I/O 的限制也适用于卷。</p>
<p>即使数据未缓存，文件系统也可能不需要缓冲区对齐。 但是，如果在打开卷时指定了非缓存选项，则会强制实施缓冲区对齐方式，而不管卷上的文件系统如何。 建议在所有文件系统上以非缓存方式打开卷句柄，并遵循非缓存 I/O 限制。</p>
<p><strong>注意</strong> 若要读取或写入卷的最后几个扇区，必须调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 并指定 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-fsctl_allow_extended_dasd_io">FSCTL_ALLOW_EXTENDED_DASD_IO</a>。 这表示文件系统驱动程序不会对分区读取或写入调用执行任何 I/O 边界检查。 相反，边界检查由设备驱动程序执行。</p>
<h4 id="更改器设备"><a href="#更改器设备" class="headerlink" title="更改器设备"></a>更改器设备</h4><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol">DeviceIoControl</a> 的 <strong>IOCTL_CHANGER_*</strong> 控制代码接受变更器设备的句柄。 若要打开变更器设备，请使用以下格式的文件名：“\.\Changer<em>x</em>”，其中 <em>x</em> 是一个数字，指示要打开的设备，从零开始。 若要在用 C 或 C++ 编写的应用程序中打开变更器设备零，请使用以下文件名：“\\.\\Changer0”。</p>
<h4 id="磁带驱动器"><a href="#磁带驱动器" class="headerlink" title="磁带驱动器"></a>磁带驱动器</h4><p>可以使用以下格式的文件名打开磁带驱动器：“\.\TAPE<em>x</em>”，其中 <em>x</em> 是一个数字，指示要打开的驱动器，从磁带驱动器零开始。 若要在以 C 或 C++ 编写的应用程序中打开磁带驱动器零，请使用以下文件名：“\\.\\TAPE0”。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Backup/backup">备份</a>。</p>
<h4 id="通信资源"><a href="#通信资源" class="headerlink" title="通信资源"></a>通信资源</h4><p><strong>CreateFile</strong> 函数可以创建通信资源的句柄，例如串行端口 COM1。 对于通信资源， <em>dwCreationDisposition</em> 参数必须 <strong>OPEN_EXISTING</strong>， <em>dwShareMode</em> 参数必须是零 (独占访问) ， <em>并且 hTemplateFile</em> 参数必须为 <strong>NULL</strong>。 可以指定读取、写入或读/写访问权限，并且可以为重叠 I/O 打开句柄。</p>
<p>若要指定大于 9 的 COM 端口号，请使用以下语法：“.\COM10”。 此语法适用于允许指定 COM 端口号的所有端口号和硬件。</p>
<p>有关通信的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/DevIO/communications-resources">通信</a>。</p>
<h4 id="机"><a href="#机" class="headerlink" title="机"></a>机</h4><p><strong>CreateFile</strong> 函数可以创建控制台输入 (CONIN$) 句柄。 如果进程由于继承或重复而具有打开的句柄，则它还可以创建活动屏幕缓冲区 (CONOUT$) 的句柄。 调用进程必须附加到继承的控制台或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/allocconsole">由 AllocConsole</a> 函数分配的控制台。 对于控制台句柄，请按如下所示设置 <strong>CreateFile</strong> 参数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">lpFileName</td>
<td style="text-align:left">使用 CONIN$ 值指定控制台输入。使用 CONOUT$ 值指定控制台输出。CONIN$ 获取控制台输入缓冲区的句柄，即使 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/setstdhandle">SetStdHandle</a> 函数重定向标准输入句柄。 若要获取标准输入句柄，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/getstdhandle">GetStdHandle</a> 函数。CONOUT$ 获取活动屏幕缓冲区的句柄，即使 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/setstdhandle">SetStdHandle</a> 重定向标准输出句柄。 若要获取标准输出句柄，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/console/getstdhandle">GetStdHandle</a>。</td>
</tr>
<tr>
<td style="text-align:left">dwDesiredAccess</td>
<td style="text-align:left">`GENERIC_READ</td>
<td>GENERIC_WRITE` 首选，但任一限制访问。</td>
</tr>
<tr>
<td style="text-align:left">dwShareMode</td>
<td style="text-align:left">打开 CONIN$时，请指定 <strong>FILE_SHARE_READ</strong>。 打开 CONOUT$时，请指定 <strong>FILE_SHARE_WRITE</strong>。如果调用进程继承控制台，或者子进程应能够访问控制台，则必须是 `FILE_SHARE_READ</td>
<td>FILE_SHARE_WRITE`此参数。</td>
</tr>
<tr>
<td style="text-align:left">lpSecurityAttributes</td>
<td style="text-align:left">如果希望继承控制台，<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/legacy/aa379560(v=vs.85">SECURITY_ATTRIBUTES结构的</a>)<strong>bInheritHandle</strong> 成员必须为 <strong>TRUE</strong>。</td>
</tr>
<tr>
<td style="text-align:left">dwCreationDisposition</td>
<td style="text-align:left">使用 <strong>CreateFile</strong> 打开控制台时，应指定<strong>OPEN_EXISTING</strong>。</td>
</tr>
<tr>
<td style="text-align:left">dwFlagsAndAttributes</td>
<td style="text-align:left">已忽略。</td>
</tr>
<tr>
<td style="text-align:left">hTemplateFile</td>
<td style="text-align:left">已忽略。</td>
</tr>
</tbody>
</table>
</div>
<p>下表显示了 <em>dwDesiredAccess</em> 和 <em>lpFileName</em> 的各种设置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">lpFileName</th>
<th style="text-align:left">dwDesiredAccess</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“CON”</td>
<td style="text-align:left"><strong>GENERIC_READ</strong></td>
<td style="text-align:left">打开用于输入的控制台。</td>
</tr>
<tr>
<td style="text-align:left">“CON”</td>
<td style="text-align:left"><strong>GENERIC_WRITE</strong></td>
<td style="text-align:left">打开用于输出的控制台。</td>
</tr>
<tr>
<td style="text-align:left">“CON”</td>
<td style="text-align:left">`GENERIC_READ</td>
<td style="text-align:left">GENERIC_WRITE`</td>
<td>导致 <strong>CreateFile</strong> 失败; <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_FILE_NOT_FOUND</strong>。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Mailslots"><a href="#Mailslots" class="headerlink" title="Mailslots"></a>Mailslots</h4><p>如果 <strong>CreateFile</strong> 打开 mailslot 的客户端端，则函数将返回 <strong>INVALID_HANDLE_VALUE</strong> 如果 mailslot 客户端尝试在 mailslot 服务器使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createmailslota">CreateMailSlot 函数创建本地 mailslot 之前打开本地 mailslot</a> 。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/mailslots">Mailslots</a>。</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>如果 <strong>CreateFile</strong> 打开命名管道的客户端端，该函数将使用处于侦听状态的命名管道的任何实例。 打开过程可以根据需要多次复制句柄，但在打开该句柄之后，另一个客户端无法打开命名管道实例。 打开管道时指定的访问必须与 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> 函数的 <em>dwOpenMode</em> 参数中指定的访问兼容。</p>
<p>如果在此操作之前未在服务器上成功调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-createnamedpipea">CreateNamedPipe</a> 函数，则管道将不存在， <strong>并且 CreateFile</strong> 将失败 <strong>并出现ERROR_FILE_NOT_FOUND</strong>。</p>
<p>如果至少有一个活动管道实例，但服务器上没有可用的侦听器管道，这意味着所有管道实例当前都已连接， <strong>则 CreateFile</strong> 会失败 <strong>并ERROR_PIPE_BUSY</strong>。</p>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/pipes">管道</a>。</p>
<h3 id="ReadFile-函数-fileapi-h"><a href="#ReadFile-函数-fileapi-h" class="headerlink" title="ReadFile 函数 (fileapi.h)"></a>ReadFile 函数 (fileapi.h)</h3><p>从指定的文件或输入/输出 (I/O) 设备读取数据。 如果设备支持，则读取发生在文件指针指定的位置。</p>
<p>此函数适用于同步操作和异步操作。 有关专为异步操作设计的类似函数，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a>。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">ReadFile</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>                HANDLE       hFile<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">]</span>               LPVOID       lpBuffer<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>                DWORD        nNumberOfBytesToRead<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>     LPDWORD      lpNumberOfBytesRead<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPOVERLAPPED lpOverlapped
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] hFile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设备句柄 (例如文件、文件流、物理磁盘、卷、控制台缓冲区、磁带驱动器、套接字、通信资源、mailslot 或管道) 。</p>
<p>必须使用读取访问权限创建 <em>hFile</em> 参数。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/SecAuthZ/generic-access-rights">通用访问权限</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-security-and-access-rights">文件安全性和访问权限</a>。</p>
<p>对于异步读取操作，<em>hFile</em> 可以是使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 函数的<strong>FILE_FLAG_OVERLAPPED</strong>标志打开的任何句柄，也可以是套接字或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock2/nf-winsock2-accept">accept</a> 函数返回的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winsock2/nf-winsock2-socket">套接字</a>句柄。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>指向接收从文件或设备读取数据的缓冲区的指针。</p>
<p>此缓冲区必须在读取操作期间保持有效。 在读取操作完成之前，调用方不得使用此缓冲区。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] nNumberOfBytesToRead<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要读取的最多字节数。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpNumberOfBytesRead<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>指向使用同步 <em>hFile</em> 参数时接收读取的字节数的变量的指针。 <strong>ReadFile</strong> 将此值设置为零，然后再执行任何工作或错误检查。 如果这是一个异步操作，请对此参数使用 <strong>NULL</strong> ，以避免潜在的错误结果。</p>
<p>仅当 <em>lpOverlapped</em> 参数不为 <strong>NULL</strong> 时，此参数才可为 <strong>NULL</strong>。</p>
<p><strong>Windows 7：</strong> 此参数不能为 <strong>NULL</strong>。</p>
<p>有关详细信息，请参见“备注”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in, out, optional] lpOverlapped<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong> 打开 <em>hFile</em> 参数，则需要指向 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的指针，否则可为 <strong>NULL</strong>。</p>
<p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong>打开 <em>hFile</em>，<em>则 lpOverlapped</em> 参数必须指向有效且唯一的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构，否则该函数无法错误地报告读取操作已完成。</p>
<p>对于支持字节偏移量的 <em>hFile</em> ，如果使用此参数，则必须指定从文件或设备开始读取的字节偏移量。 通过设置 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的 <strong>Offset</strong> 和 <strong>OffsetHigh</strong> 成员来指定此偏移量。 对于不支持字节偏移量的 <em>hFile</em>，将忽略 <strong>Offset 和 OffsetHigh</strong>。</p>
<p>有关 <em>lpOverlapped</em> 和 <strong>FILE_FLAG_OVERLAPPED</strong>的不同组合的详细信息，请参阅“备注”部分和 <strong>“同步和文件位置</strong> ”部分。</p>
<h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>如果函数成功，则返回值为非零 (<strong>TRUE</strong>) 。</p>
<p>如果函数失败或异步完成，则返回值为零， (<strong>FALSE</strong>) 。 若要获取扩展的错误信息，请调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数。</p>
<p><strong>注意</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 代码<strong>ERROR_IO_PENDING</strong>不是失败;它指定读取操作正在异步等待完成。 有关详细信息，请参阅“备注”。</p>
<h4 id="注解-2"><a href="#注解-2" class="headerlink" title="注解"></a>注解</h4><p>发生以下情况之一时， <strong>ReadFile</strong> 函数将返回：</p>
<ul>
<li></li>
<li><p>读取请求的字节数。</p>
</li>
<li>写入操作在管道的写入端完成。</li>
<li>正在使用异步句柄，读取正在异步发生。</li>
<li>发生错误。</li>
</ul>
<p>每当有过多未完成的异步 I/O 请求时，<strong>ReadFile</strong> 函数可能会失败<strong>，**</strong>ERROR_INVALID_USER_BUFFER或ERROR_NOT_ENOUGH_MEMORY**。</p>
<p>若要取消所有挂起的异步 I/O 操作，请使用以下任一操作：</p>
<ul>
<li></li>
<li><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelio">CancelIo</a> - 此函数仅取消由指定文件句柄的调用线程发出的操作。</p>
</li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelioex-func">CancelIoEx</a> - 此函数取消指定文件句柄的线程发出的所有操作。</li>
</ul>
<p>使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/cancelsynchronousio-func">CancelSynchronousIo</a> 取消挂起的同步 I/O 操作。</p>
<p>取消的 I/O 操作已完成，错误 <strong>ERROR_OPERATION_ABORTED</strong>。</p>
<p><strong>ReadFile</strong> 函数可能会失败<strong>，ERROR_NOT_ENOUGH_QUOTA</strong>，这意味着调用进程的缓冲区无法锁定页。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-setprocessworkingsetsize">SetProcessWorkingSetSize</a>。</p>
<p>如果某个文件的一部分被另一个进程锁定，并且读取操作与锁定部分重叠，则此函数将失败。</p>
<p>读取操作使用缓冲区时访问输入缓冲区可能会导致读取到该缓冲区的数据损坏。 在读取操作完成之前，应用程序不得读取、写入、重新分配或释放读取操作使用的输入缓冲区。 使用异步文件句柄时，这尤其有问题。 有关同步与异步文件句柄的其他信息，可以在 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/">“同步和文件位置</a> ”部分以及 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 参考主题中找到。</p>
<p>可以使用具有控制台输入句柄的 <strong>ReadFile</strong> 从控制台输入缓冲区读取字符。 控制台模式确定 <strong>ReadFile</strong> 函数的确切行为。 默认情况下，控制台模式 <strong>ENABLE_LINE_INPUT</strong>，指示 <strong>ReadFile</strong> 应在到达回车前读取。 如果按 Ctrl+C，则调用成功，但 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_OPERATION_ABORTED</strong>。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a>。</p>
<p>从通信设备读取时， <strong>ReadFile</strong> 的行为由当前通信超时确定为集，并使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-setcommtimeouts">SetCommTimeouts</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-getcommtimeouts">GetCommTimeouts</a> 函数进行检索。 如果无法设置超时值，则可能会出现不可预知的结果。 有关通信超时的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/ns-winbase-commtimeouts">COMMTIMEOUTS</a>。</p>
<p>如果 <strong>ReadFile</strong> 尝试从具有太小缓冲区的邮件图中读取，则函数返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_INSUFFICIENT_BUFFER</strong>。</p>
<p>使用 <strong>FILE_FLAG_NO_BUFFERING</strong> 标志成功使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 打开的文件有严格的要求。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-buffering">文件缓冲</a>。</p>
<p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong> 打开 <em>hFile</em>，则以下条件有效：</p>
<ul>
<li></li>
<li><p><em>lpOverlapped</em> 参数必须指向有效且唯一的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构，否则该函数可以错误地报告读取操作已完成。</p>
</li>
<li><em>lpNumberOfBytesRead</em> 参数应设置为 <strong>NULL</strong>。 使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> 函数获取读取的实际字节数。 如果 <em>hFile</em> 参数与 I/O 完成端口相关联，则还可以通过调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus">GetQueuedCompletionStatus</a> 函数获取读取的字节数。</li>
</ul>
<h4 id="同步和文件位置"><a href="#同步和文件位置" class="headerlink" title="同步和文件位置"></a>同步和文件位置</h4><p>如果使用 <strong>FILE_FLAG_OVERLAPPED</strong>打开 <em>hFile</em>，则它是异步文件句柄;否则为同步。 使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED</a> 结构的规则对每个结构略有不同，如前所述。</p>
<p><strong>注意</strong> 如果为异步 I/O 打开文件或设备，则使用该句柄对 <strong>ReadFile</strong> 等函数的后续调用通常会立即返回，但对于被阻止的执行，也可以同步执行。 有关更多信息，请参见<a target="_blank" rel="noopener" href="https://support.microsoft.com/kb/156932">http://support.microsoft.com/kb/156932</a>。</p>
<p>使用异步文件句柄的注意事项：</p>
<ul>
<li><p><strong>ReadFile</strong> 可能会在读取操作完成之前返回。 在此方案中， <strong>ReadFile</strong> 返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数返回 <strong>ERROR_IO_PENDING</strong>，这允许调用进程在系统完成读取操作时继续。</p>
</li>
<li><p>lpOverlapped</p>
</li>
</ul>
<p>  参数不得为</p>
<p>  NULL</p>
<p>  ，应与以下事实一起使用：</p>
<ul>
<li>尽管 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件由系统自动设置和重置，但 <strong>在 OVERLAPPED</strong> 结构中指定的偏移量不会自动更新。</li>
<li><strong>ReadFile</strong> 在开始 I/O 操作时将事件重置为非对齐状态。</li>
<li>在 READ 操作完成时， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的事件设置为信号状态;直到该时间，读取操作被视为挂起。</li>
<li>由于读取操作从 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的偏移量开始，并且 <strong>ReadFile</strong> 可能会在系统级读取操作完成 (读取挂起) 之前返回，因此，应用程序不应修改、释放或重用结构的任何其他部分，直到向事件发出信号 (（即） 读取完成) 。</li>
<li>如果在异步操作期间检测到文件结束 (EOF) ，则对该操作的 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/ioapiset/nf-ioapiset-getoverlappedresult">GetOverlappedResult</a> 的调用将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_HANDLE_EOF</strong>。</li>
</ul>
<p>使用同步文件句柄的注意事项：</p>
<ul>
<li>如果 <em>lpOverlapped</em> 为 <strong>NULL</strong>，则读取操作从当前文件位置开始， <strong>ReadFile</strong> 在操作完成之前不会返回，并且系统会在 <strong>ReadFile</strong> 返回之前更新文件指针。</li>
<li>如果 <em>lpOverlapped</em> 不是 <strong>NULL</strong>，则读取操作从 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ns-minwinbase-overlapped">在 OVERLAPPED</a> 结构中指定的偏移量开始， <strong>ReadFile</strong> 在读取操作完成之前不会返回。 系统在 <strong>ReadFile</strong> 返回之前更新 <strong>OVERLAPPED</strong> 偏移量和文件指针。</li>
<li>如果 <em>lpOverlapped</em> 为 <strong>NULL</strong>，则当同步读取操作到达文件末尾时， <strong>ReadFile</strong> 将返回 <strong>TRUE</strong> 并将设置为 <code>*lpNumberOfBytesRead</code> 零。</li>
<li>如果 <em>lpOverlapped</em> 不是 <strong>NULL</strong>，则当同步读取操作到达文件末尾时， <strong>ReadFile</strong> 将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_HANDLE_EOF</strong>。</li>
</ul>
<p>有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/synchronous-and-asynchronous-i-o">同步和异步 I/O</a>。</p>
<h4 id="管道-1"><a href="#管道-1" class="headerlink" title="管道"></a>管道</h4><p>如果使用匿名管道并且写入句柄已关闭，则 <strong>当 ReadFile</strong> 尝试使用管道的相应读取句柄进行读取时，函数将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_BROKEN_PIPE</strong>。</p>
<p>如果在消息模式下读取命名管道，并且下一条消息的长度超过 <em>nNumberOfBytesToRead</em> 参数指定， <strong>ReadFile</strong> 将返回 <strong>FALSE</strong> ， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回 <strong>ERROR_MORE_DATA</strong>。 后续调用 <strong>ReadFile</strong> 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe">PeekNamedPipe</a> 函数可以读取消息的其余部分。</p>
<p>如果 <strong>ReadFile</strong> 在管道上返回 <strong>TRUE</strong> 时<em>，lpNumberOfBytesRead</em> 参数为零，则管道的另一端称为 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-writefile">WriteFile</a> 函数，<em>nNumberOfBytesToWrite</em> 设置为零。</p>
<p>有关管道的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/ipc/pipes">管道</a>。</p>
<h4 id="事务处理的操作"><a href="#事务处理的操作" class="headerlink" title="事务处理的操作"></a>事务处理的操作</h4><p>如果存在绑定到文件句柄的事务，则该函数将从文件的事务处理视图中返回数据。 保证事务处理读取句柄在句柄期间显示文件的相同视图。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/about-transactional-ntfs">关于事务 NTFS</a>。</p>
<p>在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
<h2 id="Windows数据结构"><a href="#Windows数据结构" class="headerlink" title="Windows数据结构"></a>Windows数据结构</h2><p>​        这里的数据结构指的是Windows文件体系的结构。</p>
<p>​        这里的结构是用老式的C定义与实现的，为了与之对应，我们采取打开一个文件的属性查看作为可视化的理解。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef struct _WIN32_FILE_ATTRIBUTE_DATA &#123;
    DWORD dwFileAttributes;&#x2F;&#x2F; 文件属性
    FILETIME ftCreationTime;&#x2F;&#x2F; 创建时间
    FILETIME ftLastAccessTime;&#x2F;&#x2F; 最后访问时间
    FILETIME ftLastWriteTime;&#x2F;&#x2F; 最后修改
    DWORD nFileSizeHigh;&#x2F;&#x2F; 文件长度
    DWORD nFileSizeLow; &#x2F;&#x2F; 文件长度
&#125; WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230516204344506.png" alt="image-20230516204344506"></p>
<p>​        下面我们来看怎样使用这样的结构. </p>
<h2 id="一些函数的讲解"><a href="#一些函数的讲解" class="headerlink" title="一些函数的讲解"></a>一些函数的讲解</h2><p>​        我们获取文件属性使用Windows的<code>GetFileAttributesEx</code>函数宏,他需要参数文件地址,获取方式和<code>WIN32_FILE_ATTRIBUTE_DATA</code>结构体.这个函数跟我们熟悉的C变成一样,以参数的参数进入返回初始化后的参数.</p>
<h3 id="GetFileAttributesEx"><a href="#GetFileAttributesEx" class="headerlink" title="GetFileAttributesEx()"></a>GetFileAttributesEx()</h3><h4 id="GetFileAttributesExW-函数-fileapi-h"><a href="#GetFileAttributesExW-函数-fileapi-h" class="headerlink" title="GetFileAttributesExW 函数 (fileapi.h)"></a>GetFileAttributesExW 函数 (fileapi.h)</h4><p>反馈</p>
<p>检索指定文件或目录的属性。</p>
<p>若要将此操作作为事务处理操作执行，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-getfileattributestransacteda">GetFileAttributesTransacted</a> 函数。</p>
<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetFileAttributesExW</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  LPCWSTR                lpFileName<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  GET_FILEEX_INFO_LEVELS fInfoLevelId<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPVOID                 lpFileInformation
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h5><pre class="line-numbers language-none"><code class="language-none">[in] lpFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        文件或目录的名称。</p>
<p>​        在此函数的 ANSI 版本中，名称限制为 <strong>MAX_PATH</strong> 个字符。 若要将此限制扩展到 32，767 宽字符，请调用函数的 Unicode 版本 (<strong>GetFileAttributesExW</strong>) ，并将“\\？\”追加到路径。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-file">命名文件</a>。</p>
<p><strong>提示</strong></p>
<p>从 Windows 10 版本 1607 开始，对于此函数的 unicode 版本， (<strong>GetFileAttributesExW</strong>) ，可以选择加入以删除<strong>MAX_PATH</strong>字符限制，而无需追加“\\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径限制”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] fInfoLevelId<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        要检索的属性信息的类。</p>
<p>​        此参数可以是 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/minwinbase/ne-minwinbase-get_fileex_info_levels">GET_FILEEX_INFO_LEVELS</a> 枚举中的以下值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>GetFileExInfoStandard</strong></td>
<td style="text-align:left"><em>lpFileInformation</em> 参数是<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/ns-fileapi-win32_file_attribute_data">一个WIN32_FILE_ATTRIBUTE_DATA</a>结构。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[out] lpFileInformation<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收属性信息的缓冲区的指针。</p>
<p>​        存储在此缓冲区中的属性信息类型由 fInfoLevelId 的值决定。</p>
<h2 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为 0 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p>
<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><p>​        现在我们拿到了初始化结束的结构体,我们想看看时间.要知道,显示时间是可以多样化的,意味着微软希望我们自己书写函数来展示之.</p>
<p>​        为了提高效率,时间被压缩在几个字节,需要我们自己来转化.这个也是一个结构体<code>FileTime</code>.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void showFileTime(PFILETIME aTime)
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;
#include&lt;iostream&gt;
using namespace std;

void showFileTime(PFILETIME aTime)
&#123;
	FILETIME filetimeLocal;
	SYSTEMTIME sysFileTime;
	FileTimeToLocalFileTime(aTime, &amp;filetimeLocal);&#x2F;&#x2F; 转换成系统时区时间
	FileTimeToSystemTime(&amp;filetimeLocal, &amp;sysFileTime);

	cout &lt;&lt; sysFileTime.wYear &lt;&lt; &quot; 年 &quot; &lt;&lt; sysFileTime.wMonth &lt;&lt; &quot; 月 &quot; &lt;&lt; \
		sysFileTime.wDay &lt;&lt; &quot; 日 &quot; &lt;&lt; sysFileTime.wHour&lt;&lt;&quot;时&quot; &lt;&lt; sysFileTime.wMinute &lt;&lt; &quot; 分 &quot; &lt;&lt; sysFileTime.wSecond &lt;&lt; &quot; 秒&quot; &lt;&lt; endl;

	return;
&#125;



void showInfo(LPWIN32_FILE_ATTRIBUTE_DATA pWfad)
&#123;
	if (pWfad &#x3D;&#x3D; NULL) &#123;
		cout &lt;&lt; &quot;Failed to get the file&quot;;
		return;
	&#125;

	showFileTime(&amp;pWfad-&gt;ftCreationTime);
	showFileTime(&amp;pWfad-&gt;ftLastAccessTime);
&#125;


int main()&#123;

	WIN32_FILE_ATTRIBUTE_DATA wfad;

	if (!GetFileAttributesEx(L&quot;1.cpp&quot;, GetFileExInfoStandard, &amp;wfad))
	&#123;

		cout &lt;&lt; &quot;Failed to get the file&quot;;
		return 1;
	&#125;

	
	showInfo(&amp;wfad);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230516211817965.png" alt="image-20230516211817965"></p>
<h2 id="获取系统目录"><a href="#获取系统目录" class="headerlink" title="获取系统目录"></a>获取系统目录</h2><p>​        为了获取系统目录信息，需要使用函数来完成这项工作！这个函数是<code>GetSystemDirectory()</code></p>
<p>​        使用它很简单：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;locale.h&gt;
int main() &#123;

	setlocale(LC_ALL,&quot;&quot;);

	TCHAR szSystemDir[MAX_PATH];

	GetSystemDirectory(szSystemDir, MAX_PATH);

	printf(&quot;%ls&quot;, szSystemDir);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="GetSystemDirectoryW-函数-sysinfoapi-h"><a href="#GetSystemDirectoryW-函数-sysinfoapi-h" class="headerlink" title="GetSystemDirectoryW 函数 (sysinfoapi.h)"></a>GetSystemDirectoryW 函数 (sysinfoapi.h)</h3><p>​        检索系统目录的路径。 系统目录包含系统文件，如动态链接库和驱动程序。</p>
<p>​        此函数主要用于兼容性。 应用程序应将代码存储在 Program Files 文件夹中，并将持久数据存储在用户配置文件的 Application Data 文件夹中。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha">ShGetFolderPath</a>。</p>
<h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">UINT <span class="token function">GetSystemDirectoryW</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpBuffer<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  UINT   uSize
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向要接收路径的缓冲区的指针。 除非系统目录是根目录，否则此路径不会以反斜杠结尾。 例如，如果系统目录在驱动器 C 上命名为 Windows\System32，则此函数检索的系统目录的路径为 C：\Windows\System32。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] uSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        缓冲区的最大大小（以 <strong>TCHAR</strong> 为单位）。</p>
<h4 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值为复制到缓冲区的字符串的长度（以 <strong>TCHAR</strong> 为单位），不包括终止 null 字符。 如果长度大于缓冲区的大小，则返回值是保存路径所需的缓冲区大小，包括终止 null 字符。</p>
<p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<p>​        </p>
<p><img src="image-20230518231050866.png" alt="image-20230518231050866"></p>
<p>​        下面写之进入一个文件！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;locale.h&gt;
int main() &#123;

	setlocale(LC_ALL,&quot;&quot;);

	TCHAR szSystemDir[MAX_PATH];

	GetSystemDirectory(szSystemDir, MAX_PATH);

	printf(&quot;%ls&quot;, szSystemDir);
	DWORD dwWritten;
	HANDLE hFile;
	hFile &#x3D; CreateFile(L&quot;SystemRoot.txt&quot;, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFile !&#x3D; INVALID_HANDLE_VALUE) &#123;
		if (!WriteFile(hFile, szSystemDir, 2*lstrlen(szSystemDir), &amp;dwWritten, NULL)) &#123;
			return GetLastError();
		&#125;
	&#125;

	CloseHandle(hFile);
	printf(&quot;OK&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="创建窗口和消息处理"><a href="#创建窗口和消息处理" class="headerlink" title="创建窗口和消息处理"></a>创建窗口和消息处理</h2><p>​        两大方法：使用向导来创建窗口，或者是手写代码自己来写</p>
<p>​        我们来创建一个Windows应用程序。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; WindowsProject1.cpp : 定义应用程序的入口点。
&#x2F;&#x2F;

#include &quot;framework.h&quot;
#include &quot;WindowsProject1.h&quot;

#define MAX_LOADSTRING 100

&#x2F;&#x2F; 全局变量:
HINSTANCE hInst;                                &#x2F;&#x2F; 当前实例
WCHAR szTitle[MAX_LOADSTRING];                  &#x2F;&#x2F; 标题栏文本
WCHAR szWindowClass[MAX_LOADSTRING];            &#x2F;&#x2F; 主窗口类名

&#x2F;&#x2F; 此代码模块中包含的函数的前向声明:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    About(HWND, UINT, WPARAM, LPARAM);

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
&#123;
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    &#x2F;&#x2F; TODO: 在此处放置代码。

    &#x2F;&#x2F; 初始化全局字符串
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_WINDOWSPROJECT1, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    &#x2F;&#x2F; 执行应用程序初始化:
    if (!InitInstance (hInstance, nCmdShow))
    &#123;
        return FALSE;
    &#125;

    HACCEL hAccelTable &#x3D; LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_WINDOWSPROJECT1));

    MSG msg;

    &#x2F;&#x2F; 主消息循环:
    while (GetMessage(&amp;msg, nullptr, 0, 0))
    &#123;
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))
        &#123;
            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
        &#125;
    &#125;

    return (int) msg.wParam;
&#125;



&#x2F;&#x2F;
&#x2F;&#x2F;  函数: MyRegisterClass()
&#x2F;&#x2F;
&#x2F;&#x2F;  目标: 注册窗口类。
&#x2F;&#x2F;
ATOM MyRegisterClass(HINSTANCE hInstance)
&#123;
    WNDCLASSEXW wcex;

    wcex.cbSize &#x3D; sizeof(WNDCLASSEX);

    wcex.style          &#x3D; CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    &#x3D; WndProc;
    wcex.cbClsExtra     &#x3D; 0;
    wcex.cbWndExtra     &#x3D; 0;
    wcex.hInstance      &#x3D; hInstance;
    wcex.hIcon          &#x3D; LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WINDOWSPROJECT1));
    wcex.hCursor        &#x3D; LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  &#x3D; (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   &#x3D; MAKEINTRESOURCEW(IDC_WINDOWSPROJECT1);
    wcex.lpszClassName  &#x3D; szWindowClass;
    wcex.hIconSm        &#x3D; LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));

    return RegisterClassExW(&amp;wcex);
&#125;

&#x2F;&#x2F;
&#x2F;&#x2F;   函数: InitInstance(HINSTANCE, int)
&#x2F;&#x2F;
&#x2F;&#x2F;   目标: 保存实例句柄并创建主窗口
&#x2F;&#x2F;
&#x2F;&#x2F;   注释:
&#x2F;&#x2F;
&#x2F;&#x2F;        在此函数中，我们在全局变量中保存实例句柄并
&#x2F;&#x2F;        创建和显示主程序窗口。
&#x2F;&#x2F;
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
&#123;
   hInst &#x3D; hInstance; &#x2F;&#x2F; 将实例句柄存储在全局变量中

   HWND hWnd &#x3D; CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   &#123;
      return FALSE;
   &#125;

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   return TRUE;
&#125;

&#x2F;&#x2F;
&#x2F;&#x2F;  函数: WndProc(HWND, UINT, WPARAM, LPARAM)
&#x2F;&#x2F;
&#x2F;&#x2F;  目标: 处理主窗口的消息。
&#x2F;&#x2F;
&#x2F;&#x2F;  WM_COMMAND  - 处理应用程序菜单
&#x2F;&#x2F;  WM_PAINT    - 绘制主窗口
&#x2F;&#x2F;  WM_DESTROY  - 发送退出消息并返回
&#x2F;&#x2F;
&#x2F;&#x2F;
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
&#123;
    switch (message)
    &#123;
    case WM_COMMAND:
        &#123;
            int wmId &#x3D; LOWORD(wParam);
            &#x2F;&#x2F; 分析菜单选择:
            switch (wmId)
            &#123;
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            &#125;
        &#125;
        break;
    case WM_PAINT:
        &#123;
            PAINTSTRUCT ps;
            HDC hdc &#x3D; BeginPaint(hWnd, &amp;ps);
            &#x2F;&#x2F; TODO: 在此处添加使用 hdc 的任何绘图代码...
            EndPaint(hWnd, &amp;ps);
        &#125;
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    &#125;
    return 0;
&#125;

&#x2F;&#x2F; “关于”框的消息处理程序。
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
&#123;
    UNREFERENCED_PARAMETER(lParam);
    switch (message)
    &#123;
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) &#x3D;&#x3D; IDOK || LOWORD(wParam) &#x3D;&#x3D; IDCANCEL)
        &#123;
            EndDialog(hDlg, LOWORD(wParam));
            return (INT_PTR)TRUE;
        &#125;
        break;
    &#125;
    return (INT_PTR)FALSE;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这就是一个demo,下面我们使用手写的办法来写一个超级简化版本</p>
<p><img src="image-20230519142819377.png" alt="image-20230519142819377"></p>
<p>​        基本原理</p>
<p>​        先看窗口：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef struct tagWNDCLASSEXW &#123;
    UINT        cbSize;
    &#x2F;* Win 3.x *&#x2F;
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
    &#x2F;* Win 4.0 *&#x2F;
    HICON       hIconSm;
&#125; WNDCLASSEXW, *PWNDCLASSEXW, NEAR *NPWNDCLASSEXW, FAR *LPWNDCLASSEXW;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;
#include&lt;tchar.h&gt;
HWND hwnd;
HINSTANCE hInst;
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) &#123;

	&#x2F;&#x2F;窗口
	WNDCLASSEX wcx;
	
	&#x2F;&#x2F;消息
	MSG msg;
	BOOL fGotMsg;
	wcx.cbSize &#x3D; sizeof(wcx);
	wcx.style &#x3D; CS_HREDRAW | CS_VREDRAW; &#x2F;&#x2F; 发生大小改变时再次绘制窗口
	wcx.lpszClassName &#x3D; L&quot;MainWndProc&quot;;
	wcx.lpfnWndProc &#x3D; MainWndProc;
	wcx.cbClsExtra &#x3D; 0;&#x2F;&#x2F; 不使用额外内存
	wcx.cbWndExtra &#x3D; 0;
	wcx.hInstance &#x3D; hInstance;
	wcx.hIcon &#x3D; LoadIcon(NULL,IDI_APPLICATION);
	wcx.hCursor &#x3D; LoadCursor(NULL, IDC_ARROW);
	wcx.hbrBackground &#x3D; (HBRUSH)GetStockObject(WHITE_BRUSH);
	wcx.lpszMenuName &#x3D; NULL;
	wcx.hIconSm &#x3D; (HICON)LoadImage(hInstance, 
		MAKEINTRESOURCE(5),
		IMAGE_ICON, 
		GetSystemMetrics(SM_CXSMICON),
		GetSystemMetrics(SM_CXSMICON),
		LR_DEFAULTCOLOR
	);
	&#x2F;&#x2F; 注册！在创建
	if (!RegisterClassEx(&amp;wcx)) &#123;
		return -1;
	&#125;
	TCHAR h1[] &#x3D; L&quot;hello&quot;;
	TCHAR h2[] &#x3D; L&quot;hello&quot;;
	hwnd &#x3D; CreateWindowEx(0, h1, h2, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, \
		CW_USEDEFAULT, 300, 180, NULL, NULL, hInstance, NULL);

	if (!hwnd) &#123;
		return GetLastError();
	&#125;

	ShowWindow(hwnd, nCmdShow);
	UpdateWindow(hwnd);&#x2F;&#x2F;提升优先级到最先

	&#x2F;&#x2F; 消息队列取消息
	while ((fGotMsg &#x3D; GetMessage(&amp;msg, (HWND)NULL, 0, 0))!&#x3D;0) &#123;
		TranslateMessage(&amp;msg); &#x2F;&#x2F; 一些消息需要翻译
		DispatchMessage(&amp;msg); &#x2F;&#x2F;转发消息给窗口过程
	&#125;

	return msg.wParam;
&#125;


&#x2F;&#x2F;
LRESULT CALLBACK MainWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
&#123;

	switch (uMsg) &#123;

	case WM_DESTROY:
		PostQuitMessage(0); &#x2F;&#x2F; 退出线程
		return 0;

	case WM_LBUTTONDOWN:
		MessageBox(hwnd, L&quot;hello&quot;, L&quot;hello&quot;, MB_OK);
		return 0;
	default:
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	&#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在QT中，我们已经看到了生成一个对话框是容易的——但是现在，让我们把目光聚焦在基于Windows API的MFC下如何召唤一个对话框。</p>
<p>​        跟QT类似的——我们找到资源文件 》添加新建项 》 对话框，添加即可。</p>
<p>​        我们随后设计也界面 </p>
<p><img src="image-20230523195326640.png" alt="image-20230523195326640"></p>
<p>​        随便整点。</p>
<p>​        现在看看你的resource.h，多了四个宏：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;&#123;&#123;NO_DEPENDENCIES&#125;&#125;
&#x2F;&#x2F; Microsoft Visual C++ 生成的包含文件。
&#x2F;&#x2F; 供 Project2.rc 使用
&#x2F;&#x2F;
#define IDD_DIALOG1                     101
#define IDC_BUTTON1                     1001
#define IDC_BUTTON2                     1002
#define IDC_BUTTON3                     1003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        他们是我们操作之的接口。</p>
<p>​        下面开始写主函数的代码：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int APIENTRY WinMain(_In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nShowCmd) 
&#123;
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, MainDlgProc);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="APIEntry"><a href="#APIEntry" class="headerlink" title="APIEntry:"></a>APIEntry:</h2><pre class="line-numbers language-none"><code class="language-none">APIENTRY	系统函数的调用约定。
此类型在 WinDef.h 中声明，如下所示：
#define APIENTRY WINAPI<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        也就是说，它本质上时WINAPI的重定义与重命名。</p>
<h2 id="DialogBox"><a href="#DialogBox" class="headerlink" title="DialogBox"></a>DialogBox</h2><p>​        从对话框模板资源创建模式对话框。 在指定的回调函数通过调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> 函数终止模式对话框之前，<strong>DialogBox</strong> 不会返回控件。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">DialogBoxA</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  hInstance<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            lpTemplate<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  hWndParent<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  lpDialogFunc
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in, optional] hInstance<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>HINSTANCE</strong></p>
<p>包含对话框模板的模块的句柄。 如果此参数为 NULL，则使用当前可执行文件。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] lpTemplate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>LPCTSTR</strong></p>
<p>对话框模板。 此参数是指向指定对话框模板名称的以空字符结尾的字符串的指针，或者是指定对话框模板的资源标识符的整数值。 如果参数指定了资源标识符，则其高位字必须为零，其低位字必须包含该标识符。 你可以使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a> 宏来创建此值。</p>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] hWndParent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型：<strong>HWND</strong></p>
<p>拥有对话框的窗口的句柄。</p>
<pre class="line-numbers language-none"><code class="language-none">[in, optional] lpDialogFunc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>DLGPROC</strong></p>
<p>指向对话框过程的指针。 有关对话框过程的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nc-winuser-dlgproc">DialogProc</a>。</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p><strong>DialogBox</strong> 宏使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-createwindowexa">CreateWindowEx</a> 函数创建对话框。 然后，如果模板指定对话框过程DS_SETFONT<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/dlgbox/about-dialog-boxes">或DS_SHELLFONT</a>样式) ，<strong>则 DialogBox</strong> 会发送<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/dlgbox/wm-initdialog">WM_INITDIALOG</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/wm-setfont">消息 (</a>和WM_SETFONT消息。 该函数显示对话框 (，无论模板是否指定 <strong>WS_VISIBLE</strong> 样式) ，禁用所有者窗口，并启动其自己的消息循环来检索和调度对话框的消息。</p>
<p>当对话框过程调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winuser/nf-winuser-enddialog">EndDialog</a> 函数时，<strong>DialogBox</strong> 将销毁对话框，结束消息循环，如果以前启用) ，则启用所有者窗口 (，并在调用 <strong>EndDialog</strong> 时返回对话框过程指定的 <em>nResult</em> 参数。</p>
<h2 id="MAKEINTERSOURCE"><a href="#MAKEINTERSOURCE" class="headerlink" title="MAKEINTERSOURCE"></a>MAKEINTERSOURCE</h2><p>VC的定义是(winuser.h):</p>
<pre class="line-numbers language-none"><code class="language-none">#define MAKEINTRESOURCEA(i) ([LPSTR](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;LPSTR&#x2F;9782867?fromModule&#x3D;lemma_inlink))((ULONG_PTR)((WORD)(i)))

#define MAKEINTRESOURCEW(i) (LPWSTR)((ULONG_PTR)((WORD)(i)))

#define MAKEINTRESOURCE MAKEINTRESOURCEW

#else

#define MAKEINTRESOURCE MAKEINTRESOURCEA

[#endif](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;%23endif&#x2F;2834688?fromModule&#x3D;lemma_inlink) &#x2F;&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用这个宏的主要原因是有的资源是用序号定义的,而不是字符串.所以要把数字转换成字符串<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/指针?fromModule=lemma_inlink">指针</a>,然后再传递给<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LoadResource/530202?fromModule=lemma_inlink">LoadResource</a>之类的函数,这样才加载了资源.</p>
<p>要释放资源(用LoadResource加载的)可以调用FreeResource函数把LoadResource返回的指针传递给FreeResource.</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>​        是把一个”数字形ID”,转化为”字符串”.但是执行前后,输入的数据的内容和长度是不变的!它只不过就是C语言里面”<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/强制类型转换/1580197?fromModule=lemma_inlink">强制类型转换</a>“而已.</p>
<p>​        请看 Winuser.h 代码:</p>
<pre class="line-numbers language-none"><code class="language-none">#define MAKEINTRESOURCEA(i) ([LPSTR](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;LPSTR&#x2F;9782867?fromModule&#x3D;lemma_inlink))(([DWORD](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;DWORD&#x2F;5043783?fromModule&#x3D;lemma_inlink))((WORD)(i)))

#define MAKEINTRESOURCEW(i) (LPWSTR)((DWORD)((WORD)(i)))

#define MAKEINTRESOURCE MAKEINTRESOURCEW

#else

#define MAKEINTRESOURCE MAKEINTRESOURCEA

[#endif](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;%23endif&#x2F;2834688?fromModule&#x3D;lemma_inlink) &#x2F;&#x2F; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        的用法.就用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/FindResource/6375062?fromModule=lemma_inlink">FindResource</a>来说明.</p>
<pre class="line-numbers language-none"><code class="language-none">HRSRC FindResource(

HMODULE hModule, &#x2F;&#x2F; module handle

LPCTSTR lpName, &#x2F;&#x2F; resource name

LPCTSTR lpType &#x2F;&#x2F; resource type

);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        就是lpName参数需要使用MAKEINTRESOURCE ,因为它需要<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LPCTSTR/6495202?fromModule=lemma_inlink">LPCTSTR</a>类型的参数输入.那么,情况就很清楚了.凡涉及”资源”的API或者MFC类,在参数类型为LPCTSTR时,就应该使用 MAKEINTRESOURCE.这是针对”资源名字”为”数字类型”时的情况.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;
#include&lt;Windows.h&gt;
#include&quot;resource.h&quot;

INT_PTR CALLBACK MainDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) &#123;
    BOOL bRet &#x3D; TRUE;
    int usrChoice;
    switch (uMsg)
    &#123;

    case WM_LBUTTONDOWN:
        MessageBox(hDlg, L&quot;Hello!&quot;, L&quot;A Greeting&quot;, MB_OK);
    case WM_COMMAND:
        switch (LOWORD(wParam)) &#123;
        case IDC_BUTTON1:
            usrChoice &#x3D; MessageBox(hDlg, L&quot;I convinced that you push the button1&quot;, L&quot;A greeting&quot;, MB_OK);
            if (usrChoice &#x3D;&#x3D; MB_OK) &#123;
                bRet &#x3D; FALSE;
                break;
            &#125;
            break;

        case IDC_BUTTON2:
            usrChoice &#x3D; MessageBox(hDlg, L&quot;I convinced that you push the button2&quot;, L&quot;A greeting&quot;, MB_OK);
            if (usrChoice &#x3D;&#x3D; MB_OK) &#123;
                bRet &#x3D; FALSE;
                break;
            &#125;
            break;
        case IDC_BUTTON3:
            EndDialog(hDlg, 0);
            bRet &#x3D; FALSE;
            break;
        default:
            bRet &#x3D; FALSE;
            break;
        &#125;
        break;
    default:
        bRet &#x3D; FALSE;
        break;
    &#125;


    return bRet;
&#125;

int APIENTRY WinMain(_In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nShowCmd) 
&#123;
    DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, MainDlgProc);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个demo生成一个有趣的对话框，可以试试看。</p>
<p>​    下面专门讲授<code>wchar_t</code>，他是宽字符的意思。</p>
<p>​        因为我们需要大量的输出中文，为了适配，我们常常使用<code>wchar_t</code></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;

int main() &#123;

	char c &#x3D; &#39;A&#39;; &#x2F;&#x2F; 此类型在默认下只可以保存一个字节
	wchar_t c2 &#x3D; L&#39;牛&#39;; &#x2F;&#x2F; 现在就可以存下了。
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是这样还是会不认识，原因在于。。。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;locale.h&gt;
int main() &#123;
	setlocale(LC_ALL, &quot;&quot;); &#x2F;&#x2F; 设置windows本地的编码

	char c &#x3D; &#39;A&#39;; &#x2F;&#x2F; 此类型在默认下只可以保存一个字节
	wchar_t c2 &#x3D; L&#39;牛&#39;; &#x2F;&#x2F; 现在就可以存下了。

	wprintf(L&quot;%c&quot;, c2);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230526205326835.png" alt="image-20230526205326835"></p>
<p>​        那如何查看当前的地域呢？</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">printf(&quot;%s\n&quot;, setlocale(LC_ALL, NULL));
setlocale(LC_ALL, &quot;&quot;);
printf(&quot;%s\n&quot;, setlocale(LC_ALL, NULL));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230526205514732.png" alt="image-20230526205514732"></p>
<p>​        对于宽字符，我们有跟char一样配饰的各式各样的函数。这里不再做什么介绍了！</p>
<h2 id="三大版本的char类型"><a href="#三大版本的char类型" class="headerlink" title="三大版本的char类型"></a>三大版本的char类型</h2><p>​        在微软中，有三大类型——CHAR , WCHAR, TCHAR（ASCII，Unicode和通用版本）</p>
<p>​        随后还有字符串版本的PSTR PWSTR, PTSTR, PC(onst)STR PCWSTR, PCTSTR…</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;

int WINAPI WinMain(
    _In_ HINSTANCE hInstance,
    _In_opt_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nShowCmd
) 
&#123;
    CHAR a &#x3D; &#39;a&#39;;
    WCHAR b &#x3D; &#39;b&#39;;
    TCHAR c &#x3D; &#39;c&#39;;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        看到TCHAR是根据平台的字符集选择而发生变动！建议我们的编程使用Unicode字符集。</p>
<h2 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h2><p>​        下面来看字符转换——将多字节字符和宽字符。为了使得转换方便，我们需要使用：</p>
<h3 id="MultiByteToWideChar"><a href="#MultiByteToWideChar" class="headerlink" title="MultiByteToWideChar();"></a>MultiByteToWideChar();</h3><p>​        这个函数将字符串映射到 UTF-16 (宽字符) 字符串。 字符串不一定来自多字节字符集。</p>
<p>​        注意！错误地使用 <strong>MultiByteToWideChar</strong> 函数可能会损害应用程序的安全性。 调用此函数很容易导致缓冲区溢出，因为 <em>lpMultiByteStr</em> 指示的输入缓冲区的大小等于字符串中的字节数，而 <em>lpWideCharStr</em> 指示的输出缓冲区的大小等于字符数。 为了避免缓冲区溢出，应用程序必须指定适合缓冲区接收的数据类型的缓冲区大小。</p>
<p>​        ANSI 代码页在不同计算机上可能不同，也可以更改单个计算机，从而导致数据损坏。 为了获得最一致的结果，应用程序应使用 Unicode（如 UTF-8 或 UTF-16），而不是特定代码页，除非旧标准或数据格式阻止使用 Unicode。 如果无法使用 Unicode，应用程序应在协议允许时使用适当的编码名称标记数据流。 HTML 和 XML 文件允许标记，但文本文件不会。</p>
<h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            UINT                              CodePage<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            DWORD                             dwFlags<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            <span class="token function">_In_NLS_string_</span><span class="token punctuation">(</span>cbMultiByte<span class="token punctuation">)</span>LPCCH lpMultiByteStr<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            <span class="token keyword">int</span>                               cbMultiByte<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPWSTR                            lpWideCharStr<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            <span class="token keyword">int</span>                               cchWideChar
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] CodePage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        用于执行转换的代码页。 此参数可以设置为在操作系统中安装或可用的任何代码页的值。 有关代码页的列表，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Intl/code-page-identifiers">代码页标识符</a>。 应用程序还可以指定下表中显示的值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>CP_ACP</strong></td>
<td style="text-align:left">系统默认的 Windows ANSI 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_MACCP</strong></td>
<td style="text-align:left">当前系统 Macintosh 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。 <strong>注意</strong> 此值主要用于旧代码，通常不需要，因为新式 Macintosh 计算机使用 Unicode 进行编码。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_OEMCP</strong></td>
<td style="text-align:left">当前系统 OEM 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_SYMBOL</strong></td>
<td style="text-align:left">符号代码页 (42) 。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_THREAD_ACP</strong></td>
<td style="text-align:left">当前线程的 Windows ANSI 代码页。<strong>注意</strong> 此值在不同计算机上可能不同，即使在同一网络上也是如此。 它可以在同一台计算机上更改，从而导致存储的数据变得不可恢复损坏。 此值仅用于临时使用，永久存储应尽可能使用 UTF-16 或 UTF-8。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_UTF7</strong></td>
<td style="text-align:left">UTF-7。 仅当 7 位传输机制强制使用此值。 首选使用 UTF-8。</td>
</tr>
<tr>
<td style="text-align:left"><strong>CP_UTF8</strong></td>
<td style="text-align:left">UTF-8。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[in] dwFlags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指示转换类型的标志。 应用程序可以指定以下值的组合，MB_PRECOMPOSED为默认值。 MB_PRECOMPOSED和MB_COMPOSITE互斥。 无论其他标志的状态如何，都可以设置MB_USEGLYPHCHARS和MB_ERR_INVALID_CHARS。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Value</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>MB_COMPOSITE</strong></td>
<td style="text-align:left">始终使用分解字符，即基字符和一个或多个非分步字符各具有不同的代码点值。 例如，Ä 由 A + ー 表示：拉丁文大写字母 A (U+0041) + 组合 DIAERESIS (U+0308) 。 请注意，此标志不能与MB_PRECOMPOSED一起使用。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_ERR_INVALID_CHARS</strong></td>
<td style="text-align:left">如果遇到无效的输入字符，则失败。从 Windows Vista 开始，如果应用程序未设置此标志，函数不会删除非法代码点，而是将非法序列替换为根据指定的代码页) 编码的 U+FFFD (。<strong>Windows 2000 SP4 及更高版本，Windows XP：</strong> 如果未设置此标志，函数将无提示删除非法代码点。 对 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 的调用返回ERROR_NO_UNICODE_TRANSLATION。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_PRECOMPOSED</strong></td>
<td style="text-align:left">默认;请勿与MB_COMPOSITE一起使用。 始终使用预编译字符，即具有基字符或非加速度字符组合的单个字符值。 例如，在字符 è 中，e 是基字符，重音符严重标记是非节奏字符。 如果为字符定义了单个 Unicode 码位，则应用程序应使用它而不是单独的基字符和非节奏字符。 例如，Ä 由单一 Unicode 码位 LATIN 大写字母 A WITH DIAERESIS (U+00C4) 表示。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MB_USEGLYPHCHARS</strong></td>
<td style="text-align:left">使用字形字符而不是控制字符。</td>
</tr>
</tbody>
</table>
</div>
<p>​        对于下面列出的代码页， <em>dwFlags</em> 必须设置为 0。 否则，函数将失败并ERROR_INVALID_FLAGS。50220，50221，50222，50225，50227，，50229，57002 到 57011，65000 (UTF-7)，42 (符号)</p>
<p>​        对于 UTF-8 或代码页 54936 (GB18030，从 Windows Vista) 开始， <em>dwFlags</em> 必须设置为 0 或MB_ERR_INVALID_CHARS。 否则，函数将失败并ERROR_INVALID_FLAGS。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] lpMultiByteStr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向要转换的字符串的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] cbMultiByte<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <em>lpMultiByteStr</em> 参数指示的字符串的大小（以字节为单位）。 或者，如果字符串以 null 结尾，则可以将此参数设置为 -1。 请注意，如果 <em>cbMultiByte</em> 为 0，函数将失败。</p>
<p>​        如果此参数为 -1，则该函数将处理整个输入字符串，包括终止 null 字符。 因此，生成的 Unicode 字符串具有终止 null 字符，函数返回的长度包括此字符。</p>
<p>​        如果此参数设置为正整数，则函数将完全处理指定的字节数。 如果提供的大小不包括终止 null 字符，则生成的 Unicode 字符串不会以 null 结尾，并且返回的长度不包括此字符。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpWideCharStr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收转换后的字符串的缓冲区的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] cchWideChar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <em>lpWideCharStr</em> 指示的缓冲区的大小（以字符为单位）。 如果此值为 0，则该函数将返回所需的缓冲区大小（以字符为单位，包括任何终止 null 字符）并且不使用 <em>lpWideCharStr</em> 缓冲区。</p>
<h4 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h4><p>​        返回写入缓冲区的字符数，如果成功，则返回 <em>由 lpWideCharStr</em> 指示的字符数。 如果函数成功且 <em>cchWideChar</em> 为 0，则返回值是 <em>lpWideCharStr</em> 指示的缓冲区所需的大小（以字符为单位）。 另请参阅 <em>dwFlags</em> ，了解输入无效序列时MB_ERR_INVALID_CHARS标志如何影响返回值的信息。</p>
<p>​        如果函数不成功，则返回 0。 若要获取扩展的错误信息，应用程序可以调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>，后者可以返回以下错误代码之一：</p>
<ul>
<li>ERROR_INSUFFICIENT_BUFFER。 提供的缓冲区大小不够大，或者错误地设置为 <strong>NULL</strong>。</li>
<li>ERROR_INVALID_FLAGS。 为标志提供的值无效。</li>
<li>ERROR_INVALID_PARAMETER。 任何参数值都无效。</li>
<li>ERROR_NO_UNICODE_TRANSLATION。 在字符串中找到无效的 Unicode。</li>
</ul>
<h4 id="注解-3"><a href="#注解-3" class="headerlink" title="注解"></a>注解</h4><p>​        此函数的默认行为是转换为输入字符串的预编译形式。 如果预编译的窗体不存在，该函数将尝试转换为复合窗体。</p>
<p>​        使用MB_PRECOMPOSED标志对大多数代码页的影响很小，因为大多数输入数据已经组成。 考虑使用 <strong>MultiByteToWideChar</strong> 进行转换后调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnls/nf-winnls-normalizestring">NormalizeString</a>。 <strong>NormalizeString</strong> 提供更准确、标准和一致的数据，还可以更快。 请注意，对于传递给 <strong>NormalizeString</strong><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winnls/ne-winnls-norm_form">的NORM_FORM</a>枚举，NormalizationC 对应于MB_PRECOMPOSED，NormalizationD 对应于MB_COMPOSITE。</p>
<p>​        如上述警告中所述，如果未首先使用 <em>cchWideChar</em> 设置为 0 调用此函数，则输出缓冲区很容易溢出，以获取所需的大小。 如果使用MB_COMPOSITE标志，则每个输入字符的输出长度可以为三个或多个字符。</p>
<p>​        <em>lpMultiByteStr</em> 和 <em>lpWideCharStr</em> 指针不能相同。 如果它们相同，函数将失败， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 返回值ERROR_INVALID_PARAMETER。</p>
<p>​        如果显式指定输入字符串长度而不终止 null 字符，<strong>则 MultiByteToWideChar</strong> 不会终止输出字符串。 若要为此函数终止输出字符串，应用程序应传入 -1 或显式计算输入字符串的终止 null 字符。</p>
<p>​        如果设置了MB_ERR_INVALID_CHARS并且源字符串中遇到无效字符，则函数将失败。 无效字符为下列字符之一：</p>
<ul>
<li>不是源字符串中默认字符的字符，但在未设置MB_ERR_INVALID_CHARS时转换为默认字符</li>
<li>对于 DBCS 字符串，具有前导字节但没有有效尾随字节的字符</li>
</ul>
<p>​        从 Windows Vista 开始，此函数完全符合 UTF-8 和 UTF-16 的 Unicode 4.1 规范。 在早期操作系统上使用的函数编码或解码孤独 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Intl/surrogates-and-supplementary-characters">代理项半</a> 部分或不匹配的代理项对。 在早期版本的 Windows 中编写的代码，这些代码依赖于此行为对随机非文本二进制数据进行编码可能会遇到问题。 但是，在有效的 UTF-8 字符串上使用此函数的代码的行为方式与早期 Windows 操作系统相同。</p>
<p>​        <strong>Windowsxp：</strong> 为了防止 UTF-8 字符的非最短格式版本的安全问题， <strong>MultiByteToWideChar</strong> 会删除这些字符。</p>
<p>​        <strong>从 Windows 8 开始：</strong>MultiByteToWideChar 在 Stringapiset.h 中声明。 在Windows 8之前，它在 Winnls.h 中声明。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">catch</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>exception e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// Save in-memory logging buffer to a log file on error.</span>

    <span class="token double-colon punctuation">::</span>std<span class="token double-colon punctuation">::</span>wstring wideWhat<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> convertResult <span class="token operator">=</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>convertResult <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            wideWhat <span class="token operator">=</span> L<span class="token string">"Exception occurred: Failure to convert its message text using MultiByteToWideChar: convertResult="</span><span class="token punctuation">;</span>
            wideWhat <span class="token operator">+=</span> convertResult<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            wideWhat <span class="token operator">+=</span> L<span class="token string">"  GetLastError()="</span><span class="token punctuation">;</span>
            wideWhat <span class="token operator">+=</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            wideWhat<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>convertResult <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            convertResult <span class="token operator">=</span> <span class="token function">MultiByteToWideChar</span><span class="token punctuation">(</span>CP_UTF8<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">strlen</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wideWhat<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>wideWhat<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>convertResult <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">&#123;</span>
                wideWhat <span class="token operator">=</span> L<span class="token string">"Exception occurred: Failure to convert its message text using MultiByteToWideChar: convertResult="</span><span class="token punctuation">;</span>
                wideWhat <span class="token operator">+=</span> convertResult<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                wideWhat <span class="token operator">+=</span> L<span class="token string">"  GetLastError()="</span><span class="token punctuation">;</span>
                wideWhat <span class="token operator">+=</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span>
            <span class="token punctuation">&#123;</span>
                wideWhat<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> L<span class="token string">"Exception occurred: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">&#123;</span>
        wideWhat <span class="token operator">=</span> L<span class="token string">"Exception occurred: Unknown."</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    Platform<span class="token double-colon punctuation">::</span>String<span class="token operator">^</span> errorMessage <span class="token operator">=</span> ref <span class="token keyword">new</span> <span class="token class-name">Platform</span><span class="token double-colon punctuation">::</span><span class="token function">String</span><span class="token punctuation">(</span>wideWhat<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// The session added the channel at level Warning. Log the message at</span>
    <span class="token comment">// level Error which is above (more critical than) Warning, which</span>
    <span class="token comment">// means it will actually get logged.</span>
    _channel<span class="token operator">-></span><span class="token function">LogMessage</span><span class="token punctuation">(</span>errorMessage<span class="token punctuation">,</span> LoggingLevel<span class="token double-colon punctuation">::</span>Error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SaveLogInMemoryToFileAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span>StorageFile<span class="token operator">^</span> logFile<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        _logFileGeneratedCount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">StatusChanged</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> ref <span class="token keyword">new</span> <span class="token function">LoggingScenarioEventArgs</span><span class="token punctuation">(</span>LoggingScenarioEventType<span class="token double-colon punctuation">::</span>LogFileGenerated<span class="token punctuation">,</span> logFile<span class="token operator">-></span>Path<span class="token operator">-></span><span class="token function">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="WideCharToMultiByte"><a href="#WideCharToMultiByte" class="headerlink" title="WideCharToMultiByte"></a>WideCharToMultiByte</h3><p>传送门：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/vranger/p/3793123.html">函数WideCharToMultiByte（） 详解 - vranger - 博客园 (cnblogs.com)</a></p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><pre class="line-numbers language-none"><code class="language-none">int WideCharToMultiByte( 

UINT CodePage,  

DWORD dwFlags,  

LPWSTR lpWideCharStr,  

int cchWideChar,  

LPCSTR lpMultiByteStr,  

int cchMultiByte,  

LPCSTR lpDefaultChar,  

PBOOL pfUsedDefaultChar 

);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>函数功能：</strong></p>
<p>此函数把宽字符串转换成指定的新的字符串，如ANSI，UTF8等，新字符串不必是多字节字符集。 </p>
<p>(—-Unicode 转 ANSI(GB2312)，UTF8) </p>
<p><strong>参数：</strong></p>
<ul>
<li>CodePage：指定执行转换的代码页，这个参数可以为系统已安装或有效的任何代码页所给定的值。</li>
</ul>
<p>你也可以指定其为下面的任意一值：</p>
<p> (我想最常用的应该是CP_ACP和CP_UTF8了，前者将宽字符转 换为ANSI，后者转换为UTF8。 ) </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>CP_ACP</th>
<th>当前系统ANSI代码页</th>
</tr>
</thead>
<tbody>
<tr>
<td>CP_MACCP</td>
<td>当前系统Macintosh代码页</td>
</tr>
<tr>
<td>CP_OEMCP</td>
<td>当前系统OEM代码页，一种原始设备制造商硬件扫描码</td>
</tr>
<tr>
<td>CP_SYMBOL</td>
<td>符号代码页（42）</td>
</tr>
<tr>
<td>CP_THREAD_ACP</td>
<td>当前线程ANSI代码页</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>dwFlags：指定如何处理没有转换的字符，但不设此参数函数会运行的更快一些，我都是把它设为0。</li>
</ul>
<p>可设的值如下表所示：</p>
<pre class="line-numbers language-none"><code class="language-none">WC_NO_BEST_FIT_CHARS 
把不能直接转换成相应多字节字符的Unicode字符转换成lpDefaultChar指定的默认字符。也就是说，如果把Unicode转换成多字节字符，然后再转换回来，你并不一定得到相同的Unicode字符，因为这期间可能使用了默认字符。此选项可以单独使用，也可以和其他选项一起使用。

WC_COMPOSITECHECK 
把合成字符转换成预制的字符。它可以与后三个选项中的任何一个组合使用，如果没有与他们中的任何一个组合，则与选项WC_SEPCHARS相同。

WC_ERR_INVALID_CHARS 
此选项会致使函数遇到无效字符时失败返回，并且GetLastError会返回错误码ERROR_NO_UNICODE_TRANSLATION。否则函数会自动丢弃非法字符。此选项只能用于UTF8。

WC_DISCARDNS    
  转换时丢弃不占空间的字符，与WC_COMPOSITECHECK 一起使用

WC_SEPCHARS
 转换时产生单独的字符，此是默认转换选项，WC_COMPOSITECHECK一起使用

WC_DEFAULTCHAR
 转换时使用默认字符代替例外的字符，(最常见的如’?’)，与WC_COMPOSITECHECK一起使用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <em>注意：当指定WC_COMPOSITECHECK时，函数会将合成字符转换成预制字符。合成字符由一个基字符和一个不占空间的字符(如欧洲国家及汉语拼音的音标)组成，</em></p>
<p><em>每一个都有不同的字符值。预制字符有一个用于表示基字符和不占空间字符的合成体的单一的字符值。</em></p>
<p><em>当指定WC_COMPOSITECHECK选项时，也可以使用上表列出的最后3个选项来定制预制字符的转换规则。这些选项决定了函数在遇到宽字符串的合成字符没有对</em></p>
<p><em>应的预制字符时的行为，他们与WC_COMPOSITECHECK一起使用，如果都没有指定，函数默认WC_SEPCHARS。</em><br><em>对于下列代码页，dwFlags必须为0，否则函数返回错误码ERROR_INVALID_FLAGS。</em><br><em>50220 50221 50222 50225 50227 50229 52936 54936 57002到57011 65000(UTF7) 42(Symbol)</em><br><em>对于UTF8，dwFlags必须为0或WC_ERR_INVALID_CHARS，否则函数都将失败返回并设置错误码ERROR_INVALID_FLAGS，你可以调用GetLastError获得。</em></p>
<ul>
<li>lpWideCharStr： 待转换的宽字符串。</li>
</ul>
<ul>
<li>cchWideChar： 待转换宽字符串的长度，-1表示转换到字符串结尾。</li>
</ul>
<ul>
<li>lpMultiByteStr： 接收转换后输出新串的缓冲区。</li>
</ul>
<ul>
<li>cbMultiByte：输出缓冲区大小，如果为0，lpMultiByteStr将被忽略，函数将返回所需缓冲区大小而不使用lpMultiByteStr。</li>
</ul>
<ul>
<li>lpDefaultChar： 指向字符的指针， 在指定编码里找不到相应字符时使用此字符作为默认字符代替。如果为NULL则使用系统默认字符。对于要求此参数为NULL的dwFlags而使用此参数，函数将失败返回并设置错误码ERROR_INVALID_PARAMETER。</li>
</ul>
<ul>
<li>lpUsedDefaultChar：开关变量的指针，用以表明是否使用过默认字符。对于要求此参数为NULL的dwFlags而使用此参数，函数将失败返回并设置错误码ERROR_INVALID_PARAMETER。lpDefaultChar和lpUsedDefaultChar都设为NULL，函数会更快一些。</li>
</ul>
<ul>
<li>返回值：如果函数成功，且cbMultiByte非0，返回写入lpMultiByteStr的字节数(包括字符串结尾的null)；cbMultiByte为0，则返回转换所需字节数。函数失败，返回0。</li>
</ul>
<p>​        注意：函数WideCharToMultiByte使用不当，会给影响程序的安全。调用此函数会很容易导致内存泄漏，因为lpWideCharStr指向的输入缓冲区大小是宽字符数，而lpMultiByteStr指向的输出缓冲区大小是字节数。为了避免内存泄漏，应确保为输出缓冲区指定合适的大小。我的方法是先使cbMultiByte为0调用WideCharToMultiByte一次以获得所需缓冲区大小，为缓冲区分配空间，然后再次调用WideCharToMultiByte填充缓冲区，详见下面的代码。另外，从Unicode UTF16向非Unicode字符集转换可能会导致数据丢失，因为该字符集可能无法找到表示特定Unicode数据的字符。</p>
<h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><pre class="line-numbers language-none"><code class="language-none">wchar_t* pwszUnicode &#x3D; L&quot;Holle, word! 你好，中国！ &quot;;
int iSize;
char* pszMultiByte;

iSize &#x3D; WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, NULL, 0, NULL, NULL);
pszMultiByte &#x3D; (char*)malloc(iSize*sizeof(char));
WideCharToMultiByte(CP_ACP, 0, pwszUnicode, -1, pszMultiByte, iSize, NULL, NULL);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;stdio.h&gt;
#include&lt;Windows.h&gt;
#include&lt;locale.h&gt;

int main() &#123;

	DWORD dwNum &#x3D; 0;

	setlocale(LC_ALL, &quot;&quot;);

	char sText[] &#x3D; &quot;多字节转换为宽字符&quot;;

	&#x2F;&#x2F; 问题来了，我们给多少空间呢？
	&#x2F;*1. from ASCII 2. a control flag, we usually have no need of that3.what str 4. transform ALL 5.to where(here we don&#39;t want to get result), final: tha space that contain*&#x2F;
	dwNum &#x3D; MultiByteToWideChar(CP_ACP, 0, sText, -1, NULL, 0);

	WCHAR* pwText &#x3D; (WCHAR)malloc(sizeof(WCHAR) * dwNum*2);
	if (pwText &#x3D;&#x3D; NULL) &#123;
		free(pwText);
		return 1;
	&#125;
	MultiByteToWideChar(CP_ACP, 0, sText, -1, pwText, dwNum);
	wprintf(L&quot;M-&gt;W:%s&quot;, pwText);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="遍历卷-GetLogicalDriveStrings"><a href="#遍历卷-GetLogicalDriveStrings" class="headerlink" title="遍历卷 GetLogicalDriveStrings"></a>遍历卷 GetLogicalDriveStrings</h2><p>​        一个卷也叫做逻辑驱动器，或者叫盘！这是一个基本的概念。</p>
<p>​        注意到它一次性返回的是若干的字字符串：</p>
<p><img src="image-20230528180359422.png" alt="image-20230528180359422"></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#define BFSIZE 1024

int main()
&#123;
	WCHAR szLogicalDriveString[BFSIZE];
	PWCHAR szDrive;
	ZeroMemory(szLogicalDriveString, BFSIZE);&#x2F;&#x2F;清空内存
	szDrive &#x3D; szLogicalDriveString;
	GetLogicalDriveStrings(BFSIZE - 1, szLogicalDriveString);

	do &#123;
		printf(&quot;%s\n&quot;, szDrive);
		szDrive +&#x3D; (lstrlen(szDrive)+1);
	&#125; while (*szDrive !&#x3D; &#39;\0&#39;);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="查看第一个卷"><a href="#查看第一个卷" class="headerlink" title="查看第一个卷"></a>查看第一个卷</h2><p>​        我们可以使用<code>FindFirstVolume</code>这个函数的设备名称</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TCHAR buf[BFSIZE];
	HANDLE hVol;
	BOOL bFlag; &#x2F;&#x2F; as to see if the function work well
	hVol &#x3D; FindFirstVolume(buf, BFSIZE);
	if (hVol &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;
		wprintf(TEXT(&quot;NO... Volumn has&#39;t been find!&quot;));
		return -1;
	&#125;

printf(&quot;%ls\n&quot;, buf);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230528181002554.png" alt="image-20230528181002554"></p>
<p>​        这是驱动设备的真正名称，他是唯一的标识符。</p>
<p>​        使用<code>FindNextVolume</code>来找到下一个：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">TCHAR buf[BFSIZE];
HANDLE hVol;
BOOL bFlag; &#x2F;&#x2F; as to see if the function work well
hVol &#x3D; FindFirstVolume(buf, BFSIZE);
if (hVol &#x3D;&#x3D; INVALID_HANDLE_VALUE) &#123;
	wprintf(TEXT(&quot;NO... Volumn has&#39;t been find!&quot;));
	return -1;
&#125;
printf(&quot;%ls\n&quot;, buf);
while (FindNextVolume(hVol, buf, BFSIZE)) &#123;
	printf(&quot;%ls\n&quot;, buf);
&#125;

bFlag &#x3D; FindVolumeClose(hVol);

return bFlag;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230528181246288.png" alt="image-20230528181246288"></p>
<h2 id="Extensive-Reading-for-Microsoft-API"><a href="#Extensive-Reading-for-Microsoft-API" class="headerlink" title="Extensive Reading for Microsoft API"></a>Extensive Reading for Microsoft API</h2><h3 id="ZeroMemory-宏-wdm-h"><a href="#ZeroMemory-宏-wdm-h" class="headerlink" title="ZeroMemory 宏 (wdm.h)"></a>ZeroMemory 宏 (wdm.h)</h3><p>​        <strong>ZeroMemory</strong> 例程使用零填充内存块，给定指向块的指针和要填充的长度（以字节为单位）。</p>
<h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">RtlZeroMemory</span><span class="token punctuation">(</span>
   <span class="token keyword">void</span><span class="token operator">*</span>  Destination<span class="token punctuation">,</span>
   size_t Length
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] Destination<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>指向要用零填充的内存块的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] Length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要用零填充的字节数。</p>
<h4 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h4><p>无</p>
<h4 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h4><p>​        若要将内存缓冲区归零以擦除安全敏感数据，请改用SecureZeroMemory</p>
<p>​        如果目标内存块位于非分页系统内存中， <strong>ZeroMemory</strong> 的调用方可以在任何 IRQL 上运行。 否则，调用方必须在 IRQL &lt;= APC_LEVEL 运行。</p>
<h4 id="本质上"><a href="#本质上" class="headerlink" title="本质上"></a>本质上</h4><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">memset((Destination),0,(Length))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="getLogicalDriveStrings函数-fileapi-h"><a href="#getLogicalDriveStrings函数-fileapi-h" class="headerlink" title="getLogicalDriveStrings函数 (fileapi.h)"></a>getLogicalDriveStrings函数 (fileapi.h)</h3><p>​        用指定系统中有效驱动器的字符串填充缓冲区。</p>
<h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">DWORD <span class="token function">GetLogicalDriveStrings</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  DWORD  nBufferLength<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpBuffer
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] nBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>TCHAR</strong> 中<em>由 lpBuffer</em> 指向的缓冲区的最大大小。 此大小不包括终止 null 字符。 如果此参数为零，则不使用 <em>lpBuffer</em> 。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向一个缓冲区的指针，该缓冲区接收一系列以 null 结尾的字符串，一个用于系统中每个有效驱动器，另外还有一个 null 字符。 每个字符串都是设备名称。</p>
<h4 id="返回值-7"><a href="#返回值-7" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是复制到缓冲区的字符串的长度（以字符为单位），不包括终止 null 字符。 请注意，ANSI-ASCII null 字符使用一个字节，但 Unicode (UTF-16) null 字符使用两个字节。</p>
<p>​        如果缓冲区不够大，则返回值大于 <em>nBufferLength</em>。 它是保存驱动器字符串所需的缓冲区大小。</p>
<p>​        如果函数失败，则返回值为零。 若要获取扩展的错误信息，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 函数。</p>
<h2 id="注解-4"><a href="#注解-4" class="headerlink" title="注解"></a>注解</h2><p>​        无论需要根目录（例如 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdrivetypea">GetDriveType</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespacea">GetDiskFreeSpace</a> 函数），缓冲区中的每个字符串都可以使用。</p>
<p>​        此函数返回全局和本地 MS-DOS 设备命名空间中的驱动器串联。 如果这两个命名空间中都存在驱动器，此函数将返回本地 MS-DOS 设备命名空间中的条目。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/defining-an-ms-dos-device-name">定义 MS DOS 设备名称</a>。</p>
<p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">技术</th>
<th style="text-align:left">支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">群集共享卷文件系统 (CsvFS)</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">弹性文件系统 (ReFS)</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
</div>
<p>​        SMB 不支持卷管理功能。</p>
<h3 id="FindFirstVolume-函数-fileapi-h"><a href="#FindFirstVolume-函数-fileapi-h" class="headerlink" title="FindFirstVolume 函数 (fileapi.h)"></a>FindFirstVolume 函数 (fileapi.h)</h3><p>​        检索计算机上的卷的名称。 <strong>FindFirstVolume</strong> 用于开始扫描计算机的卷。</p>
<h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">HANDLE <span class="token function">FindFirstVolume</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpszVolumeName<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  DWORD  cchBufferLength
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[out] lpszVolumeName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收空终止字符串的缓冲区的指针，该字符串指定找到的第一个卷的卷 <strong>GUID</strong> 路径。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] cchBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        要在 <strong>TCHAR</strong> 中接收卷 <strong>GUID</strong> 路径的缓冲区的长度。</p>
<h4 id="返回值-8"><a href="#返回值-8" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果函数成功，则返回值是随后调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数时使用的搜索句柄。</p>
<p>​        如果函数找不到任何卷，则返回值为 <strong>INVALID_HANDLE_VALUE</strong> 错误代码。 要获得更多的错误信息，请调用 GetLastError。</p>
<h4 id="注解-5"><a href="#注解-5" class="headerlink" title="注解"></a>注解</h4><p>​        <strong>FindFirstVolume</strong> 函数打开卷搜索句柄，并返回有关计算机上找到的第一个卷的信息。 建立搜索句柄后，可以使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findnextvolumew">FindNextVolume</a> 函数搜索其他卷。 不再需要搜索句柄时，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数将其关闭。</p>
<p>​        不应假定这些函数返回的卷的顺序与计算机上的卷顺序之间存在任何关联。 具体而言，如果) 或磁盘管理员，则不要假定由 BIOS (分配的卷顺序和驱动器号之间的任何关联。</p>
<p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">技术</th>
<th style="text-align:left">支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">群集共享卷文件系统 (CsvFS)</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">弹性文件系统 (ReFS)</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
</div>
<p>​        SMB 不支持卷管理功能。</p>
<h3 id="FindNextVolume-函数-fileapi-h"><a href="#FindNextVolume-函数-fileapi-h" class="headerlink" title="FindNextVolume 函数 (fileapi.h)"></a>FindNextVolume 函数 (fileapi.h)</h3><p>继续通过调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 函数开始的卷搜索。 <strong>FindNextVolume</strong> 为每个调用查找一个卷。</p>
<h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">FindNextVolume</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  HANDLE hFindVolume<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPWSTR lpszVolumeName<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  DWORD  cchBufferLength
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-9"><a href="#参数-9" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] hFindVolume<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        上一次调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 函数返回的卷搜索句柄。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpszVolumeName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收找到的卷 <strong>GUID</strong> 路径的字符串的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] cchBufferLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        接收卷 <strong>GUID</strong> 路径的缓冲区的长度（以 <strong>TCHAR</strong> 为单位）。</p>
<h4 id="返回值-9"><a href="#返回值-9" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。 如果未找到匹配的文件， <strong>GetLastError</strong> 函数将返回 <strong>ERROR_NO_MORE_FILES</strong> 错误代码。 在这种情况下，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findvolumeclose">FindVolumeClose</a> 函数关闭搜索。</p>
<h4 id="注解-6"><a href="#注解-6" class="headerlink" title="注解"></a>注解</h4><p>​        通过调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-findfirstvolumew">FindFirstVolume</a> 建立搜索句柄后，可以使用 <strong>FindNextVolume</strong> 函数搜索其他卷。</p>
<p>​        不应假定这些函数返回的卷的顺序与计算机上的卷顺序之间存在任何关联。 具体而言，如果存在任何) 或磁盘管理员，则不要假定 BIOS (分配的卷顺序和驱动器号之间的任何关联。</p>
<p>​        在Windows 8和Windows Server 2012中，以下技术支持此函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">技术</th>
<th style="text-align:left">支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">群集共享卷文件系统 (CsvFS)</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">弹性文件系统 (ReFS)</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
</div>
<p>​        SMB 不支持卷管理功能。</p>
<h2 id="查看驱动器属性-GetDriverType-amp-amp-GetVolumeInformation"><a href="#查看驱动器属性-GetDriverType-amp-amp-GetVolumeInformation" class="headerlink" title="查看驱动器属性 GetDriverType &amp;&amp; GetVolumeInformation"></a>查看驱动器属性 GetDriverType &amp;&amp; GetVolumeInformation</h2><p>​        我们在盘上右键查看属性。</p>
<p><img src="image-20230528182104767.png" alt="image-20230528182104767"></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;
BOOL GetDriverInfo(LPSTR szDriver) &#123;

	UINT uDriverType &#x3D; GetDriveType(szDriver);
	printf(&quot;%u&quot;, uDriverType);

	return TRUE;
&#125;

int main()
&#123;
	GetDriverInfo(TEXT(&quot;c:\\&quot;));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230528182835061.png" alt="image-20230528182835061"></p>
<p>​        有自己的特殊含义！在<code>WinBase.h</code>文件下</p>
<p><img src="image-20230528184406835.png" alt="image-20230528184406835"></p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define DRIVE_UNKNOWN     0
#define DRIVE_NO_ROOT_DIR 1
#define DRIVE_REMOVABLE   2
#define DRIVE_FIXED       3
#define DRIVE_REMOTE      4
#define DRIVE_CDROM       5
#define DRIVE_RAMDISK     6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>     正是如此！
</code></pre><p>​        下面是给出详细信息的：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;

BOOL GetDriverInfo(LPSTR szDriver) &#123;

	UINT uDriverType &#x3D; GetDriveType(szDriver);
	printf(&quot;%ls,the type is %u\n&quot;,szDriver, uDriverType);
	switch (uDriverType) &#123;
	case DRIVE_UNKNOWN: &#123;
		printf(&quot;can&#39;t get the driver type&quot;);
		break;
	&#125;
	case DRIVE_NO_ROOT_DIR: &#123;
		printf(&quot;the root path is invalid&quot;);
		break;
	&#125;
	case DRIVE_REMOVABLE:
	&#123;
		printf(&quot;the driver can be removed!&quot;);
		break;
	&#125;
	case DRIVE_FIXED :
	&#123;
		printf(&quot;this is a type that cannot move!&quot;);
		break;
	&#125;
	case DRIVE_REMOTE:
	&#123;
		printf(&quot;the driver is a remote drive!&quot;);
		break;
	&#125;
	case DRIVE_CDROM:
	&#123;
		printf(&quot;the driver is a CD-ROM!&quot;);
		break;
	&#125;
	case DRIVE_RAMDISK:
	&#123;
		printf(&quot;The driver is a RAM disk!&quot;);
		break;
	&#125;
	default:
		break;
	&#125;
	printf(&quot;\n&quot;);

	&#x2F;&#x2F; For more Information
	&#x2F;&#x2F; 
	&#x2F;&#x2F; need to get Some val
	WCHAR szDriverName[MAX_PATH];
	DWORD dwVolumeSerialNumber;
	DWORD dwMaxComponentLength;
	DWORD dwFileSystemFlags;
	WCHAR szFileSystemNameBuffer[MAX_PATH];
	if (!GetVolumeInformation(
		szDriver,
		szDriverName,
		MAX_PATH,
		&amp;dwVolumeSerialNumber,
		&amp;dwMaxComponentLength,
		&amp;dwFileSystemFlags,
		szFileSystemNameBuffer,
		MAX_PATH
	)) &#123;
		return FALSE;
	&#125;

	if (lstrlen(szDriverName)) &#123;
		printf(&quot;\nDriverName is %ls\n&quot;, szDriverName);
	&#125;

	printf(&quot;Volumn Serial Number is %u\n&quot;, dwVolumeSerialNumber);
	printf(&quot;Maxinum Component Length is %u&quot;, dwMaxComponentLength);
	printf(&quot;Systems Type:%ls&quot;, szFileSystemNameBuffer);
	if (dwFileSystemFlags &amp; FILE_VOLUME_QUOTAS) &#123;&#x2F;&#x2F; 可以看到这是要求位判断
		printf(&quot;the file system does support the QUOTAS&quot;);
	&#125;
	&#x2F;&#x2F;...
	return TRUE;
&#125;



int main()
&#123;
	GetDriverInfo(TEXT(&quot;c:\\&quot;));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Extensive-Reading-for-Microsoft-API-1"><a href="#Extensive-Reading-for-Microsoft-API-1" class="headerlink" title="Extensive Reading for Microsoft API"></a>Extensive Reading for Microsoft API</h2><h3 id="getDriveType-函数-fileapi-h"><a href="#getDriveType-函数-fileapi-h" class="headerlink" title="getDriveType 函数 (fileapi.h)"></a>getDriveType 函数 (fileapi.h)</h3><p>​        确定磁盘驱动器是可移动的、固定的、CD-ROM、RAM 磁盘还是网络驱动器。</p>
<p>​        若要确定驱动器是否为 USB 类型驱动器，请调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/setupapi/nf-setupapi-setupdigetdeviceregistrypropertya">SetupDiGetDeviceRegistryProperty</a> 并指定 <strong>SPDRP_REMOVAL_POLICY</strong> 属性。</p>
<h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">UINT <span class="token function">GetDriveTypeW</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPCWSTR lpRootPathName
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-10"><a href="#参数-10" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        驱动器的根目录。</p>
<p>​        需要尾随反斜杠。 如果此参数为 <strong>NULL</strong>，则该函数使用当前目录的根目录。</p>
<h4 id="返回值-10"><a href="#返回值-10" class="headerlink" title="返回值"></a>返回值</h4><p>​        返回值指定驱动器的类型，可以是下列值之一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">返回代码/值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>DRIVE_UNKNOWN</strong>0</td>
<td style="text-align:left">无法确定驱动器类型。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_NO_ROOT_DIR</strong>1</td>
<td style="text-align:left">根路径无效;例如，在指定路径上没有装载卷。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_REMOVABLE</strong>2</td>
<td style="text-align:left">驱动器具有可移动媒体;例如，软盘驱动器、拇指驱动器或闪存卡读取器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_FIXED</strong>3</td>
<td style="text-align:left">驱动器具有固定媒体;例如，硬盘驱动器或闪存驱动器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_REMOTE</strong>4</td>
<td style="text-align:left">驱动器是远程 (网络) 驱动器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_CDROM</strong>5</td>
<td style="text-align:left">驱动器是 CD-ROM 驱动器。</td>
</tr>
<tr>
<td style="text-align:left"><strong>DRIVE_RAMDISK</strong>6</td>
<td style="text-align:left">驱动器是一个 RAM 磁盘。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="getVolumeInformationW-函数-fileapi-h"><a href="#getVolumeInformationW-函数-fileapi-h" class="headerlink" title="getVolumeInformationW 函数 (fileapi.h)"></a>getVolumeInformationW 函数 (fileapi.h)</h3><p>​        检索与指定根目录关联的文件系统和卷的相关信息。</p>
<p>​        若要在检索此信息时指定句柄，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationbyhandlew">GetVolumeInformationByHandleW</a> 函数。</p>
<p>​        若要检索文件或目录的当前压缩状态，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winioctl/ni-winioctl-fsctl_get_compression">FSCTL_GET_COMPRESSION</a>。</p>
<h4 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetVolumeInformationW</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  LPCWSTR lpRootPathName<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPWSTR  lpVolumeNameBuffer<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            DWORD   nVolumeNameSize<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPDWORD lpVolumeSerialNumber<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPDWORD lpMaximumComponentLength<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPDWORD lpFileSystemFlags<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> LPWSTR  lpFileSystemNameBuffer<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>            DWORD   nFileSystemNameSize
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-11"><a href="#参数-11" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向包含要描述的卷的根目录的字符串的指针。</p>
<p>​        如果此参数为 <strong>NULL</strong>，则使用当前目录的根目录。 尾随反斜杠是必需的。 例如，将 \\MyServer\MyShare 指定为“\\MyServer\MyShare\”，或将 C 驱动器指定为“C：\”。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpVolumeNameBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收指定卷名称的缓冲区的指针。 缓冲区大小由 <em>nVolumeNameSize</em> 参数指定。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] nVolumeNameSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        卷名称缓冲区的长度（以 <strong>TCHAR 为单位</strong>）。 最大缓冲区大小为 <strong>MAX_PATH</strong>+1。</p>
<p>​        如果未提供卷名缓冲区，则忽略此参数。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpVolumeSerialNumber<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收卷序列号的变量的指针。</p>
<p>​        如果不需要序列号，此参数可以为 <strong>NULL</strong> 。</p>
<p>​        此函数返回格式化硬盘时操作系统分配的卷序列号。 若要以编程方式获取制造商分配的硬盘序列号，请使用 Windows Management Instrumentation (WMI) <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/previous-versions/windows/desktop/cimwin32a/win32-physicalmedia">Win32_PhysicalMedia</a> 属性 <strong>SerialNumber</strong>。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpMaximumComponentLength<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向变量的指针，该变量接收指定文件系统支持的文件名组件的最大长度（以 <strong>TCHAR 为单位</strong>）。</p>
<p>​        文件名组件是文件名在反斜杠之间的部分。</p>
<p>​        存储在 <em>*lpMaximumComponentLength</em> 指向的变量中的值用于指示指定的文件系统支持长名称。 例如，对于支持长名称的 FAT 文件系统，函数存储值 255，而不是以前的 8.3 指示器。 使用 NTFS 文件系统的系统上也支持长名称。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFileSystemFlags<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收与指定文件系统关联的标志的变量的指针。</p>
<p>​        此参数可以是以下一个或多个标志。 但是， <strong>FILE_FILE_COMPRESSION</strong> 和 <strong>FILE_VOL_IS_COMPRESSED</strong> 是相互排斥的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>FILE_CASE_SENSITIVE_SEARCH</strong> 0x00000001</td>
<td style="text-align:left">指定的卷支持区分大小写的文件名。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_CASE_PRESERVED_NAMES</strong> 0x00000002</td>
<td style="text-align:left">指定的卷支持在磁盘上放置名称时保留文件名大小写。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_UNICODE_ON_DISK</strong> 0x00000004</td>
<td style="text-align:left">指定的卷支持在磁盘上显示的文件名中的 Unicode。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_PERSISTENT_ACLS</strong> 0x00000008</td>
<td style="text-align:left">指定的卷保留并强制实施访问控制列表 (ACL) 。 例如，NTFS 文件系统保留并强制实施 ACL，而 FAT 文件系统则不这样做。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_FILE_COMPRESSION</strong> 0x00000010</td>
<td style="text-align:left">指定的卷支持基于文件的压缩。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_VOLUME_QUOTAS</strong> 0x00000020</td>
<td style="text-align:left">指定的卷支持磁盘配额。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_SPARSE_FILES</strong> 0x00000040</td>
<td style="text-align:left">指定的卷支持稀疏文件。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_REPARSE_POINTS</strong> 0x00000080</td>
<td style="text-align:left">指定的卷支持重新分析点。  <strong>裁判：</strong> ReFS 支持重新分析点，但不对其进行索引，因此 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-findfirstvolumemountpointa">FindFirstVolumeMountPoint</a> 和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-findnextvolumemountpointa">FindNextVolumeMountPoint</a> 将无法按预期工作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_REMOTE_STORAGE</strong> 0x00000100</td>
<td style="text-align:left">文件系统支持远程存储。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_RETURNS_CLEANUP_RESULT_INFO</strong> 0x00000200</td>
<td style="text-align:left">成功执行清理操作后，文件系统将返回描述清理期间执行的其他操作的信息，例如删除文件。 文件系统筛选器可以在清理后回调中检查此信息。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_POSIX_UNLINK_RENAME</strong> 0x00000400</td>
<td style="text-align:left">文件系统支持 POSIX 样式的删除和重命名操作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_VOLUME_IS_COMPRESSED</strong> 0x00008000</td>
<td style="text-align:left">指定的卷是压缩卷，例如 DoubleSpace 卷。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_OBJECT_IDS</strong> 0x00010000</td>
<td style="text-align:left">指定的卷支持对象标识符。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_ENCRYPTION</strong> 0x00020000</td>
<td style="text-align:left">指定的卷支持 EFS) 加密文件系统 (。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/FileIO/file-encryption">文件加密</a>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_NAMED_STREAMS</strong> 0x00040000</td>
<td style="text-align:left">指定的卷支持命名流。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_READ_ONLY_VOLUME</strong> 0x00080000</td>
<td style="text-align:left">指定的卷是只读的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SEQUENTIAL_WRITE_ONCE</strong> 0x00100000</td>
<td style="text-align:left">指定的卷支持单个顺序写入。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_TRANSACTIONS</strong> 0x00200000</td>
<td style="text-align:left">指定的卷支持事务。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/Ktm/about-ktm">关于 KTM</a>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_HARD_LINKS</strong> 0x00400000</td>
<td style="text-align:left">指定的卷支持硬链接。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/hard-links-and-junctions">硬链接和交接点</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前不支持此值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_EXTENDED_ATTRIBUTES</strong> 0x00800000</td>
<td style="text-align:left">指定的卷支持扩展属性。 扩展属性是应用程序特定的元数据片段，应用程序可与文件关联，并且不属于文件数据。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_OPEN_BY_FILE_ID</strong> 0x01000000</td>
<td style="text-align:left">文件系统支持通过 FileID 打开。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/ns-winbase-file_id_both_dir_info">FILE_ID_BOTH_DIR_INFO</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_USN_JOURNAL</strong> 0x02000000</td>
<td style="text-align:left">指定的卷支持更新序列号 (USN) 日志。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/FileIO/change-journal-records">更改日记记录</a>。  <strong>Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在 Windows Server 2008 R2 和 Windows 7 之前，不支持此值。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_INTEGRITY_STREAMS</strong> 0x04000000</td>
<td style="text-align:left">文件系统支持 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-server/storage/refs/integrity-streams">完整性流</a>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_BLOCK_REFCOUNTING</strong> 0x08000000</td>
<td style="text-align:left">指定的卷支持在同一卷上的文件之间共享逻辑群集。 文件系统在写入共享群集时重新分配。 指示 <strong>FSCTL_DUPLICATE_EXTENTS_TO_FILE</strong> 是受支持的操作。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_SPARSE_VDL</strong> 0x10000000</td>
<td style="text-align:left">文件系统跟踪文件的每个群集是否包含来自显式文件写入或自动零的有效数据 () 或无效数据 (尚未写入或归零) 。 使用稀疏的有效数据长度 (VDL) 的文件系统不会存储有效的数据长度，也不需要有效数据在文件中连续。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_DAX_VOLUME</strong> 0x20000000</td>
<td style="text-align:left">指定的卷是 DAX) 卷 (直接访问。  <strong>注意：</strong>此标志是在 Windows 10 版本 1607 中引入的。</td>
</tr>
<tr>
<td style="text-align:left"><strong>FILE_SUPPORTS_GHOSTING</strong> 0x40000000</td>
<td style="text-align:left">文件系统支持重影。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFileSystemNameBuffer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收文件系统名称的缓冲区的指针，例如 FAT 文件系统或 NTFS 文件系统。 缓冲区大小由 <em>nFileSystemNameSize</em> 参数指定。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] nFileSystemNameSize<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        文件系统名称缓冲区的长度（以 <strong>TCHAR 为单位</strong>）。 最大缓冲区大小为 <strong>MAX_PATH</strong>+1。</p>
<p>​        如果未提供文件系统名称缓冲区，则忽略此参数。</p>
<h4 id="返回值-11"><a href="#返回值-11" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果检索了所有请求的信息，则返回值为非零值。</p>
<p>​        如果未检索所有请求的信息，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<h4 id="注解-7"><a href="#注解-7" class="headerlink" title="注解"></a>注解</h4><p>​        当用户尝试获取有关没有软盘的软盘驱动器或没有光盘的 CD-ROM 驱动器的信息时，系统会显示一个消息框，供用户分别插入软盘或光盘。 若要防止系统显示此消息框，请使用 <strong>SEM_FAILCRITICALERRORS</strong>调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/errhandlingapi/nf-errhandlingapi-seterrormode">SetErrorMode</a> 函数。</p>
<p>​        <strong>FILE_VOL_IS_COMPRESSED</strong>标志是基于卷的压缩的唯一指示器。 文件系统名称不会更改以指示压缩，例如，此标志在 DoubleSpace 卷上返回设置。 如果压缩是基于卷的，则会压缩或未压缩整个卷。</p>
<p>​        <strong>FILE_FILE_COMPRESSION</strong>标志指示文件系统是否支持基于文件的压缩。 当压缩基于文件时，可以压缩或不压缩单个文件。</p>
<p>​        <strong>FILE_FILE_COMPRESSION</strong>和<strong>FILE_VOL_IS_COMPRESSED</strong>标志互斥。 不能设置这两个位。</p>
<p>​        <em>存储在 lpMaximumComponentLength</em> 中的最大组件长度值是唯一指示卷支持长于正常 FAT 文件系统 (或其他文件系统) 文件名。 不会更改文件系统名称以指示对长文件名的支持。</p>
<p>​        <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getcompressedfilesizea">GetCompressedFileSize</a> 函数获取文件的压缩大小。 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getfileattributesa">GetFileAttributes</a> 函数可以确定是否压缩单个文件。</p>
<h4 id="符号链接行为-1"><a href="#符号链接行为-1" class="headerlink" title="符号链接行为"></a>符号链接行为</h4><p>​        如果路径指向符号链接，则 函数将返回目标的卷信息。</p>
<p>​        从Windows 8和Windows Server 2012开始，以下技术支持此函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">技术</th>
<th style="text-align:left">支持</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务器消息块 (SMB) 3.0 协议</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">SMB 3.0 透明故障转移 (TFO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">具有横向扩展文件共享的 SMB 3.0 (SO)</td>
<td style="text-align:left">否</td>
</tr>
<tr>
<td style="text-align:left">群集共享卷文件系统 (CsvFS)</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">弹性文件系统 (ReFS)</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
</div>
<p>​        SMB 不支持卷管理功能。</p>
<h4 id="事务处理操作"><a href="#事务处理操作" class="headerlink" title="事务处理操作"></a>事务处理操作</h4><p>​        如果卷支持文件系统事务，则函数返回 <em>lpFileSystemFlags</em> 中的<strong>FILE_SUPPORTS_TRANSACTIONS</strong>。</p>
<h5 id="备注-2"><a href="#备注-2" class="headerlink" title="备注"></a>备注</h5><p>​        标头 <code>fileapi.h</code> 将 <strong>GetVolumeInformation</strong> 定义为别名，该别名根据 UNICODE 预处理器常量的定义自动选择此函数的 ANSI 或 Unicode 版本。 将非特定编码别名的使用与非非特定编码的代码混合使用可能会导致不匹配，从而导致编译或运行时错误。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/intl/conventions-for-function-prototypes">函数原型的约定</a></p>
<h2 id="查看磁盘容量"><a href="#查看磁盘容量" class="headerlink" title="查看磁盘容量"></a>查看磁盘容量</h2><h3 id="GetDiskFreeSpace-amp-amp-GetDiskFreeSpaceEx"><a href="#GetDiskFreeSpace-amp-amp-GetDiskFreeSpaceEx" class="headerlink" title="GetDiskFreeSpace &amp;&amp; GetDiskFreeSpaceEx"></a>GetDiskFreeSpace &amp;&amp; GetDiskFreeSpaceEx</h3><p>​        我们使用这些函数来得到我们想要的信息：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;


int main() &#123;
	BOOL isFine;

	&#x2F;&#x2F; 蔟
	DWORD dwTotlaClusters;
	DWORD dwFreeCluster;
	&#x2F;&#x2F; 扇区
	DWORD dwSectPerClust;
	&#x2F;&#x2F;字节
	DWORD dwBytesPerSect;

	isFine &#x3D; GetDiskFreeSpace(
		TEXT(&quot;C:&#x2F;&quot;),
		&amp;dwSectPerClust,
		&amp;dwBytesPerSect,
		&amp;dwFreeCluster,
		&amp;dwTotlaClusters
	);
	if (!isFine) &#123;
		printf(&quot;Error&quot;);
		return GetLastError();
	&#125;

	printf(&quot;\nGet:&gt;\n&quot;);
	printf(&quot;总蔟：%d\t每一蔟的扇区数:%d\t空闲的数量：%d\t每个扇区的字节数：%d\t&quot;, dwTotlaClusters, dwSectPerClust, dwFreeCluster, dwBytesPerSect);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <img src="image-20230529162144848.png" alt="image-20230529162144848"></p>
<p>​        OK的！</p>
<p>​        那这个Ex版本的是啥呢：精简的版本的：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DWORD64 qwFreeBytes, qwFreeBytesToCaller, qwTotalBytes;
isFine &#x3D; GetDiskFreeSpaceEx(
	TEXT(&quot;C:&quot;), 
	(PULARGE_INTEGER)&amp; qwFreeBytesToCaller,
	(PULARGE_INTEGER)&amp;qwTotalBytes, 
	(PULARGE_INTEGER)&amp;qwFreeBytes
);
if(!isFine) &#123;
	printf(&quot;Error&quot;);
	return GetLastError();
&#125;
printf(&quot;磁盘的总容量：%I64d\t磁盘的总空闲容量：%I64d\t&quot;, 
	qwTotalBytes, qwFreeBytes);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230529163015847.png" alt="image-20230529163015847"></p>
<h3 id="getDiskFreeSpace-函数-fileapi-h"><a href="#getDiskFreeSpace-函数-fileapi-h" class="headerlink" title="getDiskFreeSpace 函数 (fileapi.h)"></a>getDiskFreeSpace 函数 (fileapi.h)</h3><p>​        本文内容<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#syntax">语法</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#parameters">参数</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#return-value">返回值</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#remarks">注解</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#requirements">要求</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespacea#see-also">另请参阅</a></p>
<p>​        检索有关指定磁盘的信息，包括磁盘上的可用空间量。</p>
<h4 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetDiskFreeSpace</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span>  LPCSTR  lpRootPathName<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpSectorsPerCluster<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpBytesPerSector<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpNumberOfFreeClusters<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">]</span> LPDWORD lpTotalNumberOfClusters
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-12"><a href="#参数-12" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in] lpRootPathName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        要为其返回信息的磁盘的根目录。 如果此参数为 <strong>NULL</strong>，则该函数使用当前磁盘的根目录。 如果此参数是 UNC 名称，则必须包含尾随反斜杠 (，例如“\\MyServer\MyShare\”) 。 此外，驱动器规范必须具有尾随反斜杠 (，例如“C：\”) 。 调用应用程序必须具有此目录 <strong>FILE_LIST_DIRECTORY</strong> 访问权限。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpSectorsPerCluster<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收每个群集扇区数的变量的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpBytesPerSector<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收每个扇区字节数的变量的指针。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpNumberOfFreeClusters<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收磁盘上可用可用群集总数的变量的指针，该群集可供与调用线程关联的用户使用。</p>
<p>​        如果使用每用户磁盘配额，此值可能小于磁盘上的可用群集总数。</p>
<pre class="line-numbers language-none"><code class="language-none">[out] lpTotalNumberOfClusters<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向一个变量的指针，该变量接收磁盘上可用于与调用线程关联的用户的群集总数。</p>
<p>​        如果使用每用户磁盘配额，此值可能小于磁盘上的群集总数。</p>
<h4 id="返回值-12"><a href="#返回值-12" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<h4 id="注解-8"><a href="#注解-8" class="headerlink" title="注解"></a>注解</h4><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-getdiskfreespaceexa">        GetDiskFreeSpaceEx</a> 函数可避免 <strong>GetDiskFreeSpace</strong> 函数所需的一些算术。</p>
<p>​        符号链接行为 - 如果路径指向符号链接，则会对目标执行操作。</p>
<p> 备注</p>
<p>​        fileapi.h 标头将 GetDiskFreeSpace 定义为别名，该别名根据 UNICODE 预处理器常量的定义自动选择此函数的 ANSI 或 Unicode 版本。 将非中性编码别名与非非编码的代码混合使用可能会导致编译或运行时错误不匹配。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/intl/conventions-for-function-prototypes">函数原型的约定</a>。</p>
<h3 id="getDiskFreeSpaceEx函数-fileapi-h"><a href="#getDiskFreeSpaceEx函数-fileapi-h" class="headerlink" title="getDiskFreeSpaceEx函数 (fileapi.h)"></a>getDiskFreeSpaceEx函数 (fileapi.h)</h3><p>​        本文内容<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#syntax">语法</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#parameters">参数</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#return-value">返回值</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#remarks">注解</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#requirements">要求</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-getdiskfreespaceexa#see-also">另请参阅</a></p>
<p>​        检索有关磁盘卷上可用空间量的信息，即总空间量、可用空间总量以及与调用线程关联的用户可用的可用空间总量。</p>
<h4 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">GetDiskFreeSpaceEx</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">,</span> optional<span class="token punctuation">]</span>  LPCSTR          lpDirectoryName<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> PULARGE_INTEGER lpFreeBytesAvailableToCaller<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> PULARGE_INTEGER lpTotalNumberOfBytes<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>out<span class="token punctuation">,</span> optional<span class="token punctuation">]</span> PULARGE_INTEGER lpTotalNumberOfFreeBytes
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数-13"><a href="#参数-13" class="headerlink" title="参数"></a>参数</h4><pre class="line-numbers language-none"><code class="language-none">[in, optional] lpDirectoryName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        磁盘上的目录。</p>
<p>​        如果此参数为 <strong>NULL</strong>，则该函数使用当前磁盘的根目录。</p>
<p>​        如果此参数是 UNC 名称，则必须包含尾随反斜杠，例如“\\MyServer\MyShare\”。</p>
<p>​        此参数不必在磁盘上指定根目录。 该函数接受磁盘上的任何目录。</p>
<p>​        调用应用程序必须对此具有 <strong>FILE_LIST_DIRECTORY</strong> 访问权限<br>“sample”目录中。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpFreeBytesAvailableToCaller<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向一个变量的指针，该变量接收磁盘上的可用字节总数，这些字节可供与调用线程关联的用户使用。</p>
<p>​        此参数可以为 NULL。</p>
<p>​        如果使用每用户配额，此值可能小于磁盘上的可用字节总数。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpTotalNumberOfBytes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向一个变量的指针，该变量接收磁盘上可用于与调用线程关联的用户的字节总数。</p>
<p>​        此参数可以为 NULL。</p>
<p>​        如果使用每用户配额，此值可能小于磁盘上的字节总数。</p>
<p>​        若要确定磁盘或卷上的字节总数，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winioctl/ni-winioctl-ioctl_disk_get_length_info">IOCTL_DISK_GET_LENGTH_INFO</a>。</p>
<pre class="line-numbers language-none"><code class="language-none">[out, optional] lpTotalNumberOfFreeBytes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        指向接收磁盘上可用字节总数的变量的指针。</p>
<p>​        此参数可以为 NULL。</p>
<h4 id="返回值-13"><a href="#返回值-13" class="headerlink" title="返回值"></a>返回值</h4><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为 0 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p>
<h4 id="注解-9"><a href="#注解-9" class="headerlink" title="注解"></a>注解</h4><p>​        此函数获取的值的类型 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer~r1">为ULARGE_INTEGER</a>。 不要将这些值截断为 32 位。</p>
<p>​        <strong>GetDiskFreeSpaceEx</strong> 函数返回 <em>lpTotalNumberOfFreeBytes</em> 和 <em>lpFreeBytesAvailable</em> 的所有 CD 请求的零 (0) ，除非磁盘是 CD-RW 驱动器中的未写入 CD。</p>
<p>​        符号链接行为 - 如果路径指向符号链接，则会对目标执行操作。</p>
<h3 id="ULARGE-INTEGER-union-winnt-h"><a href="#ULARGE-INTEGER-union-winnt-h" class="headerlink" title="ULARGE_INTEGER union (winnt.h)"></a>ULARGE_INTEGER union (winnt.h)</h3><p>​        本文内容<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#syntax">语法</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#members">成员</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#remarks">备注</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#requirements">要求</a><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-ularge_integer-r1#see-also">另请参阅</a></p>
<p>表示 64 位无符号整数值。</p>
<p><strong>注意</strong> C 编译器可能本机支持 64 位整数。 例如，Microsoft Visual C++支持<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/Midl/--int64">__int64</a>大小的整数类型。 有关详细信息，请参阅 C 编译器随附的文档。</p>
<h4 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">union</span> _ULARGE_INTEGER <span class="token punctuation">&#123;</span>
  <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    DWORD LowPart<span class="token punctuation">;</span>
    DWORD HighPart<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> DUMMYSTRUCTNAME<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    DWORD LowPart<span class="token punctuation">;</span>
    DWORD HighPart<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> u<span class="token punctuation">;</span>
  ULONGLONG QuadPart<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> ULARGE_INTEGER<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><pre class="line-numbers language-none"><code class="language-none">DUMMYSTRUCTNAME
DUMMYSTRUCTNAME.LowPart
DUMMYSTRUCTNAME.HighPart
u
u.LowPart
u.HighPart
QuadPart<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>64 位无符号整数。</p>
<h4 id="备注-3"><a href="#备注-3" class="headerlink" title="备注"></a>备注</h4><p><strong>ULARGE_INTEGER</strong>结构实际上是一个联合体。 如果编译器内置了对 64 位整数的支持，请使用 <strong>QuadPart</strong> 成员存储 64 位整数。 否则，请使用 <strong>LowPart</strong> 和 <strong>HighPart</strong> 成员存储 64 位整数。</p>
<h2 id="文件操作的四种方法"><a href="#文件操作的四种方法" class="headerlink" title="文件操作的四种方法"></a>文件操作的四种方法</h2><p>​        我们学习到现在，实质上有四种方法进行文件操作。<code>C++, C, Windows API, Windows MFC</code></p>
<p>​        合适的选取方法是十分重要的。下面，为了能够更好的演示，我们选择在Windows MFC下演示之。</p>
<h2 id="创建MFC"><a href="#创建MFC" class="headerlink" title="创建MFC"></a>创建MFC</h2><p>​        如果先前并没有勾选过VS桌面开发者，可以前往安装之。这里就不再多述了，创建一个MFC的基于对话框的应用程序即可！</p>
<p>​        用MFC工具集，我搭建一个演示平台：</p>
<p><img src="image-20230603090808135.png" alt="image-20230603090808135"></p>
<p>​        其中，事先准备好一个文本（我这里是随意的一个1.txt）放到工程文件目录下面去了。</p>
<h2 id="clear按钮"><a href="#clear按钮" class="headerlink" title="clear按钮"></a>clear按钮</h2><p>​        介绍一下函数：<code>SetDlgItemText</code></p>
<h3 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">SetDlgItemTextW</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> HWND    hDlg<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token keyword">int</span>     nIDDlgItem<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCWSTR lpString
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="参数-14"><a href="#参数-14" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in] hDlg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型：<strong>HWND</strong></p>
<p>包含控件的对话框的句柄。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] nIDDlgItem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>int</strong></p>
<p>具有要设置的标题或文本的控件。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] lpString<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>类型： <strong>LPCTSTR</strong></p>
<p>要复制到控件的文本。</p>
<h3 id="返回值-14"><a href="#返回值-14" class="headerlink" title="返回值"></a>返回值</h3><p>类型： <strong>BOOL</strong></p>
<p>如果该函数成功，则返回值为非零值。</p>
<p>如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<h3 id="注解-10"><a href="#注解-10" class="headerlink" title="注解"></a>注解</h3><p><strong>SetDlgItemText</strong> 函数将<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/winmsg/wm-settext">WM_SETTEXT</a>消息发送到指定的控件。</p>
<p>​        而在MFC中，只需要给定指定的控件编号和文本即可：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton5()
&#123;
	&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码
	SetDlgItemText(IDC_EDIT1, TEXT(&quot;&quot;));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="C-方式"><a href="#C-方式" class="headerlink" title="C  方式"></a>C  方式</h2><p>​        点击第一个按钮，书写响应函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton1()
&#123;
	&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码
	CString s &#x3D; TEXT(&quot;************C*************\r\n&quot;); &#x2F;&#x2F;一个MFC类
	FILE* pF; &#x2F;&#x2F; 声明文件指针
	char line[256]; &#x2F;&#x2F;准备字符空间
	fopen_s(&amp;pF,&quot;1.txt&quot;, &quot;r&quot;); &#x2F;&#x2F; 阅读内容
	while (fgets(line, 256, pF) !&#x3D; NULL) &#123;
		s +&#x3D; line;			&#x2F;&#x2F; 使用Cstring的函数
		s +&#x3D; TEXT(&quot;\r\n&quot;);
	&#125;
	fclose(pF);
	SetDlgItemText(IDC_EDIT1, s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="C-方式-1"><a href="#C-方式-1" class="headerlink" title="C++ 方式"></a>C++ 方式</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton2()
&#123;
	&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码
	CString s &#x3D; TEXT(&quot;************C++*************\r\n&quot;);
	char line[256];
	std::ifstream ifs(&quot;1.txt&quot;);
	while (ifs.getline(line, 256)) &#123;
		s +&#x3D; line;
		s +&#x3D; TEXT(&quot;\r\n&quot;);
	&#125;

	ifs.close();
	SetDlgItemText(IDC_EDIT1, s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton3()
&#123;
	&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码
	CString c &#x3D; TEXT(&quot;*****************API********************\r\n&quot;);
	CHAR lpFileDataBuffer[4096];
	ZeroMemory(lpFileDataBuffer, 4096);
	DWORD dwReadSize;
	HANDLE hfile;
	hfile &#x3D; CreateFile(
		TEXT(&quot;1.txt&quot;),
		GENERIC_READ, 
		FILE_SHARE_READ,
		NULL, 
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);
	ReadFile(hfile, lpFileDataBuffer, 4096, &amp;dwReadSize, NULL);
	CloseHandle(hfile);
	c +&#x3D; lpFileDataBuffer;
	SetDlgItemText(IDC_EDIT1,c);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Windows-MFC"><a href="#Windows-MFC" class="headerlink" title="Windows MFC"></a>Windows MFC</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void CMFCApplication1Dlg::OnBnClickedButton4()
&#123;
	&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码
	CString s &#x3D; TEXT(&quot;******************MFC*******************\r\n&quot;);
	CString line;
	CStdioFile file(TEXT(&quot;1.txt&quot;),CFile::modeRead);
	while (file.ReadString(line))
	&#123;
		s +&#x3D; line;
		s +&#x3D; TEXT(&quot;\r\n&quot;);
	&#125;
	SetDlgItemText(IDC_EDIT1, s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="系统学习Windows-API-8"><a href="#系统学习Windows-API-8" class="headerlink" title="系统学习Windows API 8"></a>系统学习Windows API 8</h1><h2 id="前导-1"><a href="#前导-1" class="headerlink" title="前导"></a>前导</h2><p>​        首先，熟悉一下这个形式的main函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main(int argc, char* argv[])&#123;
	&#x2F;&#x2F;...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​                在这里，<code>argc</code>指出了命令行有几个，<code>argv</code>给出了具体的参数是什么，来个demo:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;Windows.h&gt;
#include&lt;stdio.h&gt;

int main(int argc, char* argv[]) &#123;
	printf(&quot;个数：%d\n&quot;, argc);
	printf(&quot;第一个:%s\n&quot;, argv[0]);
	printf(&quot;第二个:%s\n&quot;, argv[1]);
	printf(&quot;第三个:%s\n&quot;, argv[2]);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在只是<code>生成工程</code>！随后，使用<code>PowerShell</code>切换到工程的debug目录下面，找到这个自己的可执行文件。由于此时<code>int main(int argc, char* argv[])</code>带上了命令行参数，它可以接受命令！</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./mu.exe <span class="token parameter variable">-d</span> a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230603094626567.png" alt="image-20230603094626567"></p>
<p><img src="image-20230603094646043.png" alt="image-20230603094646043"></p>
<p>​        这就是运行的结果。</p>
<h2 id="DeleteFile"><a href="#DeleteFile" class="headerlink" title="DeleteFile"></a>DeleteFile</h2><p>​        删除现有文件。</p>
<p>若要以事务处理操作的形式执行此操作，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-deletefiletransacteda">DeleteFileTransacted</a> 函数。</p>
<h3 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">DeleteFile</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpFileName
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="参数-15"><a href="#参数-15" class="headerlink" title="参数"></a>参数</h3><pre class="line-numbers language-none"><code class="language-none">[in] lpFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        要删除的文件的名称。</p>
<p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\\？\”。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p>
<p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p>
<h2 id="返回值-15"><a href="#返回值-15" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为零 (0) 。 要获得更多的错误信息，请调用 GetLastError。</p>
<h2 id="注解-11"><a href="#注解-11" class="headerlink" title="注解"></a>注解</h2><p>​        如果应用程序尝试删除不存在的文件， <strong>DeleteFile</strong> 函数将失败并 <strong>ERROR_FILE_NOT_FOUND</strong>。 如果文件是只读文件，则函数将失败并 <strong>ERROR_ACCESS_DENIED</strong>。</p>
<p>​        以下列表标识了删除、删除或关闭文件的一些提示：</p>
<ul>
<li>若要删除只读文件，首先必须删除只读属性。</li>
<li>若要删除或重命名文件，必须对文件具有删除权限，或者具有父目录中的删除子权限。</li>
<li>若要以递归方式删除目录中的文件，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/shellapi/nf-shellapi-shfileoperationa">SHFileOperation</a> 函数。</li>
<li>若要删除空目录，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-removedirectorya">RemoveDirectory</a> 函数。</li>
<li>若要关闭打开的文件，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> 函数。</li>
</ul>
<p>​        如果设置了除 delete 和 delete child 以外的所有访问权限的目录，并且访问控制列表 (ACL) 继承了新文件，则可以创建一个文件，但无法将其删除。 但是，你可以创建一个文件，然后获取在创建文件时返回给你的句柄上请求的所有访问权限。</p>
<p>​        如果在创建文件时请求删除权限，则可以使用该句柄删除或重命名文件，但不能使用任何其他句柄。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/file-security-and-access-rights">文件安全和访问权限</a>。</p>
<p>​        如果应用程序尝试删除具有打开正常 I/O 的其他句柄的文件或作为内存映射文件的文件 (<strong>FILE_SHARE_DELETE</strong>必须在打开其他句柄) 时指定，<strong>DeleteFile</strong> 函数将失败。</p>
<p>​        <strong>DeleteFile</strong> 函数在关闭时标记要删除的文件。 因此，在关闭文件的最后一个句柄之前，不会删除文件。 后续调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 以打开文件失败， <strong>并显示ERROR_ACCESS_DENIED</strong>。</p>
<p>​        符号链接行为 —</p>
<p>​        如果路径指向符号链接，则删除符号链接，而不是目标。 若要删除目标，必须调用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/fileapi/nf-fileapi-createfilea">CreateFile</a> 并指定 <strong>FILE_FLAG_DELETE_ON_CLOSE</strong>。</p>
<h2 id="CopyFile"><a href="#CopyFile" class="headerlink" title="CopyFile"></a>CopyFile</h2><p>​        将现有文件复制到新文件。</p>
<p>​        <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-copyfileexa">CopyFileEx</a> 函数提供两个附加功能。 每次完成复制操作的一部分时，<strong>CopyFileEx</strong> 都可以调用指定的回调函数，并且可以在复制操作期间取消 <strong>CopyFileEx</strong>。</p>
<p>​        若要以事务处理操作的形式执行此操作，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-copyfiletransacteda">CopyFileTransacted</a> 函数。</p>
<h3 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">CopyFile</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpExistingFileName<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpNewFileName<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> BOOL    bFailIfExists
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="参数-16"><a href="#参数-16" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-none"><code class="language-none">[in] lpExistingFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        现有文件的名称。</p>
<p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\？\”。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p>
<p> 提示</p>
<p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p>
<p>​        如果 <em>lpExistingFileName</em> 不存在， <strong>则 CopyFile</strong> 将失败， <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a> 将返回 <strong>ERROR_FILE_NOT_FOUND</strong>。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] lpNewFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        新文件的名称。</p>
<p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\？\”。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p>
<p> 提示</p>
<p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] bFailIfExists<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果此参数为 <strong>TRUE</strong> 并且 <em>lpNewFileName</em> 指定的新文件已存在，则函数将失败。 如果此参数为 <strong>FALSE</strong> 且新文件已存在，则函数将覆盖现有文件并成功。</p>
<h2 id="返回值-16"><a href="#返回值-16" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<h2 id="注解-12"><a href="#注解-12" class="headerlink" title="注解"></a>注解</h2><p>​        现有文件 (<strong>ATTRIBUTE_SECURITY_INFORMATION</strong>) 的安全资源属性将复制到新文件。</p>
<p>​        <strong>Windows 7、Windows Server 2008 R2、Windows Server 2008、Windows Vista、Windows Server 2003 和 Windows XP：</strong> 在Windows 8和Windows Server 2012之前，现有文件的安全资源属性不会复制到新文件。</p>
<p>​        现有文件的文件属性将复制到新文件。 例如，如果现有文件具有 <strong>FILE_ATTRIBUTE_READONLY</strong> 文件属性，则通过调用 <strong>CopyFile</strong> 创建的副本也将具有 <strong>FILE_ATTRIBUTE_READONLY</strong> 文件属性。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/FileIO/retrieving-and-changing-file-attributes">检索和更改文件属性</a>。</p>
<p>​        如果目标文件已存在并且设置了<strong>FILE_ATTRIBUTE_HIDDEN或FILE_ATTRIBUTE_READONLY</strong>属性，则此函数将失败<strong>并ERROR_ACCESS_DENIED</strong>。</p>
<p>​        当 <strong>CopyFile</strong> 用于复制加密的文件时，它会尝试使用源文件加密中使用的密钥来加密目标文件。 如果无法执行此操作，此函数将尝试使用默认密钥加密目标文件。 如果这两种方法都无法完成， <strong>则 CopyFile</strong> 将失败并 <strong>显示ERROR_ENCRYPTION_FAILED</strong> 错误代码。</p>
<p>​        符号链接行为 - 如果源文件是符号链接，则复制的实际文件是符号链接的目标。</p>
<p>​        如果目标文件已存在并且是符号链接，则符号链接的目标将被源文件覆盖。</p>
<h2 id="MoveFile"><a href="#MoveFile" class="headerlink" title="MoveFile"></a>MoveFile</h2><p>​        移动现有文件或目录，包括其子级。</p>
<p>​        若要指定如何移动文件，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefileexa">MoveFileEx</a> 或 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefilewithprogressa">MoveFileWithProgress</a> 函数。</p>
<p>​        若要以事务处理操作的形式执行此操作，请使用 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/desktop/api/winbase/nf-winbase-movefiletransacteda">MoveFileTransacted</a> 函数。</p>
<h3 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BOOL <span class="token function">MoveFile</span><span class="token punctuation">(</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpExistingFileName<span class="token punctuation">,</span>
  <span class="token punctuation">[</span>in<span class="token punctuation">]</span> LPCTSTR lpNewFileName
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="参数-17"><a href="#参数-17" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-none"><code class="language-none">[in] lpExistingFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        本地计算机上文件或目录的当前名称。</p>
<p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\\？\”。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p>
<p> 提示</p>
<p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p>
<pre class="line-numbers language-none"><code class="language-none">[in] lpNewFileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        文件或目录的新名称。 新名称不得已存在。 新文件可能位于不同的文件系统或驱动器上。 新目录必须位于同一驱动器上。</p>
<p>​        默认情况下，名称限制为MAX_PATH个字符。 若要将此限制扩展到 32，767 个宽字符，请在路径前面添加“\\？\”。 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a>。</p>
<p> 提示</p>
<p>​        从 Windows 10 版本 1607 开始，可以选择删除MAX_PATH限制，而无需在前面添加“\\？\”。 有关详细信息，请参阅 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/fileio/naming-a-file">命名文件、路径和命名空间</a> 的“最大路径长度限制”部分。</p>
<h2 id="返回值-17"><a href="#返回值-17" class="headerlink" title="返回值"></a>返回值</h2><p>​        如果该函数成功，则返回值为非零值。</p>
<p>​        如果函数失败，则返回值为零。 要获得更多的错误信息，请调用 GetLastError。</p>
<h2 id="注解-13"><a href="#注解-13" class="headerlink" title="注解"></a>注解</h2><p>​        <strong>MoveFile</strong> 函数将移动 (重命名) 文件或目录 (包括其子级) 在同一目录中或跨目录。 需要注意的是，当目标位于其他卷上时，移动目录时 <strong>，MoveFile</strong> 函数将失败。</p>
<p>​        如果文件跨卷移动， <strong>MoveFile</strong> 不会随文件一起移动安全描述符。 将为文件分配目标目录中的默认安全描述符。</p>
<p>​        <strong>MoveFile</strong> 函数将其操作与链接跟踪服务协调，因此可以在移动链接源时对其进行跟踪。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/06/06/Learn-Windows-API-Semester-I/">http://charliechen114514.github.io/2023/06/06/Learn-Windows-API-Semester-I/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Windows-32API/">Windows 32API</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/06/Learn-Qt-I/" title="Learn_Qt-I"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Learn_Qt-I</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/06/Learn-Pytorch-1/" title="Learn_Pytorch_1"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Learn_Pytorch_1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/23/TCP-IP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941%EF%BC%8C2%EF%BC%8C3/" title="TCP&#x2F;IP 网络编程笔记——1，2，3"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-23</div><div class="title">TCP&#x2F;IP 网络编程笔记——1，2，3</div></div></a></div><div><a href="/2023/06/06/Algorithm-RecursionSpecial/" title="Algorithm_RecursionSpecial"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_RecursionSpecial</div></div></a></div><div><a href="/2023/06/06/Algorithm-in-C-1/" title="Algorithm_in_C(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_in_C(1)</div></div></a></div><div><a href="/2024/01/09/2024%E5%AF%92%E5%81%87%E6%95%B4%E6%B4%BB-C-Cppb%E9%AB%98%E7%BA%A7%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/" title="2024寒假整活_C_Cppb高级编译技术"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-09</div><div class="title">2024寒假整活_C_Cppb高级编译技术</div></div></a></div><div><a href="/2023/12/03/C-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%93%8D%E4%BD%9C%E6%89%93%E5%8D%B0tuple/" title="C++使用模板操作打印tuple"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-03</div><div class="title">C++使用模板操作打印tuple</div></div></a></div><div><a href="/2023/12/28/AutoClassGenerator%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/" title="AutoClassGenerator开发记录"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-28</div><div class="title">AutoClassGenerator开发记录</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Windows-API"><span class="toc-number">1.</span> <span class="toc-text">系统学习Windows API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E6%8E%A2"><span class="toc-number">1.1.</span> <span class="toc-text">初探</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%AF%BC"><span class="toc-number">1.2.</span> <span class="toc-text">前导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E8%AF%95%E4%B8%80%E6%89%8B"><span class="toc-number">1.3.</span> <span class="toc-text">小试一手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%90%E4%B8%80%E8%A7%A3%E9%87%8A"><span class="toc-number">1.4.</span> <span class="toc-text">逐一解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#include-lt-Windows-h-gt"><span class="toc-number">1.4.1.</span> <span class="toc-text">#include&lt; Windows.h &gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-WINAPI-WinMain-HINSTANCE-hInstance-HINSTANCE-hPrevInstance-LPSTR-ipCmdLine-int-nCmdShow"><span class="toc-number">1.4.2.</span> <span class="toc-text">int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR ipCmdLine, int nCmdShow)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#What-is-WINAPI"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">What is WINAPI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E6%B3%A8%EF%BC%9F"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">批注？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MessageBox%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">MessageBox函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.5.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.6.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BB%E9%A2%98"><span class="toc-number">1.7.</span> <span class="toc-text">字符串主题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">1.7.1.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wchar-t%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text">wchar_t类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E4%B8%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AE%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">1.7.3.</span> <span class="toc-text">Windows下的字符和宽字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.8.</span> <span class="toc-text">常见的字符串处理工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">1.8.1.</span> <span class="toc-text">获取字符串的长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BB%E9%A2%98-1"><span class="toc-number">1.9.</span> <span class="toc-text">字符串主题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8-1"><span class="toc-number">1.9.1.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wchar-t%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">1.9.2.</span> <span class="toc-text">wchar_t类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E4%B8%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AE%BD%E5%AD%97%E7%AC%A6-1"><span class="toc-number">1.9.3.</span> <span class="toc-text">Windows下的字符和宽字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%B7%A5%E4%BD%9C-1"><span class="toc-number">1.10.</span> <span class="toc-text">常见的字符串处理工作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6-1"><span class="toc-number">1.10.1.</span> <span class="toc-text">获取字符串的长度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%80%E7%9C%8B"><span class="toc-number">1.11.</span> <span class="toc-text">数据类型一看</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.</span> <span class="toc-text">API基础函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6demo"><span class="toc-number">1.13.</span> <span class="toc-text">读取文件demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read-file"><span class="toc-number">1.14.</span> <span class="toc-text">read file</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#createFileW-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.14.1.</span> <span class="toc-text">createFileW 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-1"><span class="toc-number">1.14.1.1.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-1"><span class="toc-number">1.14.1.2.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.14.1.3.</span> <span class="toc-text">符号链接行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.14.1.4.</span> <span class="toc-text">缓存行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">1.14.1.5.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5-I-O-%E5%8F%A5%E6%9F%84"><span class="toc-number">1.14.1.6.</span> <span class="toc-text">同步和异步 I&#x2F;O 句柄</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">1.14.1.7.</span> <span class="toc-text">文件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.14.1.8.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%A3%81%E7%9B%98%E5%92%8C%E5%8D%B7"><span class="toc-number">1.14.1.9.</span> <span class="toc-text">物理磁盘和卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E5%99%A8%E8%AE%BE%E5%A4%87"><span class="toc-number">1.14.1.10.</span> <span class="toc-text">更改器设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A3%81%E5%B8%A6%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="toc-number">1.14.1.11.</span> <span class="toc-text">磁带驱动器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E8%B5%84%E6%BA%90"><span class="toc-number">1.14.1.12.</span> <span class="toc-text">通信资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%BA"><span class="toc-number">1.14.1.13.</span> <span class="toc-text">机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mailslots"><span class="toc-number">1.14.1.14.</span> <span class="toc-text">Mailslots</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">1.14.1.15.</span> <span class="toc-text">管道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadFile-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.14.2.</span> <span class="toc-text">ReadFile 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-1"><span class="toc-number">1.14.2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-2"><span class="toc-number">1.14.2.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-2"><span class="toc-number">1.14.2.4.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.14.2.5.</span> <span class="toc-text">同步和文件位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93-1"><span class="toc-number">1.14.2.6.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.14.2.7.</span> <span class="toc-text">事务处理的操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.15.</span> <span class="toc-text">Windows数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%B2%E8%A7%A3"><span class="toc-number">1.16.</span> <span class="toc-text">一些函数的讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetFileAttributesEx"><span class="toc-number">1.16.1.</span> <span class="toc-text">GetFileAttributesEx()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GetFileAttributesExW-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.16.1.1.</span> <span class="toc-text">GetFileAttributesExW 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">1.16.1.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-2"><span class="toc-number">1.16.1.1.2.</span> <span class="toc-text">参数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-3"><span class="toc-number">1.17.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="toc-number">1.18.</span> <span class="toc-text">获取时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95"><span class="toc-number">1.19.</span> <span class="toc-text">获取系统目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetSystemDirectoryW-%E5%87%BD%E6%95%B0-sysinfoapi-h"><span class="toc-number">1.19.1.</span> <span class="toc-text">GetSystemDirectoryW 函数 (sysinfoapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-3"><span class="toc-number">1.19.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-3"><span class="toc-number">1.19.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-4"><span class="toc-number">1.19.1.3.</span> <span class="toc-text">返回值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.20.</span> <span class="toc-text">创建窗口和消息处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APIEntry"><span class="toc-number">1.21.</span> <span class="toc-text">APIEntry:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DialogBox"><span class="toc-number">1.22.</span> <span class="toc-text">DialogBox</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-4"><span class="toc-number">1.22.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-4"><span class="toc-number">1.22.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8"><span class="toc-number">1.22.3.</span> <span class="toc-text">备注</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MAKEINTERSOURCE"><span class="toc-number">1.23.</span> <span class="toc-text">MAKEINTERSOURCE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.24.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%89%88%E6%9C%AC%E7%9A%84char%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.25.</span> <span class="toc-text">三大版本的char类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.26.</span> <span class="toc-text">字符转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MultiByteToWideChar"><span class="toc-number">1.26.1.</span> <span class="toc-text">MultiByteToWideChar();</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-5"><span class="toc-number">1.26.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-5"><span class="toc-number">1.26.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-5"><span class="toc-number">1.26.1.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-3"><span class="toc-number">1.26.1.4.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.26.1.5.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WideCharToMultiByte"><span class="toc-number">1.26.2.</span> <span class="toc-text">WideCharToMultiByte</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">1.26.2.1.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E4%BE%8B"><span class="toc-number">1.26.2.2.</span> <span class="toc-text">范例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%8D%B7-GetLogicalDriveStrings"><span class="toc-number">1.27.</span> <span class="toc-text">遍历卷 GetLogicalDriveStrings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%B7"><span class="toc-number">1.28.</span> <span class="toc-text">查看第一个卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extensive-Reading-for-Microsoft-API"><span class="toc-number">1.29.</span> <span class="toc-text">Extensive Reading for Microsoft API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZeroMemory-%E5%AE%8F-wdm-h"><span class="toc-number">1.29.1.</span> <span class="toc-text">ZeroMemory 宏 (wdm.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-6"><span class="toc-number">1.29.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-6"><span class="toc-number">1.29.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-6"><span class="toc-number">1.29.1.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8-1"><span class="toc-number">1.29.1.4.</span> <span class="toc-text">备注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E8%B4%A8%E4%B8%8A"><span class="toc-number">1.29.1.5.</span> <span class="toc-text">本质上</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getLogicalDriveStrings%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.29.2.</span> <span class="toc-text">getLogicalDriveStrings函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-7"><span class="toc-number">1.29.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-7"><span class="toc-number">1.29.2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-7"><span class="toc-number">1.29.2.3.</span> <span class="toc-text">返回值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-4"><span class="toc-number">1.30.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FindFirstVolume-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.30.1.</span> <span class="toc-text">FindFirstVolume 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-8"><span class="toc-number">1.30.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-8"><span class="toc-number">1.30.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-8"><span class="toc-number">1.30.1.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-5"><span class="toc-number">1.30.1.4.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FindNextVolume-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.30.2.</span> <span class="toc-text">FindNextVolume 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-9"><span class="toc-number">1.30.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-9"><span class="toc-number">1.30.2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-9"><span class="toc-number">1.30.2.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-6"><span class="toc-number">1.30.2.4.</span> <span class="toc-text">注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%A9%B1%E5%8A%A8%E5%99%A8%E5%B1%9E%E6%80%A7-GetDriverType-amp-amp-GetVolumeInformation"><span class="toc-number">1.31.</span> <span class="toc-text">查看驱动器属性 GetDriverType &amp;&amp; GetVolumeInformation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extensive-Reading-for-Microsoft-API-1"><span class="toc-number">1.32.</span> <span class="toc-text">Extensive Reading for Microsoft API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getDriveType-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.32.1.</span> <span class="toc-text">getDriveType 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-10"><span class="toc-number">1.32.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-10"><span class="toc-number">1.32.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-10"><span class="toc-number">1.32.1.3.</span> <span class="toc-text">返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getVolumeInformationW-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.32.2.</span> <span class="toc-text">getVolumeInformationW 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-11"><span class="toc-number">1.32.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-11"><span class="toc-number">1.32.2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-11"><span class="toc-number">1.32.2.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-7"><span class="toc-number">1.32.2.4.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E8%A1%8C%E4%B8%BA-1"><span class="toc-number">1.32.2.5.</span> <span class="toc-text">符号链接行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C"><span class="toc-number">1.32.2.6.</span> <span class="toc-text">事务处理操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8-2"><span class="toc-number">1.32.2.6.1.</span> <span class="toc-text">备注</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F"><span class="toc-number">1.33.</span> <span class="toc-text">查看磁盘容量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetDiskFreeSpace-amp-amp-GetDiskFreeSpaceEx"><span class="toc-number">1.33.1.</span> <span class="toc-text">GetDiskFreeSpace &amp;&amp; GetDiskFreeSpaceEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getDiskFreeSpace-%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.33.2.</span> <span class="toc-text">getDiskFreeSpace 函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-12"><span class="toc-number">1.33.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-12"><span class="toc-number">1.33.2.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-12"><span class="toc-number">1.33.2.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-8"><span class="toc-number">1.33.2.4.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getDiskFreeSpaceEx%E5%87%BD%E6%95%B0-fileapi-h"><span class="toc-number">1.33.3.</span> <span class="toc-text">getDiskFreeSpaceEx函数 (fileapi.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-13"><span class="toc-number">1.33.3.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-13"><span class="toc-number">1.33.3.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-13"><span class="toc-number">1.33.3.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-9"><span class="toc-number">1.33.3.4.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ULARGE-INTEGER-union-winnt-h"><span class="toc-number">1.33.4.</span> <span class="toc-text">ULARGE_INTEGER union (winnt.h)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-14"><span class="toc-number">1.33.4.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98"><span class="toc-number">1.33.4.2.</span> <span class="toc-text">成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8-3"><span class="toc-number">1.33.4.3.</span> <span class="toc-text">备注</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.34.</span> <span class="toc-text">文件操作的四种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAMFC"><span class="toc-number">1.35.</span> <span class="toc-text">创建MFC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clear%E6%8C%89%E9%92%AE"><span class="toc-number">1.36.</span> <span class="toc-text">clear按钮</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-15"><span class="toc-number">1.36.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-14"><span class="toc-number">1.36.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-14"><span class="toc-number">1.36.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-10"><span class="toc-number">1.36.4.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%96%B9%E5%BC%8F"><span class="toc-number">1.37.</span> <span class="toc-text">C  方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E6%96%B9%E5%BC%8F-1"><span class="toc-number">1.38.</span> <span class="toc-text">C++ 方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-API"><span class="toc-number">1.39.</span> <span class="toc-text">Windows API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-MFC"><span class="toc-number">1.40.</span> <span class="toc-text">Windows MFC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Windows-API-8"><span class="toc-number">2.</span> <span class="toc-text">系统学习Windows API 8</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%AF%BC-1"><span class="toc-number">2.1.</span> <span class="toc-text">前导</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DeleteFile"><span class="toc-number">2.2.</span> <span class="toc-text">DeleteFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-16"><span class="toc-number">2.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-15"><span class="toc-number">2.2.2.</span> <span class="toc-text">参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-15"><span class="toc-number">2.3.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-11"><span class="toc-number">2.4.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyFile"><span class="toc-number">2.5.</span> <span class="toc-text">CopyFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-17"><span class="toc-number">2.5.1.</span> <span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-16"><span class="toc-number">2.6.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-16"><span class="toc-number">2.7.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-12"><span class="toc-number">2.8.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MoveFile"><span class="toc-number">2.9.</span> <span class="toc-text">MoveFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-18"><span class="toc-number">2.9.1.</span> <span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-17"><span class="toc-number">2.10.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC-17"><span class="toc-number">2.11.</span> <span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3-13"><span class="toc-number">2.12.</span> <span class="toc-text">注解</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/18/MissingClassInCS/" title="MissingClassInCS"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MissingClassInCS"/></a><div class="content"><a class="title" href="/2024/01/18/MissingClassInCS/" title="MissingClassInCS">MissingClassInCS</a><time datetime="2024-01-18T02:18:25.000Z" title="发表于 2024-01-18 10:18:25">2024-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/17/MITS6081-Notes/" title="MITS6081 Notes"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MITS6081 Notes"/></a><div class="content"><a class="title" href="/2024/01/17/MITS6081-Notes/" title="MITS6081 Notes">MITS6081 Notes</a><time datetime="2024-01-17T02:28:48.000Z" title="发表于 2024-01-17 10:28:48">2024-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/16/Cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/" title="Cpp异常处理与并发编程简单笔记"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cpp异常处理与并发编程简单笔记"/></a><div class="content"><a class="title" href="/2024/01/16/Cpp%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/" title="Cpp异常处理与并发编程简单笔记">Cpp异常处理与并发编程简单笔记</a><time datetime="2024-01-16T12:15:37.000Z" title="发表于 2024-01-16 20:15:37">2024-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/16/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-3/" title="重新学习Linux系统编程-3"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="重新学习Linux系统编程-3"/></a><div class="content"><a class="title" href="/2024/01/16/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-3/" title="重新学习Linux系统编程-3">重新学习Linux系统编程-3</a><time datetime="2024-01-16T05:17:44.000Z" title="发表于 2024-01-16 13:17:44">2024-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%A6%82%E8%AE%BA/" title="计算机网络笔记概论"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络笔记概论"/></a><div class="content"><a class="title" href="/2024/01/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%A6%82%E8%AE%BA/" title="计算机网络笔记概论">计算机网络笔记概论</a><time datetime="2024-01-16T05:17:18.000Z" title="发表于 2024-01-16 13:17:18">2024-01-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>