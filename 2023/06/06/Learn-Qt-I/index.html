<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Learn_Qt-I | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="QT开发-初探​    注意创建工程路径的时候不要不要不要整到含有中文的路径！ ​        我们下载了 QT 之后，创建信息之后，会发现有三个类： 1）QWeidge 作为父类 2）QMainWindows子类 3）QDialog子类 2，3是1的子类  ​        可以看到，有一个.pro文件，跟VS文件是一样的，他是一个工程文件！  ​        这是一个工程的目录 ​">
<meta property="og:type" content="article">
<meta property="og:title" content="Learn_Qt-I">
<meta property="og:url" content="http://charliechen114514.github.io/2023/06/06/Learn-Qt-I/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="QT开发-初探​    注意创建工程路径的时候不要不要不要整到含有中文的路径！ ​        我们下载了 QT 之后，创建信息之后，会发现有三个类： 1）QWeidge 作为父类 2）QMainWindows子类 3）QDialog子类 2，3是1的子类  ​        可以看到，有一个.pro文件，跟VS文件是一样的，他是一个工程文件！  ​        这是一个工程的目录 ​">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-06-06T14:45:12.000Z">
<meta property="article:modified_time" content="2023-06-08T07:37:57.222Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Qt">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/06/06/Learn-Qt-I/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Learn_Qt-I',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-08 15:37:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Learn_Qt-I</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-06T14:45:12.000Z" title="发表于 2023-06-06 22:45:12">2023-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-08T07:37:57.222Z" title="更新于 2023-06-08 15:37:57">2023-06-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>149分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Learn_Qt-I"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="QT开发-初探"><a href="#QT开发-初探" class="headerlink" title="QT开发-初探"></a>QT开发-初探</h1><p>​    注意创建工程路径的时候不要不要不要整到含有中文的路径！</p>
<p>​        我们下载了 QT 之后，创建信息之后，会发现有三个类：</p>
<p>1）QWeidge 作为父类</p>
<p>2）QMainWindows子类</p>
<p>3）QDialog子类</p>
<p>2，3是1的子类</p>
<p><img src="image-20230228192413374.png" alt="image-20230228192413374"></p>
<p>​        可以看到，有一个.pro文件，跟VS文件是一样的，他是一个工程文件！</p>
<p><img src="image-20230228192501749.png" alt="image-20230228192501749"></p>
<p>​        这是一个工程的目录</p>
<p>​        先看主要的显示文件：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;
#include &lt;QApplication&gt; &#x2F;&#x2F; 包含一个应用程序类的文件

&#x2F;&#x2F;argc 命令行变量的数量， *argv[] 是命令行变量的数组
int main(int argc, char *argv[])
&#123;
    &#x2F;&#x2F;应用程序对象，再QT中方，应用程序对像只有一个
    QApplication a(argc, argv);
    
    &#x2F;&#x2F;窗口对象， widget- 父类 -&gt; QWedget
    Widget w;
    &#x2F;&#x2F; 显示窗口
    w.show();

    &#x2F;&#x2F; 让应用程序对象进入消息循环
    return a.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个循环可以被类比成如下的C程序：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;conio.h&gt;
int main()
&#123;
	while(_get() &#x3D;&#x3D; &#39; &#39;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这里，是点击窗口’ X ‘来关闭！</p>
<h2 id="看看工程文件"><a href="#看看工程文件" class="headerlink" title="看看工程文件"></a>看看工程文件</h2><p>​        工程文件自身可以在QT里打开：</p>
<p><img src="image-20230228193538543.png" alt="image-20230228193538543"></p>
<p>​        点击 1.pro 文件，可以看到如下的内容</p>
<p><img src="image-20230228193615493.png" alt="image-20230228193615493"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
# <span class="token comment">//工程创建时间</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Project created by QtCreator <span class="token number">2023</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">28</span>T19<span class="token operator">:</span><span class="token number">15</span><span class="token operator">:</span><span class="token number">11</span></span></span>
#
#<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>

QT       <span class="token operator">+=</span> core gui <span class="token comment">// 包含的模块（1）</span>

<span class="token function">greaterThan</span><span class="token punctuation">(</span>QT_MAJOR_VERSION<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">:</span> QT <span class="token operator">+=</span> widgets <span class="token comment">// 大于这个版本才添加模块</span>

TARGET <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 目标 生成的.exe文件的名字（2）不满意名字可以自行更换</span>
TEMPLATE <span class="token operator">=</span> app <span class="token comment">//模板</span>

<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">The following define makes your compiler emit warnings <span class="token keyword">if</span> you use</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">any</span> <span class="token expression">feature of Qt which as been marked as <span class="token function">deprecated</span> <span class="token punctuation">(</span>the exact warnings</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">depend</span> <span class="token expression">on your compiler<span class="token punctuation">)</span><span class="token punctuation">.</span> Please consult the documentation of the</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">deprecated</span> <span class="token expression">API in order to know how to port your code away from it<span class="token punctuation">.</span></span></span>
DEFINES <span class="token operator">+=</span> QT_DEPRECATED_WARNINGS

<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">You can also make your code fail to compile <span class="token keyword">if</span> you use deprecated APIs<span class="token punctuation">.</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">In order to <span class="token keyword">do</span> so<span class="token punctuation">,</span> uncomment the following line<span class="token punctuation">.</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">You can also select to disable deprecated APIs only up to a certain version of Qt<span class="token punctuation">.</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">DEFINES <span class="token operator">+=</span> QT_DISABLE_DEPRECATED_BEFORE<span class="token operator">=</span><span class="token number">0x060000</span>    # disables all the APIs deprecated before Qt <span class="token number">6.0</span><span class="token number">.0</span></span></span>


SOURCES <span class="token operator">+=</span> \
        main<span class="token punctuation">.</span>cpp \ <span class="token comment">//源文件</span>
        widget<span class="token punctuation">.</span>cpp

HEADERS <span class="token operator">+=</span> \
        widget<span class="token punctuation">.</span>h <span class="token comment">// 头文件</span>

FORMS <span class="token operator">+=</span> \
        widget<span class="token punctuation">.</span>ui<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（1）：</p>
<p><img src="image-20230228193822499.png" alt="image-20230228193822499"></p>
<p>（2）那个exe文件在这里：打开你的工程目录，返回上级会发现：</p>
<p><img src="image-20230228194240791.png" alt="image-20230228194240791"></p>
<p>点击下面的文件夹</p>
<p><img src="image-20230228194256086.png" alt="image-20230228194256086"></p>
<p>点击 debug</p>
<p><img src="image-20230228194315627.png" alt="image-20230228194315627"></p>
<p>就在这里的 1.exe</p>
<h2 id="看看头文件和widget-cpp"><a href="#看看头文件和widget-cpp" class="headerlink" title="看看头文件和widget.cpp"></a>看看头文件和widget.cpp</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef WIDGET_H
#define WIDGET_H

#include &lt;QWidget&gt;

namespace Ui &#123;
class Widget;
&#125;

class Widget : public QWidget
&#123;
    Q_OBJECT &#x2F;&#x2F; 允许类中使用信号和槽的宏，不要轻易改动

public:
    explicit Widget(QWidget *parent &#x3D; 0);&#x2F;&#x2F; 默认构造函数
    ~Widget();

private:
    Ui::Widget *ui;
&#125;;

#endif &#x2F;&#x2F; WIDGET_H
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>​        类名：首字母大写，单词与单词之间首字母大写</p>
<p>​        函数名，变量名称：首字母小写，但单词与单词之间首字母大写</p>
<p>​        快捷键一览：</p>
<p>​        注释：ctrl + /</p>
<p>​        运行：ctrl + r</p>
<p>​        编译：ctrl + b</p>
<p>​        查找：ctrl + f</p>
<p>​        整行移动：ctrl + shift + ↑ 或者 ↓</p>
<p>​        自动对齐：ctrl + i</p>
<p>​        同名的.cpp 和 .h: F4</p>
<h2 id="创建一个按钮"><a href="#创建一个按钮" class="headerlink" title="创建一个按钮"></a>创建一个按钮</h2><p>​        我们查询帮助文档，得到这些信息</p>
<pre class="line-numbers language-none"><code class="language-none">QPushButton Class
The QPushButton widget provides a command button. More...

Header:
#include &lt;QPushButton&gt; 
qmake:
QT +&#x3D; widgets
Inherits:
QAbstractButton
Inherited By:
QCommandLinkButton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        当然要留意是什么模块，如果 pro 文件里没有，那需要我们手动添加，在</p>
<p><img src="image-20230301221926786.png" alt="image-20230301221926786"></p>
<p>​        的QT += 处 添加模块。</p>
<p>​        当然可以看看函数的功能</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">QPushButton</span><span class="token punctuation">(</span>QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span>

<span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span>

<span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token keyword">const</span> QIcon <span class="token operator">&amp;</span>icon<span class="token punctuation">,</span> <span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span>

<span class="token operator">~</span><span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

bool 
<span class="token function">autoDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>

bool 
<span class="token function">isDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>

bool 
<span class="token function">isFlat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>

QMenu <span class="token operator">*</span>
<span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>

<span class="token keyword">void</span> 
<span class="token function">setAutoDefault</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span>

<span class="token keyword">void</span> 
<span class="token function">setDefault</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span>

<span class="token keyword">void</span> 
<span class="token function">setFlat</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span>

<span class="token keyword">void</span> 
<span class="token function">setMenu</span><span class="token punctuation">(</span>QMenu <span class="token operator">*</span>menu<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        于是可以在 widget.cpp 中书写如下代码：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include&lt;QPushButton&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    QPushButton* btn &#x3D; new QPushButton;
    btn-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点

    btn-&gt;setText(&quot;hello world&quot;);
&#125;

Widget::~Widget()
&#123;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230301222534315.png" alt="image-20230301222534315"></p>
<p>​        如果我们重新设置一下窗口大小，那就</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> Height<span class="token punctuation">,</span><span class="token keyword">int</span> Width<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        但是如果我们直接创建第二个按钮，那就会覆盖第一个，那怎么办？使用 move 方法！</p>
<pre class="line-numbers language-none"><code class="language-none">btn-&gt;move(int x_pos,int y_pos)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当然啊，我们可以设置窗口的名字：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">setWindowTitle(&quot;My first windows&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        以及可以固定窗口大小：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">setFixedSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> Height<span class="token punctuation">,</span><span class="token keyword">int</span> Width<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230301223238957.png" alt="image-20230301223238957"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;
#include&lt;QPushButton&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    QPushButton* btn &#x3D; new QPushButton;
    btn-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点

    btn-&gt;setText(&quot;hello world&quot;);
    QPushButton* btn2 &#x3D; new QPushButton;
    btn2-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点
    btn2-&gt;move(100,100);
    setWindowTitle(&quot;My first Window&quot;);
    resize(600,400);
    setFixedSize(600,400);
&#125;

Widget::~Widget()
&#123;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="QT对象树"><a href="#QT对象树" class="headerlink" title="QT对象树"></a>QT对象树</h2><p>​        我们发现，程序结束后，不需要一个一个手动的释放对象，这是因为，我们调用构造函数指定了一个Parent父对象，其父对象会把我们自己搞的子对象挂到对象树上，</p>
<p><img src="image-20230411202327161.png" alt="image-20230411202327161"></p>
<p>​        （补充：一个类创建时需要调用一个函数来构造初始化这个类，这叫构造函数。当类的什么周期结束时需要调用一个删除函数，释放类占用的空间，这叫析构函数。类默认有这两个函数）于是在QT中只要指定好父对象就会帮助管理！不需要我们手动释放，很是方便</p>
<p>​        现在，我们来创建一个新类：MyPushBtn</p>
<p>​        右键工程-&gt; 添加新文件-&gt;C++ Class -&gt;选择 QWedget就好了。</p>
<p>​        随后，就发现多了一些文件</p>
<p><img src="image-20230411203853556.png" alt="image-20230411203853556"></p>
<p>​        pro文件下多了我们自己定义的类的cpp文件和头文件</p>
<p><img src="image-20230411204458973.png" alt="image-20230411204458973"></p>
<p><img src="image-20230411204545650.png" alt="image-20230411204545650"></p>
<p>​        现在我们调一下自己写的：</p>
<p><img src="image-20230411205908628.png" alt="image-20230411205908628"></p>
<p>​        可以看到我们自己的按钮产生了！</p>
<h2 id="QT-坐标系"><a href="#QT-坐标系" class="headerlink" title="QT 坐标系"></a>QT 坐标系</h2><p>​        QT的坐标原点在窗口的最左上角，这是值得注意的一点，同时：X向右增大，向左减小，而Y 向下增大，向上减小。对于嵌套窗口，则是以父窗口为例子的！</p>
<p>​        </p>
<h2 id="信号与槽的基础概念"><a href="#信号与槽的基础概念" class="headerlink" title="信号与槽的基础概念"></a>信号与槽的基础概念</h2><p>​        我们现在开始关联我们的行为和效果！比若说：我希望点击按钮后就帮我关闭窗口！于是</p>
<p><img src="image-20230412232937449.png" alt="image-20230412232937449"></p>
<p>​        这就是我们分解完后发现就是这样的，现在开始关联他们：</p>
<p>​        英语里：connect就是连接的，结合上图发现，想要表达一个链接，无非就是：</p>
<pre class="line-numbers language-none"><code class="language-none">connect(sender, sendSignal, receiver, slogAsActionReact)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        注意了：注意！我们点击按钮，不一定是去关闭窗口，而窗口关闭了不一定时我点击了按钮导致的</p>
<p>​        于是，信号槽的优点就是：松散耦合的！他们之间本来没啥关联！但是现在我们直接用connect函数来耦合在一起！</p>
<p>​        QT里，就是connect函数完成我们的工作！先来看发送者：按钮！那信号呢？</p>
<p><img src="image-20230412233514694.png" alt="image-20230412233514694"></p>
<p>​        于是找到一个信号clicked. </p>
<p><img src="image-20230412233547084.png" alt="image-20230412233547084"></p>
<p>​        所以传入一个函数的地址！&amp;QPushButton::clicked</p>
<p>​        接收者同理！：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">connect(mine, &amp;QPushButton::clicked,this,&amp;QWidget::close);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这一思想十分重要！还是需要好好消化！</p>
<p>​        现在尝试自己来书写两个类，来建立相应的关系！</p>
<p>​        现在构建程序如下：</p>
<p>​        在最大工程文件之下添加两个类！，首先是 Teacher类。 随后是学生类。假设这一场景！老师要求学生交作业！学生听到老师的要求来拿出作业，老师看到学生拿出作业之后再上前收取。这个行为我们使用 QT 的槽与信号来完成我们的实现。</p>
<p>​        选择新建两个类： Student 和 Teacher. 注意到为了能够使用 QT系统的一些性质，有必要来选择继承QT类。</p>
<p>​        当我们完成了新建，马上就发现，它同我们所想象的不太一样！</p>
<p><img src="image-20230414145816352.png" alt="image-20230414145816352"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef TEACHER_H
#define TEACHER_H

#include &lt;QObject&gt;

class Teacher : public QObject &#x2F;&#x2F; QObject 是 Teacher 的一个基类
&#123;
    Q_OBJECT &#x2F;&#x2F; 这是QObject宏，声明启用Slot - Signals关系的
public:
    explicit Teacher(QObject *parent &#x3D; nullptr);
    
    &#x2F;&#x2F; 只有在有 Q_OBJECT下才生效
signals:
	&#x2F;&#x2F; 我们在这里书写 signals 作为信号函数
public slots:
    
    &#x2F;&#x2F; 我们在这里书写 slots 作为响应信号的槽函数
&#125;;

#endif &#x2F;&#x2F; TEACHER_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意到我们在这里完成槽函数和信号函数的书写！</p>
<p>​        以及这里需要提醒的是：槽函数在这里是一个实现的占位函数，这是在底层的文件中，QT为我们实现了函数了，不要在定义实现文件里再次定义信号函数，否则会发生报错。</p>
<p>​        但是，槽函数需要实现，这是需要在实现文件里自己重写的！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void student::reactions()&#123;

	qDebug() &lt;&lt; &quot;Yep, I think I will help you!&quot;;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        书写完响应之后，我们现在可以来干活了（在Widget.cpp）</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include&quot;student.h&quot;
#include&quot;teacher.h&quot;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;

    Teacher* t &#x3D; new Teacher(this);
    student* s &#x3D; new student(this);
	
    &#x2F;&#x2F; 这里是链接信号和槽，但是这又这样是不行的，英文不是所有的这个函数都是信号，只有当我们认为指定他是信号的时候才需要出发槽函数
    connect(t,&amp;Teacher::announceHungry,s,&amp;s-&gt;reactions);
	&#x2F;&#x2F; 而emit就是声命这是这是一个信号函数且需要调用s-&gt;reactions
    emit t-&gt;announceHungry();


&#125;

Widget::~Widget()
&#123;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样，只要我们一开始运行程序，就会发现</p>
<p><img src="image-20230418202145548.png" alt="image-20230418202145548"></p>
<p>​        嗯，打印了（如果跑的是我的那个demo就是Yep, I think I will help you!）</p>
<h2 id="槽函数的重载版本"><a href="#槽函数的重载版本" class="headerlink" title="槽函数的重载版本"></a>槽函数的重载版本</h2><p>​        下面，我们进一步的探索可以重载版本的槽函数</p>
<p>​        以上一小节的场景为例子，加上槽函数的重载版本！</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; in .h

slots:
	void reactions(QString s); 

&#x2F;&#x2F; .cpp

void student::reactions(QSrting s)&#123;
	qDebug() &lt;&lt; &quot;yep, I think it is&quot; &lt;&lt; s;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，注释掉原先的emit 就可以发现智能提示上函数有重载版本！</p>
<p>​        但是，当我们直接单击运行的时候，QT报错了！原因很简单！QT不知道你要那个回应！于是，我们转向传专门到具体的函数的指针！也就是直接传重载版本的函数指针！</p>
<p>​        但是，我们的信号来源信息是需要从信号函数那里来的，于是还要重载Signal函数</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//.h</span>

signal<span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">announceHungry</span><span class="token punctuation">(</span>QString s<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// .cpp</span>
<span class="token keyword">void</span> <span class="token class-name">Teacher</span><span class="token double-colon punctuation">::</span><span class="token function">announceHungry</span><span class="token punctuation">(</span>QString s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 仍然不实现！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，告诉引发的信号是来自：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">emit t<span class="token operator">-></span><span class="token function">announceHungry</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从这里编译器判断函数类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span class="token punctuation">;</span>
<span class="token function">connect</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>StringOne<span class="token punctuation">,</span>s<span class="token punctuation">,</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230418210445433.png" alt="image-20230418210445433"></p>
<h2 id="令人恼火的是："><a href="#令人恼火的是：" class="headerlink" title="令人恼火的是："></a>令人恼火的是：</h2><p>​        马上强迫症发现了：不对啊，我们的111不应该打印“” 啊！，这是因为类型是QString导致的，这个时候只要我们进行转化就好了</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">toUtf8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
<span class="token comment">// QString -> ByteArray -> const char*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230418211415114.png" alt="image-20230418211415114"></p>
<h2 id="高级一点的信号与槽"><a href="#高级一点的信号与槽" class="headerlink" title="高级一点的信号与槽"></a>高级一点的信号与槽</h2><p>​        现在，让我们点击按钮，连续的触发事件来让样例复杂起来。</p>
<p>​        信号与槽的一个重要的要求就是信号和槽的函数的参数必须一致(有参的信号和QPushButton的clicked信号的参数不匹配就会编译报错)，于是，包装一个Emit函数</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Widget::Emit()
&#123;
	&#x2F;&#x2F; 预先在Widget里添加成员t，并且初始化
	Emit t-&gt;announcement(&quot;111&quot;)

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，开始关联：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QPushButton<span class="token operator">*</span> btn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"Press me"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
btn<span class="token operator">-></span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">connect</span><span class="token punctuation">(</span>btn<span class="token punctuation">,</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>Widget<span class="token double-colon punctuation">::</span>Emit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span class="token punctuation">;</span>
<span class="token function">connect</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>StringOne<span class="token punctuation">,</span>s<span class="token punctuation">,</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230418213636339.png" alt="image-20230418213636339"></p>
<p>​        对了，信号也可以来连接信号，就是：</p>
<p><img src="image-20230418214613353.png" alt="image-20230418214613353"></p>
<p><img src="image-20230418214631458.png" alt="image-20230418214631458"></p>
<h2 id="断开链接"><a href="#断开链接" class="headerlink" title="断开链接"></a>断开链接</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">disconnect</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>signalF<span class="token punctuation">,</span>sloter<span class="token punctuation">,</span>slotF<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>复习一下：</p>
<p>​        1）信号可以链接信号</p>
<p>​        2）一个信号可以链接多个槽函数</p>
<p>​        3）多个信号可以链接同一个槽函数</p>
<p>​        4）但是信号与槽函数的参数必须一一对应</p>
<p>这是我们练习生活实际是不难发现的！关于四，仔细看看！</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        可以看到必须一 一对应！</p>
<p>​        5）信号的参数个数是可以多于槽的参数，也就是说，信号携带的信息必须多余槽需要的！</p>
<pre class="line-numbers language-none"><code class="language-none">void(A::*sig)(QString,int) &#x3D; &amp;A::singals;
void(B::*slot)(QString,int) &#x3D; &amp;B::slots;(√)

void(A::*sig)(QString,int) &#x3D; &amp;A::singals;
void(B::*slot)(int，QString) &#x3D; &amp;B::slots;(×)
必须一一对应<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        而在QT4之前，我们使用SIGNAL,SLOT宏链接的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">connect(sig1,SIGNAL(signals()),slot1,SLOT(slot()))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="补充Lambda表达式"><a href="#补充Lambda表达式" class="headerlink" title="补充Lambda表达式"></a>补充Lambda表达式</h2><p>​        这是C++11的产物，我们由此创建一个匿名的函数以简化编程工作：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[capture](parameters)mutable-&gt;return-type&#123;
	
	statements

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        人话：[函数对象参数]（操作符重载函数参数）mutable-&gt;返回值{函数体实现}</p>
<h3 id="1-函数对象参数"><a href="#1-函数对象参数" class="headerlink" title="1.函数对象参数"></a>1.函数对象参数</h3><p>​        [ ]，这标志Lambda表达式的开始，不允许省略！其中，空表示没有使用任何函数对象。</p>
<p>​        [=] : 函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this），并且传递方式是值传递</p>
<p>​        [&amp;]： 函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this），并且传递方式是引用传递。</p>
<p>​        这是一个修改的demo.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[&#x3D;]()&#123;
   btn2-&gt;setText(&quot;Lol&quot;);
&#125;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        最后的（）表示的是当地声明马上调用</p>
<p>​        [this] :函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this和内部成员的变量），并且传递方式是值传递</p>
<p>​        [varName] 只认识varName，其他都看不见到，用于仅操作一个变量的匿名表达式</p>
<p><img src="image-20230419202055676.png" alt="image-20230419202055676"></p>
<p>​        当然后面的很少使用！</p>
<p>​        mutable关键字：可以修改按值传递进来的拷贝</p>
<p>​        可以观察这个代码</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QPushButton<span class="token operator">*</span> btn2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"this is a btn2"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token function">connect</span><span class="token punctuation">(</span>btn2<span class="token punctuation">,</span><span class="token operator">&amp;</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span><span class="token punctuation">&#123;</span>n<span class="token operator">=</span><span class="token number">110</span><span class="token punctuation">,</span><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
QPushButton<span class="token operator">*</span> btn3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"this is a btn3"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
btn3<span class="token operator">-></span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">connect</span><span class="token punctuation">(</span>btn3<span class="token punctuation">,</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span><span class="token punctuation">&#123;</span><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        你会发现，点击btn2之后又点击btn3，发现并没有修改n，说明确实只是更改了拷贝而已！</p>
<p>​        下面来用一下，复盘一下我们学习的知识，那就是设计一个按钮，位于图片中学附近，且点击之后可以使传入的一个值+=10，同时打印信息：From lambda’s reactions!</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);
    resize(640,480);
    btn-&gt;move(320,240);
    connect(btn,&amp;QPushButton::clicked,this,[]()&#123;qDebug()&lt;&lt;&quot;From lambda&#39;s reactions!&quot;;&#125;);
    unsigned int m &#x3D; 10;
    connect(btn,&amp;QPushButton::clicked,this,[m]()mutable&#123;m+&#x3D;10;qDebug()&lt;&lt;m;&#125;);
&#125;

Widget::~Widget()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        返回值：就是在（）后写 -&gt; type随后写实现！</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[]()-&gt;int&#123;return 1000&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int in &#x3D; 10;
  int res &#x3D; [&#x3D;]()-&gt;int&#123;return in*in;&#125;();
  qDebug() &lt;&lt; res;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        又如点击按钮关闭窗口的demo:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);
resize(640,480);
btn-&gt;move(320,240);
connect(btn,&amp;QPushButton::clicked,this,&amp;Widget::close);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        好吧，那又加一个打印log?转向Lambda就好了</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);
resize(640,480);
btn-&gt;move(320,240);
connect(btn,&amp;QPushButton::clicked,this,[this]()&#123;this-&gt;close();qDebug()&lt;&lt;&quot;Windows is closed!&quot;;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a>QMainWindow</h1><p>​        QMainWindow是一个为用户提供主窗口程序的类，它包含一个菜单栏，多个工具栏，多个铆接部件，一个状态栏和一个中心部件，是多个应用程序的基础，如文本编辑器，图片编辑器等等</p>
<p><img src="image-20230425213236864.png" alt="image-20230425213236864"></p>
<p>​        现在我们尝试创建一个QMainWindow，并运行之：</p>
<p><img src="image-20230425213429856.png" alt="image-20230425213429856"></p>
<p>​        好小！调整一下，在MainWindow里头resize一下完事！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
	resize(640,480);
&#125;

MainWindow::~MainWindow()
&#123;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230425213559077.png" alt="image-20230425213559077"></p>
<p>​        下面创建一个菜单栏，他是QMenuBar类的</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QMenuBar* bar &#x3D; menuBar();

&#x2F;&#x2F; 设置当前窗口的菜单栏

setMenuBar(bar);

&#x2F;&#x2F; 设定名称
&#x2F;&#x2F; 事实上不是这样用的，但是为了展示效果如此
bar-&gt;addMenu(&quot;文件&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230425214129151.png" alt="image-20230425214129151"></p>
<p>​        好吧，事实上是我们是使用一个菜单对象来接受之：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QMenu<span class="token operator">*</span> fileMenu <span class="token operator">=</span> bar<span class="token operator">-></span><span class="token function">addMenu</span><span class="token punctuation">(</span><span class="token string">"文件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们这样做是为了后续的其他操作！比如说，现在我们想点击它让他下拉一个菜单来，那就</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">fileMenu<span class="token operator">-></span><span class="token function">addAction</span><span class="token punctuation">(</span><span class="token string">"新建"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
<span class="token comment">//添加一个分割符</span>
fileMenu<span class="token operator">-></span><span class="token function">addSeparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
fileMenu<span class="token operator">-></span><span class="token function">addAction</span><span class="token punctuation">(</span><span class="token string">"打开"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230425214843993.png" alt="image-20230425214843993"></p>
<h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;工具栏

 QToolBar* toolBar &#x3D; new QToolBar(this);
 addToolBar(toolBar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​            这个流程为我们的窗口添加了一个工具栏</p>
<p><img src="image-20230425215242772.png" alt="image-20230425215242772"></p>
<p>​        看到有变化！是的就是我们的工具栏。</p>
<p>​        工具栏是允许有多个的！我们再仔细瞧瞧其他的add重载函数！</p>
<p>​        这个引起了我们的注意</p>
<p><img src="image-20230425215627044.png" alt="image-20230425215627044"></p>
<p>​        这个函数究竟实现了啥功能呢？把这个函数扔进QT  帮助手册里</p>
<p><img src="image-20230425215808333.png" alt="image-20230425215808333"></p>
<p>​        这个地方，点击第一个参数的类去</p>
<p><img src="image-20230425215834180.png" alt="image-20230425215834180"></p>
<p>​        很明显了！就是再说这个工具栏初始时停靠在哪里！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">addToolBar(Qt::LeftToolBarArea,toolBar);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230425215957733.png" alt="image-20230425215957733"></p>
<p>​        这是设计默认区域。总结一下</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include&lt;QMenuBar&gt;
#include&lt;QToolBar&gt;
#include&lt;QDebug&gt;

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
    &#x2F;&#x2F;重置窗口大小
    resize(640,480);


    &#x2F;&#x2F;创建菜单栏，最多只能有一个
    QMenuBar* bar&#x3D; menuBar();
    &#x2F;&#x2F;设置显示窗口为当前窗口
    setMenuBar(bar);
    &#x2F;&#x2F;菜单
    QMenu* fileMenu &#x3D; bar-&gt;addMenu(&quot;文件&quot;);

    QMenu* editMenu &#x3D; bar-&gt;addMenu(&quot;编辑&quot;);
    &#x2F;&#x2F;添加菜单项
    fileMenu-&gt;addAction(&quot;新建&quot;);
    &#x2F;&#x2F;添加分隔符
    fileMenu-&gt;addSeparator();

    fileMenu-&gt;addAction(&quot;打开&quot;);
    &#x2F;&#x2F;添加工具栏
    QToolBar* toolBar &#x3D; new QToolBar(this);
    addToolBar(Qt::LeftToolBarArea,toolBar);
    
    
&#125;

MainWindow::~MainWindow()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下面说说它只允许停靠在一个方向。我们可以查看QToolBar的成员函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; constructor
QToolBar(const QString &amp;title, QWidget *parent &#x3D; Q_NULLPTR)

QToolBar(QWidget *parent &#x3D; Q_NULLPTR)
&#x2F;&#x2F; destructor
~QToolBar()
QAction *
actionAt(const QPoint &amp;p) const
QAction *
actionAt(int x, int y) const
QAction *
addAction(const QString &amp;text)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text)
QAction *
addAction(const QString &amp;text, const QObject *receiver, const char *member)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *receiver, const char *member)
QAction *
addAction(const QString &amp;text, const QObject *receiver, PointerToMemberFunction method)
QAction *
addAction(const QString &amp;text, Functor functor)
QAction *
addAction(const QString &amp;text, const QObject *context, Functor functor)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *receiver, PointerToMemberFunction method)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, Functor functor)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *context, Functor functor)
QAction *
addSeparator()
QAction *
addWidget(QWidget *widget)
Qt::ToolBarAreas 
allowedAreas() const
void 
clear()
QSize 
iconSize() const
QAction *
insertSeparator(QAction *before)
QAction *
insertWidget(QAction *before, QWidget *widget)
bool 
isAreaAllowed(Qt::ToolBarArea area) const
bool 
isFloatable() const
bool 
isFloating() const
bool 
isMovable() const
Qt::Orientation 
orientation() const
void 
setAllowedAreas(Qt::ToolBarAreas areas)
void 
setFloatable(bool floatable)
void 
setMovable(bool movable)
void 
setOrientation(Qt::Orientation orientation)
QAction *
toggleViewAction() const
Qt::ToolButtonStyle 
toolButtonStyle() const
QWidget *
widgetForAction(QAction *action) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        看到</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool 
isAreaAllowed(Qt::ToolBarArea area) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        不正是表明停靠范围！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setAllowedAreas(Qt::RightToolBarArea|Qt::LeftToolBarArea);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        以及设置是否可以浮动：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setFloatable(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        甚至可以设置是否可以移动！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setMovable(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        下面设置内容：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;addAction(&quot;这是action 1&quot;);

toolBar-&gt;addAction(&quot;这是action2&quot;);

&#x2F;&#x2F;使用这个方法表明的是跟菜单栏是公用同一个功能的！
&#x2F;&#x2F;需要接受返回值
&#x2F;&#x2F;QAction* newAct &#x3D; fileMenu-&gt;addAction(&quot;新建&quot;);
toolBar-&gt;addAction(openAct);
&#x2F;&#x2F;其他类似
toolBar-&gt;addAction(newAct);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        工具栏也可以添加分割线：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;addSeparator();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        还可以添加控件！！！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QPushButton* btn &#x3D; new QPushButton(&quot;a btn for the toolBar&quot;,this);

toolBar-&gt;addWidget(btn);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>​        最多也只能有一个</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QStatusBar* stbar &#x3D; statusBar();

setStatusBar(stbar);

QLabel* lab &#x3D; new QLabel(&quot;a mentions&quot;,this);
&#x2F;&#x2F; QLable是Widget控件
stbar-&gt;addWidget(lab);&#x2F;&#x2F; 左侧
QLabel* lab2 &#x3D; new QLabel(&quot;2 mentions&quot;,this);
stbar-&gt;addPermanentWidget(lab2);&#x2F;&#x2F;右侧<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        也可以添加铆接部件，可以有多个</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;铆接部件（可以一大堆）
QDockWidget* dock &#x3D; new QDockWidget(this);
addDockWidget(Qt::BottomDockWidgetArea,dock);
&#x2F;&#x2F;设置中心部件.可以别让浮动窗口占据窗口
QTextEdit* edit &#x3D; new QTextEdit(this);
setCentralWidget(edit);
dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对于全局者，都是set,只能有一个，反之可以多个（add_）</p>
<p>​        回顾一下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include&lt;QMenuBar&gt;
#include&lt;QToolBar&gt;
#include&lt;QDebug&gt;
#include&lt;QPushButton&gt;
#include&lt;QStatusBar&gt;
#include&lt;QLabel&gt;
#include&lt;QDockWidget&gt;
#include&lt;QTextEdit&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
    &#x2F;&#x2F;重置窗口大小
    resize(1640,880);


    &#x2F;&#x2F;创建菜单栏，最多只能有一个
    QMenuBar* bar&#x3D; menuBar();
    &#x2F;&#x2F;设置显示窗口为当前窗口
    setMenuBar(bar);
    &#x2F;&#x2F;菜单
    QMenu* fileMenu &#x3D; bar-&gt;addMenu(&quot;文件&quot;);

    QMenu* editMenu &#x3D; bar-&gt;addMenu(&quot;编辑&quot;);
    &#x2F;&#x2F;添加菜单项
    QAction* newAct&#x3D; fileMenu-&gt;addAction(&quot;新建&quot;);
    &#x2F;&#x2F;添加分隔符
    fileMenu-&gt;addSeparator();

     QAction* openAct&#x3D; fileMenu-&gt;addAction(&quot;打开&quot;);
    &#x2F;&#x2F;添加工具栏
    QToolBar* toolBar &#x3D; new QToolBar(this);
    addToolBar(Qt::LeftToolBarArea,toolBar);
    &#x2F;&#x2F;设置允许停靠区域
    toolBar-&gt;setAllowedAreas(Qt::RightToolBarArea|Qt::LeftToolBarArea);
    &#x2F;&#x2F;设置行为
    toolBar-&gt;addAction(&quot;这是action 1&quot;);

    toolBar-&gt;addAction(&quot;这是action2&quot;);

    toolBar-&gt;addAction(openAct);

    toolBar-&gt;addSeparator();

    toolBar-&gt;addAction(newAct);
    &#x2F;&#x2F;放置控件
    QPushButton* btn &#x3D; new QPushButton(&quot;a btn for the toolBar&quot;,this);

    toolBar-&gt;addWidget(btn);

    &#x2F;&#x2F;状态栏
    QStatusBar* stbar &#x3D; statusBar();

    setStatusBar(stbar);
    &#x2F;&#x2F;加点东西
    QLabel* lab &#x3D; new QLabel(&quot;a mentions&quot;,this);
    &#x2F;&#x2F; QLable是Widget控件
    stbar-&gt;addWidget(lab);
    QLabel* lab2 &#x3D; new QLabel(&quot;2 mentions&quot;,this);
    stbar-&gt;addPermanentWidget(lab2);

    &#x2F;&#x2F;铆接部件（可以一大堆）
    QDockWidget* dock &#x3D; new QDockWidget(this);
    addDockWidget(Qt::BottomDockWidgetArea,dock);

    &#x2F;&#x2F;设置中心部件.可以别让浮动窗口占据窗口
    QTextEdit* edit &#x3D; new QTextEdit(this);
    setCentralWidget(edit);
    dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea);
&#125;

MainWindow::~MainWindow()
&#123;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="添加资源文件"><a href="#添加资源文件" class="headerlink" title="添加资源文件"></a>添加资源文件</h2><p>​        我们现在打开UI设计一栏，现在可以直接开始先设计后构建代码逻辑了</p>
<p><img src="image-20230514102111415.png" alt="image-20230514102111415"></p>
<p>​        菜单项必须必须输入英文，这是因为跟变量命名有关，可以后续改动text 值来改变显示</p>
<p><img src="image-20230514101928675.png" alt="image-20230514101928675"></p>
<p>​        其他就不多阐述了，类似的。</p>
<p>​        如何使用代码访问ui呢？会带mainwindow.cpp</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this); &#x2F;&#x2F; 类似于这样的！
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        添加一个图标吧：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;D:&#x2F;QT projects&#x2F;9&#x2F;source&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        首先先把资源放到项目目录路径下，不然肯定找不到！</p>
<p>​        如何快速的在项目中添加文件呢？先去右键项目：添加性文件，选择QT下的Qt resource files</p>
<p>​        然后，添加：会发现要求你写一个前缀，这是为了分类资源文件。可以偷懒直接写一个\</p>
<p>​        在项目中引用只需要按照格式：</p>
<pre class="line-numbers language-none"><code class="language-none">: + prefix + fileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        也即是: + 前缀加上文件名即可</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;:&#x2F;source&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p>​            可是我们的点击事件还是没有任何反应。下面使用信号与槽让他动起来</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QDialog&gt;
#include&lt;QDebug&gt;
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F; 点击新建按钮来弹出对话框

    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;
        &#x2F;&#x2F; 对话框 分类
        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）
        QDialog dlg(this);  &#x2F;&#x2F;创建一个
        dlg.exec();

        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;
    &#125;);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230516215248714.png" alt="image-20230516215248714"></p>
<p>​        出现这样的警告，说明是对话框太小了，需要调整</p>
<p><img src="image-20230516215825806.png" alt="image-20230516215825806"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QDialog&gt;
#include&lt;QDebug&gt;
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F; 点击新建按钮来弹出对话框

    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;
        &#x2F;&#x2F; 对话框 分类
        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）
        QDialog dlg(this);
        dlg.resize(100,200);
        dlg.exec();
        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;
    &#125;);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        那我们现在来看一个非模糊的：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QDialog&gt;
#include&lt;QDebug&gt;
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F; 点击新建按钮来弹出对话框

    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;
        &#x2F;&#x2F; 对话框 分类
        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）
&#x2F;&#x2F;        QDialog dlg(this);
&#x2F;&#x2F;        dlg.resize(100,200);
&#x2F;&#x2F;        dlg.exec();
        QDialog* dig &#x3D; new QDialog(this); &#x2F;&#x2F; 不可以开栈上，对象一show完就没了！
        dig-&gt;resize(100,200);
        dig-&gt;show();
        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;
    &#125;);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        为了防止用户一直点，一直创建对话框，我们可以设置关闭就删掉的属性</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">dig-&gt;setAttribute(Qt::WA_DeleteOnClose);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="消息对话框"><a href="#消息对话框" class="headerlink" title="消息对话框"></a>消息对话框</h1><h2 id="消息对话框-1"><a href="#消息对话框-1" class="headerlink" title="消息对话框"></a>消息对话框</h2><p>​        系统自己提供了大量的对话框，如：</p>
<p>​        QColorDialog                选择颜色</p>
<p>​        QFileDialog                    选择文件或者目录</p>
<p>​        QFontDialog                    选择字体</p>
<p>​        QInputDialog                允许用户输入一个值</p>
<p>​        QMessageDialog            模态对话框</p>
<p>​        QPageSetUpDialog        为打印机提供相关选项</p>
<p>​        QPrintDialog                    打印机配置</p>
<p>​        QPrintPreviewDialog        打印预览</p>
<p>​        QProcessDialog                显示操作过程</p>
<p>​        我们现在着重看看消息框是啥情况！在帮助文档下搜索QMessageBox</p>
<p><img src="image-20230519123236586.png" alt="image-20230519123236586"></p>
<p>​        下面显示之。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;

QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    ui.setupUi(this);

    QMessageBox::critical(this, &quot;critical&quot;, &quot;666&quot;);
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230519123918761.png" alt="image-20230519123918761"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;

QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    ui.setupUi(this);

    QMessageBox::information(this, &quot;information&quot;, &quot;666&quot;);
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>C++</p>
<p><img src="image-20230519124310043.png" alt="image-20230519124310043"></p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;

QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    ui.setupUi(this);

    QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;);
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230519124401064.png" alt="image-20230519124401064"></p>
<p><img src="image-20230519124448267.png" alt="image-20230519124448267"></p>
<p>​        于是可以更改参数就好了。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;,QMessageBox::Save|QMessageBox::Cancel);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230519124653246.png" alt="image-20230519124653246"></p>
<p>​        这个函数参数是这样的：</p>
<p>​        参数1：父类</p>
<p>​        参数2：标题</p>
<p>​        参数3：提示内容</p>
<p>​        参数4：按键类型</p>
<p>​        参数5：默认回车关联的按键</p>
<p>​        返回参数：用户选择</p>
<p>如：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;
#include&lt;tchar.h&gt;
QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    setLocale(QLocale::AnyLanguage);
    ui.setupUi(this);

    if (QMessageBox::Save &#x3D;&#x3D; QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;, QMessageBox::Save | QMessageBox::Cancel)) &#123;
        qDebug() &lt;&lt; &quot;you clicked the save&quot;;
    &#125;
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        想看Debug信息去项目属性那里更改一下输出为控制台即可！</p>
<p><img src="image-20230519125534877.png" alt="image-20230519125534877"></p>
<p>​        来看看其他demo:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;
#include&lt;qcolordialog.h&gt;
#include&lt;qcolor.h&gt;
QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    setLocale(QLocale::AnyLanguage);
    ui.setupUi(this);

    QColor color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));
    qDebug() &lt;&lt; &quot;r &#x3D; &quot; &lt;&lt; color.red() &lt;&lt; &quot;g &#x3D; &quot; &lt;&lt; color.green() &lt;&lt; &quot;h &#x3D; &quot; &lt;&lt; color.blue() ;
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230519125944025.png" alt="image-20230519125944025"></p>
<p><img src="image-20230519125950425.png" alt="image-20230519125950425"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;
#include&lt;qcolordialog.h&gt;
#include&lt;qcolor.h&gt;
#include&lt;qfile.h&gt;
#include&lt;qfiledialog.h&gt;
QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    setLocale(QLocale::AnyLanguage);
    ui.setupUi(this);

    &#x2F;*QColor color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));
    qDebug() &lt;&lt; &quot;r &#x3D; &quot; &lt;&lt; color.red() &lt;&lt; &quot;g &#x3D; &quot; &lt;&lt; color.green() &lt;&lt; &quot;h &#x3D; &quot; &lt;&lt; color.blue() ;*&#x2F;

&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;
    QFileDialog::getOpenFileName(

        this,&#x2F;&#x2F; 设置父亲
        &quot;open the file&quot;, &#x2F;&#x2F; caption
        &#x2F;&#x2F;目录
        &quot;D:\\&quot;&#x2F;&#x2F;文件夹
        &quot;(*.txt)&quot;&#x2F;&#x2F;过滤器，回忆Linux通配符就好了！
    );

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230519130333549.png" alt="image-20230519130333549"></p>
<p>​        返回的是文件的路径！这个可以注意一下！</p>
<h2 id="登录窗口界面布局介绍"><a href="#登录窗口界面布局介绍" class="headerlink" title="登录窗口界面布局介绍"></a>登录窗口界面布局介绍</h2><p>​        现在使用Widget控件把一些模块分类装之，随后垂直布局，就是这样</p>
<p><img src="image-20230519131530620.png" alt="image-20230519131530620"></p>
<h2 id="QListWidget空间"><a href="#QListWidget空间" class="headerlink" title="QListWidget空间"></a>QListWidget空间</h2><p><img src="image-20230523200845020.png" alt="image-20230523200845020"></p>
<p>​        是的！从这里拖一个QListWidget控件出来！</p>
<p><img src="image-20230523201158972.png" alt="image-20230523201158972"></p>
<p>​        代码里如上图所示，运行：</p>
<p><img src="image-20230523201220072.png" alt="image-20230523201220072"></p>
<p>​        也可以使用类似于list的容器放置一大堆内容：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include &lt;QListWidgetItem&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    QListWidgetItem* item &#x3D; new QListWidgetItem(&quot;锄禾日当午&quot;);

    ui-&gt;listWidget-&gt;addItem(item);

    item-&gt;setTextAlignment(Qt::AlignHCenter);

    &#x2F;&#x2F; QStringList      List&lt;String&gt;
    QStringList list;
    list &lt;&lt; &quot;锄禾日当午&quot;&lt;&lt;&quot;汗&quot;;
    ui-&gt;listWidget-&gt;addItems(list);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230523201833675.png" alt="image-20230523201833675"></p>
<h3 id="QListWidget"><a href="#QListWidget" class="headerlink" title="QListWidget"></a>QListWidget</h3><p>​        下面的文段来自QT帮助助手！</p>
<pre><code>Detailed Description
</code></pre><p><img src="image-20230526191818350.png" alt="image-20230526191818350"></p>
<p>​        QListWidget is a convenience class that provides a list view similar to the one supplied by QListView, but with a classic item-based interface for adding and removing items. QListWidget uses an internal model to manage each QListWidgetItem in the list.<br>For a more flexible list view widget, use the QListView class with a standard model.<br>List widgets are constructed in the same way as other widgets:</p>
<pre class="line-numbers language-none"><code class="language-none">QListWidget *listWidget &#x3D; new QListWidget(this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        The selectionMode() of a list widget determines how many of the items in the list can be selected at the same time, and whether complex selections of items can be created. This can be set with the setSelectionMode() function.<br>There are two ways to add items to the list: they can be constructed with the list widget as their parent widget, or they can be constructed with no parent widget and added to the list later. If a list widget already exists when the items are constructed, the first method is easier to use:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">new QListWidgetItem(tr(&quot;Oak&quot;), listWidget);
new QListWidgetItem(tr(&quot;Fir&quot;), listWidget);
new QListWidgetItem(tr(&quot;Pine&quot;), listWidget);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        If you need to insert a new item into the list at a particular position, then it should be constructed without a parent widget. The insertItem() function should then be used to place it within the list. The list widget will take ownership of the item.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem *newItem &#x3D; new QListWidgetItem;
newItem-&gt;setText(itemText);
listWidget-&gt;insertItem(row, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        For multiple items, insertItems() can be used instead. The number of items in the list is found with the count() function. To remove items from the list, use takeItem().<br>​        The current item in the list can be found with currentItem(), and changed with setCurrentItem(). The user can also change the current item by navigating with the keyboard or clicking on a different item. When the current item changes, the currentItemChanged() signal is emitted with the new current item and the item that was previously current.</p>
<p>​        大致就是创建一个长得像那样链表似的一个控件！</p>
<p><img src="image-20230526192003545.png" alt="image-20230526192003545">        在QT 的 UI设计下，常常见这个控件于： List Widget下面。</p>
<p>​        我们这里不对对象名称做什么修改了！默认的情况下——</p>
<pre class="line-numbers language-none"><code class="language-none">ui -&gt; listWidget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        找到它来！</p>
<p>​        为了添加控件，我们有两种方式来进行：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 方式1
QListWidgetItem* item &#x3D; new QListWidgetItem(&quot;卢本伟牛逼&quot;);

ui-&gt;listWidget-&gt;addItem(item);

item-&gt;setTextAlignment(Qt::AlignHCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这就是一种方式——通过包装成 Item 送到Widget里去。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 方式2
QStringList list;
list &lt;&lt; &quot;卢&quot;&lt;&lt;&quot;本&quot;&lt;&lt;&quot;伪&quot;&lt;&lt;&quot;牛&quot;&lt;&lt;&quot;逼&quot;;
ui-&gt;listWidget-&gt;addItems(list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是通过传入String List 链表的方式送数据。</p>
<h2 id="1）添加条目的函数"><a href="#1）添加条目的函数" class="headerlink" title="1）添加条目的函数"></a>1）添加条目的函数</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">void</span> <span class="token class-name static-context">QListWidget</span><span class="token operator">::</span><span class="token function">addItem</span><span class="token punctuation">(</span>QListWidgetItem <span class="token operator">*</span> item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这个添加函数需要实现 new 一个 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 条目对象，然后添加到列表控件末尾，下面小节会专门讲 QListWidgetItem 类。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::addItem(const QString &amp; label)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这第二个添加函数其实更常用，因为更简便，功能是将字符串 label 添加到列表控件末尾显示，其实该函数内部会自动根据字符串 new 一个条目对象添加到列表控件。<br>如果有设置好的字符串列表，那么可以通过如下函数把多个字符串全部添加到列表控件：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::addItems(const QStringList &amp; labels)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>add<em> 函数是将条目添加到末尾，如果要将条目插入到指定行 row 位置，则使用 insert</em> 函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::insertItem(int row, QListWidgetItem * item) &#x2F;&#x2F;插入条目到第 row 行
void QListWidget::insertItem(int row, const QString &amp; label) &#x2F;&#x2F;插入字符串到第 row 行
void QListWidget::insertItems(int row, const QStringList &amp; labels) &#x2F;&#x2F;插入多个字符串到从 row 行开始的多个行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>获取列表控件里面的条目计数使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QListWidget::count() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（2）删除函数"><a href="#（2）删除函数" class="headerlink" title="（2）删除函数"></a>（2）<strong>删除函数</strong></h2><p>​        因为是基于条目的控件，所以列表控件的删除单个条目函数名字是 <strong>takeItem()</strong>：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::takeItem(int row)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        takeItem() 根据行号从列表控件移除一个条目，并返回该条目指针，如果行号不合法，返回 NULL 指针。<br>​        如果返回的是实际存在的条目，那么需要注意，返回的条目指针需要手动 delete 掉，因为列表控件不再拥有该条目，该条目<strong>不会由列表控件析构时自动删除。</strong><br>​        <strong>takeItem() 函数还有第二个用途，因为列表控件没有直接的调整条目前后顺序的函数，可以先将要调整顺序的条目移出来takeItem()，然后再调用 insertItem() 把这个条目插入到新的位置。</strong>（重点关注之）</p>
<p>​        如果要清空整个列表控件，删除之前添加的所有条目，可以调用槽函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（3）条目访问函数"><a href="#（3）条目访问函数" class="headerlink" title="（3）条目访问函数"></a>（3）<strong>条目访问函数</strong></h2><p>​        根据行号获取条目对象的指针，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::item(int row) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果已知列表控件含有的条目对象指针，反查当前行号，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QListWidget::row(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>在图形界面，如果希望根据列表控件在屏幕显示的相对坐标位置（以列表控件内部左上角为原点）来获取条目，使用如下函数：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::itemAt(const QPoint &amp; p) const

QListWidgetItem * QListWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>反过来，如果根据已知条目，获取这个条目占据的矩形区域，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QRect QListWidget::visualItemRect(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（4）当前选中条目的操作"><a href="#（4）当前选中条目的操作" class="headerlink" title="（4）当前选中条目的操作"></a>（4）<strong>当前选中条目的操作</strong></h2><p>获取列表控件当前选中条目的函数如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::currentItem() const &#x2F;&#x2F;当前选中 条目
int QListWidget::currentRow() const  &#x2F;&#x2F;当前选中的行号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果当前没有选中的条目，那么返回的指针为 NULL，返回的序号为 -1 ，代码里要注意判断返回值。</p>
<p>设置已存在的某个条目为选中状态，使用函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::setCurrentItem(QListWidgetItem * item)    &#x2F;&#x2F;设置当前选中条目为 item
void QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)
void QListWidget::setCurrentRow(int row, QItemSelectionModel::SelectionFlags command)&#x2F;&#x2F;设置当前选中行为 row
void QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        第二个和第四个设置函数有个 SelectionFlags 类型的参数 command，这个参数决定选中的方式，是要选中QItemSelectionModel::Select ，还是取消选中 QItemSelectionModel::Deselect，还有其他选中方式，等到表格控件一节再详细列出来。<br>如果当前选中的条目发生变化，会触发如下三个信号，可以根据实际用途选择合适的信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::currentItemChanged(QListWidgetItem * current, QListWidgetItem * previous)

void QListWidget::currentRowChanged(int currentRow)

void QListWidget::currentTextChanged(const QString &amp; currentText)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意参数里的指针有可能为空值，序号可能为 -1，字符串也可能是空串，一定要注意判断非法的参数值。</p>
<p>​        本章的三个控件都可以设置选中模式，比如单选模式，一次只能选中一个条目，多选模式，一次可以选中多个条目等等，详细的选中模式在放到表格控件一节讲解，因为表格 中涉及的选中模式较多，一块讲解。本节的列表控件默认情况下，选中模式为单选 。QAbstractItemView::SingleSelection，以上的 <em>current</em> 等函数都是基于默认的单选模式的。</p>
<p>​        如果需要用到多选模式，可以设置 selectionMode 属性为 QAbstractItemView::ExtendedSelection，这种扩展选中模式类似常见的文件资源管理器的选中模式，可以使用 Ctrl 或 Shift 加鼠标点击实现多选：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setSelectionMode(QAbstractItemView::SelectionMode mode)  &#x2F;&#x2F;设置选中模式
QAbstractItemView::SelectionMode    selectionMode() const     &#x2F;&#x2F;获取选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        QAbstractItemView 是本章所有控件的抽象基类，本章后面控件也有类似的选中模式设置，如果把列表控件设置成多选模式，那么可以用如下函数获取同 时选中的多个条目：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QListWidgetItem *&gt; QListWidget::selectedItems() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        不论单选还是多选模式，条目选中情况有任何变化时，会触发如下信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemSelectionChanged()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（5）条目查找和排序"><a href="#（5）条目查找和排序" class="headerlink" title="（5）条目查找和排序"></a>（5）<strong>条目查找和排序</strong></h2><p>​        如果需要根据文本查找匹配的条目，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QListWidgetItem *&gt; QListWidget::findItems(const QString &amp; text, Qt::MatchFlags flags) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        该函数第一个参数 text 是要查找的模板子串，第二个参数是匹配标志，Qt::MatchFlags 是非常通用的枚举类型，不仅可用于字符串匹配，还能用于其他类型变量的匹配，Qt::MatchFlags 包含关于查找匹配的多种方式的枚举值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Qt::MatchFlags 枚举常量</strong></th>
<th><strong>数值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::MatchExactly</td>
<td>0</td>
<td>精确匹配，执行基于 QVariant 的匹配。</td>
</tr>
<tr>
<td>Qt::MatchFixedString</td>
<td>8</td>
<td>执行基于字符串的匹配，如果不指定 MatchCaseSensitive，默认是大小写不敏感。</td>
</tr>
<tr>
<td>Qt::MatchContains</td>
<td>1</td>
<td>条目包含要查找的模板子串。</td>
</tr>
<tr>
<td>Qt::MatchStartsWith</td>
<td>2</td>
<td>条目以要查找的模板子串打头。</td>
</tr>
<tr>
<td>Qt::MatchEndsWith</td>
<td>3</td>
<td>条目以要查找的模板子串结尾。</td>
</tr>
<tr>
<td>Qt::MatchCaseSensitive</td>
<td>16</td>
<td>查找时大小写敏感。</td>
</tr>
<tr>
<td>Qt::MatchRegExp</td>
<td>4</td>
<td>根据正则表达式模板子串匹配字符串。</td>
</tr>
<tr>
<td>Qt::MatchWildcard</td>
<td>5</td>
<td>根据通配符模板子串（如 *.txt）匹配字符串。</td>
</tr>
<tr>
<td>Qt::MatchWrap</td>
<td>32</td>
<td>执行回绕查找，当查找到最后一个条目时返回到第一个的条目继续查找，直到所有的条目都检查一遍。</td>
</tr>
<tr>
<td>Qt::MatchRecursive</td>
<td>64</td>
<td>递归查找，遍历所有子条目。</td>
</tr>
</tbody>
</table>
</div>
<p>​        后面两节的表格控件和树形控件也有类似的查找函数 findItems() ，第二个匹配标志参数也是一样的类型。</p>
<p>​        列表控件的自动排序是通过 sortingEnabled 属性来控制，获取和设置函数如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool isSortingEnabled() const
void setSortingEnabled(bool enable)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        列表控件条目默认是不排序的，如果希望自动按照字典序排序，调用 setSortingEnabled(true) 即可。另外还可以手动对列表控件现有条目排序：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::sortItems(Qt::SortOrder order &#x3D; Qt::AscendingOrder)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Qt::AscendingOrder 是按升序排列，Qt::DescendingOrder 是按降序排列。</p>
<h2 id="（6）条目显示和运行时条目编辑"><a href="#（6）条目显示和运行时条目编辑" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）<strong>条目显示和运行时条目编辑</strong></h2><p>​        关于列表控件 QListWidget 和里面的条目 QListWidgetItem，需要注意条目 QListWidgetItem 仅仅是数据，不是控件或子控件，列表控件根据多个 QListWidgetItem 对象，来呈现条目里的数据，<strong>只有列表控件自己是控件实体。</strong><br>列表控件默认以自己的方式呈现条目数据，比如白底黑字的普通条目显示，如果要按照特殊的子控件来显示字符串，比如用 QLabel 对象显示条目数据，可以用如下函 数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::setItemWidget(QListWidgetItem * item, QWidget * widget)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        列表控件会同时拥有 item 数据条目和用于显示 item 的子控件 widget。注意这里的子控件 widget 只有静态显示功能，如果用按钮作为显示子控件，那么按钮是不可点击的。如果希望自己定制一个能交互操作的子条目显示控件，需要使用 QListView 并子类化 QItemDelegate 类，这些复杂的等到模型视图章节再讲。</p>
<p>​        对于本节列表控件，如果要获取 setItemWidget() 函数指定某个条目的显示子控件，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QWidget * QListWidget::itemWidget(QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果要删除上面 setItemWidget() 指定的特殊显示控件，使用函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::removeItemWidget(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        特殊的显示子控件移除后，该条目就还按照列表控件原来的普通条目显示。</p>
<p>​        <strong>如果希望在程序运行时编辑列表控件的条目，有两种方式，本小节先讲第一种（第二种是设置条目自身的特性标志），手动打开条目的文本编辑器（这个编辑器是列表控件自 带功能，与 setItemWidget 设置的显示子控件没关系）：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::openPersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>这个函数名是打开条目的持续编辑器，持续的意思是如果不调用关闭函数，该条目的编辑器会一直开启，关闭这个持续编辑器使用如下函数：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::closePersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>一般可以在检测到条目激活信号（itemActivated）时调用打开函数 openPersistentEditor() ，在当前条目变化（ currentItemChanged）时调用关闭函数 closePersistentEditor() 。</strong> 使用这一对开关持续编辑器函数涉及到编写多个信号的槽函数，使用比较麻烦，建议用后面第二小节介绍的条目标 志位和 QListWidget::editItem(QListWidgetItem * item) 实现条目的可编辑功能。</p>
<h2 id="（7）其他信号和槽函数"><a href="#（7）其他信号和槽函数" class="headerlink" title="（7）其他信号和槽函数"></a>（7）<strong>其他信号和槽函数</strong></h2><p>除了上面关于当前条目变化和选中条目变化的信号，条目还有激活、单击、双击等信号，罗列如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemActivated(QListWidgetItem * item)  &#x2F;&#x2F;激活信号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当用户点击或双击条目时，条目会被激活，具体哪些操作会激活条目，要根据操作系统设置来定，比如 Windows 一般是双击打开激活，KDE 桌面通常是单击打开激活。另外，系统的快捷键也可以激活条目，如 Windows 和 Linux X11 桌面是回车键激活，Mac OS X 是 Ctrl+0 ，一般激活信号用于开启编辑等操作。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemChanged(QListWidgetItem * item)   &#x2F;&#x2F;条目内容发生变化<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意这是条目内容变化的信号，不是选中状态变化，程序如果在运行时改变了条目文本内容，比如持续编辑器修改了文本，会触发这个信号。<br>剩下几个单击、双击、进入、按压等信号意义比较直白，不详细解释了：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemClicked(QListWidgetItem * item)   &#x2F;&#x2F;条目单击信号
void QListWidget::itemDoubleClicked(QListWidgetItem * item)  &#x2F;&#x2F;条目双击信号
void QListWidget::itemEntered(QListWidgetItem * item)  &#x2F;&#x2F;鼠标追踪时进入条目的信号，一般用不着
void QListWidget::itemPressed(QListWidgetItem * item)  &#x2F;&#x2F;鼠标按键在条目上处于按下状态时发的信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>列表控件的槽函数除了前面讲过的 clear() 槽函数用于清空所有条目，还有个比较实用的条目滚动函数，列表控件自带滚动条，当条目总数超出控件矩形能呈现的数目时，滚动条自动出现，通过滚动条支持更多的条目显示。使 用如下槽函数可 以让列表控件滚动到想显示的某个条目位置：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::scrollToItem(const QListWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第一个参数 item 就是想显示出来的条目，第二个参数是滚动显示方式，默认是 QAbstractItemView::EnsureVisible，即保证指定条目显示出来，还有其他的滚动显示方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>QAbstractItemView::ScrollHint 枚举常量</strong></th>
<th><strong>数值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>QAbstractItemView::EnsureVisible</td>
<td>0</td>
<td>滚动到指定条目能显示出来即可。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtTop</td>
<td>1</td>
<td>滚动直到将指定条目显示到可视区域的顶部。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtBottom</td>
<td>2</td>
<td>滚动直到将指定条目显示到可视区域的底部。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtCenter</td>
<td>3</td>
<td>滚动直到将指定条目显示到可视区域的中间。</td>
</tr>
</tbody>
</table>
</div>
<p>原博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kongcheng253/article/details/128615688">[QT_007]Qt学习之QListWidget控件详解_天空之城8020的博客-CSDN博客</a></p>
<h1 id="一些主要控件"><a href="#一些主要控件" class="headerlink" title="一些主要控件"></a>一些主要控件</h1><h2 id="主要控件"><a href="#主要控件" class="headerlink" title="主要控件"></a>主要控件</h2><h3 id="QTreeWidget"><a href="#QTreeWidget" class="headerlink" title="QTreeWidget"></a>QTreeWidget</h3><pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        The QTreeWidget class is a convenience class that provides a standard tree widget with a classic item-based interface similar to that used by the QListView class in Qt 3. This class is based on Qt’s Model/View architecture and uses a default model to hold items, each of which is a QTreeWidgetItem.<br>​        Developers who do not need the flexibility of the Model/View framework can use this class to create simple hierarchical lists very easily. A more flexible approach involves combining a QTreeView with a standard item model. This allows the storage of data to be separated from its representation.<br>​        In its simplest form, a tree widget can be constructed in the following way:</p>
<pre class="line-numbers language-none"><code class="language-none">QTreeWidget *treeWidget &#x3D; new QTreeWidget();
treeWidget-&gt;setColumnCount(1);
QList&lt;QTreeWidgetItem *&gt; items;
for (int i &#x3D; 0; i &lt; 10; ++i)
&#123; 
	items.append(new QTreeWidgetItem(static_cast&lt;QTreeWidget *&gt;\		(nullptr), 
	QStringList(QString(&quot;item: %1&quot;).arg(i))));
&#125;
 treeWidget-&gt;insertTopLevelItems(0, items);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        Before items can be added to the tree widget, the number of columns must be set with setColumnCount(). This allows each item to have one or more labels or other decorations. The number of columns in use can be found with the columnCount() function.<br>The tree can have a header that contains a section for each column in the widget. It is easiest to set up the labels for each section by supplying a list of strings with setHeaderLabels(), but a custom header can be constructed with a QTreeWidgetItem and inserted into the tree with the setHeaderItem() function.<br>​        The items in the tree can be sorted by column according to a predefined sort order. If sorting is enabled, the user can sort the items by clicking on a column header. Sorting can be enabled or disabled by calling setSortingEnabled(). The isSortingEnabled() function indicates whether sorting is enabled.</p>
<p>原博客：</p>
<p>​        <a target="_blank" rel="noopener" href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p>
<p>​        树形控件的节点可以有多层、多个子节点， 如果将子节点全部展开，那么每一行都是一个数据条目。<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QTreeWidgetItem&amp;spm=1001.2101.3001.7020">QTreeWidgetItem</a> 比较特殊，一个条目内部可以有多列数据信息，相当于表格控件一整行的表格单元集成为一个条目，所以树形条目要比前面两节的列表条目和表格条目都复杂。树形控件每行的条目之间可以是兄弟关系或父子关系，含有子节点的条目可以折叠也可以展开，进行遍历时有专门的迭代器 QTreeWidgetItemIterator 实现，也可以自行编写<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=递归算法&amp;spm=1001.2101.3001.7020">递归算法</a>遍历所有条目。</p>
<h3 id="8-3-1-QTreeWidget"><a href="#8-3-1-QTreeWidget" class="headerlink" title="8.3.1 QTreeWidget"></a>8.3.1 QTreeWidget</h3><p>在 Qt 设计师界面可以直接拖动树形控件到窗口里，下图展示树形控件的外观和构成：</p>
<p><img src="1.png" alt="f1ce3ab52d8fb8ed2698fa14a9ddb2b0.png"></p>
<p> 默认情况下，树形控件<strong>最上面是一个树头条目</strong>，<strong><em>\</em>树头条目也是 QTreeWidgetItem 对象**</strong>，可以有<strong>多列内容</strong>。<br>树头下面是真正的树形控件所有条目，在折叠的情况下，如上图所示，每行一个顶级条目，顶级条目也是 QTreeWidgetItem 对象，<strong>顶级条目的父节点指针 QTreeWidgetItem::parent() 为 NULL</strong>。<br>将所有节点展开之后，可以看到每个节点可以有多个子节点：</p>
<p><img src="2d11f9ba73fbaed337db73e2e141f4e7.png" alt="2d11f9ba73fbaed337db73e2e141f4e7.png"></p>
<p>对于包含子节点的父节点，左边会有小的三角形指示器，用于控制折叠或展开父节点。子节点也可以拥有更低级别的子节点（孙节点），以此类推，树形控件没 有限定子节点 的层数。顶级节点和其子孙节点的数据结构一样，都可以有多列数据，只是添加的函数、父节点指针不一样。下面介绍树形控件的函数和功能。</p>
<h3 id="（0）树形控件的构造函数很简单："><a href="#（0）树形控件的构造函数很简单：" class="headerlink" title="（0）树形控件的构造函数很简单："></a>（0）树形控件的构造函数很简单：</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidget(QWidget * parent &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里只有指定父窗口或父控件的指针 parent 。树形控件在添加条目之前，必须要先设置列数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setColumnCount(int columns) &#x2F;&#x2F;设置列数
int columnCount() const &#x2F;&#x2F;获取列数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>默认的列数是 1 列</strong>，如果涉及到多列数据，比如文件浏览树，有文件名、文件类型、大小、修改时间等等，就需要设置为多列数据的树。<br>树形控件设置好列数就可以添加相应的顶级条目，添加顶级条目是由树形控件自身的函数实现，而子条目则由 QTreeWidgetItem 的函数实现。本小节主要围绕树形控件和其基类的函数来讲，<strong>树形控件也可以设置和表格控件类似的表头，这里称为树头条目</strong>。</p>
<h3 id="（1）添加和访问顶级条目"><a href="#（1）添加和访问顶级条目" class="headerlink" title="（1）添加和访问顶级条目"></a>（1）添加和访问顶级条目</h3><p>树形控件顶级条目的操作比较类似 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidget&amp;spm=1001.2101.3001.7020">QListWidget</a> 的列表条目操作函数。新建条目之后，可以用如下函数把条目添加到树形控件的顶级条目<strong>列表末尾</strong>：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::addTopLevelItem(QTreeWidgetItem * item) &#x2F;&#x2F;添加一个顶级条目到末尾
void QTreeWidget::addTopLevelItems(const QList&lt;QTreeWidgetItem *&gt; &amp; items) &#x2F;&#x2F;添加多个顶级条目到末尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        如果希望将条目插入到指定顶级条目列表的 index 序号位置，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::insertTopLevelItem(int index, QTreeWidgetItem * item)
void QTreeWidget::insertTopLevelItems(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; items)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>树形控件所有的顶级条目父节点指针都为 NULL</strong> （父节点是指树形层次中的节点关系，<strong>而条目的父控件依然是树形控件本身</strong>）。<br>​        添加了顶级条目之后，可以对顶级条目进行计数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::topLevelItemCount() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（2）移除顶级条目"><a href="#（2）移除顶级条目" class="headerlink" title="（2）移除顶级条目"></a>（2）移除顶级条目</h3><p>​        移除顶级条目的函数也是take*打头：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::takeTopLevelItem(int index)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        index是顶级条目的序号，<strong>该函数只是从树形控件卸下顶级条目，但不会删除条目的内存空间，如果希望彻底删除，那么手动 delete 该函数返回的条目。</strong><br>如果要清空所有的顶级条目和子条目，使用槽函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（3）条目访问函数-1"><a href="#（3）条目访问函数-1" class="headerlink" title="（3）条目访问函数"></a>（3）条目访问函数</h3><p>​        对于顶级条目，如果知道顶级条目的序号获取对应的条目：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::topLevelItem(int index) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        反过来，对于已知顶级条目对象，查看其顶级序号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::indexOfTopLevelItem(QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果条目不是顶级条目或者条目不属于该控件，那么会返回 -1。<br>​        树形控件实际运行时，可能既有顶级条目，也有展开后的子孙条目同时显示，<strong>所以某个条目上面或下面的相邻条目不一定是同级别的兄弟条目，有可能是叔辈祖 辈的条目，也 可能是子辈孙辈条目。</strong>获取某个条目的相邻条目函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::itemAbove(const QTreeWidgetItem * item) const &#x2F;&#x2F;上面相邻条目
QTreeWidgetItem * QTreeWidget::itemBelow(const QTreeWidgetItem * item) const &#x2F;&#x2F;下面相邻条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        从屏幕控件显示角度，如果根据树形控件<strong>内部相对坐标</strong>获取条目（树形控件显示区域的左上角为原点），使用下面函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::itemAt(const QPoint &amp; p) const
QTreeWidgetItem * QTreeWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这两个函数是一个意思，一<strong>个用 QPoint 对象表示相对坐标，另一个直接用 x 和 y 数值表示坐标，如果对应坐标没有条目，会返回</strong> <strong>NULL</strong>，注意判断 返回值。<br>​        树形控件也是自带滚动条的，如果条目特别多，自动显示滚动条，对于树形控件在屏幕可见的条目，可以根据条目对象获取它的<strong>可视矩形</strong>（树形控件显示区域的 左上角为原 点）：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QRect QTreeWidget::visualItemRect(const QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（4）当前条目的操作"><a href="#（4）当前条目的操作" class="headerlink" title="（4）当前条目的操作"></a>（4）当前条目的操作</h3><p>​        树形控件的选中操作默认比较像 QListWidget，如果不手动设置，<strong>只能选中一个高亮条目</strong>。<br>获取当前高亮选中条目的函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::currentItem() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        树形控件可以有多列，当前条目被点击选中的列号为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::currentColumn() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        树形控件内的条目一般都没有固定行号，<strong>因为条目可以展开也可以折叠，行号是变化的，所以没有基于行号的操作函数。</strong></p>
<p>​        如果要设置某个条目为当前选中的状态：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setCurrentItem(QTreeWidgetItem * item)
void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column)
void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        第一个 setCurrentItem() 函数相当<strong>于设置该条目整行高亮选中</strong>，第二个是设置该条目行的 column <strong>列高亮选中</strong>，第三个函数是<strong>单次选中命令</strong>，参考“8.2.4 选中区域和选中行为”的单次选中命令内容，<strong>只是树形控件是一整行为一个条目，定位到条目的某列数据，就 类似指定表格控件的单元格。</strong><br>如果当前高亮选中的状态发生变化，会触发如下信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::currentItemChanged(QTreeWidgetItem * current, QTreeWidgetItem * previous)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里分别是当前高亮选中的条目，和之前高亮选中的条目，注意指针可能是 NULL，使用指针前一定要判断指针非空</p>
<h3 id="（5）条目查找和排序-1"><a href="#（5）条目查找和排序-1" class="headerlink" title="（5）条目查找和排序"></a>（5）条目查找和排序</h3><p>​        如果要根据模板子串查找某列文本匹配的条目，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QTreeWidgetItem *&gt; QTreeWidget::findItems(const QString &amp; text, Qt::MatchFlags flags, int column &#x3D; 0) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里text是模板子串，flags是匹配标志（参看“8.1.1 QListWidget”中的字符串匹配标志表格），第三个参数是指定查找的列。<strong>该函数只查找一列的文本，其他列的文本是不查找的</strong>。如果需要查找所有列数据，那么要根据不同列号逐列查询。</p>
<p>​        类似表格控件，树形控件也可以按照列的文本进行自动排序，自动排序的设置函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool    isSortingEnabled() const          &#x2F;&#x2F;设置是否自动排序
void    setSortingEnabled(bool enable)   &#x2F;&#x2F;查看是否开启自动排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        指定排序的列号和升序降序，使用从基类继承的函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeView::sortByColumn(int column, Qt::SortOrder order)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>在没有开启自动排序的情况下，也可以调用该函数进行一次性的条目排序。</strong></p>
<h3 id="（6）条目显示和运行时条目编辑-1"><a href="#（6）条目显示和运行时条目编辑-1" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）条目显示和运行时条目编辑</h3><p>​        可以为条目的某列“单元格”设置单独的控件来静态显示（控件不具有编辑功能）：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setItemWidget(QTreeWidgetItem * item, int column, QWidget * widget) &#x2F;&#x2F;设置条目列控件
QWidget * QTreeWidget::itemWidget(QTreeWidgetItem * item, int column) const &#x2F;&#x2F;获取条目列控件，不设置就是NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        注意该函数只能在条目添加到树形控件之后*<em>才能调用，否则无效，\并且条目列控件只能用于显示，无法编辑，如果要定制可编辑的“单元格”控件，必须用基类 QTreeView 并继承 QItemDelegate 做代理，这些内容到后面模型视图章节讲解<br>​        再次强调：itemWidget 条目控件，在默认情况下是与条目本身数据完全无关的，是条目数据的替换品，而不是协作模式。<strong>只有手动设置信号与槽，它们才可能关联上。</strong><br>QListWidget 和 QTreeWidget 的条目控件<strong>都是静态显示，不能编辑。</strong><br>​        QTreeWidget 控件的条目列控件 widget 还必须把默认是透明背景<em>*，</em></em>这样控件的内容和内部模型数据（就是条目的列数据）同时显示，文本会重影，效果就糟糕了。<br>删除条目的列控件使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::removeItemWidget(QTreeWidgetItem * item, int column)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>这个函数没有返回值，会自动地彻底删除条目列控件。</strong></p>
<p>​        在大多数情况下都用不到 itemWidget ，因为能够为条目设置可编辑标志位，然后调用如下函数开启树形控件自带的文本编辑器：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::editItem(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数 item 是指定的条目，column 是条目的列（类似“单元格”）。在没有为条目设置可编辑标志位的情况下，可以调用下面一对函数进行持续编辑器的开启和关闭：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::openPersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)
void QTreeWidget::closePersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>注意这对函数一开一关，要成对调用，否则编辑完了不会自动关闭持续编辑器。</strong></p>
<h3 id="（7）信号"><a href="#（7）信号" class="headerlink" title="（7）信号"></a>（7）信号</h3><p>​        关于当前高亮选中变化的信号 currentItemChanged() 前面讲过了，这里先列几个常规的信号，然后再将树形控件独有的信号。常规信号就是下面这 几个：（条目列就类似表格控件的单元格）</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void itemActivated(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被激活
void itemChanged(QTreeWidgetItem * item, int column)   &#x2F;&#x2F;条目列的数据发生变化，比如文本或图标修改了
void itemClicked(QTreeWidgetItem * item, int column)  &#x2F;&#x2F;条目列被单击
void itemDoubleClicked(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被双击
void itemEntered(QTreeWidgetItem * item, int column) &#x2F;&#x2F;进入条目列
void itemPressed(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被点 击按下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>树形控件最独特的就是展开和折叠信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::itemExpanded(QTreeWidgetItem * item)  &#x2F;&#x2F;条目展开时发送信号
void QTreeWidget::itemCollapsed(QTreeWidgetItem * item) &#x2F;&#x2F;条目折叠时发送信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        如果调用槽函数 expandAll() 展开所有子孙条目，那么不会触发 itemExpanded() 信号，因为触发太多会非常影响性能。<br>​        类似地，如果用槽函数 collapseAll() 折叠所有子孙条目，也不会触发 itemCollapsed() 信号，以免影响性能。<br>举例来说，在文件夹浏览的时候，因为操作系统里的文件太多，没法一次性构建完整的文件树，那么就可以用展开和折叠信号实时枚举某一层次文件夹的内容， 而不是一次性 枚举文件系统所有文件，因为一次性枚举所有文件的性能太糟糕。<br>树形控件还有一个 <strong>itemSelectionChanged</strong>() 信号，一般在多选模式才会用到，稍后讲解。</p>
<h3 id="（8）槽函数"><a href="#（8）槽函数" class="headerlink" title="（8）槽函数"></a>（8）槽函数</h3><p>​        树形控件的槽函数包括四个（基类的另算）：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void clear() &#x2F;&#x2F;清空整个树形控件
void collapseItem(const QTreeWidgetItem * item) &#x2F;&#x2F;折叠指定的条目
void expandItem(const QTreeWidgetItem * item)  &#x2F;&#x2F;展开指定 条目
void scrollToItem(const QTreeWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible) &#x2F;&#x2F;滚动到指定条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        滚动函数 scrollToItem() 第二个参数是<strong><em>\</em>滚到到该条目的显示方式**</strong>，参考“8.1.1 QListWidget”QAbstractItemView::  ScrollHint 枚举常量的表格。</p>
<h3 id="（9）基类-QTreeView-的函数"><a href="#（9）基类-QTreeView-的函数" class="headerlink" title="（9）基类 QTreeView 的函数"></a>（9）基类 QTreeView 的函数</h3><p>QTreeView 的功能函数也很多，这里列举几个可能常用的，详细的内容等到模型视图章节讲解。关于列隐藏或显示、设置列宽的函数如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeView::setColumnHidden(int column, bool hide) &#x2F;&#x2F;设置列隐藏或显示
bool QTreeView::isColumnHidden(int column) const &#x2F;&#x2F;判断列是否隐藏
void QTreeView::hideColumn(int column) &#x2F;&#x2F;槽函数，隐藏指定列
void QTreeView::showColumn(int column) &#x2F;&#x2F;槽函数，显示指定列
void QTreeView::setColumnWidth(int column, int width) &#x2F;&#x2F;设置列宽
int QTreeView::columnWidth(int column) const &#x2F;&#x2F;获取指定列的宽度
void QTreeView::resizeColumnToContents(int column) &#x2F;&#x2F;槽函数，自动调整 指定列的宽度属性 
 &#x2F;&#x2F;indentation 控制显示父子节点的缩进宽度：
int indentation() const    &#x2F;&#x2F;获取父子节点的缩进宽度
void setIndentation(int i) &#x2F;&#x2F;设置缩进宽度
void resetIndentation()    &#x2F;&#x2F;重置缩进宽度为默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基类还有几个常用的折叠和展开槽函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void collapseAll() &#x2F;&#x2F;折叠所有子孙节点，这样只能看到顶级节点
void expandAll() &#x2F;&#x2F;展开所有子孙节点，完全展开的树
void expandToDepth(int depth) &#x2F;&#x2F;展开 depth 层级的子节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        expandToDepth() 函数是指一直展开，直到将第 depth 层级的子节点都展开为止。以顶级条目为第 0 层级，顶级条目的直接子节点为第 1 层级，孙子节点为第 2 层级，依次类推。<br>​        例如 expandToDepth(0) 的效果如下：</p>
<p><img src="c1f8eac3f9ec327ea98347e5abab1354.png" alt="c1f8eac3f9ec327ea98347e5abab1354.png"></p>
<p>​        如果调用 expandToDepth(1) 展开第1级的节点：</p>
<p><img src="590d3ad8a2fcae012d2240bdbe9a012c.png" alt="590d3ad8a2fcae012d2240bdbe9a012c.png"></p>
<p>​        如果把 expandToDepth() <strong>参数设置成负数，那么相当于展开无穷大级别，就是展开所有的子孙节点。</strong></p>
<h3 id="（10）树头条目"><a href="#（10）树头条目" class="headerlink" title="（10）树头条目"></a>（10）树头条目</h3><p>​        树形控件只有一个表头，就是<strong>显示在上面的水平表头，本节也叫树头条目</strong>。设置树头条目的函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setHeaderItem(QTreeWidgetItem * item) &#x2F;&#x2F;设置树头条目，树头条目可以有多列数据，相当于多列的表头一次性设置了。
void QTreeWidget::setHeaderLabel(const QString &amp; label) &#x2F;&#x2F;只设置第 0 列的表头
void QTreeWidget::setHeaderLabels(const QStringList &amp; labels) &#x2F;&#x2F;设置多列的表头
QTreeWidgetItem * QTreeWidget::headerItem() const &#x2F;&#x2F;获取树头条目
树头条目本质其实也是由 QHeaderView 子控件来显示的，可以在基类找到相关函数：
QHeaderView * QTreeView::header() const &#x2F;&#x2F;获取表头视图控件
void QTreeView::setHeader(QHeaderView * header) &#x2F;&#x2F;设置表头视图， 一般树形控件不需要用这个函数
void QTreeView::setHeaderHidden(bool hide) &#x2F;&#x2F;设置表头是否隐藏
bool QTreeView::isHeaderHidden() const &#x2F;&#x2F;判断是否隐藏了表头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        无论是 QTableWidget 还是 QTreeWidget 的表头，都是 QHeaderView 子控件显示，QHeaderView 参考“8.2.3 表头设置”的内容。</p>
<h3 id="（11）选中行为和选中模式"><a href="#（11）选中行为和选中模式" class="headerlink" title="（11）选中行为和选中模式"></a>（11）选中行为和选中模式</h3><p>​        与 QTableWidget 类似，QTreeWidget也从祖类 QAbstractItemView 继承了选中行为和选中模式的属性：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QAbstractItemView::SelectionBehavior  selectionBehavior() const &#x2F;&#x2F;获取选中行为，按条目选中、整行或整列选中
void setSelectionBehavior(QAbstractItemView::SelectionBehavior behavior) &#x2F;&#x2F;设置选中行为
QAbstractItemView::SelectionMode  selectionMode() const &#x2F;&#x2F;获取选中模式，比如单选、多选、扩展选择
void setSelectionMode(QAbstractItemView::SelectionMode mode) &#x2F;&#x2F;设置选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        关于选中模式和选中行为的枚举常量参看“8.2.4 选中区域和选中行为”小节中的枚举常量表格，单次选中命令的函数和枚举常量也参考该小节。</p>
<p>​        默认情况下，树形控件是按照整行选中，并且是单选模式，如果把选中模式改成多选的 QAbstractItemView::ExtendedSelection，那么树形控件也可以使多选的，这时候信号 itemSelectionChanged() 就能派上用场：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">void</span> <span class="token class-name static-context">QTreeWidget</span><span class="token operator">::</span><span class="token function">itemSelectionChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        多选状态变化时会触发该信号（单选模式也触发，只是不需要用这个信号），可以关联该信号，监视当前所有选中的条目：</p>
<pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">QList<span class="token operator">&lt;</span>QTreeWidgetItem <span class="token comment">*> QTreeWidget::selectedItems() const</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        注意，<strong>这里的选中条目仅仅是指实际显示的直接选中的条目，不包括折叠隐藏的子孙条目计数</strong>，因为选中父节点与选中其子孙节点没关系，不会递归选中所有子 孙：</p>
<p><img src="c216490e8c65baf4903b5093b2deddcc.png" alt="c216490e8c65baf4903b5093b2deddcc.png"></p>
<p>​        树形控件及其基类没有递归选中子条目的属性或函数，<strong>如果希望递归选中某个节点的所有子孙节点，那么需要自行编写递归函数。</strong>关于树形控件类本身的内容介 绍到这，因为 涉及到父子节点隶属关系、节点展开和折叠，树形控件还有很大一部分功能都是由其条目类 QTreeWidgetItem 的函数实现的.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QListWidgetItem&gt;
#include&lt;QStringList&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
&#123;   
    ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt;&quot;卢本伟&quot;&lt;&lt;&quot;牛逼&quot;);
	QTreeWidgetItem* item &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐&quot;);
    QTreeWidgetItem* item2 &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐2&quot;);
    ui-&gt;treeWidget-&gt;addTopLevelItem(item);
    ui-&gt;treeWidget-&gt;addTopLevelItem(item2);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230526200623971.png" alt="image-20230526200623971"></p>
<h2 id="QTableWidget"><a href="#QTableWidget" class="headerlink" title="QTableWidget"></a>QTableWidget</h2><p><img src="image-20230526200740443.png" alt="image-20230526200740443"></p>
<pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Table widgets provide standard table display facilities for applications. The items in a QTableWidget are provided by QTableWidgetItem.<br>​        If you want a table that uses your own data model you should use QTableView rather than this class.<br>​        Table widgets can be constructed with the required numbers of rows and columns:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">tableWidget &#x3D; new QTableWidget(12, 3, this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Alternatively, tables can be constructed without a given size and resized later:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">tableWidget &#x3D; new QTableWidget(this);
tableWidget-&gt;setRowCount(10);
tableWidget-&gt;setColumnCount(5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        Items are created outside the table (with no parent widget) and inserted into the table with setItem():</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem *newItem &#x3D; new QTableWidgetItem(tr(&quot;%1&quot;).arg(\
        								 (row+1)*(column+1)));
tableWidget-&gt;setItem(row, column, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        If you want to enable sorting in your table widget, do so after you have populated it with items, otherwise sorting may interfere with the insertion order (see setItem() for details).<br>Tables can be given both horizontal and vertical headers. The simplest way to create the headers is to supply a list of strings to the setHorizontalHeaderLabels() and setVerticalHeaderLabels() functions. These will provide simple textual headers for the table’s columns and rows. More sophisticated headers can be created from existing table items that are usually constructed outside the table. For example, we can construct a table item with an icon and aligned text, and use it as the header for a particular column:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem *cubesHeaderItem &#x3D; new QTableWidgetItem(tr(&quot;Cubes&quot;));
cubesHeaderItem-&gt;setIcon(QIcon(QPixmap(&quot;:&#x2F;Images&#x2F;cubed.png&quot;)));
cubesHeaderItem-&gt;setTextAlignment(Qt::AlignVCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        The number of rows in the table can be found with rowCount(), and the number of columns with columnCount(). The table can be cleared with the clear() function.</p>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>​        原博客：</p>
<p>​        <a target="_blank" rel="noopener" href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p>
<h2 id="QTableWidgetItem"><a href="#QTableWidgetItem" class="headerlink" title="QTableWidgetItem"></a>QTableWidgetItem</h2><p>​        表格控件条目 QTableWidgetItem 与 8.1.2 节 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 有很多相似的地方，<br>QTableWidgetItem 也是一个纯数据类，不是控件，没有基类，也就没有信号和槽函数。QTableWidgetItem 可以直接用数据流 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QDataStream&amp;spm=1001.2101.3001.7020">QDataStream</a> 读写，表格条目不单单有文本，还可以有自己的图标、复选框等特性，表格控件会根据条目对象的丰富特性来呈现数据并进行交互操作。</p>
<h3 id="（1）首先来看看条目的构造函数："><a href="#（1）首先来看看条目的构造函数：" class="headerlink" title="（1）首先来看看条目的构造函数："></a>（1）<strong>首先来看看条目的构造函数：</strong></h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem(int type &#x3D; Type)
QTableWidgetItem(const QString &amp; text, int type &#x3D; Type)
QTableWidgetItem(const QIcon &amp; icon, const QString &amp; text, int type &#x3D; Type)
QTableWidgetItem(const QTableWidgetItem &amp; other) &#x2F;&#x2F;复制构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        参数里的 type 一般用于派生类，指定条目独特的分类，对于普通的表格控件条目，通常用默认的数值即可。第二个构造函数是指定了条目的文本，第三个构造函数同 时指定了条目图标和文本。<br>​        在构造函数里不能直接指定所属的表格控件，因为表格控件有行号、列号所以不能简单追加到表格里，而只能用表格控件的 QTableWidget::setItem() 函数把条目设置到指定单元格里。注意一个条目只能设置给表格控件唯一的一个单元格，不能把一个条目设置给多个单元格。如果希望为多个单元格设置相似的条目数据内容，那么可 以用后面介绍的 clone() 函数制造大量新的复制体条目。<br>​        复制构造函数不会复制旧条目的 type() 类型值和tableWidget() 所属表格控件指针，条目其他的内部数据和条目标志都会复制。</p>
<h3 id="（2）复制函数和运算符函数"><a href="#（2）复制函数和运算符函数" class="headerlink" title="（2）复制函数和运算符函数"></a>（2）<strong>复制函数和运算符函数</strong></h3><p>​        除了复制构造函数，还有专门的克隆函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem * QTableWidgetItem::clone() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        克隆函数会新建一个当前条目的复制体，然后返回新复制体条目的指针，如果要构造并添加大量重复内容的条目，这个函数就比较实用。clone() 函数内部会调用复制构造函数创建新条目并返回。<br>​        条目复制还可以用等于号函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        等于号函数复制的内容与复制构造函数差不多，type() 类型值和 tableWidget() 所属表格控件指针也不复制。<br>​        还有个小于号函数，可以比较条目文本的字典序：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果希望使用更多的比较函数，可以直接用 QString 的比较函数。</p>
<h3 id="（3）QTableWidgetItem-的功能函数与内部数据"><a href="#（3）QTableWidgetItem-的功能函数与内部数据" class="headerlink" title="（3）QTableWidgetItem 的功能函数与内部数据"></a>（3）<strong>QTableWidgetItem 的功能函数与内部数据</strong></h3><p>​        QTableWidgetItem 内部的数据也大致分为两类：第一类是以数据角色形式管理的通用数据，这些数据自动参与 QDataStream 数据流的读写；第二类是非通用数据，不参与数据流读写，与 QListWidgetItem 和 QListWidget 自身特性有关。QTableWidgetItem 主要的功能函数也是围绕这两类内部数据展开的。</p>
<p>​        ● <strong>第一类：通用数据及其处理函数</strong><br>​        通用数据是以数据角色与数据变量一一对应的形式存储管理，比如设置文本 setText()、设置图标 setIcon() 等函数，其本质都是根据各自的角色调用通用设置数据的函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">virtual void setData(int role, const QVariant &amp; value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        也可以根据角色来获取各个数据变量：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">virtual QVariant data(int role) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        查看表格控件的源代码文件可以看到关于图标操作函数的源码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> QIcon <span class="token function">icon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span> 
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">qvariant_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QIcon<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DecorationRole<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">QTableWidgetItem</span><span class="token double-colon punctuation">::</span><span class="token function">setIcon</span><span class="token punctuation">(</span><span class="token keyword">const</span> QIcon <span class="token operator">&amp;</span>aicon<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">setData</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DecorationRole<span class="token punctuation">,</span> aicon<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        QTableWidgetItem 的通用数据与 QListWidgetItem 的通用数据一模一样，函数名也一样，列表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>获取函数</strong></th>
<th><strong>设置函数</strong></th>
<th><strong>数据角色</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>text()</td>
<td>setText(const QString &amp;text)</td>
<td>Qt::DisplayRole</td>
<td>条目显示的文本。</td>
</tr>
<tr>
<td>icon()</td>
<td>setIcon(const QIcon &amp;icon)</td>
<td>Qt::DecorationRole</td>
<td>条目显示的图标。</td>
</tr>
<tr>
<td>statusTip()</td>
<td>setStatusTip(const QString &amp;statusTip)</td>
<td>Qt::StatusTipRole</td>
<td>如果主界面有状态栏，鼠标悬停在该条目上时显示该状态信息到状态栏。</td>
</tr>
<tr>
<td>toolTip()</td>
<td>setToolTip(const QString &amp;toolTip)</td>
<td>Qt::ToolTipRole</td>
<td>鼠标悬停在该条目上时显示的工具提示信息。</td>
</tr>
<tr>
<td>whatsThis()</td>
<td>setWhatsThis(const QString &amp;whatsThis)</td>
<td>Qt::WhatsThisRole</td>
<td>如果主界面窗口标题栏有？帮助按钮，点击帮助按钮再点击该条目会显示该帮助信息。</td>
</tr>
<tr>
<td>font()</td>
<td>setFont(const QFont &amp;font)</td>
<td>Qt::FontRole</td>
<td>显示条目文本用的字体。</td>
</tr>
<tr>
<td>textAlignment()</td>
<td>setTextAlignment(int alignment)</td>
<td>Qt::TextAlignmentRole</td>
<td>文本的对齐方式。</td>
</tr>
<tr>
<td>backgroundColor()</td>
<td>setBackgroundColor(const QColor &amp;color)</td>
<td>Qt::BackgroundColorRole</td>
<td>文本背景色。</td>
</tr>
<tr>
<td>textColor()</td>
<td>setTextColor(const QColor &amp;color)</td>
<td>Qt::TextColorRole</td>
<td>文字颜色。</td>
</tr>
<tr>
<td>background()</td>
<td>setBackground(const QBrush &amp;brush)</td>
<td>Qt::BackgroundRole</td>
<td>条目的背景画刷。</td>
</tr>
<tr>
<td>foreground()</td>
<td>setForeground(const QBrush &amp;brush)</td>
<td>Qt::ForegroundRole</td>
<td>条目的前景画刷。</td>
</tr>
<tr>
<td>checkState()</td>
<td>setCheckState(Qt::CheckState state)</td>
<td>Qt::CheckStateRole</td>
<td>条目自带的复选框选中状态，可以是三态复选框。</td>
</tr>
<tr>
<td>sizeHint()</td>
<td>setSizeHint(const QSize &amp;size)</td>
<td>Qt::SizeHintRole</td>
<td>条目显示的建议尺寸。</td>
</tr>
</tbody>
</table>
</div>
<p>​        表格条目 QTableWidgetItem 可以直接用数据流 QDataStream 读写，是通过下面运算符重载函数实现的：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QDataStream &amp;    operator&lt;&lt;(QDataStream &amp; out, const QTableWidgetItem &amp; item)
QDataStream &amp;    operator&gt;&gt;(QDataStream &amp; in, QTableWidgetItem &amp; item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        使用 &gt;&gt; 和 &lt;&lt; 运算符进行流输入输出比较常见，当然也可以用 QTableWidgetItem 类内部的读写函数进行输入输出：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTableWidgetItem::read(QDataStream &amp; in)
void QTableWidgetItem::write(QDataStream &amp; out) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​         <strong>第二类：非通用数据及其操作函数</strong><br>表格控件的条目也是在构造函数一次性指定条目类型，然后这个类型是只读的：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTableWidgetItem::type() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        类型值一般用于派生类区分不同的条目类型，自定义的条目类型值需要大于等于 QTableWidgetItem::UserType 。<br>​        新条目通过表格控件 QTableWidget::setItem() 函数设置给表格控件之后，条<strong>目会自动保存所属的表格控件指针，</strong>可以用如下函数获取：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidget * QTableWidgetItem::tableWidget() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        程序运行时，除了可以通过表格控件的 QTableWidget::selectedItems() 获取用户选中的条目列表，每个单元格条目自身也会记录是否 被用户选中，并且能设置自身是否被选中：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool QTableWidgetItem::isSelected() const &#x2F;&#x2F;判断条目自身是否高亮选中
void QTableWidgetItem::setSelected(bool select) &#x2F;&#x2F;设置条目自身是 否被选中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>表格控件条目初始化时也有默认的标志位，并且运行时可以修改条目的特性标志：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Qt::ItemFlags QTableWidgetItem::flags() const &#x2F;&#x2F;获取特性标志位
void QTableWidgetItem::setFlags(Qt::ItemFlags flags) &#x2F;&#x2F;设置特性标志位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        QTableWidgetItem 构造<strong>时默认的标志位为</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>QT宏</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::ItemIsSelectable</td>
</tr>
<tr>
<td>Qt::ItemIsUserCheckable</td>
</tr>
<tr>
<td>Qt::ItemIsEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsDragEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsDropEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsEditable</td>
</tr>
</tbody>
</table>
</div>
<p>​        因此程序代码生成的所有表格条目默认都是可编辑的，程序运行时用户双击空的单元格时，表格控件会自动创建新条目保存用户编辑内容，这些自动创建的条目也都是可编辑的。如果希望条目是只读的，那么把标志位设置不带Qt::ItemIsEditable 的新标志位即可。</p>
<p>​        Qt::ItemFlags 所有的枚举常量在 8.1.2 节末尾有详细的表格描述，这里不重复贴了。表格条目默认就是支持复选状态的，只是默认没有显示出来，要让表格控件显示条目对应的复选框，可以用下面一句代码实现：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">item-&gt;setCheckState( Qt::Unchecked );  &#x2F;&#x2F;显示复选框<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        对于表格控件和表格条目，自带单行编辑器和复选框功能，因此不需要为单元格添加自定义的单行编辑器或复选框，如果要用到其他更多的输入控件，那才需要定制单元格。<br>​        表格控件条目与 QListWidgetItem 最大的一个区别就是表格条目既有行号，也有列号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTableWidgetItem::row() const &#x2F;&#x2F;获取行号
int QTableWidgetItem::column() const &#x2F;&#x2F;获取列号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        行号和列号也是在 QTableWidget::setItem() 函数里指定的，条目自身并不能修改行号或列号。表格控件条目与 QListWidgetItem 另一个区别是，<strong>表格控件条目没有隐藏函数，所有表格条目都是显示的（只要不被单元格控件QTableWidget::cellWidget() 遮挡）。</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;设函数列数
    ui-&gt;tableWidget-&gt;setColumnCount(3);

    &#x2F;&#x2F;设置表头
    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;&quot;姓名&quot;&lt;&lt;&quot;性别&quot;&lt;&lt;&quot;年龄&quot;);

    ui-&gt;tableWidget-&gt;setRowCount(10);
    ui-&gt;tableWidget-&gt;setItem(0,0,new QTableWidgetItem(&quot;泰勒&quot;));


&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230526202457563.png" alt="image-20230526202457563"></p>
<h2 id="其他常见的控件一览"><a href="#其他常见的控件一览" class="headerlink" title="其他常见的控件一览"></a>其他常见的控件一览</h2><h3 id="滚动条控件"><a href="#滚动条控件" class="headerlink" title="滚动条控件"></a>滚动条控件</h3><p>​        我们可以在UI界面中找到滚动条控件——Scroll Widget，将大量的控件扔到里面之后，可以得到：</p>
<p><img src="image-20230527100557180.png" alt="image-20230527100557180"></p>
<p>​        可以上下拖拽的那种！</p>
<h3 id="ToolBox"><a href="#ToolBox" class="headerlink" title="ToolBox"></a>ToolBox</h3><p>​        回忆一下，我们的ToolBox，就跟QQ的好友栏一样的</p>
<p><img src="image-20230527100815303.png" alt="image-20230527100815303"></p>
<p>​        这里的Page1 和 Page2单击一下在属性栏的CurrrentPageName里更改就好了</p>
<h3 id="Tab-Widget"><a href="#Tab-Widget" class="headerlink" title="Tab Widget"></a>Tab Widget</h3><p>​        有点像网页那样的东西!</p>
<p><img src="image-20230527101102584.png" alt="image-20230527101102584"></p>
<p>​        当然,我们切换就带上按钮就好了!,使用信号与槽即可</p>
<p><img src="image-20230527101328100.png" alt="image-20230527101328100"></p>
<p>​        等等…</p>
<h3 id="利用QLable显示图片"><a href="#利用QLable显示图片" class="headerlink" title="利用QLable显示图片"></a>利用QLable显示图片</h3><p><img src="image-20230527101714658.png" alt="image-20230527101714658"></p>
<h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><p>​                可以在工程中新建一个QT文件_自定义设计师类&gt;默认的Widget类中!设计好空间之后返回主窗口的UI, 随后点击提升为(本质是换成子对象),将之提升为设计好的Widget的名称后点击提升,运行就可看到效果</p>
<p>​        点击全局提升，下一次直接提升为.</p>
<h2 id="QEvent"><a href="#QEvent" class="headerlink" title="QEvent"></a>QEvent</h2><p>​        下面我们自己写一个Lable，来学习自定义的事件这个模块。</p>
<p>​        首先，我们选择新建一个Widget：回忆下，就是在添加新文件下面——选择QWidget类型后include进来！</p>
<p>​        先不要着急include控件到UI界面下，我们修改几个地方：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef MYLABEL_H
#define MYLABEL_H

#include &lt;QLabel&gt;

class MyLabel : public QLabel &#x2F;&#x2F; here
&#123;
    Q_OBJECT
public:
    explicit MyLabel(QWidget *parent &#x3D; nullptr);

    void enterEvent(QEnterEvent*); &#x2F;&#x2F; add this
    void leaveEvent(QEvent*); &#x2F;&#x2F;add this
signals:

&#125;;

#endif &#x2F;&#x2F; MYLABEL_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;
#include&lt;QDebug&gt;
MyLabel::MyLabel(QWidget *parent)
    : QLabel&#123;parent&#125;
&#123;

&#125;
void MyLabel::enterEvent(QEnterEvent* event)&#123;
    qDebug()&lt;&lt;&quot;111&quot;;
&#125;
void MyLabel::leaveEvent(QEvent*)&#123;
      qDebug()&lt;&lt;&quot;222&quot;;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​         然后在UI界面中添加Label控件，提升为MyLabel。现在：</p>
<p><img src="image-20230528171240039.png" alt="image-20230528171240039"></p>
<p>​        现在，进入正题——鼠标事件的改写。</p>
<p>​        我们添加如下的事件函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef MYLABEL_H
#define MYLABEL_H

#include &lt;QLabel&gt;

class MyLabel : public QLabel
&#123;
    Q_OBJECT
public:
    explicit MyLabel(QWidget *parent &#x3D; nullptr);

    void enterEvent(QEnterEvent*);
    void leaveEvent(QEvent*);

    virtual void mousePressEvent(QMouseEvent* ev);
    virtual void mouseReleaseEvent(QMouseEvent* ev);
    virtual void mouseMoveEvent(QMouseEvent* ev);
signals:

&#125;;

#endif &#x2F;&#x2F; MYLABEL_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;
#include&lt;QDebug&gt;
MyLabel::MyLabel(QWidget *parent)
    : QLabel&#123;parent&#125;
&#123;

&#125;
void MyLabel::enterEvent(QEnterEvent* event)&#123;
    qDebug()&lt;&lt;&quot;111&quot;;
&#125;
void MyLabel::leaveEvent(QEvent*)&#123;
      qDebug()&lt;&lt;&quot;222&quot;;
&#125;

void MyLabel::mousePressEvent(QMouseEvent* ev)&#123;
      qDebug()&lt;&lt;&quot;You press your mouse&quot;;
&#125;
void MyLabel::mouseReleaseEvent(QMouseEvent* ev)&#123;
      qDebug() &lt;&lt; &quot;yes, you depress the mouse&quot;;
&#125;
void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;
      qDebug() &lt;&lt; &quot;yes, you move mouse&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230528171807801.png" alt="image-20230528171807801"></p>
<p>​        我们的ev实际上就返回了所有的信息：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;
#include&lt;QDebug&gt;
#include&lt;QMouseEvent&gt;
MyLabel::MyLabel(QWidget *parent)
    : QLabel&#123;parent&#125;
&#123;

&#125;
void MyLabel::enterEvent(QEnterEvent* event)&#123;
    qDebug()&lt;&lt;&quot;111&quot;;
&#125;
void MyLabel::leaveEvent(QEvent*)&#123;
      qDebug()&lt;&lt;&quot;222&quot;;
&#125;

void MyLabel::mousePressEvent(QMouseEvent* ev)&#123;
      qDebug()&lt;&lt;&quot;You press your mouse&quot;;
&#125;
void MyLabel::mouseReleaseEvent(QMouseEvent* ev)&#123;
      qDebug() &lt;&lt; &quot;yes, you depress the mouse&quot;;
&#125;
void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;
      QString str &#x3D; QString(&quot;yes, you move mouse x &#x3D; %1 y &#x3D; %2&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()); &#x2F;&#x2F; QString的格式化
      qDebug() &lt;&lt;str;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230528172343019.png" alt="image-20230528172343019"></p>
<p>​        还有globle的，表明是相对于屏幕的为止！</p>
<p>​        如果是检测是不是：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;
    if(ev-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;
        QString str &#x3D; QString(&quot;yes, you move mouse x &#x3D; %1 y &#x3D; %2&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()); &#x2F;&#x2F; QString的格式化
      	qDebug() &lt;&lt;str;   
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Qt-Event事件详解"><a href="#Qt-Event事件详解" class="headerlink" title="Qt Event事件详解"></a>Qt Event事件详解</h2><p>​        传送门：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/48f007c2de09">https://www.jianshu.com/p/48f007c2de09</a></p>
<p>​        <strong>在与用户交互时发生</strong>。比如按下鼠标（mousePressEvent），敲击键盘（keyPressEvent）等。<br>​        <strong>系统自动发生</strong>，比如计时器事件（timerEvent）等。<br>在发生事件时（比如说上面说的按下鼠标），就会产生一个QEvent对象（这里是QMouseEvent，为QEvent的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=子类&amp;spm=1001.2101.3001.7020">子类</a>），这个QEvent对象会传给当前组件的event函数。如果当前组件没有安装事件过滤器（这个下文会提到），则会被event函数发放到相应的xxxEvent函数中（这里是mousePressEvent函数）。</p>
<p>​        Qt中所有的事件类都继承于QEvent类</p>
<p>​        这个QEvent对象会有各种各样的属性，这是由用户与界面交互时产生的。xxxEvent函数可以对其进行不同的处理（比如说是鼠标左键按下还是右键？）。查看帮助文档，可以看到QMouseEvent类有以下枚举。<br>在QtCreator中查看帮助文档<br>那么就可以在mousePressEvent中根据这个QEvent对象的这些枚举值来进行不同的处理，比如</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">myLabel</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QLabel</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">mousePressEvent</span><span class="token punctuation">(</span>QMouseEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> myLabel<span class="token double-colon punctuation">::</span><span class="token function">mousePressEvent</span><span class="token punctuation">(</span>QMouseEvent <span class="token operator">*</span>event<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>event<span class="token operator">-></span>Buttons <span class="token operator">==</span> LeftButton<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">//do sth</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>event<span class="token operator">-></span>Buttons <span class="token operator">==</span> RightButton<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">//do sth</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        可以看到，我们首先需要先创建一个自己的QLabel类，并继承于Qt的QLabel类，然后并重写相应的xxxEvent函数（这些事件处理函数都是虚函数）。</p>
<p>​        Qt程序的main函数中需要创建一个QApplication对象，然后调用exec函数。这将令程序进入一个死循环，并不断监听应用程序的事件，发生事件时就生成一个QEvent对象。这又称为事件循环。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;QApplication></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mainwindow.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    QApplication <span class="token function">app</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    MainWindow window<span class="token punctuation">;</span>
    window<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> app<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="二、事件的分发：event函数"><a href="#二、事件的分发：event函数" class="headerlink" title="二、事件的分发：event函数"></a>二、事件的分发：event函数</h3><p>​        上面提到的xxxEvent函数，称为事件处理器（event handler）。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听某个按键的按下。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myWidget<span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>QEvent <span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        <span class="token comment">//将QEvent对象转换为真正的QKeyEvent对象</span>
        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span> 
        <span class="token punctuation">&#123;</span>
            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//按照原来的流程来进行事件的分发</span>
    <span class="token keyword">return</span> <span class="token class-name">QWidget</span><span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在上面的程序中，myWidget是QWidget的子类。同样的，它的event函数是一个虚函数，带有一个QEvent类型的参数。当系统产生QEvent对象时，就会传入这个函数并调用。函数的返回值是bool类型，返回值不同有不同的意义。</p>
<p>​        如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODczOTU5OA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>​        Qt系统在处理事件时，有一种机制叫事件传播机制。也就是说，在子组件（比如说一个QButton）中发生的事件，调用了子组件的event函数之后，还会调用父组件（比如说QWidget）的event函数。event函数的返回值就用于控制这样的一个过程。</p>
<p>​        需要注意的是，重写event函数之后最好返回父类的event函数来处理其他的事件分发，不然就只能处理自己定义的事件。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myTextEdit<span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>QEvent <span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        <span class="token comment">//将QEvent对象转换为真正的QKeyEvent对象</span>
        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span> 
        <span class="token punctuation">&#123;</span>
            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//直接返回false</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在这个例子中，因为没有调用父类QTextEdit的event函数，所以只能处理Tab的情况，你再按其他按键就啥反应都没有了。同样，事件也不能进行传播。</p>
<h3 id="三、事件过滤器（Even-Filter）"><a href="#三、事件过滤器（Even-Filter）" class="headerlink" title="三、事件过滤器（Even Filter）"></a>三、事件过滤器（Even Filter）</h3><p>​        某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器（evenFilter）。</p>
<p>​        QObject有一个虚函数，原型如下</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token class-name">QObject</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> watched<span class="token punctuation">,</span> QEvent <span class="token operator">*</span> event <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件（产生的QEvent对象）。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p>
<p>​        实际使用中，我们需要对QObject组件调用installEvenFilter函数，即为组件安装过滤器，才能使用事件过滤器这个机制。这样，该组件及其子组件的事件就会被监听。这个机制的好处在于不用像重写QEvent和xxxEvent函数一样需要继承Qt的内置类。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">QObject</span><span class="token double-colon punctuation">::</span><span class="token function">installEventFilter</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> filterObj <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        下面举一个例子。MainWindow中有一个QTextEdit控件，我们拦截它的键盘按下的事件。这样处理之后，会在输出窗口打印出按下的键位，但不会在控件上显示。这表明事件已被拦截，不会去调用even函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MainWindow</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QMainWindow</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">MainWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>obj<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    QTextEdit <span class="token operator">*</span>textEdit<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
 
<span class="token class-name">MainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">MainWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    textEdit <span class="token operator">=</span> <span class="token keyword">new</span> QTextEdit<span class="token punctuation">;</span>
    <span class="token function">setCentralWidget</span><span class="token punctuation">(</span>textEdit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    textEdit<span class="token operator">-></span><span class="token function">installEventFilter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
 
<span class="token keyword">bool</span> <span class="token class-name">MainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>obj<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> textEdit<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span> 
        <span class="token punctuation">&#123;</span>
            QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"you press"</span> <span class="token operator">&lt;&lt;</span> keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//事件不再进行传播，拦截</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> 
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//继续传播</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> 
    <span class="token keyword">else</span> 
    <span class="token punctuation">&#123;</span>
        <span class="token comment">//当不确定是否继续传播时，按照父类的方法来处理</span>
        <span class="token comment">//即调用父类的evenFilter函数</span>
        <span class="token keyword">return</span> <span class="token class-name">QMainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样的，even函数能干的事情，evenFilter也能干。比如说上面的处理键盘按下Tab键。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myObject<span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>object<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> target <span class="token operator">&amp;&amp;</span> event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span> 
        <span class="token punctuation">&#123;</span>
            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>
            <span class="token comment">//拦截</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> 
        <span class="token keyword">else</span> 
        <span class="token punctuation">&#123;</span>
            <span class="token comment">//不进行拦截</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//不进行拦截</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们可以对QApplication或者QCoreApplication对象添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。这种行为会严重降低整个应用程序的事件分发效率，要看具体情况使用。</p>
<p>​        事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>Qt中使用事件机制，每一种事件对应一个事件处理器，比如：</p>
<ul>
<li>mouseEvent()</li>
<li>keyPressEvent()</li>
<li>etc…<br>发生事件时会生成一个QEvent对象，则需要even函数进行分发，来调用相应的事件处理器</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> QEvent<span class="token double-colon punctuation">::</span>MouseMove<span class="token operator">:</span>
        <span class="token function">mouseMoveEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>QMouseEvent<span class="token operator">*</span><span class="token punctuation">)</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        事件过滤器（evenFilter）可以令事件进行拦截，阻止其传播，从而实现某些功能。</p>
<p>另外，有一种一般很少使用的方法，即去重写这么一个函数</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token class-name">QCoreApplication</span><span class="token double-colon punctuation">::</span><span class="token function">notify</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> receiver<span class="token punctuation">,</span> QEvent <span class="token operator">*</span> event <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该函数原实现相当于让组件调用even函数，即receiver-&gt;event(event)。这相当于全局的事件过滤器，且不会受到多线程的限制。</p>
<p>那么，在使用Qt的事件机制时，应该按照以下思路进行</p>
<ul>
<li>重写paintEvent、mousePressEvent等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</li>
<li>重写event函数。event函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</li>
<li>在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</li>
<li>在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，但会有多线程问题。</li>
<li>重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。</li>
</ul>
<h2 id="鼠标事件（QMouseEvent）"><a href="#鼠标事件（QMouseEvent）" class="headerlink" title="鼠标事件（QMouseEvent）"></a>鼠标事件（QMouseEvent）</h2><p>传送门：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44386034/article/details/125637737">https://blog.csdn.net/qq_44386034/article/details/125637737</a></p>
<p>​        常用的鼠标事件：(本篇处理事件用的是方法一：重写鼠标事件)</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void mousePressEvent(QMouseEvent *event);           &#x2F;&#x2F;单击
void mouseReleaseEvent(QMouseEvent *event);       &#x2F;&#x2F;释放
void mouseDoubleClickEvent(QMouseEvent *event); &#x2F;&#x2F;双击
void mouseMoveEvent(QMouseEvent *event);           &#x2F;&#x2F;移动
void wheelEvent(QWheelEvent *event);                      &#x2F;&#x2F;滑轮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        鼠标事件使用的时候，加头文件：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QMouseEvent&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>重写事件框架：</p>
<pre class="line-numbers language-none"><code class="language-none">鼠标按下事件
void Widget::mousePressEvent(QMouseEvent *event)
&#123;
    &#x2F;&#x2F; 如果是鼠标左键按下   
    if(event-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;
        ···
    &#125;
    &#x2F;&#x2F; 如果是鼠标右键按下
    else if(event-&gt;button() &#x3D;&#x3D; Qt::RightButton)&#123;
       ···
    &#125;
&#125;

鼠标移动事件

void Widget::mouseMoveEvent(QMouseEvent *event)
&#123;
    &#x2F;&#x2F; 这里必须使用buttons()
    if(event-&gt;buttons() &amp; Qt::LeftButton)&#123;  &#x2F;&#x2F;进行的按位与
       ···
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        默认情况下，触发事件需要点击一下，才能触发。可设置为自动触发:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">setMouseTracking(true); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">鼠标释放事件

void Widget::mouseReleaseEvent(QMouseEvent *event)
&#123;
   ···
&#125;

鼠标双击事件

void Widget::mouseDoubleClickEvent(QMouseEvent *event)
&#123;
    &#x2F;&#x2F; 如果是鼠标左键按下
    if(event-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;
      

        ···
    &#125;

&#125;

滚轮事件

void Widget::wheelEvent(QWheelEvent *event)
&#123;
    &#x2F;&#x2F; 当滚轮远离使用者时
    if(event-&gt;delta() &gt; 0)&#123;
        ···
    &#125;else&#123;&#x2F;&#x2F;当滚轮向使用者方向旋转时
        ···
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实例演示-在label控件中，移动鼠标获取实时位置，并显示在界面上"><a href="#实例演示-在label控件中，移动鼠标获取实时位置，并显示在界面上" class="headerlink" title="实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)"></a>实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)</h3><p>​        创建mylabel类，基类设置为QLabel <img src="b63f2e133baf5913fe5393dc477bfe20.png" alt="img"></p>
<pre><code>     这里用了类似自定义控件的方法，对Mylabel类进行封装。设置基类QLabel 是为了在ui界面中提升label控件(即将label控件和Mylabel关联，提升时候必须二者基类相同)
</code></pre><p>​        在mylabel.h中声明鼠标事件</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once
#include &lt;qlabel.h&gt;

class mylabel : public QLabel
&#123;
public:
    mylabel(QWidget* parent &#x3D; 0);
    ~mylabel();
public:
    &#x2F;&#x2F;鼠标移动事件
    void mouseMoveEvent(QMouseEvent* event);
    &#x2F;&#x2F;鼠标按下事件
    void mousePressEvent(QMouseEvent* event);
    &#x2F;&#x2F;鼠标释放事件
    void mouseReleaseEvent(QMouseEvent* event);
&#125;;

在mylabel.cpp中重写事件
#include &quot;mylabel.h&quot;
#include&quot;QMouseEvent&quot;


mylabel::mylabel(QWidget* parent) :QLabel(parent)
&#123;
    
&#125;
mylabel::~mylabel()
&#123;

&#125;
&#x2F;&#x2F;鼠标移动显示坐标
void mylabel::mouseMoveEvent(QMouseEvent* event)
&#123;
    if (event-&gt;buttons() &amp; Qt::LeftButton)  &#x2F;&#x2F;进行的按位与(只有左键点击移动才满足)
    &#123; 
        QString str &#x3D; QString(&quot;Move:(X:%1,Y:%2)&quot;).arg(event-&gt;x()).arg(event-&gt;y());
         this-&gt;setText(str);
         

    &#125;

&#125;
&#x2F;&#x2F;鼠标按下显示“ok，mouse is press”
void mylabel::mousePressEvent(QMouseEvent* event)
&#123;
    setText(&quot;Ok, mouse is press&quot;);

&#125;
&#x2F;&#x2F;鼠标释放清除显示
void mylabel::mouseReleaseEvent(QMouseEvent* event)
&#123;
    setText(&quot; &quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在主函数(QTest.cpp)中声明mylabel的类对象(即声明一个mylabel类的label控件)</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;qtest.h&quot;

QTest::QTest(QWidget *parent)
    : QWidget(parent)
&#123;
    ui.setupUi(this);
    &#x2F;&#x2F;声明mylabel类的控件
    mylabel* label1 &#x3D; new mylabel(this);
    label1-&gt;setGeometry(QRect(130, 100, 271, 161));
    &#x2F;&#x2F;设置边框
    label1-&gt;setFrameShape(QFrame::Panel);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>     ![img](D:\My notebook project\Program language\C++\QT\QT new 13\2b78bd5ca82261a28798c809af0ef282.gif)
</code></pre><p>​        另外，当调用setMouseTracking(true);时(即设置鼠标状态为自动触发)，需要将鼠标移动事件的if语句去掉(因为不需要点击触发了)</p>
<p>​        修改maylabel.cpp事件：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;
#include&quot;QMouseEvent&quot;


mylabel::mylabel(QWidget* parent) :QLabel(parent)
&#123;
    &#x2F;&#x2F;设置鼠标状态(自动触发)
    setMouseTracking(true);
&#125;
mylabel::~mylabel()
&#123;

&#125;
&#x2F;&#x2F;鼠标移动显示坐标
void mylabel::mouseMoveEvent(QMouseEvent* event)
&#123;
   QString str &#x3D; QString(&quot;Move:(X:%1,Y:%2)&quot;).arg(event-&gt;x()).arg(event-&gt;y());
   this-&gt;setText(str);
&#125;
&#x2F;&#x2F;鼠标按下显示“ok，mouse is press”
void mylabel::mousePressEvent(QMouseEvent* event)
&#123;
    setText(&quot;Ok, mouse is press&quot;);

&#125;
&#x2F;&#x2F;鼠标释放清除显示
void mylabel::mouseReleaseEvent(QMouseEvent* event)
&#123;
    setText(&quot; &quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>效果展示：</p>
<p><img src="0c83943e6ee8c74e39d09db4a899b2c6.gif" alt="img"></p>
<p>​        这里用的是代码创建label控件，那么能不能用ui界面编辑然后在对label控件提升呢？</p>
<p>答案是可以的，但是需要注意的是：此处不能选择全局包含</p>
<p><img src="4cb8112d483f6e94c8fe196258871445.png" alt="img"></p>
<p> 否则会出现：</p>
<p><img src="e7df65e65f36ed436c5ec6ab7c41f417.png" alt="img"></p>
<p>​        我想其中的原因主要是因为：</p>
<p>​        本实例是新建了一个mylabel类，而不是像QT常用控件(三)——自定义控件封装 - 唯有自己强大 - 博客园 (cnblogs.com)这篇博文中直接新添加了一个设计师界面类(即包含ui .h .cpp)。当选择全局包含时，就包含了主类。</p>
<p>​        其实也有解决的办法：需要在提升界面的头文件处，将工程目录下自定义控件的地址放于此处(本篇地址：C:/Users/WFD/Desktop/QTest/QTest/mylabel.h)</p>
<p><img src="c3a41a90d53c14e6f9e28ea56aa4c497.png" alt="img"></p>
<p> 二，事件的分发：event函数<br>        上面提到的xxxEvent函数，称为事件处理器(event handler)。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听(阻塞)鼠标按下事件。</p>
<pre><code>     如果希望在事件分发之前做一些操作，就可以重写这个 event()函数了。比如我们希望阻塞鼠标按下事件，那么我们就在新建的Mylabel类中重写event()函数(该类的父类是QLabel)
</code></pre><p>在Mylabel.h中声明event事件</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;qlabel.h&quot;
class Mylabel : public QLabel
&#123;
public:
    explicit Mylabel(QWidget* parent &#x3D; 0);

    &#x2F;&#x2F;鼠标按下事件
    void mousePressEvent(QMouseEvent* event); 
    &#x2F;&#x2F;鼠标释放事件
    void mouseReleaseEvent(QMouseEvent* event);
    &#x2F;&#x2F;声明event事件
    bool event(QEvent* e);

&#125;;

在Mylabel.cpp中重写event事件。
#include &quot;Mylabel.h&quot;
#include&quot;QMouseEvent&quot;

Mylabel::Mylabel(QWidget* parent) :QLabel(parent)
&#123;

&#125;

&#x2F;&#x2F;重写鼠标按下事件
void Mylabel::mousePressEvent(QMouseEvent* event)
&#123;
    this-&gt;setText(QString(&quot;mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
&#125;
&#x2F;&#x2F;重写鼠标释放事件
void Mylabel::mouseReleaseEvent(QMouseEvent* event)
&#123;
    this-&gt;setText(&quot;mouse is release &quot;);
&#125;
&#x2F;&#x2F;重写event事件
bool Mylabel::event(QEvent* e)
&#123;
    &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截
    if (e-&gt;type()&#x3D;&#x3D;QEvent::MouseButtonPress)
    &#123;
        &#x2F;&#x2F;静态转换(将QEvent的对象转换为QMouseEvent对象)
        QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);
        this-&gt;setText(QString(&quot;event mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
        return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)
    &#125;
    return QLabel::event(e);
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <img src="06ef2891b59dcc3d4f1953b7e3404c5e.png" alt="img"></p>
<p>​        点击鼠标可以看到，触发的是event的事件(即阻塞了mousePressEvent的事件)。特别需要注意的是：在将不需要阻塞分发的时候，需要分发给父类的event函数处理。即(return QLable::event(e)；)</p>
<p>​        由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个 event()函数，通过 QEvent::type()判断不同的事件。鉴于重写 event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器(当然，也必须记得是不是应该调用父类的同名处理器)。</p>
<h3 id="三，事件过滤器-Even-Filter"><a href="#三，事件过滤器-Even-Filter" class="headerlink" title="三，事件过滤器(Even Filter)"></a>三，事件过滤器(Even Filter)</h3><p>​         某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器，该过滤器在event分发之前进行拦截。</p>
<p>事件的过滤有两个步骤：</p>
<p>​        对QObject组件安装过滤器(调用installEvenFilter函数)</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QObject::installEventFilter ( QObject * filterObj );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数filterobj 是指谁为组件安装过滤器(一般是父类)</p>
<p>​        这个函数接受一个 QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是 QObject 的一个成员函数，因此，任意 QObject 都可以作为事件过滤器(问题在于，如果你没有重写 eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤)。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。<br>我们可以向一个对象上面安装多个事件处理器 ，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。<br>​        事件过滤器的重写(evenFilter函数)</p>
<pre class="line-numbers language-none"><code class="language-none">virtual bool QObject::eventFilter ( QObject * watched, QEvent * event );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件(产生的QEvent对象)。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p>
<p>​        实例：通过事件过滤器阻塞上面代码中的鼠标按下事件</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;qtest.h&quot;
#include&quot;qmouseevent&quot;

QTest::QTest(QWidget *parent)
    : QWidget(parent)
&#123;
    ui.setupUi(this);
    &#x2F;&#x2F;第一步：给label添加过滤器
    ui.label-&gt;installEventFilter(this);


&#125;
&#x2F;&#x2F;第二步：重写过滤事件
bool QTest::eventFilter(QObject* obj, QEvent* e)
&#123;
    if (obj &#x3D;&#x3D; ui.label)
    &#123;
        &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截
        if (e-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress)
        &#123;
            QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);
            ui.label-&gt;setText(QString(&quot;eventfilter mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
            return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)
        &#125;
    &#125;
    return QWidget::eventFilter(obj, e);
&#125;

&#x2F;&#x2F;重写鼠标按下事件
void QTest::mousePressEvent(QMouseEvent* event)
&#123;
    ui.label-&gt;setText(QString(&quot;mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
&#125;

&#x2F;&#x2F;重写事件分发
bool QTest::event(QEvent* e)
&#123;
    &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截
    if (e-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress)
    &#123;
        QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);
        ui.label-&gt;setText(QString(&quot;event mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
        return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)
    &#125;
    return QWidget::event(e);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：<img src="09dd8a5f89d61fa32b9e3800fe5fff9a.png" alt="img"></p>
<p>可以看到在过滤器事件中就监听了鼠标按压(即阻塞了后面的事件分发和鼠标按压)</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>​        我们的定时器可以做到随着事件的事件流逝触发事件。</p>
<p>​        我们的办法是：添加窗口的代码，从而实现计时器。</p>
<p>​        在窗口中添加两个label:</p>
<p>​        随后改写事件：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef WIDGET_H
#define WIDGET_H

#include &lt;QWidget&gt;

QT_BEGIN_NAMESPACE
namespace Ui &#123; class Widget; &#125;
QT_END_NAMESPACE

class Widget : public QWidget
&#123;
    Q_OBJECT

public:
    Widget(QWidget *parent &#x3D; nullptr);
    ~Widget();
    void timerEvent(QTimerEvent*);

    int id1;
    int id2;
private:
    Ui::Widget *ui;
&#125;;
#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;启动定时器
    id1  &#x3D; startTimer(1000);&#x2F;&#x2F;1,间隔, 单位是毫秒

    id2 &#x3D; startTimer(2000);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;

void Widget::timerEvent(QTimerEvent* ev)&#123;
    if(ev-&gt;timerId() &#x3D;&#x3D; id1)&#123;

        static int num &#x3D; 1;
        ui-&gt;label_2-&gt;setText(QString::number(num++));

    &#125;
     if(ev-&gt;timerId() &#x3D;&#x3D; id2)
    &#123;
        static int num2 &#x3D; 1;
        ui-&gt;label_3-&gt;setText(QString::number(num2++));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意到，对于多个计时器需要接受返回ID并加之以判断才好！</p>
<h2 id="类的形式"><a href="#类的形式" class="headerlink" title="类的形式"></a>类的形式</h2><p>​        这个形式简单的多!直接一个类解决所有的问题!</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include&lt;QTimer&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;启动定时器
    id1  &#x3D; startTimer(1000);&#x2F;&#x2F;1,间隔, 单位是毫秒

    id2 &#x3D; startTimer(2000);

    QTimer* timer &#x3D; new QTimer(this);

    timer-&gt;start(500); &#x2F;&#x2F; 到0.5秒发出信号

    connect(timer,&amp;QTimer::timeout,[&#x3D;]()&#123;
        static int num &#x3D; 1;
        ui-&gt;label_4-&gt;setText(QString::number(num++));

    &#125;);

    &#x2F;&#x2F;

    connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[&#x3D;]()&#123;
        timer-&gt;stop();

    &#125;);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;

void Widget::timerEvent(QTimerEvent* ev)&#123;
    if(ev-&gt;timerId() &#x3D;&#x3D; id1)&#123;

        static int num &#x3D; 1;
        ui-&gt;label_2-&gt;setText(QString::number(num++));

    &#125;
     if(ev-&gt;timerId() &#x3D;&#x3D; id2)
    &#123;
        static int num2 &#x3D; 1;
        ui-&gt;label_3-&gt;setText(QString::number(num2++));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Extensive-Reading"><a href="#Extensive-Reading" class="headerlink" title="Extensive Reading"></a>Extensive Reading</h2><p>​        传送门：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Mountain_tai_li/article/details/130529628">https://blog.csdn.net/Mountain_tai_li/article/details/130529628</a></p>
<p>​        QTimer 类提供重复和单次计时器。</p>
<p>​        QTimer 类为计时器提供了一个高级编程接口。要使用它，首先创建一个 QTimer实例，将其 timeout() 信号连接到相应的插槽，然后调用 start()。从那时起，它将以恒定的间隔发出 timeout() 信号。</p>
<p>​        一秒（1000毫秒）计时器的示例（来自模拟时钟示例）：</p>
<pre class="line-numbers language-none"><code class="language-none">QTimer *timer &#x3D; new QTimer(this);
connect(timer, SIGNAL(timeout()), this, SLOT(update()));
timer-&gt;start(1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        从那时起，每秒调用一次 update() 槽函数。</p>
<p>​        也可以通过调用 setSingleShot（true） 将计时器设置为仅超时一次。您还可以使用静态 QTimer::singleShot() 函数在指定的时间间隔后调用槽函数：</p>
<p>​        QTimer::singleShot(200, this, SLOT(updateCaption()));<br>​        在多线程应用程序中，可以在任何具有事件循环的线程中使用 QTimer。要从非 GUI 线程启动事件循环，使用 QThread::exec()。Qt使用计时器的线程亲和力来确定哪个线程将发出timeout()信号。因此，您必须在其线程中启动和停止计时器;无法从另一个线程启动计时器。作为特殊情况timeout 为 0 的 QTimer 将在窗口系统的事件队列中的所有事件都得到处理后立即timeout。这可用于完成繁重的工作，同时提供活泼的用户界面：</p>
<pre class="line-numbers language-none"><code class="language-none">QTimer *timer &#x3D; new QTimer(this);
connect(timer, SIGNAL(timeout()), this, SLOT(processOneThing()));
timer-&gt;start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        从那时起，processOneThing()槽函数将被重复调用。它应该以这样一种方式编写，即它总是快速返回（通常在处理一个数据项之后），以便Qt可以将事件传递到用户界面，并在完成所有工作后立即停止计时器。这是在GUI应用程序中实现繁重工作的传统方式，但随着多线程在越来越多的平台上变得可用，我们预计零毫秒QTimer对象将逐渐被QThreads取代。</p>
<p>​        定时器精度和分辨率<br>​        计时器的准确性取决于底层操作系统和硬件。大多数平台都支持 1 毫秒的分辨率，尽管在许多现实情况下，计时器的精度不会等于此分辨率。</p>
<p>​        精度还取决于计时器类型。对于Qt::PreciseTimer，QTimer将尝试将精度保持在1毫秒。精确的计时器也不会比预期早超时。对于 Qt::CoarseTimer 和 Qt::VeryCoarseTimer 类型，QTimer 可能会比预期更早timeout，在这些类型的范围内：Qt::CoarseTimer 的间隔为 5%，Qt::VeryCoarseTimer 的间隔为 500 毫秒。如果系统繁忙或无法提供请求的准确性，则所有计时器类型都可能晚于预期超时。在timeout 溢出的情况下，Qt只会发出一次active()，即使多个超时已经过期，然后恢复原始间隔。 </p>
<h2 id="绘图事件"><a href="#绘图事件" class="headerlink" title="绘图事件"></a>绘图事件</h2><p>​        我们可以在窗口中绘制图像。比如说，我们新建一个Widget：在widget.h这个文件下书写有：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef WIDGET_H
#define WIDGET_H

#include &lt;QWidget&gt;
#include&lt;QPaintEvent&gt; &#x2F;&#x2F; include neccessaryFile
QT_BEGIN_NAMESPACE
namespace Ui &#123; class Widget; &#125;
QT_END_NAMESPACE

class Widget : public QWidget
&#123;
    Q_OBJECT

public:
    Widget(QWidget *parent &#x3D; nullptr);
    ~Widget();
    &#x2F;&#x2F; 绘图事件
    void paintEvent(QPaintEvent*); &#x2F;&#x2F; add code here...

private:
    Ui::Widget *ui;
&#125;;
#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        也就是说，我们需要重写一个函数叫做<code>paintEvent(QPaintEvent*)</code></p>
<p>​        转到widget.cpp下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include&lt;QPainter&gt;
#include&lt;QPoint&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);
&#125;

void Widget::paintEvent(QPaintEvent*)
&#123;

    QPainter painter(this);

    painter.drawLine(QPoint(0,0),QPoint(100,100));
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230605182550682.png" alt="image-20230605182550682"></p>
<p>​        我们还可以画圆：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">painter.drawEllipse(QPoint(100,100),50,50); &#x2F;&#x2F; 画椭圆<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230605182711434.png" alt="image-20230605182711434"></p>
<p>​        画矩形：</p>
<pre class="line-numbers language-none"><code class="language-none">painter.drawRect(QRect(QPoint(200,200),QPoint(300,300)));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230605183009972.png" alt="image-20230605183009972"></p>
<p>​        或者是展示文字：</p>
<pre class="line-numbers language-none"><code class="language-none">painter.drawText(QRect(10,200,200,200),&quot;好好学习，逆天享受&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230605183201375.png" alt="image-20230605183201375"></p>
<p>​        当然，我们可以设置画笔性质：</p>
<pre class="line-numbers language-none"><code class="language-none">QPen pen(QColor(255,0,0));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230605183341509.png" alt="image-20230605183341509"></p>
<p>​        我们还可以使用画刷：</p>
<pre class="line-numbers language-none"><code class="language-none">QBrush brush(Qt::green);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230605183737110.png" alt="image-20230605183737110"></p>
<p>​        其他：</p>
<p><img src="image-20230605183952474.png" alt="image-20230605183952474"></p>
<p><img src="image-20230605183959522.png" alt="image-20230605183959522"></p>
<p>​        上面的这个是让画笔的起笔点平移了！</p>
<p><img src="image-20230605184248890.png" alt="image-20230605184248890"></p>
<p>​        上面就是存储与换元的状态。</p>
<h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>​        使用QPixmap类从而加载图片：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QPainter painter(this);
painter.drawPixmap(20,100,QPixmap(&quot;:&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="image-20230605184915345.png" alt="image-20230605184915345"></p>
<p>​        注意我们若是想要刷新图片，更好的使用<code>update()</code>！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include&lt;QPainter&gt;
#include&lt;QPoint&gt;
#include&lt;QPushButton&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[&#x3D;]()&#123;

        posX +&#x3D; 20;
        update();

    &#125;);

    connect(ui-&gt;pushButton_2,&amp;QPushButton::clicked,[&#x3D;]()&#123;

        posX -&#x3D; 20;
        update();

    &#125;);


&#125;

void Widget::paintEvent(QPaintEvent*)
&#123;

    QPainter painter(this);
    painter.drawPixmap(posX,0,QPixmap(&quot;:&#x2F;1.png&quot;));
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Extensive-Reading-I"><a href="#Extensive-Reading-I" class="headerlink" title="Extensive Reading I"></a>Extensive Reading I</h2><p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Jeffxu_lib/article/details/111224870">https://blog.csdn.net/Jeffxu_lib/article/details/111224870</a></p>
<h3 id="一、QPaintEvent-绘图事件"><a href="#一、QPaintEvent-绘图事件" class="headerlink" title="一、QPaintEvent 绘图事件"></a>一、QPaintEvent 绘图事件</h3><h4 id="1、paintEvent-函数"><a href="#1、paintEvent-函数" class="headerlink" title="1、paintEvent 函数"></a>1、paintEvent 函数</h4><p>该绘图函数为虚函数，一般要在子类中去重新实现，来接受绘图事件。<br>通过QPainter来绘图时，一般必须要在paintEvent 函数中来进行。在该函数中重新实现所有的绘图操作，程序在初始化之后会自动调用该绘图事件函数来进行绘图。</p>
<h4 id="2、绘图函数的调用"><a href="#2、绘图函数的调用" class="headerlink" title="2、绘图函数的调用"></a>2、绘图函数的调用</h4><p>绘图函数paintEvent 的首次调用是在所有的UI都初始化之后进行的。<br>当程序的UI发生变化时，如控件大小位置变化、控件由隐藏到显示变化时，程序会调用paintEvent函数<br>当调用repaint或update函数时，会导致程序调用paintEvent 函数。一般推荐使用update函数，因为Qt针对update做了优化和处理，而repaint则没有。</p>
<h3 id="二、QPainter基础"><a href="#二、QPainter基础" class="headerlink" title="二、QPainter基础"></a>二、QPainter基础</h3><h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>QPainter一般在 paintEvent 事件函数中去使用，否则不会生效。在虚函数paintEvent中去重新实现对应功能，如构建和自定义画家QPainter对象，并指定绘图设备(即具体在什么上绘制，如指定的label或widget等控件)，进行绘制对应的UI<br>QPainter 在绘制GUI的程序上，提供了高度的优化功能。它能绘制几乎所有的 UI，如：点、线条、矩形、圆弧、椭圆、弦、图片、文字、填充等。</p>
<h4 id="2、常用接口"><a href="#2、常用接口" class="headerlink" title="2、常用接口"></a>2、常用接口</h4><p>QPainter (QPaintDevice *device)：构建画家对象，并指定绘图设备，即在哪上面进行绘制。<br>drawArc：在指定的矩形中画内切的圆弧<br>drawChord：在指定的矩形中画弦<br>drawPie：在指定矩形中画饼型图<br>drawConvexPolygon：根据给定的多个点来画凸多边形<br>drawPolygon：画多边形<br>drawEllipse：在指定矩形内画椭圆<br>drawImage：绘制图片，相当于用指定的图片来填充指定的矩形。<br>drawLine：根据给定的点来画线<br>drawPolyline：根据多个点来画折线，折线的首尾不相连<br>drawPath (const QPainterPath &amp;path)：画指定的路径图，可以画各种各样的不规则图形。<br>drawPicture：在给定的点重新加载展示指定的图片<br>drawPixmap:画像素图，即用指定的图来在指定矩形中进行填充<br>drawPoint：画一个点<br>drawRect：画方正的矩形<br>drawRoundedRect：画带圆角的矩形<br>drawText：画文本文字<br>fillRect：用指定的颜色来填充矩形区域，此时没有边线，只是填充指定区域<br>font：返回当前用来绘制文本的字体<br>fontMetrics：在画家处于激活的状态下返回当前字体的几何尺寸信息<br>opacity：返回当前的画家的透明度，默认值为1<br>layoutDirection：当绘制文本内容时，返回布局方向<br>setPen：设置画笔的样式<br>setOpacity：设置不透明度，取值的范围是0.0 0.00.0 ~ 1.0 1.01.0，当值为0.0 0.00.0时为完全透明，当值为1.0 1.01.0时为完全不透明。<br>setBackground：设置填充背景的颜色样式，当背景模式为透明时，该函数将不起作用<br>setBrush：以指定的颜色样式填充所画的图形<br>setFont：绘制文本内容时，来设置对应的字体样式<br>setLayoutDirection：当绘制文本内容时，用来设置布局的方向<br>3、对比 QPainter 和 QPen</p>
<p>QPainter和QPen都可以调用各自的setBrush函数，但是作用的效果完全不同</p>
<p>(1)、 QPainter 调用setBrush函数</p>
<p>此时画家QPainter可以以指定的颜色来填充所绘制的整个封闭图形(只有封闭的图形才能被填充，如弦Arc未封闭将不能被填充)，相当于刷子。<br>或者此时画家QPainter以指定的样式来填充封闭图形，(以颜色或样式填充只能有一种起作用，不可以同时起作用)。<br>应用示例</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void PaintEventTest::paintEvent(QPaintEvent *event)
&#123;
    QPainter painter(this);
    painter.setBrush(QColor(0, 200, 250, 200)); &#x2F;&#x2F;设置填充颜色
    painter.setPen(QPen(Qt::red,20)); &#x2F;&#x2F;设置画笔的颜色和宽度。若不设置画笔，则画家会以默认宽度和颜色的画笔来绘制边线
    painter.drawPie(QRect(50, 50, 500, 500), 0, 260 * 16);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>(2)、 QPen 调用setBrush函数</p>
<p>此时只是用来填充笔画，其效果相当于setColor。即只是设置线条的颜色。<br>应用示例</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void PaintEventTest::paintEvent(QPaintEvent *event)
&#123;
    QPainter painter(this);
    

    QPen pen;
    pen.setBrush(Qt::red); &#x2F;&#x2F;只是设置画笔的颜色
    &#x2F;&#x2F;pen.setColor(Qt::blue); &#x2F;&#x2F;和上面setBrush作用相同都是设置画笔的颜色
    pen.setWidth(6);
    painter.setPen(pen);
    painter.drawPie(QRect(100, 100, 500, 500), 0, 260 * 16);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="一、QPaintEvent-绘图事件-1"><a href="#一、QPaintEvent-绘图事件-1" class="headerlink" title="一、QPaintEvent 绘图事件"></a>一、<code>QPaintEvent</code> 绘图事件</h3><p><strong>1、<code>paintEvent</code> 函数</strong></p>
<ul>
<li>该绘图函数为虚函数，一般要在子类中去重新实现，来接受绘图事件。</li>
<li>通过<code>QPainter</code>来绘图时，一般必须要在<code>paintEvent</code> 函数中来进行。在该函数中重新实现所有的绘图操作，程序在初始化之后会自动调用该绘图事件函数来进行绘图。</li>
</ul>
<p><strong>2、绘图函数的调用</strong></p>
<ul>
<li>绘图函数<code>paintEvent</code> 的首次调用是在所有的<code>UI</code>都初始化之后进行的。</li>
<li>当程序的<code>UI</code>发生变化时，如控件大小位置变化、控件由隐藏到显示变化时，程序会调用<code>paintEvent</code>函数</li>
<li>当调用<code>repaint</code>或<code>update</code>函数时，会导致程序调用<code>paintEvent</code> 函数。一般推荐使用<code>update</code>函数，因为<code>Qt</code>针对<code>update</code>做了优化和处理，而<code>repaint</code>则没有。</li>
</ul>
<hr>
<h3 id="二、QPainter基础-1"><a href="#二、QPainter基础-1" class="headerlink" title="二、QPainter基础"></a>二、<code>QPainter</code>基础</h3><p><strong>1、简介</strong></p>
<ul>
<li><code>QPainter</code>一般在 <code>paintEvent</code> 事件函数中去使用，否则不会生效。在虚函数<code>paintEvent</code>中去重新实现对应功能，如构建和自定义画家<code>QPainter</code>对象，并指定绘图设备(即具体在什么上绘制，如指定的<code>label</code>或<code>widget</code>等控件)，进行绘制对应的UI</li>
<li><code>QPainter</code> 在绘制GUI的程序上，提供了高度的优化功能。它能绘制几乎所有的 UI，如：点、线条、矩形、圆弧、椭圆、弦、图片、文字、填充等。</li>
</ul>
<p><strong>2、常用接口</strong></p>
<ul>
<li><code>QPainter (QPaintDevice *device)</code>：构建画家对象，并指定绘图设备，即在哪上面进行绘制。</li>
<li><code>drawArc</code>：在指定的矩形中画内切的圆弧</li>
<li><code>drawChord</code>：在指定的矩形中画弦</li>
<li><code>drawPie</code>：在指定矩形中画饼型图</li>
<li><code>drawConvexPolygon</code>：根据给定的多个点来画凸多边形</li>
<li><code>drawPolygon</code>：画多边形</li>
<li><code>drawEllipse</code>：在指定矩形内画椭圆</li>
<li><code>drawImage</code>：绘制图片，相当于用指定的图片来填充指定的矩形。</li>
<li><code>drawLine</code>：根据给定的点来画线</li>
<li><code>drawPolyline</code>：根据多个点来画折线，折线的首尾不相连</li>
<li><code>drawPath (const QPainterPath &amp;path)</code>：画指定的路径图，可以画各种各样的不规则图形。</li>
<li><code>drawPicture</code>：在给定的点重新加载展示指定的图片</li>
<li><code>drawPixmap</code>:画像素图，即用指定的图来在指定矩形中进行填充</li>
<li><code>drawPoint</code>：画一个点</li>
<li><code>drawRect</code>：画方正的矩形</li>
<li><code>drawRoundedRect</code>：画带圆角的矩形</li>
<li><code>drawText</code>：画文本文字</li>
<li><code>fillRect</code>：用指定的颜色来填充矩形区域，此时没有边线，只是填充指定区域</li>
<li><code>font</code>：返回当前用来绘制文本的字体</li>
<li><code>fontMetrics</code>：在画家处于激活的状态下返回当前字体的几何尺寸信息</li>
<li><code>opacity</code>：返回当前的画家的透明度，默认值为1</li>
<li><code>layoutDirection</code>：当绘制文本内容时，返回布局方向</li>
<li><code>setPen</code>：设置画笔的样式</li>
<li><code>setOpacity</code>：设置不透明度，取值的范围是0.0 0.00.0 ~ 1.0 1.01.0，当值为0.0 0.00.0时为完全透明，当值为1.0 1.01.0时为完全不透明。</li>
<li><code>setBackground</code>：设置填充背景的颜色样式，当背景模式为透明时，该函数将不起作用</li>
<li><code>setBrush</code>：以指定的颜色样式填充所画的图形</li>
<li><code>setFont</code>：绘制文本内容时，来设置对应的字体样式</li>
<li><code>setLayoutDirection</code>：当绘制文本内容时，用来设置布局的方向</li>
</ul>
<p><strong>3、对比 <code>QPainter</code> 和 <code>QPen</code></strong></p>
<p><code>QPainter</code>和<code>QPen</code>都可以调用各自的setBrush函数，但是作用的效果完全不同</p>
<p>(1)、 <code>QPainter</code> 调用setBrush函数</p>
<ul>
<li>此时画家<code>QPainter</code>可以以指定的颜色来填充所绘制的整个封闭图形(只有封闭的图形才能被填充，如弦<code>Arc</code>未封闭将不能被填充)，相当于刷子。</li>
<li>或者此时画家<code>QPainter</code>以指定的样式来填充封闭图形，(以颜色或样式填充只能有一种起作用，不可以同时起作用)。</li>
<li>应用示例</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PaintEventTest</span><span class="token double-colon punctuation">::</span><span class="token function">paintEvent</span><span class="token punctuation">(</span>QPaintEvent <span class="token operator">*</span>event<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    QPainter <span class="token function">painter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    painter<span class="token punctuation">.</span><span class="token function">setBrush</span><span class="token punctuation">(</span><span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置填充颜色</span>
    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span><span class="token function">QPen</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>red<span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//设置画笔的颜色和宽度。若不设置画笔，则画家会以默认宽度和颜色的画笔来绘制边线</span>
    painter<span class="token punctuation">.</span><span class="token function">drawPie</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">260</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token number">12345678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZmZ4dV9saWI=,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>(2)、 <code>QPen</code> 调用setBrush函数</p>
<ul>
<li>此时只是用来填充笔画，其效果相当于setColor。即只是设置线条的颜色。</li>
<li>应用示例</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PaintEventTest</span><span class="token double-colon punctuation">::</span><span class="token function">paintEvent</span><span class="token punctuation">(</span>QPaintEvent <span class="token operator">*</span>event<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    QPainter <span class="token function">painter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    QPen pen<span class="token punctuation">;</span>
    pen<span class="token punctuation">.</span><span class="token function">setBrush</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>red<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//只是设置画笔的颜色</span>
    <span class="token comment">//pen.setColor(Qt::blue); //和上面setBrush作用相同都是设置画笔的颜色</span>
    pen<span class="token punctuation">.</span><span class="token function">setWidth</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span>pen<span class="token punctuation">)</span><span class="token punctuation">;</span>
    painter<span class="token punctuation">.</span><span class="token function">drawPie</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">260</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZmZ4dV9saWI=,size_16,color_FFFFFF,t_70-16859635782821.png" alt="在这里插入图片描述"></p>
<hr>
<h3 id="三、基本应用"><a href="#三、基本应用" class="headerlink" title="三、基本应用"></a>三、基本应用</h3><p><strong>1、设置画笔样式 <code>setPen</code> 有三种方式</strong></p>
<p>（1）、<code>setPen(const QPen &amp;pen)</code> ：直接设置画笔QPen的样式，该项可以同时设置画笔的众多属性，如：宽度、线条样式、颜色等，因此最为常用。</p>
<ul>
<li>首先创建QPen的对象画笔，然后设置该画笔</li>
<li>在此可以通过构造函数或子函数来设置画笔的：样式、颜色(包括透明度)、线宽等属性。</li>
<li>然后画家通过 setPen 函数来将该画笔设置到对应的画家对象上。</li>
<li>Qt::PenStyle默认为实线类型。</li>
<li>使用示例如下：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">    <span class="token comment">// 1、通过构造函数创建画笔pen01的属性</span>
    QPen <span class="token function">pen01</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>red<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2、通过子函数来单独设置pen02的属性</span>
    QPen pen02<span class="token punctuation">;</span>
    pen02<span class="token punctuation">.</span><span class="token function">setBrush</span><span class="token punctuation">(</span><span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pen02<span class="token punctuation">.</span><span class="token function">setWidth</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pen02<span class="token punctuation">.</span><span class="token function">setStyle</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DotLine<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">1234567</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（2）、<code>setPen(const QColor &amp;color)</code> ：只能设置画笔的颜色</p>
<ul>
<li>该函数只能设置画笔的颜色，包括透明度；不可以设置其它的属性</li>
<li>QColor(int r, int g, int b, int a = 255)在设置颜色的时候，可以通过构造函数来设置其对应的值，其中透明度值只能是0到255之间，不可以用0.0~1.0之间的值来代替</li>
<li>透明度默认值为 255，即不透明。</li>
<li>使用示例</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">	<span class="token comment">// 直接通过画家设置其颜色和透明度，最后一个值255为透明度</span>
    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span><span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>（3）、<code>setPen(Qt::PenStyle style)</code> ：设置画笔的样式，如实线、虚线、点画线等样式</p>
<ul>
<li>只能设置画笔的样式，默认为实线，应用最少。</li>
</ul>
<p><strong>2、绘制圆弧类图形，如<code>drawArc</code>,<code>drawChord</code>,<code>drawPie</code></strong></p>
<p>（1）、绘制圆弧时，函数参数具体如下：</p>
<ul>
<li>指定的矩形、起始的角度和圆弧的跨度角。其中圆弧内切于指定的矩形；起始角度和圆弧跨度角必须为一个角度的 1 16 \frac{1}{16}161 ，如需要绘制的圆弧图形起始角度为 10 ° 10°10°，跨度角为 90 ° 90°90°，就需要指定对应的参数为：起始角度<code>startAngle = 10*16</code>，跨度角<code>spanAngle = 90*16</code>。因为该函数在绘制圆弧时会自动取给定角度参数的 1 16 \frac{1}{16}161 ，所以要将需要的角度值乘以 16，才能得到预定的结果。</li>
<li>起始角度 <code>0</code> 度位于3点钟方向，即X XX轴正方向的位置，如下图所示：<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZmZ4dV9saWI=,size_16,color_FFFFFF,t_70-16859635782832.png" alt="在这里插入图片描述"></li>
<li>角度值为正，则是逆时针；角度值为负，则是顺时针</li>
</ul>
<p>（2）、示例如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PaintEventTest</span><span class="token double-colon punctuation">::</span><span class="token function">paintEvent</span><span class="token punctuation">(</span>QPaintEvent <span class="token operator">*</span>event<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    QPainter <span class="token function">painter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    QPen <span class="token function">pen01</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>red<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    QPen <span class="token function">pen02</span><span class="token punctuation">(</span><span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    QPen <span class="token function">pen03</span><span class="token punctuation">(</span><span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span>pen01<span class="token punctuation">)</span><span class="token punctuation">;</span>
    painter<span class="token punctuation">.</span><span class="token function">drawArc</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">260</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span>pen02<span class="token punctuation">)</span><span class="token punctuation">;</span>
    painter<span class="token punctuation">.</span><span class="token function">drawChord</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">260</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    painter<span class="token punctuation">.</span><span class="token function">setPen</span><span class="token punctuation">(</span>pen03<span class="token punctuation">)</span><span class="token punctuation">;</span>
    painter<span class="token punctuation">.</span><span class="token function">drawPie</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">1160</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">260</span> <span class="token operator">*</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token number">1234567891011121314151617</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从左到右依次为<code>drawArc</code>,<code>drawChord</code>,<code>drawPie</code><br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZmZ4dV9saWI=,size_16,color_FFFFFF,t_70-16859635782833.png" alt="在这里插入图片描述"></p>
<p><strong>3、填充矩形区域 <code>fillRect</code></strong></p>
<p>(1)、应用分析</p>
<ul>
<li>用指定的颜色来填充矩形区域，且该矩形区域没有边线，此时可以通过画家<code>QPainter</code>来调用fillRect函数实现。</li>
<li>fillRect可以用指定的颜色或样式来对矩形区域进行填充，相当于画刷。</li>
</ul>
<p>(2)、示例</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">PaintEventTest</span><span class="token double-colon punctuation">::</span><span class="token function">paintEvent</span><span class="token punctuation">(</span>QPaintEvent <span class="token operator">*</span>event<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    QPainter <span class="token function">painter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 以指定颜色填充矩形</span>
    painter<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">QColor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 以指定样式填充矩形</span>
    painter<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span><span class="token function">QRect</span><span class="token punctuation">(</span><span class="token number">700</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Qt<span class="token double-colon punctuation">::</span>DiagCrossPattern<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token number">123456789</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZmZ4dV9saWI=,size_16,color_FFFFFF,t_70-16859635782834.png" alt="在这里插入图片描述"></p>
<h3 id="三、基本应用-1"><a href="#三、基本应用-1" class="headerlink" title="三、基本应用"></a>三、基本应用</h3><h4 id="1、设置画笔样式-setPen-有三种方式"><a href="#1、设置画笔样式-setPen-有三种方式" class="headerlink" title="1、设置画笔样式 setPen 有三种方式"></a>1、设置画笔样式 setPen 有三种方式</h4><p>（1）、setPen(const QPen &amp;pen) ：直接设置画笔QPen的样式，该项可以同时设置画笔的众多属性，如：宽度、线条样式、颜色等，因此最为常用。</p>
<p>首先创建QPen的对象画笔，然后设置该画笔<br>在此可以通过构造函数或子函数来设置画笔的：样式、颜色(包括透明度)、线宽等属性。<br>然后画家通过 setPen 函数来将该画笔设置到对应的画家对象上。<br>Qt::PenStyle默认为实线类型。<br>使用示例如下：</p>
<pre class="line-numbers language-none"><code class="language-none">  &#x2F;&#x2F; 1、通过构造函数创建画笔pen01的属性
    QPen pen01(Qt::red, 8);
    &#x2F;&#x2F; 2、通过子函数来单独设置pen02的属性
    QPen pen02;
    pen02.setBrush(QColor(0, 200, 200, 100));
    pen02.setWidth(10);
    pen02.setStyle(Qt::DotLine);
（2）、setPen(const QColor &amp;color) ：只能设置画笔的颜色<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        该函数只能设置画笔的颜色，包括透明度；不可以设置其它的属性<br>​        QColor(int r, int g, int b, int a = 255)在设置颜色的时候，可以通过构造函数来设置其对应的值，其中透明度值只能是0到255之间，不可以用0.0~1.0之间的值来代替,透明度默认值为 255，即不透明。<br>使用示例</p>
<pre class="line-numbers language-none"><code class="language-none">	&#x2F;&#x2F; 直接通过画家设置其颜色和透明度，最后一个值255为透明度
    painter.setPen(QColor(200,0,0,255));
（3）、setPen(Qt::PenStyle style) ：设置画笔的样式，如实线、虚线、点画线等样式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>只能设置画笔的样式，默认为实线，应用最少。<br>2、绘制圆弧类图形，如drawArc,drawChord,drawPie</p>
<p>（1）、绘制圆弧时，函数参数具体如下：</p>
<p>​        指定的矩形、起始的角度和圆弧的跨度角。其中圆弧内切于指定的矩形；起始角度和圆弧跨度角必须为一个角度的 $ \frac{1}{16} $，如需要绘制的圆弧图形起始角度为 10 ° ，跨度角为 90 °，就需要指定对应的参数为：起始角度startAngle = 10*16，跨度角spanAngle = 90*16。因为该函数在绘制圆弧时会自动取给定角度参数的$\frac{1}{16}$  ，所以要将需要的角度值乘以 16，才能得到预定的结果。<br>​        起始角度 0 度位于3点钟方向，即X XX轴正方向的位置，如下图所示：</p>
<p>​        角度值为正，则是逆时针；角度值为负，则是顺时针<br>（2）、示例如下：</p>
<pre class="line-numbers language-none"><code class="language-none">void PaintEventTest::paintEvent(QPaintEvent *event)
&#123;
    QPainter painter(this);

    QPen pen01(Qt::red, 8);
    QPen pen02(QColor(0, 200, 200), 6);
    QPen pen03(QColor(0, 0, 255, 200), 7);
    
    painter.setPen(pen01);
    painter.drawArc(QRect(10, 10, 500, 500), 0, 260 * 16);
    
    painter.setPen(pen02);
    painter.drawChord(QRect(600, 10, 500, 500), 0, 260 * 16);
    
    painter.setPen(pen03);
    painter.drawPie(QRect(1160, 10, 500, 500), 0, 260 * 16);

&#125;


<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        从左到右依次为drawArc,drawChord,drawPie</p>
<p>3、填充矩形区域 fillRect</p>
<p>(1)、应用分析</p>
<p>用指定的颜色来填充矩形区域，且该矩形区域没有边线，此时可以通过画家QPainter来调用fillRect函数实现。<br>fillRect可以用指定的颜色或样式来对矩形区域进行填充，相当于画刷。<br>(2)、示例</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void PaintEventTest::paintEvent(QPaintEvent *event)
&#123;
    QPainter painter(this);

    &#x2F;&#x2F; 以指定颜色填充矩形
    painter.fillRect(QRect(50, 50, 600, 300), QColor(0, 200, 250, 200));
    &#x2F;&#x2F; 以指定样式填充矩形
    painter.fillRect(QRect(700, 50, 600, 300), Qt::DiagCrossPattern);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>QRect类使用整数精度在平面上定义了一个矩形。</p>
<blockquote>
<p>Header:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">	<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;QRect></span></span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>CMake:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">find_package</span><span class="token punctuation">(</span>Qt6 COMPONENTS Core REQUIRED<span class="token punctuation">)</span>
<span class="token function">target_link_libraries</span><span class="token punctuation">(</span>mytarget PRIVATE Qt6<span class="token double-colon punctuation">::</span>Core<span class="token punctuation">)</span>
<span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>qmake:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QT <span class="token operator">+=</span> core
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</blockquote>
<p>注意:这个类中的所有函数都是可重入的。</p>
<h2 id="Qrect详细说明"><a href="#Qrect详细说明" class="headerlink" title="Qrect详细说明"></a>Qrect详细说明</h2><p>​        矩形通常表示为左上角和大小。QRect的大小(宽度和高度)总是等价于数学矩形(构成其呈现的基础)。</p>
<p>​        QRect可以用一组左、顶、宽和高整数来构造，也可以用QPoint和QSize来构造。下面的代码创建了两个相同的矩形。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QRect <span class="token function">r1</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
QRect <span class="token function">r2</span><span class="token punctuation">(</span><span class="token function">QPoint</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">QSize</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        还有第三个构造函数使用左上角和右下角坐标创建QRect，但是我们建议您避免使用它。其基本原理是由于历史原因，由bottom()和right()函数返回的值偏离了矩形真正的右下角。</p>
<p>​        QRect类提供了一组函数，它们返回各种矩形坐标，并支持对它们进行操作。QRect还提供了相对于各种坐标移动矩形的函数。此外，还有一个moveTo()函数可以移动矩形，使其左上角保持在给定的坐标位置。或者，translate()函数将矩形移动到给定的相对于当前位置的偏移量，然后translate()函数返回该矩形的已翻译副本</p>
<p>​        size() 函数的作用是:返回矩形的尺寸为QSize。尺寸也可以使用width()和height()函数单独检索。使用setSize()、setWidth()或setHeight()函数来操作维度。或者，可以通过应用设置矩形坐标的函数来更改大小，例如setBottom()或setRight()。</p>
<p>​        contains()函数的作用是:告知给定的点是否在矩形内;如果矩形与给定的矩形相交，则intersects()函数返回true。QRect类还提供了intersected()函数，它返回相交的矩形，以及united()函数，它返回包含给定矩形的矩形，并如下所示:</p>
<p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poaXpoZW5nZ3Vhbg==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"><br>        如果left() &gt; right()或top() &gt; bottom()，则isEmpty()函数返回true。请注意，空矩形是无效的:如果left() &lt;= right()和top() &lt;= bottom()，则isValid()函数返回true。另一方面，一个空矩形(isNull() == true)的宽度和高度都设置为0。</p>
<p>​        注意，由于QRect和QRectF的定义方式，空QRect的定义基本上与QRectF相同。</p>
<p>​        最后，可以对QRect对象进行流化和比较。</p>
<h2 id="呈现"><a href="#呈现" class="headerlink" title="呈现"></a>呈现</h2><p>​        当使用反锯齿绘制器时，QRect的边界线将在数学矩形边界线的两侧对称地绘制。但是当使用别名绘制器(默认)时，应用其他规则。</p>
<p>​        然后，当使用一个像素宽的笔进行渲染时，QRect的边界线将被渲染到数学矩形边界线的右边和下面。</p>
<p>​        当使用两个像素宽的笔进行渲染时，边界线将被数学矩形从中间分割。当画笔被设置为偶数像素时，当画笔被设置为奇数像素时，备用像素将被渲染到数学矩形的右边和下面，就像在一个像素的情况下一样。<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poaXpoZW5nZ3Vhbg==,size_16,color_FFFFFF,t_70-16859636729591.png" alt="在这里插入图片描述"></p>
<h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>​        QRect类提供了一组函数，它们返回各种矩形坐标，并支持对它们进行操作。QRect还提供了相对于各种坐标移动矩形的函数。</p>
<p>​        以left()， setLeft()和moveLeft()函数为例:左()返回矩形的坐标的左边缘,setLeft()矩形的左边缘设置为给定的x坐标(它可能改变宽度,但永远不会改变矩形的右边缘)和moveLeft()整个矩形水平移动,离开矩形的左边缘在给定的x坐标和其大小不变。<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poaXpoZW5nZ3Vhbg==,size_16,color_FFFFFF,t_70-16859636729592.png" alt="在这里插入图片描述"><br>​        请注意，由于历史原因，由bottom()和right()函数返回的值偏离了矩形真正的右下角:right()函数返回left() + width() - 1, bottom()函数返回top() + height() - 1。由bottomRight()函数返回的point也是同样的情况。另外，topRight()函数和bottomLeft()函数的x坐标和y坐标与右真边和底边的偏差是相同的。</p>
<p>​        我们建议使用x() + width()和y() + height()来找到真正的右下角，避免使用right()和bottom()。另一种解决方案是使用QRectF: QRectF类使用浮点精度在坐标上定义平面中的矩形，QRectF::right()和QRectF::bottom()函数确实返回右坐标和底坐标。</p>
<p>​        还可以使用adjust()函数向这个矩形的坐标添加偏移量，也可以使用adjusted()函数根据对原矩形的调整获取新的矩形。如果宽度和高度是负的，使用normalized()函数来获取一个边角被交换的矩形。</p>
<p>​        此外，QRect提供了getCoords()函数，它提取矩形的左上角和右下角的位置，以及getRect()函数，它提取矩形的左上角、宽度和高度。使用setCoords()和setRect()函数一次性操作矩形的坐标和尺寸。</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>​        QRect被限制为int类型的最小值和最大值。QRect上的操作可能会导致值超出这个范围，这将导致未定义的行为。</p>
<p>参见QRectF和QRegion。</p>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><h4 id="QRect"><a href="#QRect" class="headerlink" title="QRect"></a>QRect</h4><blockquote>
<p><strong>QRect::QRect(int x, int y, int width, int height)</strong></p>
</blockquote>
<p>构造一个以(x, y)为左上角、给定宽度和高度的矩形。</p>
<p>参见setRect()</p>
<blockquote>
<p><strong>QRect::QRect(const QPoint &amp;topLeft, const QSize &amp;size)</strong></p>
</blockquote>
<p>构造具有给定顶角和给定大小的矩形。</p>
<p>参见setTopLeft()和setSize()。</p>
<blockquote>
<p><strong>QRect::QRect(const QPoint &amp;topLeft, const QPoint &amp;bottomRight)</strong></p>
</blockquote>
<p>构造一个矩形，包含给定的顶角和右下角。</p>
<p>如果右下角比顶部更高且在顶部的左边，则定义的矩形将不包含角。</p>
<p>注意:为了确保这两个点都被包含，而不考虑相对顺序，请使用span()。</p>
<p>参见setTopLeft()、setBottomRight()和span()。</p>
<blockquote>
<p><strong>QRect::QRect()</strong></p>
</blockquote>
<p>构造一个空矩形。</p>
<p>参见isNull()。</p>
<h2 id="QPoint类"><a href="#QPoint类" class="headerlink" title="QPoint类"></a>QPoint类</h2><p>QPoint类定义了平面上的一个点。 详情请见……</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;qpoint.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>所有成员函数的列表。</p>
<h2 id="公有成员"><a href="#公有成员" class="headerlink" title="公有成员"></a>公有成员</h2><ul>
<li><strong>QPoint</strong> ()</li>
<li><strong>QPoint</strong> ( intxpos, intypos )</li>
<li>bool <strong>isNull</strong> () const</li>
<li>int <strong>x</strong> () const</li>
<li>int <strong>y</strong> () const</li>
<li>void <strong>setX</strong> ( intx )</li>
<li>void <strong>setY</strong> ( inty )</li>
<li>int <strong>manhattanLength</strong> () const</li>
<li>QCOORD &amp; <strong>rx</strong> ()</li>
<li>QCOORD &amp; <strong>ry</strong> ()</li>
<li>QPoint &amp; <strong>operator+=</strong> ( constQPoint&amp;p )</li>
<li>QPoint &amp; <strong>operator-=</strong> ( constQPoint&amp;p )</li>
<li>QPoint &amp; <strong>operator*=</strong> ( intc )</li>
<li>QPoint &amp; <strong>operator*=</strong> ( doublec )</li>
<li>QPoint &amp; <strong>operator/=</strong> ( intc )</li>
<li>QPoint &amp; <strong>operator/=</strong> ( doublec )</li>
</ul>
<h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><ul>
<li>bool <strong>operator==</strong> ( constQPoint&amp;p1, constQPoint&amp;p2 )</li>
<li>bool <strong>operator!=</strong> ( constQPoint&amp;p1, constQPoint&amp;p2 )</li>
<li>const QPoint <strong>operator+</strong> ( constQPoint&amp;p1, constQPoint&amp;p2 )</li>
<li>const QPoint <strong>operator-</strong> ( constQPoint&amp;p1, constQPoint&amp;p2 )</li>
<li>const QPoint <strong>operator*</strong> ( constQPoint&amp;p, intc )</li>
<li>const QPoint <strong>operator*</strong> ( intc, constQPoint&amp;p )</li>
<li>const QPoint <strong>operator*</strong> ( constQPoint&amp;p, doublec )</li>
<li>const QPoint <strong>operator*</strong> ( doublec, constQPoint&amp;p )</li>
<li>const QPoint <strong>operator-</strong> ( constQPoint&amp;p )</li>
<li>const QPoint <strong>operator/</strong> ( constQPoint&amp;p, intc )</li>
<li>const QPoint <strong>operator/</strong> ( constQPoint&amp;p, doublec )</li>
<li>QDataStream &amp; <strong>operator&lt;&lt;</strong> ( QDataStream&amp;s, constQPoint&amp;p )</li>
<li>QDataStream &amp; <strong>operator&gt;&gt;</strong> ( QDataStream&amp;s, QPoint&amp;p )</li>
</ul>
<hr>
<h2 id="QPoint详细描述"><a href="#QPoint详细描述" class="headerlink" title="QPoint详细描述"></a>QPoint详细描述</h2><p>​        QPoint类定义了平面上的一个点。</p>
<p>​        一个点由一个x坐标和一个y坐标确定。</p>
<p>​        坐标类型是<code>QCOORD</code>（一个32位整数）。<code>QCOORD</code>的最小值是<code>QCOORD_MIN</code>（-2147483648），最大值是<code>QCOORD_MAX</code>（2147483647）。</p>
<p>​        坐标可以通过函数x()和y()来访问，它们可以由setX()和setY()来设置并且由rx()由ry()来参考。</p>
<p>​        假设一个点<em>p</em>，下面的语句都是等价的：</p>
<pre class="line-numbers language-none"><code class="language-none">p.setX( p.x() + 1 );
p +&#x3D; QPoint( 1, 0 );
p.rx()++;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        一个QPoint也可以用作是一个矢量。QPoint的加法和减法也像矢量一样定义了（每个分量分别的被相加或者相减）。你可以把一个QPoint与一个<code>int</code>或者一个<code>double</code>做乘法或者除法。函数manhattanLength()像对矢量那样给出了QPoint一个比较廉价的长度接近值的说明。</p>
<p>Example:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;QPoint oldPos在其它什么地方定义过了
MyWidget::mouseMoveEvent( QMouseEvent *e )
&#123;
    QPoint vector &#x3D; e-&gt;pos() - oldPos;
    if ( vector.manhattanLength() &gt; 3 )
	... &#x2F;&#x2F;鼠标从oldPos移动超过3个象素
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        QPoint可以进行比较得出相等或者不等，并且它们可以写到QStream或者从QStream中读出。</p>
<p>​        也可以参考QPointArray、QSize、QRect、图形类和图像处理类。</p>
<h2 id="成员函数文档"><a href="#成员函数文档" class="headerlink" title="成员函数文档"></a>成员函数文档</h2><pre class="line-numbers language-none"><code class="language-none">QPoint::QPoint ()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>构造一个坐标为(0,0)的点（isNull()返回真）。</p>
<pre class="line-numbers language-none"><code class="language-none">QPoint::QPoint ( intxpos, intypos )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>构造一个x值为<em>xpos</em>，y值为<em>ypos</em>的点。</p>
<pre class="line-numbers language-none"><code class="language-none">bool QPoint::isNull () const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果x值和y值都是0的话，返回真，否则返回假。</p>
<pre class="line-numbers language-none"><code class="language-none">int QPoint::manhattanLength () const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回x()和y()的绝对值得和，就是传统上的从原点开始的矢量的“曼哈顿长度”。这个传统的出现是因为这样的距离适用于在矩形方格上旅行的履行者们，就像曼哈顿的街道一样。</p>
<p>这个很有用的，并且运算很快，和真实长度sqrt(pow(x(),2)+pow(y(),2))很接近。</p>
<pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator*&#x3D; ( intc )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用<em>c</em>与这个点的x和y做乘法，并且返回这个点的引用。</p>
<p>实例：</p>
<pre class="line-numbers language-none"><code class="language-none">QPoint p( -1, 4 );
p *&#x3D; 2;            &#x2F;&#x2F; p变成了(-2,8)   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator*&#x3D; ( doublec )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p>
<p>用<em>c</em>与这个点的x和y做乘法，并且返回这个点的引用。</p>
<p>实例：</p>
<pre class="line-numbers language-none"><code class="language-none">QPoint p( -1, 4 );
p *&#x3D; 2.5;          &#x2F;&#x2F; p变成了(-3,10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意这个结果被取整了，因为点是用整数保存的。</p>
<pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator+&#x3D; ( constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>把点<em>p</em>加到这个点上，并且返回这个点的引用。</p>
<p>实例：</p>
<pre class="line-numbers language-none"><code class="language-none">QPoint p(  3, 7 );
QPoint q( -1, 4 );
p +&#x3D; q;            &#x2F;&#x2F; p变成了(2,11)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator-&#x3D; ( constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        从这个点上减去点<em>p</em>，并且返回这个点的引用。</p>
<p>实例：</p>
<pre class="line-numbers language-none"><code class="language-none">QPoint p(  3, 7 );
QPoint q( -1, 4 );
p -&#x3D; q;            &#x2F;&#x2F; p变成了(4,3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator&#x2F;&#x3D; ( intc )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        x和y都除以<em>c</em>，并且返回这个点的引用。</p>
<p>​        实例：</p>
<pre class="line-numbers language-none"><code class="language-none">QPoint p( -2, 8 );
p &#x2F;&#x3D; 2;            &#x2F;&#x2F; p变成了(-1,4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">QPoint&amp; QPoint::operator&#x2F;&#x3D; ( doublec )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p>
<p>x和y都除以<em>c</em>，并且返回这个点的引用。</p>
<p>实例：</p>
<pre class="line-numbers language-none"><code class="language-none">QPoint p( -3, 10 );
p &#x2F;&#x3D; 2.5;           &#x2F;&#x2F; p变成了(-1,4)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意这个结果被取整了，因为点是用整数保存的。</p>
<pre class="line-numbers language-none"><code class="language-none">QCOORD &amp; QPoint::rx ()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        返回这个点的x坐标的引用。</p>
<p>​        使用这个引用可以直接操作x。</p>
<p>​        实例：</p>
<pre class="line-numbers language-none"><code class="language-none">QPoint p( 1, 2 );
p.rx()--;         &#x2F;&#x2F; p变成了(0, 2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        也可以参考ry()。</p>
<pre class="line-numbers language-none"><code class="language-none">QCOORD &amp; QPoint::ry ()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        返回这个点的y坐标的引用。</p>
<p>​        使用这个引用可以直接操作y。</p>
<p>实例：</p>
<pre class="line-numbers language-none"><code class="language-none">QPoint p( 1, 2 );
p.ry()++;         &#x2F;&#x2F; p变成了(1, 3)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也可以参考rx()。</p>
<pre class="line-numbers language-none"><code class="language-none">void QPoint::setX ( intx )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设置这个点的x坐标为<em>x</em>。</p>
<pre class="line-numbers language-none"><code class="language-none">void QPoint::setY ( inty )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设置这个点的y坐标为<em>y</em>。</p>
<pre class="line-numbers language-none"><code class="language-none">int QPoint::x () const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回这个点的x坐标。</p>
<pre class="line-numbers language-none"><code class="language-none">int QPoint::y () const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回这个点的y坐标。</p>
<p>也可以参考setY()和x()。</p>
<h2 id="相关函数-1"><a href="#相关函数-1" class="headerlink" title="相关函数"></a>相关函数</h2><pre class="line-numbers language-none"><code class="language-none">bool operator!&#x3D; ( constQPoint&amp;p1, constQPoint&amp;p2 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果<em>p1</em>和<em>p2</em>相等，返回真，否则返回假。</p>
<pre class="line-numbers language-none"><code class="language-none">constQPoint operator* ( constQPoint&amp;p, intc )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        返回由<em>p</em>的分量和<em>c</em>相乘构成的QPoint。</p>
<pre class="line-numbers language-none"><code class="language-none">constQPoint operator* ( intc, constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p>
<p>​        返回由<em>p</em>的分量和<em>c</em>相乘构成的QPoint。</p>
<pre class="line-numbers language-none"><code class="language-none">constQPoint operator* ( constQPoint&amp;p, doublec )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p>
<p>​        返回由<em>p</em>的分量和<em>c</em>相乘构成的QPoint。</p>
<p>​        注意这个结果被取整了，因为点是用整数保存的。</p>
<pre class="line-numbers language-none"><code class="language-none">constQPoint operator* ( doublec, constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p>
<p>​        返回由<em>p</em>的分量和<em>c</em>相乘构成的QPoint。</p>
<p>​        注意这个结果被取整了，因为点是用整数保存的。</p>
<pre class="line-numbers language-none"><code class="language-none">constQPoint operator+ ( constQPoint&amp;p1, constQPoint&amp;p2 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        返回<em>p1</em>和<em>p2</em>的和，每个分量都分别相加。</p>
<pre class="line-numbers language-none"><code class="language-none">constQPoint operator- ( constQPoint&amp;p1, constQPoint&amp;p2 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        返回<em>p1</em>减去<em>p2</em>得到的结果，每个分量都分别相减。</p>
<pre class="line-numbers language-none"><code class="language-none">constQPoint operator- ( constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p>
<p>​        返回<em>p</em>每个分量都变号后构成的QPoint，和<code>QPoint(0,0) - p</code>是一样的。</p>
<pre class="line-numbers language-none"><code class="language-none">constQPoint operator&#x2F; ( constQPoint&amp;p, intc )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        返回<em>p</em>每个分量除以<em>c</em>后构成的QPoint。</p>
<pre class="line-numbers language-none"><code class="language-none">constQPoint operator&#x2F; ( constQPoint&amp;p, doublec )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这是一个重载成员函数，提供了方便。它的行为和上面的函数基本一致。</p>
<p>​        返回<em>p</em>每个分量除以<em>c</em>后构成的QPoint。</p>
<p>​        注意这个结果被取整了，因为点是用整数保存的。</p>
<pre class="line-numbers language-none"><code class="language-none">QDataStream&amp; operator&lt;&lt; ( QDataStream&amp;s, constQPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        把点<em>p</em>写到流<em>s</em>中并且返回流的引用。</p>
<p>​        也可以参考QDataStream操作符的格式。</p>
<pre class="line-numbers language-none"><code class="language-none">bool operator&#x3D;&#x3D; ( constQPoint&amp;p1, constQPoint&amp;p2 )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果<em>p1</em>和<em>p2</em>相等，返回真，否则返回假。</p>
<pre class="line-numbers language-none"><code class="language-none">QDataStream&amp; operator&gt;&gt; ( QDataStream&amp;s, QPoint&amp;p )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        从流<em>s</em>中读取一个QPoint到点<em>p</em>并且返回这个流的引用。</p>
<h2 id="QPen"><a href="#QPen" class="headerlink" title="QPen"></a>QPen</h2><p>​        QPen 类定义了QPainter 应该怎样画线条和形状的轮廓。 </p>
<p>​        对于QPen 画笔有以下几个重要特性。</p>
<p>​        <code>1.color(): 定义了线条的颜色。使用setColor(QColor(255, 0, 0, 100))定义画笔的颜色。</code></p>
<p>​        <code>2.width():定义了线条的宽度。使用setWidth(int width)设置线条的宽度。</code></p>
<p>​        这里有个特殊情况，要说明一下，按照我们的理解，如果setWidth（0）的话，应该是线条宽度为0，应该是不显示线条啊。可是实际不是这样，当设置为线条宽度为0的时候，相当于使用了sosmetic（美化笔，自己翻译的，可能不对），意味着画笔的宽度一直是1像素宽。</p>
<p>​        如果我们想不显示线条的话，怎么办？有两种方式：</p>
<pre><code>1&gt; setStyle(Qt::NoPen)
2&gt; setWidth(-1)
</code></pre><p>​        这两种方式效果是一样的，都是不显示轮廓。</p>
<p>​        <code>3.style() : 定义了线条的类型，使用setStyle()设置画笔线条的类型。</code></p>
<p>​        具体线条的类型和形状 有Qt::solidLine, 虚线Qt::dotLine, Qt::dashLine具体如下</p>
<p>Pen Style</p>
<p>​        Qt provides several built-in styles represented by the Qt::PenStyle enum:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>1<img src="70.png" alt="img"></th>
<th>2<img src="70-168596436330319.png" alt="img"></th>
<th>3<img src="70-168596436857522.png" alt="img"></th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::SolidLine</td>
<td>Qt::DashLine</td>
<td>Qt::DotLine</td>
</tr>
<tr>
<td>4<img src="70-168596437885725.png" alt="img"></td>
<td>5<img src="70-168596438197928.png" alt="img"></td>
<td>6<img src="70-168596438461531.png" alt="img"></td>
</tr>
<tr>
<td>Qt::DashDotLine</td>
<td>Qt::DashDotDotLine</td>
<td>Qt::CustomDashLine</td>
</tr>
</tbody>
</table>
</div>
<p>​        如果style设置为Qt::dashLine时候，我们怎样可以设置实线与空线（space）的比例呢？或者换种说法，我们怎样可以设置dashLine 两段实线相隔多远呢？ 幸好，我们有种方法 setDashPattern();来控制dashLine这种线条实线与虚线的比例。具体用法如下</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">pen.setDashPattern(QVector&lt;qreal&gt;() &lt;&lt; 10 &lt;&lt; 5 )
&#x2F;&#x2F;实线：空线的比例为10 ：5 。每10个单位长度的实线，然后每5个单位长度的虚线。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <code>4.capStyle() :设置线条两头的形状，可以是矩形，也可以是圆形的头。通过setCapStyle()设置线条端点形状。</code></p>
<p>​         有以下选择和相关形状。enum Qt::PenCapStyle</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>1<img src="70-168596451184534.png" alt="img"></th>
<th>2<img src="70-168596451968937.png" alt="img"></th>
<th>3<img src="70-168596452229740.png" alt="img"></th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::SquareCap</td>
<td>Qt::FlatCap</td>
<td>Qt::RoundCap</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::FlatCap</td>
<td>a square line end that does not cover the end point of the line.//方形头部，但是并不包含最后一个点</td>
</tr>
<tr>
<td>Qt::SquareCap</td>
<td>a square line end that covers the end point and extends beyond it by half the line width.//方形顶端，并且包含最后一个点</td>
</tr>
<tr>
<td>Qt::RoundCap</td>
<td>a rounded line end. //顶端是半圆形</td>
</tr>
</tbody>
</table>
</div>
<p><code>5.joinStyle() 是两条线的连接点的类型。可以通过setJoinStyle（）来设置两条线之间的连接点形状。</code></p>
<h4 id="enum-Qt-PenJoinStyle"><a href="#enum-Qt-PenJoinStyle" class="headerlink" title="enum Qt::PenJoinStyle"></a>enum Qt::PenJoinStyle</h4><div class="table-container">
<table>
<thead>
<tr>
<th>1<img src="70-168596471419343.png" alt="img"></th>
<th>2<img src="70-168596471874246.png" alt="img"></th>
<th>3<img src="70-168596472194249.png" alt="img"></th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::BevelJoin</td>
<td>Qt::MiterJoin</td>
<td>Qt::RoundJoin</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::MiterJoin</td>
<td>0x00</td>
<td>线的外缘延伸成一个角度，这个区域被填充。</td>
</tr>
<tr>
<td>Qt::BevelJoin</td>
<td>0x40</td>
<td>两条线之间的三角形缺口填满了。</td>
</tr>
<tr>
<td>Qt::RoundJoin</td>
<td>0x80</td>
<td>两条线之间有弧度，就是很圆滑</td>
</tr>
<tr>
<td>Qt::SvgMiterJoin</td>
<td>0x100</td>
<td>一个斜角连接对应一个斜切的定义加入SVG 1.2小规格。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="文件读写QFile"><a href="#文件读写QFile" class="headerlink" title="文件读写QFile"></a>文件读写QFile</h2><p>​        <img src="image-20230608151236146.png" alt="image-20230608151236146"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include &lt;QFileDialog&gt;
#include&lt;QFile&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);
    connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[&#x3D;]()&#123;
        QString Path &#x3D; QFileDialog::getOpenFileName(this,&quot;打开文件&quot;,&quot;D:\\QT projects\\untitled\\1.txt&quot;);
        ui-&gt;lineEdit-&gt;setText(Path);
        QFile file(Path);
        file.open(QIODevice::ReadOnly);
        QByteArray array &#x3D; file.readAll();

        ui-&gt;textEdit-&gt;setText(QString(array));
    &#125;);


&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        完成读写！</p>
<p>​        也可以用：<code>QFileInfo</code>获取信息：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">QFileInfo info(Path);
qDebug() &lt;&lt; &quot;大小：&quot;&lt;&lt;info.size() &lt;&lt; &quot;后缀：&quot;&lt;&lt;info.suffix();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        完结撒花！</p>
<h3 id="Extensive-Reading-1"><a href="#Extensive-Reading-1" class="headerlink" title="Extensive Reading"></a>Extensive Reading</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/9430.html">Qt QFile文件操作详解 (biancheng.net)</a></p>
<h3 id="QFile文件操作"><a href="#QFile文件操作" class="headerlink" title="QFile文件操作"></a>QFile文件操作</h3><p>​        QFile 类支持对文件进行读取、写入、删除、重命名、拷贝等操作，它既可以操作文件文件，也可以操作二进制文件。</p>
<p>​        使用 QFile 类操作文件之前，程序中需引入<code>&lt;QFile&gt;</code>头文件。创建 QFile 类的对象，常用的构造函数有：</p>
<pre class="line-numbers language-none"><code class="language-none">QFile::QFile()
QFile::QFile(const QString &amp;name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        参数 name 用来指定要操作的目标文件，包含文件的存储路径和文件名，存储路径可以使用绝对路径（比如 “D:/Demo/test.txt”）或者相对路径（比如”./Demo/test.txt”），路径中的分隔符要用 “/“ 表示。</p>
<p>​        通常情况下，我们会调用第二个构造函数，直接指明要操作的文件。对于第一个构造函数创建的 QFile 对象，需要再调用 setFileName() 方法指明要操作的文件。</p>
<p>​        与 C++ 读写文件的规则一样，使用 QFile 读写文件之前必须先打开文件，调用 open() 成员方法即可，常用的语法格式为：</p>
<pre class="line-numbers language-none"><code class="language-none">bool QFile::open(OpenMode mode)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        mode 参数用来指定文件的打开方式，下表罗列了此参数的可选值以及各自的含义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>打开方式</th>
<th>含 义</th>
</tr>
</thead>
<tbody>
<tr>
<td>QIODevice::ReadOnly</td>
<td>只能对文件进行读操作</td>
</tr>
<tr>
<td>QIODevice::WriteOnly</td>
<td>只能对文件进行写操作，如果目标文件不存在，会自行创建一个新文件。</td>
</tr>
<tr>
<td>QIODevice::ReadWrite</td>
<td>等价于 ReadOnly \</td>
<td>WriteOnly，能对文件进行读和写操作。</td>
</tr>
<tr>
<td>QIODevice::Append</td>
<td>以追加模式打开文件，写入的数据会追加到文件的末尾（文件原有的内容保留）。</td>
</tr>
<tr>
<td>QIODevice::Truncate</td>
<td>以重写模式打开，写入的数据会将原有数据全部清除。注意，此打开方式不能单独使用，通常会和 ReadOnly 或 WriteOnly 搭配。</td>
</tr>
<tr>
<td>QIODevice::Text</td>
<td>读取文件时，会将行尾结束符（Unix 系统中是 “\n”，Windows 系统中是 “\r\n”）转换成‘\n’；将数据写入文件时，会将行尾结束符转换成本地格式，例如 Win32 平台上是‘\r\n’。</td>
</tr>
</tbody>
</table>
</div>
<p>​        根据需要，可以为 mode 参数一次性指定多个值，值和值之间用<code>|</code>分割。比如：</p>
<ul>
<li>QIODevice::ReadOnly | QIODevice::Text：表示只允许对文件进行读操作，读取文件时，会将行尾结束符转换为 ‘\n’；</li>
<li>QIODevice::WriteOnly | QIODevice::Text：表示只允许对文件进行写操作，将数据写入文件时，会将行尾结束符转换为本地格式；</li>
<li>QIODevice::ReadWrite | QIODevice::Append | QIODevice::Text：表示对文件进行写操作，写入的数据会存放到文件的尾部，同时数据中的行尾结束符转换为本地格式。</li>
</ul>
<blockquote>
<p>注意，传递给 mode 参数的多个值之间不能相互冲突，比如 Append 和 Truncate 不能同时使用。</p>
</blockquote>
<p>​        如果文件成功打开，open() 函数返回 true，否则返回 false。</p>
<p>​        QFile 类提供了很多功能实用的方法，可以快速完成对文件的操作，下表列举了常用的一些：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>普通成员方法</th>
<th>功 能</th>
</tr>
</thead>
<tbody>
<tr>
<td>qint64 QFile::size() const</td>
<td>获取当前文件的大小。对于打开的文件，该方法返回文件中可以读取的字节数。</td>
</tr>
<tr>
<td>bool QIODevice::getChar(char *c)</td>
<td>从文件中读取一个字符，并存储到 c 中。读取成功时，方法返回 true，否则返回 false。</td>
</tr>
<tr>
<td>bool QIODevice::putChar(char c)</td>
<td>向文件中写入字符 c，成功时返回 true，否则返回 false。</td>
</tr>
<tr>
<td>QByteArray QIODevice::read(qint64 maxSize)</td>
<td>从文件中一次性最多读取 maxSize 个字节，然后返回读取到的字节。</td>
</tr>
<tr>
<td>qint64 QIODevice::read(char *data, qint64 maxSize)</td>
<td>从文件中一次性对多读取 maxSize 个字节，读取到的字节存储到 data 指针指定的内存控件中。该方法返回成功读取到的字节数。</td>
</tr>
<tr>
<td>QByteArray QIODevice::readAll()</td>
<td>读取文件中所有的数据。</td>
</tr>
<tr>
<td>qint64 QIODevice::readLine(char *data, qint64 maxSize)</td>
<td>每次从文件中读取一行数据或者读取最多 maxSize-1 个字节，存储到 data 中。该方法返回实际读取到的字节数。</td>
</tr>
<tr>
<td>qint64 QIODevice::write(const char *data, qint64 maxSize)</td>
<td>向 data 数据一次性最多写入 maxSize 个字节，该方法返回实际写入的字节数。</td>
</tr>
<tr>
<td>qint64 QIODevice::write(const char *data)</td>
<td>将 data 数据写入文件，该方法返回实际写入的字节数。</td>
</tr>
<tr>
<td>qint64 QIODevice::write(const QByteArray &amp;byteArray)</td>
<td>将 byteArray 数组中存储的字节写入文件，返回实际写入的字节数。</td>
</tr>
<tr>
<td>bool QFile::copy(const QString &amp;newName)</td>
<td>将当前文件的内容拷贝到名为 newName 的文件中，如果成功，方法返回 true，否则返回 false。  copy 方法在执行复制操作之前，会关闭源文件。</td>
</tr>
<tr>
<td>bool QFile::rename(const QString &amp;newName)</td>
<td>对当前文件进行重命名，新名称为 newName，成功返回 true，失败返回 false。</td>
</tr>
<tr>
<td>bool QFile::remove()</td>
<td>删除当前文件，成功返回 true，失败返回 false。</td>
</tr>
</tbody>
</table>
</div>
<p>【实例一】演示了 QFile 类读写文本文件的过程。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QFile&gt;
#include &lt;QDebug&gt;
int main(int argc, char *argv[])
&#123;    
	&#x2F;&#x2F;创建 QFile 对象，同时指定要操作的文件   
	QFile file(&quot;D:&#x2F;demo.txt&quot;);    &#x2F;&#x2F;对文件进行写操作
    if(!file.open(QIODevice::WriteOnly|QIODevice::Text))&#123;
        qDebug()&lt;&lt;&quot;文件打开失败&quot;;   
    &#125;    
    &#x2F;&#x2F;向文件中写入两行字符串    
    file.write(&quot;C语言中文网\n&quot;);    
    file.write(&quot;http:&#x2F;&#x2F;c.biancheng.net&quot;);    
    &#x2F;&#x2F;关闭文件   
    file.close();    
    
    &#x2F;&#x2F;重新打开文件，对文件进行读操作    
    if(!file.open(QIODevice::ReadOnly|QIODevice::Text))&#123;       
    	qDebug()&lt;&lt;&quot;文件打开失败&quot;;    
    &#125;    
    &#x2F;&#x2F;每次都去文件中的一行，然后输出读取到的字符串    
    char * str &#x3D; new char[100];    
    qint64 readNum &#x3D; file.readLine(str,100);    
    &#x2F;&#x2F;当读取出现错误（返回 -1）或者读取到的字符数为 0 时，结束读取
    while((readNum !&#x3D;0) &amp;&amp; (readNum !&#x3D; -1))&#123;       
        qDebug() &lt;&lt; str;        
        readNum &#x3D; file.readLine(str,100);    
    &#125;    
    file.close();    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        执行程序，”C语言中文网” 和 “<a target="_blank" rel="noopener" href="http://c.biancheng.net">http://c.biancheng.net</a>“ 先写入 D 盘的 demo.txt 文件，然后再从文件中将它们读取出来。</p>
<p>【实例二】演示 QFile 读写二进制文件的过程。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QFile&gt;
#include &lt;QDebug&gt;
int main(int argc, char *argv[])&#123;    
    &#x2F;&#x2F;指定要写入文件的数据    
    qint32 nums[5]&#x3D;&#123;1,2,3,4,5&#125;;   
    &#x2F;&#x2F;写入文件之前，要将数据以二进制方式存储到字节数组中   
    QByteArray byteArr;    
    byteArr.resize(sizeof(nums));    
    for(int i&#x3D;0;i&lt;5;i++)&#123;        
        &#x2F;&#x2F;借助指针，将每个整数拷贝到字节数组中        
        memcpy(byteArr.data()+i*sizeof(qint32),&amp;(nums[i]),sizeof(qint32));    	&#125;    
    &#x2F;&#x2F;将 byteArr 字节数组存储到文件中    
    QFile file(&quot;D:&#x2F;demo.dat&quot;);    
    file.open(QIODevice::WriteOnly);    
    file.write(byteArr);    
    file.close();    
    &#x2F;&#x2F;再次打开文件，读取文件中存储的二进制数据    
    file.open(QIODevice::ReadOnly);    
    QByteArray resArr &#x3D; file.readAll();    
    &#x2F;&#x2F;输出读取到的二进制数据    
    qDebug()&lt;&lt;&quot;resArr: &quot;&lt;&lt;resArr;    
    &#x2F;&#x2F;将二进制数据转化为整数    
    char* data &#x3D; resArr.data();   
    while(*data)&#123;        
        qDebug() &lt;&lt; *(qint32*)data;        
        data +&#x3D; sizeof(qint32);    
    &#125;    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        执行程序，demo.dat 文件中会存储 {1,2,3,4,5} 这 5 个整数的二进制形式，同时输出以下内容：</p>
<pre class="line-numbers language-none"><code class="language-none">resArr: &quot;\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00\x04\x00\x00\x00\x05\x00\x00\x00&quot;
1
2
3
4
5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        单独使用 QFile 类读写文件的过程既繁琐又复杂，Qt 提供了两个辅助类 QTextStream 和 QDataStream，前者用来读写文件文件，后者用来读写二进制文件，QFile 可以和它们搭配使用，从整体上提高读写文件的开发效率。</p>
<h4 id="QFile-QTextStream"><a href="#QFile-QTextStream" class="headerlink" title="QFile+QTextStream"></a>QFile+QTextStream</h4><p>​        和单独使用 QFile 类读写文本文件相比，QTextStream 类提供了很多读写文件相关的方法，还可以设定写入到文件中的数据格式，比如对齐方式、写入数字是否带前缀等等。</p>
<p>​        使用 QTextStream 类之前，程序中要先引入<code>&lt;QTextStream&gt;</code>头文件。QTextStream 类提供了很多种构造函数，常用的是：</p>
<pre class="line-numbers language-none"><code class="language-none">QTextStream(QIODevice *device)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        QIODevice 是 QFile 的父类，因此在构造 QTextStream 类的对象时，需要传递一个 QFile 类的对象。</p>
<p>下表罗列了 QTextStream 类常用的一些方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功 能</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool QTextStream::atEnd() const</td>
<td>判断是否读到文件末尾，如果已经达到末尾，返回 true，否则返回 false。</td>
</tr>
<tr>
<td>QString QTextStream::read(qint64 maxlen)</td>
<td>从文件中读最多 maxlen 个字符，返回这些字符组成的 QString 字符串。</td>
</tr>
<tr>
<td>QString QTextStream::readAll()</td>
<td>从文件中读取所有内容，返回由读取内容组成的 QString 字符串。</td>
</tr>
<tr>
<td>QString QTextStream::readLine(qint64 maxlen = 0)</td>
<td>默认读取一行文本，如果手动指定 maxlen 的值，则最多读取 maxlen 个字符，并返回读取内容组成的 QString 字符串。</td>
</tr>
<tr>
<td>void QTextStream::setFieldAlignment(FieldAlignment mode)</td>
<td>设置对齐方式，通常与 setFieldWidth() 一起使用。</td>
</tr>
<tr>
<td>void QTextStream::setFieldWidth(int width)</td>
<td>设置每份数据占用的位置宽度为 width。</td>
</tr>
</tbody>
</table>
</div>
<p>QTextStream 类重载了<code>&gt;&gt;</code>输入运算符和<code>&gt;&gt;</code>输出运算符，使读写文本文件变得更简单。例如，用 QTextStream 实现【实例一】的程序如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QFile&gt;
#include &lt;QDebug&gt;
#include &lt;QString&gt;
#include &lt;QTextStream&gt;
int main(int argc, char *argv[])
&#123;    
    &#x2F;&#x2F;创建 QFile 对象，同时指定要操作的文件    
    QFile file(&quot;D:&#x2F;demo.txt&quot;);    
    &#x2F;&#x2F;对文件进行写操作    
    if(!file.open(QIODevice::WriteOnly|QIODevice::Text))
    &#123;        
        qDebug()&lt;&lt;&quot;文件打开失败&quot;;    
    &#125;    
    QTextStream out(&amp;file);    
    &#x2F;&#x2F;向文件中写入两行字符串    
    out &lt;&lt; (QString)&quot;C语言中文网\n&quot; &lt;&lt; (QString)&quot;http:&#x2F;&#x2F;c.biancheng.net&quot;;    	&#x2F;&#x2F;关闭文件    
    file.close();    
    &#x2F;&#x2F;重新打开文件，对文件进行读操作
    if(!file.open(QIODevice::ReadOnly|QIODevice::Text))&#123;  
        qDebug()&lt;&lt;&quot;文件打开失败&quot;;   
    &#125;   
    QTextStream in(&amp;file);   
    &#x2F;&#x2F;一直读，直至读取失败   
    while(!in.atEnd())&#123;      
        QString str;        
        &#x2F;&#x2F;从文件中读取一个字符串    
        in &gt;&gt; str;        qDebug() &lt;&lt; str;   
    &#125;    
    file.close();   
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        和<code>&lt;iostream&gt;</code>类似，QTextStream 类提供了两种格式化输出的方法，一种是调用该类的成员方法，例如表 3 中的 setFieldAlignment()、setFieldWidth 等，另一种是调用 QTextStream 类提供的格式描述符，下表罗列了常用的一些：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>描述符</th>
<th>功能相同的方法</th>
<th>功 能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::hex</td>
<td>QTextStream::setIntegerBase(16)</td>
<td>将指定整数对应的 16 进制数写入到文件中。</td>
</tr>
<tr>
<td>Qt::showbase</td>
<td>QTextStream::setNumberFlags(numberFlags() \</td>
<td>ShowBase)</td>
<td>对于非十进制数，写入到文件中时带上相应的前缀。二进制数前缀是 0b，八进制数前缀是 0，十六进制数前缀是 0x。</td>
</tr>
<tr>
<td>Qt::forcesign</td>
<td>QTextStream::setNumberFlags(numberFlags() \</td>
<td>ForceSign)</td>
<td>将数字写入文件时，带上正负号。</td>
</tr>
<tr>
<td>Qt::fixed</td>
<td>QTextStream::setRealNumberNotation(FixedNotation)</td>
<td>将浮点数以普通小数的形式写入文件。</td>
</tr>
<tr>
<td>Qt::scientific</td>
<td>QTextStream::setRealNumberNotation(ScientificNotation)</td>
<td>将浮点数以科学计数法的形式写入文件。</td>
</tr>
<tr>
<td>Qt::left</td>
<td>QTextStream::setFieldAlignment(AlignLeft)</td>
<td>左对齐</td>
</tr>
<tr>
<td>Qt::right</td>
<td>QTextStream::setFieldAlignment(AlignRight)</td>
<td>右对齐</td>
</tr>
<tr>
<td>Qt::center</td>
<td>QTextStream::setFieldAlignment(AlignCenter)</td>
<td>居中对齐</td>
</tr>
</tbody>
</table>
</div>
<p>​        举个简单的例子：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QFile&gt;
#include &lt;QDebug&gt;
#include &lt;QString&gt;
#include &lt;QTextStream&gt;
int main(int argc, char *argv[])&#123;    
    QFile file(&quot;D:&#x2F;demo.txt&quot;);
    if(!file.open(QIODevice::WriteOnly|QIODevice::Text))&#123;  
        qDebug()&lt;&lt;&quot;文件打开失败&quot;;   
    &#125;    
    QTextStream out(&amp;file);   
    &#x2F;&#x2F;将 10 的十六进制数写入文件    
    out &lt;&lt; hex &lt;&lt; 10;    
    &#x2F;&#x2F;设置每份数据占用 10 个字符的位置    
    out.setFieldWidth(10);    
    &#x2F;&#x2F;以右对齐的方式写入 3.14    
    out &lt;&lt; left &lt;&lt; 3.14;    
    &#x2F;&#x2F;后续数据以左对齐的方式写入文件    
    out.setFieldAlignment(QTextStream::AlignRight);    
    out &lt;&lt; 2.7;    
    &#x2F;&#x2F;关闭文件    
    file.close();    
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        程序运行后，demo.txt 存储的文本内容为：</p>
<p>a3.14       2.7</p>
<h4 id="QFile-QDataStream"><a href="#QFile-QDataStream" class="headerlink" title="QFile+QDataStream"></a>QFile+QDataStream</h4><p>​        QDataStream 类的用法和 QTextStream 非常类似，最主要的区别在于，QDataStream 用于读写二进制文件。</p>
<p>​        使用 QDataStream 类之前，程序中要引入<code>&lt;QDataStream&gt;</code>头文件。创建 QDataStream 对象常用的构造函数为：</p>
<pre class="line-numbers language-none"><code class="language-none">QDataStream::QDataStream(QIODevice *d)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        下表罗列了 QDataStream 类常用的成员方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功 能</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool QDataStream::atEnd() const</td>
<td>判断是否读到文件末尾，如果已经达到末尾，返回 true，否则返回 false。</td>
</tr>
<tr>
<td>QDataStream &amp;QDataStream::readBytes(char *&amp;s, uint &amp;l)</td>
<td>对于用 writeBytes() 方法写入文件的 l 和 s，只能使用 readBytes() 方法读取出来。</td>
</tr>
<tr>
<td>int QDataStream::readRawData(char *s, int len)</td>
<td>从文件中读取最多 len 字节的数据到 s 中，返回值表示实际读取的字节数。注意，调用该方法之前，需要先给 s 参数分配好内存空间。</td>
</tr>
<tr>
<td>void QDataStream::setVersion(int v)</td>
<td>不同版本的 Qt 中，同名称的数据类型也可能存在差异，通过调用此方法手动指定版本号，可以确保读取数据的一致性。</td>
</tr>
<tr>
<td>int QDataStream::skipRawData(int len)</td>
<td>跳过文件中的 len 个字节，返回实际跳过的字节数。</td>
</tr>
<tr>
<td>QDataStream &amp;QDataStream::writeBytes(const char *s, uint len)</td>
<td>将长度 len 和 s 一起写入到文件中，对于 writeBytes() 写入的数据，只能用 readBytes() 方法读取。</td>
</tr>
<tr>
<td>int QDataStream::writeRawData(const char *s, int len)</td>
<td>将 s 中前 len 字节的数据写入文件，返回值表示成功写入的字节数。</td>
</tr>
</tbody>
</table>
</div>
<p>​        QDataStream 类也对<code>&lt;&lt;</code>和<code>&gt;&gt;</code>进行了重载，举个简单的例子，用 QDataStream 重新实现实例二：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;QFile&gt;#include &lt;QDebug&gt;#include &lt;QDataStream&gt;int main(int argc, char *argv[])&#123;    &#x2F;&#x2F;指定要写入文件的数据    qint32 nums[5]&#x3D;&#123;1,2,3,4,5&#125;;    QFile file(&quot;D:&#x2F;demo.dat&quot;);    file.open(QIODevice::WriteOnly);    &#x2F;&#x2F;创建 QDataStream 对象    QDataStream out(&amp;file);    &#x2F;&#x2F;将 nums 数组中的整数逐个写入到二进制文件中    for(int i&#x3D;0;i&lt;5;i++)&#123;      out &lt;&lt; nums[i];    &#125;    file.close();    &#x2F;&#x2F;再次打开文件，读取文件中存储的二进制数据    file.open(QIODevice::ReadOnly);    QDataStream in(&amp;file);    &#x2F;&#x2F;读取二进制文件中的数据    while(!in.atEnd())&#123;        &#x2F;&#x2F;每次读取一个整数        qint32 num;        in &gt;&gt; num;        qDebug() &lt;&lt; num;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        输出结果为：</p>
<pre class="line-numbers language-none"><code class="language-none">1
2
3
4
5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="QFileInfo"><a href="#QFileInfo" class="headerlink" title="QFileInfo"></a>QFileInfo</h2><p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kenfan1647/article/details/120465102">https://blog.csdn.net/kenfan1647/article/details/120465102</a></p>
<p>一、描述<br>        QFileInfo 提供有关文件系统中文件的名称和位置（路径）、访问权限、文件类型等信息。</p>
<p>​        FileInfo 还可用于获取有关 Qt 资源的信息。这个类是隐式共享的。</p>
<p>二、成员函数<br>2.1、判断函数</p>
<pre class="line-numbers language-none"><code class="language-none">1、bool isAbsolute() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>文件路径是否绝对路径。</p>
<p>注意：以冒号 (:) 开头的路径始终被视为绝对路径，因为它们表示 QResource。</p>
<pre class="line-numbers language-none"><code class="language-none">2、bool isBundle() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对象是否指向一个包或指向 macOS 和 iOS 上的包的符号链接。</p>
<pre class="line-numbers language-none"><code class="language-none">3、bool isDir() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对象是否指向目录或指向目录的符号链接。</p>
<pre class="line-numbers language-none"><code class="language-none">4、bool isExecutable() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>文件是否是可执行的。</p>
<p>如果文件是符号链接，并且目标是可执行的，则此函数返回 true。</p>
<pre class="line-numbers language-none"><code class="language-none">5、bool isFile() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对象是否指向文件或指向文件的符号链接。</p>
<p>如果文件是符号链接，并且目标是常规文件，则此函数返回 true。</p>
<pre class="line-numbers language-none"><code class="language-none">6、bool isHidden() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>是否隐藏文件。</p>
<pre class="line-numbers language-none"><code class="language-none">7、bool isJunction() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对象是否指向一个连接点。</p>
<p>连接仅存在于 Windows 的 NTFS 文件系统上，并且通常由 mklink 命令创建。 它们可以被认为是目录的符号链接，并且只能为本地卷上的绝对路径创建。</p>
<pre class="line-numbers language-none"><code class="language-none">8、bool isNativePath() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果文件路径可以直接用于本机 API，则返回 true。 如果 Qt 内的虚拟文件系统（例如 Qt 资源系统）支持该文件，则返回 false。</p>
<p>本机路径可能仍需要转换路径分隔符和字符编码，具体取决于本机 API 的平台和输入要求。</p>
<pre class="line-numbers language-none"><code class="language-none">9、bool isReadable() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用户是否可以读取文件。</p>
<p>如果文件是符号链接，并且目标可读，则此函数返回 true。</p>
<p>注意：如果未启用 NTFS 权限检查，Windows 上的结果将仅反映文件是否存在。</p>
<pre class="line-numbers language-none"><code class="language-none">10、bool isRelative() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>文件路径是否相对的。</p>
<p>注意：以冒号 (:) 开头的路径始终被视为绝对路径，因为它们表示 QResource。</p>
<pre class="line-numbers language-none"><code class="language-none">11、bool isRoot() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对象是否指向根目录或指向根目录的符号链接。</p>
<pre class="line-numbers language-none"><code class="language-none">12、bool isShortcut() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对象是否指向快捷方式。</p>
<p>快捷方式仅存在于 Windows 上，通常是 .lnk 文件。</p>
<p>快捷方式 (.lnk) 文件被视为常规文件。 打开这些将打开 .lnk 文件本身。 为了打开快捷方式引用的文件，必须在快捷方式上使用 symLinkTarget()。</p>
<p>注意：即使快捷方式（损坏的快捷方式）指向不存在的文件，isShortcut() 也会返回 true。</p>
<pre class="line-numbers language-none"><code class="language-none">13、bool isSymLink() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对象是否指向符号链接或快捷方式。</p>
<pre class="line-numbers language-none"><code class="language-none">14、bool isSymbolicLink()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对象是否指向符号链接。</p>
<pre class="line-numbers language-none"><code class="language-none">15、bool isWritable() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用户是否可以写入文件。</p>
<p>如果文件是符号链接，并且目标是可写的，则此函数返回 true。</p>
<p>注意：如果未启用 NTFS 权限检查，Windows 上的结果将仅反映文件是否标记为只读。</p>
<p>2.2、其他函数</p>
<pre class="line-numbers language-none"><code class="language-none">1、QFileInfo(const QDir &amp;dir, const QString &amp;file)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>构造一个 QFileInfo，它提供有关给定file相对于目录 dir 的信息。</p>
<p>如果 dir 是相对路径，则 QFileInfo 也将具有相对路径。<br>如果 file 是绝对路径，则 dir 指定的目录将被忽略。</p>
<pre class="line-numbers language-none"><code class="language-none">QFileInfo(const QString &amp;file)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>构造一个 QFileInfo，提供有关给定文件的信息。该文件可以是绝对或相对路径。</p>
<pre class="line-numbers language-none"><code class="language-none">2、QDir absoluteDir() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>以 QDir 对象的形式返回文件的绝对路径。 </p>
<pre class="line-numbers language-none"><code class="language-none">3、QString absoluteFilePath() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>  std::filesystem::path filesystemAbsoluteFilePath()
</code></pre><p>返回包含文件名的绝对路径。绝对路径名由完整路径和文件名组成。</p>
<p>在 Unix 上，这将始终以根目录“/”开头。<br>在 Windows 上，这将始终以“D:/”开头，其中 D 是驱动器号，但未映射到驱动器号的网络共享除外（在这种情况下，路径将以“//sharename/”开头）。驱动器号将大写。<br>警告：如果 filePath() 为空，则此函数的行为未定义。</p>
<pre class="line-numbers language-none"><code class="language-none">4、QString absolutePath() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">std::filesystem::path filesystemAbsolutePath()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回文件的路径绝对路径。 这不包括文件名。</p>
<p>在 Unix 上，绝对路径将始终以根目录“/”开头。<br>在 Windows 上，这将始终以“D:/”开头，其中 D 是驱动器号，但未映射到驱动器号的网络共享除外（在这种情况下，路径将以“//sharename/”开头）。<br>警告：如果 filePath() 为空，则此函数的行为未定义。</p>
<pre class="line-numbers language-none"><code class="language-none">5、QString baseName() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回不带路径的文件的基本名称。</p>
<pre class="line-numbers language-none"><code class="language-none">6、QDateTime birthTime() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回文件创建的日期和时间。如果文件是符号链接，则返回目标文件的时间。</p>
<pre class="line-numbers language-none"><code class="language-none">7、QString bundleName() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回包的名称。</p>
<p>在 macOS 和 iOS 上，如果路径 isBundle()，这将返回包的正确本地化名称。<br>在其他平台上，返回一个空的 QString。 </p>
<pre class="line-numbers language-none"><code class="language-none">QFileInfo fi(&quot;&#x2F;Applications&#x2F;Safari.app&quot;);
QString bundle &#x3D; fi.bundleName();                &#x2F;&#x2F; name &#x3D; &quot;Safari&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">8、bool caching()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>是否启用了缓存。</p>
<pre class="line-numbers language-none"><code class="language-none">9、QString canonicalFilePath()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>  std::filesystem::path filesystemCanonicalFilePath()
</code></pre><p>返回包含文件名的规范路径。</p>
<pre class="line-numbers language-none"><code class="language-none">10、QString canonicalPath() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>   std::filesystem::path filesystemCanonicalPath()
</code></pre><p>返回文件的路径规范路径（不包括文件名）。</p>
<pre class="line-numbers language-none"><code class="language-none">11、QString completeBaseName() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回不带路径的文件的完整基本名称。</p>
<pre><code>QFileInfo info(&quot;C:/Users/70957/Pictures/aaa.bbb.jpg&quot;);
qDebug()&lt;&lt;info.baseName();
qDebug()&lt;&lt;info.completeBaseName();
</code></pre><pre class="line-numbers language-none"><code class="language-none">12、QString completeSuffix()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回文件的完整后缀（扩展名）。完整的后缀由文件中第一个 ‘.’ 之后的所有字符组成。</p>
<pre class="line-numbers language-none"><code class="language-none">QFileInfo fi(&quot;&#x2F;tmp&#x2F;archive.tar.gz&quot;);
QString ext &#x3D; fi.completeSuffix();  &#x2F;&#x2F; ext &#x3D; &quot;tar.gz&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">13、QDir dir()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>以 QDir 对象的形式返回对象的父目录的路径。</p>
<p>注意：返回的 QDir 总是对应于对象的父目录，即使 QFileInfo 代表一个目录。</p>
<p>对于以下每个 QFileInfo，dir() 返回 QDir“~/examples/191697”。</p>
<pre><code> QFileInfo fileInfo1(&quot;~/examples/191697/.&quot;);
 QFileInfo fileInfo2(&quot;~/examples/191697/..&quot;);
 QFileInfo fileInfo3(&quot;~/examples/191697/main.cpp&quot;);
</code></pre><p>对于以下每个 QFileInfo，dir() 返回 QDir“.”。</p>
<pre><code> QFileInfo fileInfo4(&quot;.&quot;);
 QFileInfo fileInfo5(&quot;..&quot;);
 QFileInfo fileInfo6(&quot;main.cpp&quot;);
</code></pre><pre class="line-numbers language-none"><code class="language-none">14、bool exists()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>文件是否存在。</p>
<p>注意：如果文件是指向不存在文件的符号链接，则返回 false。</p>
<pre><code>   [static] bool exists(const QString &amp;file)
</code></pre><p>使用此静态函数比使用非静态的重载函数进行文件系统访问更快。</p>
<pre class="line-numbers language-none"><code class="language-none">15、QString fileName() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回文件的名称，不包括路径。</p>
<pre><code>QFileInfo info(&quot;C:/Users/70957/Pictures/aaa.bbb.jpg&quot;);
qDebug()&lt;&lt;info.baseName();
qDebug()&lt;&lt;info.completeBaseName();
qDebug()&lt;&lt;info.fileName();
</code></pre><pre class="line-numbers language-none"><code class="language-none">16、QString filePath()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>   std::filesystem::path filesystemFilePath()
</code></pre><p>返回文件名，包括路径。</p>
<pre class="line-numbers language-none"><code class="language-none">17、QDateTime fileTime(QFile::FileTime time) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回时间指定的文件时间。如果文件是符号链接，则返回目标文件的时间。</p>
<p>enum QFileDevice::FileTime：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Enum</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td>FileAccessTime</td>
<td>最近一次访问文件的时间（例如读取或写入）。</td>
</tr>
<tr>
<td>FileBirthTime</td>
<td>创建文件时（在 UNIX 上可能不支持）。</td>
</tr>
<tr>
<td>FileMetadataChangeTime</td>
<td>上次更改文件元数据的时间。</td>
</tr>
<tr>
<td>FileModificationTime</td>
<td>最近一次修改文件的时间。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">18、QString group() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回文件的组。如果文件是符号链接，则此函数返回目标的拥有组。</p>
<p>在 Windows 、文件没有组的系统上返回空字符串。在 Unix 下可能很耗时（毫秒为单位）。</p>
<pre class="line-numbers language-none"><code class="language-none">19、uint groupId() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回文件所属组的 id。如果文件是符号链接，则此函数返回拥有目标的组的 ID（。 </p>
<p>在 Windows 、文件没有组的系统上，此函数始终返回 (uint) -2。</p>
<pre class="line-numbers language-none"><code class="language-none">20、QString junctionTarget() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>   std::filesystem::path filesystemJunctionTarget()
</code></pre><p>将 NTFS 结点解析为它引用的路径。不能保证由 NTFS 联结命名的目录确实存在。</p>
<p>返回 NTFS 连接点指向的目录的绝对路径，如果对象不是 NTFS 连接点，则返回空字符串。</p>
<pre class="line-numbers language-none"><code class="language-none">21、QDateTime lastModified()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回上次修改文件的日期和本地时间。如果文件是符号链接，则返回目标文件的时间。</p>
<pre class="line-numbers language-none"><code class="language-none">22、QDateTime lastRead()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回上次读取文件的日期和本地时间。如果文件是符号链接，则返回目标文件的时间。</p>
<p>在此信息不可用的平台上，返回与 lastModified() 相同的内容。</p>
<pre class="line-numbers language-none"><code class="language-none">23、bool makeAbsolute()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果文件的路径不是绝对路径，则将文件的路径转换为绝对路径。</p>
<p>返回 true 表示路径已转换； 否则返回 false 表示路径已经是绝对路径。</p>
<pre class="line-numbers language-none"><code class="language-none">24、QDateTime metadataChangeTime()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回文件元数据更改的日期和时间。如果文件是符号链接，则返回目标文件的时间。</p>
<pre class="line-numbers language-none"><code class="language-none">25、QString owner() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回文件的所有者。在文件没有所有者的系统上，或者如果发生错误，则返回空字符串。</p>
<p>如果文件是符号链接，则此函数返回目标的所有者。 </p>
<p>这个函数在 Unix 下可能很耗时（毫秒为单位）。</p>
<p>在 Windows 上，除非启用了 NTFS 权限检查，否则它将返回一个空字符串。</p>
<pre class="line-numbers language-none"><code class="language-none">26、uint ownerId()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回文件所有者的 ID。如果文件是符号链接，则此函数返回目标所有者的 ID。</p>
<p>在 Windows 和文件没有所有者的系统上，此函数返回 ((uint) -2)。</p>
<pre class="line-numbers language-none"><code class="language-none">27、QString path() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>    std::filesystem::path filesystemPath() 
</code></pre><p>返回文件的路径。不包括文件名。</p>
<pre class="line-numbers language-none"><code class="language-none">28、bool permission(QFile::Permissions permissions) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>测试文件权限。权限参数可以是多个 QFile::Permissions 类型的标志或一起检查权限组合。</p>
<p>在文件没有权限的系统上，此函数始终返回 true。</p>
<p>注意：如果未启用 NTFS 权限检查，结果在 Windows 上可能不准确。</p>
<p>如果文件是符号链接，则此函数会检查目标的权限。</p>
<pre class="line-numbers language-none"><code class="language-none">enum QFileDevice::Permission：<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        文件的权限和所有权。可以将这些值进行 OR 运算以测试多个权限和所有权值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Enum</th>
<th>Descriptions</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReadOwner：</td>
<td>文件可供所有者读取。</td>
</tr>
<tr>
<td>WriteOwner：</td>
<td>文件可供所有者写入。</td>
</tr>
<tr>
<td>ExeOwner：</td>
<td>文件可供所有者执行。</td>
</tr>
<tr>
<td>ReadUser：</td>
<td>文件可供用户读取。</td>
</tr>
<tr>
<td>WriteUser：</td>
<td>文件可供用户写入。</td>
</tr>
<tr>
<td>ExeUser：</td>
<td>文件可供用户执行。</td>
</tr>
<tr>
<td>ReadGroup：</td>
<td>文件可供组读取。</td>
</tr>
<tr>
<td>WriteGroup：</td>
<td>文件可供组写入。</td>
</tr>
<tr>
<td>ExeGroup：</td>
<td>文件可供组执行。</td>
</tr>
<tr>
<td>ReadOther：</td>
<td>文件可供任何人读取。</td>
</tr>
<tr>
<td>WriteOther：</td>
<td>文件可供任何人写入。</td>
</tr>
<tr>
<td>ExeOther</td>
<td>文件可供任何人执行。</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-none"><code class="language-none">29、QFile::Permissions permissions()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回文件的 QFile::Permissions 的完整 OR 组合。</p>
<p>如果文件是符号链接，则此函数返回目标（而不是符号链接）的权限。</p>
<pre class="line-numbers language-none"><code class="language-none">30、void refresh()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>刷新有关文件的信息，即在下次获取缓存属性时从文件系统中读取信息。 </p>
<pre class="line-numbers language-none"><code class="language-none">31、void setCaching(bool enable)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>设置是否启用文件信息的缓存。默认情况下启用缓存。 </p>
<p>启用缓存后，将会首次在需要时从文件系统读取文件信息，之后从缓存中读取文件信息。</p>
<pre class="line-numbers language-none"><code class="language-none">32、void setFile(const QString &amp;file)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>    void setFile(const std::filesystem::path &amp;file)
</code></pre><p>设置 QFileInfo 提供有关文件的信息的文件。</p>
<p>文件可以包括绝对或相对路径。绝对路径以目录分隔符（例如 Unix 下的“/”）或驱动器规范（Windows 下）开头。 相对文件名以目录名或文件名开头，并指定相对于当前目录的路径。</p>
<pre class="line-numbers language-none"><code class="language-none">QString absolute &#x3D; &quot;&#x2F;local&#x2F;bin&quot;;
  QString relative &#x3D; &quot;local&#x2F;bin&quot;;
  QFileInfo absFile(absolute);
  QFileInfo relFile(relative);

  QDir::setCurrent(QDir::rootPath());
  &#x2F;&#x2F; absFile 和 relFile 现在指向同一个文件

  QDir::setCurrent(&quot;&#x2F;tmp&quot;);
  &#x2F;&#x2F; absFile 现在指向“&#x2F;local&#x2F;bin”，
  &#x2F;&#x2F; 而 relFile 指向“&#x2F;tmp&#x2F;local&#x2F;bin”
       void setFile(const QDir &amp;dir, const QString &amp;file)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>设置 QFileInfo 为目录 dir 中的 file 提供信息的文件。</p>
<p>如果 file 包含相对路径，则 QFileInfo 也将具有相对路径。</p>
<pre class="line-numbers language-none"><code class="language-none">33、qint64 size()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>以字节为单位返回文件大小。如果文件不存在或无法获取，则返回 0。</p>
<p>如果文件是符号链接，则返回目标文件的大小。 </p>
<pre class="line-numbers language-none"><code class="language-none">34、void stat()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>从文件系统中读取所有属性并缓存。</p>
<p>当有关文件系统的信息在工作线程中收集，然后以缓存 QFileInfo 实例的形式传递给 UI 时，这很有用。</p>
<p><img src="2021092513423551.png" alt="img"></p>
<pre class="line-numbers language-none"><code class="language-none">35、QString suffix() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>返回文件的后缀（扩展名）。后缀由文件中最后一个“.”之后的所有字符组成。</p>
<pre class="line-numbers language-none"><code class="language-none">36、QString symLinkTarget() <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>    std::filesystem::path filesystemSymLinkTarget()
</code></pre><p>返回符号链接指向的文件或目录的绝对路径，如果对象不是符号链接，则返回空字符串。</p>
<pre class="line-numbers language-none"><code class="language-none">37、bool operator&#x3D;&#x3D;(const QFileInfo &amp;fileinfo) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此 QFileInfo 对象是否引用与 fileinfo 位于同一位置的文件。</p>
<p>请注意，比较两个不包含文件引用（不存在或为空的文件路径）的空 QFileInfo 对象的结果是未定义的。</p>
<p>三、宏成员</p>
<pre class="line-numbers language-none"><code class="language-none">1、QT_IMPLICIT_QFILEINFO_CONSTRUCTION<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>定义这个宏会使大多数 QFileInfo 构造函数隐式而不是显式。由于 QFileInfo 对象的构建成本很高，因此应避免意外创建它们。例如：</p>
<pre><code>QDir dir(&quot;D:/迅雷下载&quot;);
QDirIterator it(dir);
while (it.hasNext())
&#123;
    QFileInfo fi = it.next();
    qDebug()&lt;&lt;fi.fileName();
&#125;
</code></pre><p>默认情况下，会报错：试图将QString转成QFileInfo：</p>
<p><img src="2021092514073295.png" alt="img"></p>
<p>在 pro 文件中加入：</p>
<p>DEFINES += QT_IMPLICIT_QFILEINFO_CONSTRUCTION<br>则可编译通过。</p>
<p>要避免隐式构造 QFileInfo 对象的代价，应该不要使用这个宏。</p>
<p>同时，这里正确获取 QFileInfo 对象的方法：</p>
<p><img src="20210925141326177.png" alt="img"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/06/06/Learn-Qt-I/">http://charliechen114514.github.io/2023/06/06/Learn-Qt-I/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Qt/">Qt</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/06/Learn-ROS-I/" title="Learn_ROS-I"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Learn_ROS-I</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/06/Learn-Windows-API-Semester-I/" title="Learn_Windows_API-Semester-I"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Learn_Windows_API-Semester-I</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/07/DeepLearningQt-ReadingDocuments1/" title="DeepLearningQt-ReadingDocuments1"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="title">DeepLearningQt-ReadingDocuments1</div></div></a></div><div><a href="/2023/02/09/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89string-h%E7%B3%BB%E5%88%97/" title="C语言常用函数（1）string.h系列"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="title">C语言常用函数（1）string.h系列</div></div></a></div><div><a href="/2023/04/17/High-Quality-of-C-Cpp-programming-in-formats-1/" title="High Quality of C_Cpp programming in formats(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-17</div><div class="title">High Quality of C_Cpp programming in formats(1)</div></div></a></div><div><a href="/2023/06/06/Algorithm-in-C-1/" title="Algorithm_in_C(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_in_C(1)</div></div></a></div><div><a href="/2023/06/06/Opencv-learning-CPP/" title="Opencv_learning_CPP"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Opencv_learning_CPP</div></div></a></div><div><a href="/2023/06/06/CPP-ExtensiveReadingNotes-1-EssentialCPP/" title="CPP_ExtensiveReadingNotes-1-EssentialCPP"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">CPP_ExtensiveReadingNotes-1-EssentialCPP</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E5%BC%80%E5%8F%91-%E5%88%9D%E6%8E%A2"><span class="toc-number">1.</span> <span class="toc-text">QT开发-初探</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E7%9C%8B%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">看看工程文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E7%9C%8B%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8Cwidget-cpp"><span class="toc-number">1.2.</span> <span class="toc-text">看看头文件和widget.cpp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">1.3.</span> <span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE"><span class="toc-number">1.4.</span> <span class="toc-text">创建一个按钮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QT%E5%AF%B9%E8%B1%A1%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">QT对象树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QT-%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">1.6.</span> <span class="toc-text">QT 坐标系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.</span> <span class="toc-text">信号与槽的基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A7%BD%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%E7%89%88%E6%9C%AC"><span class="toc-number">1.8.</span> <span class="toc-text">槽函数的重载版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A4%E4%BA%BA%E6%81%BC%E7%81%AB%E7%9A%84%E6%98%AF%EF%BC%9A"><span class="toc-number">1.9.</span> <span class="toc-text">令人恼火的是：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E4%B8%80%E7%82%B9%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD"><span class="toc-number">1.10.</span> <span class="toc-text">高级一点的信号与槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E9%93%BE%E6%8E%A5"><span class="toc-number">1.11.</span> <span class="toc-text">断开链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.12.</span> <span class="toc-text">补充Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0"><span class="toc-number">1.12.1.</span> <span class="toc-text">1.函数对象参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QMainWindow"><span class="toc-number">2.</span> <span class="toc-text">QMainWindow</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="toc-number">2.1.</span> <span class="toc-text">工具栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A0%8F"><span class="toc-number">2.2.</span> <span class="toc-text">状态栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">添加资源文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">2.4.</span> <span class="toc-text">对话框</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">3.</span> <span class="toc-text">消息对话框</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86-1"><span class="toc-number">3.1.</span> <span class="toc-text">消息对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E7%AA%97%E5%8F%A3%E7%95%8C%E9%9D%A2%E5%B8%83%E5%B1%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.</span> <span class="toc-text">登录窗口界面布局介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QListWidget%E7%A9%BA%E9%97%B4"><span class="toc-number">3.3.</span> <span class="toc-text">QListWidget空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QListWidget"><span class="toc-number">3.3.1.</span> <span class="toc-text">QListWidget</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%9D%A1%E7%9B%AE%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">1）添加条目的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">（2）删除函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9D%A1%E7%9B%AE%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">（3）条目访问函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%BD%93%E5%89%8D%E9%80%89%E4%B8%AD%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.7.</span> <span class="toc-text">（4）当前选中条目的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">3.8.</span> <span class="toc-text">（5）条目查找和排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%98%BE%E7%A4%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%A1%E7%9B%AE%E7%BC%96%E8%BE%91"><span class="toc-number">3.9.</span> <span class="toc-text">（6）条目显示和运行时条目编辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%85%B6%E4%BB%96%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E5%87%BD%E6%95%B0"><span class="toc-number">3.10.</span> <span class="toc-text">（7）其他信号和槽函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E4%B8%BB%E8%A6%81%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">一些主要控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">主要控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QTreeWidget"><span class="toc-number">4.1.1.</span> <span class="toc-text">QTreeWidget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-QTreeWidget"><span class="toc-number">4.1.2.</span> <span class="toc-text">8.3.1 QTreeWidget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%880%EF%BC%89%E6%A0%91%E5%BD%A2%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%9A"><span class="toc-number">4.1.3.</span> <span class="toc-text">（0）树形控件的构造函数很简单：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B7%BB%E5%8A%A0%E5%92%8C%E8%AE%BF%E9%97%AE%E9%A1%B6%E7%BA%A7%E6%9D%A1%E7%9B%AE"><span class="toc-number">4.1.4.</span> <span class="toc-text">（1）添加和访问顶级条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A7%BB%E9%99%A4%E9%A1%B6%E7%BA%A7%E6%9D%A1%E7%9B%AE"><span class="toc-number">4.1.5.</span> <span class="toc-text">（2）移除顶级条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9D%A1%E7%9B%AE%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0-1"><span class="toc-number">4.1.6.</span> <span class="toc-text">（3）条目访问函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%BD%93%E5%89%8D%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.7.</span> <span class="toc-text">（4）当前条目的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F-1"><span class="toc-number">4.1.8.</span> <span class="toc-text">（5）条目查找和排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%98%BE%E7%A4%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%A1%E7%9B%AE%E7%BC%96%E8%BE%91-1"><span class="toc-number">4.1.9.</span> <span class="toc-text">（6）条目显示和运行时条目编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E4%BF%A1%E5%8F%B7"><span class="toc-number">4.1.10.</span> <span class="toc-text">（7）信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E6%A7%BD%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.11.</span> <span class="toc-text">（8）槽函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%889%EF%BC%89%E5%9F%BA%E7%B1%BB-QTreeView-%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.12.</span> <span class="toc-text">（9）基类 QTreeView 的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89%E6%A0%91%E5%A4%B4%E6%9D%A1%E7%9B%AE"><span class="toc-number">4.1.13.</span> <span class="toc-text">（10）树头条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89%E9%80%89%E4%B8%AD%E8%A1%8C%E4%B8%BA%E5%92%8C%E9%80%89%E4%B8%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.14.</span> <span class="toc-text">（11）选中行为和选中模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QTableWidget"><span class="toc-number">4.2.</span> <span class="toc-text">QTableWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.3.</span> <span class="toc-text">详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QTableWidgetItem"><span class="toc-number">4.4.</span> <span class="toc-text">QTableWidgetItem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A6%96%E5%85%88%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">4.4.1.</span> <span class="toc-text">（1）首先来看看条目的构造函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A4%8D%E5%88%B6%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.2.</span> <span class="toc-text">（2）复制函数和运算符函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89QTableWidgetItem-%E7%9A%84%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">4.4.3.</span> <span class="toc-text">（3）QTableWidgetItem 的功能函数与内部数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%80%E8%A7%88"><span class="toc-number">4.5.</span> <span class="toc-text">其他常见的控件一览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.5.1.</span> <span class="toc-text">滚动条控件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ToolBox"><span class="toc-number">4.5.2.</span> <span class="toc-text">ToolBox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tab-Widget"><span class="toc-number">4.5.3.</span> <span class="toc-text">Tab Widget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8QLable%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87"><span class="toc-number">4.5.4.</span> <span class="toc-text">利用QLable显示图片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.6.</span> <span class="toc-text">自定义控件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QEvent"><span class="toc-number">4.7.</span> <span class="toc-text">QEvent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt-Event%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.8.</span> <span class="toc-text">Qt Event事件详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91%EF%BC%9Aevent%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.1.</span> <span class="toc-text">二、事件的分发：event函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Even-Filter%EF%BC%89"><span class="toc-number">4.8.2.</span> <span class="toc-text">三、事件过滤器（Even Filter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">4.8.3.</span> <span class="toc-text">四、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%EF%BC%88QMouseEvent%EF%BC%89"><span class="toc-number">4.9.</span> <span class="toc-text">鼠标事件（QMouseEvent）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA-%E5%9C%A8label%E6%8E%A7%E4%BB%B6%E4%B8%AD%EF%BC%8C%E7%A7%BB%E5%8A%A8%E9%BC%A0%E6%A0%87%E8%8E%B7%E5%8F%96%E5%AE%9E%E6%97%B6%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%B9%B6%E6%98%BE%E7%A4%BA%E5%9C%A8%E7%95%8C%E9%9D%A2%E4%B8%8A"><span class="toc-number">4.9.1.</span> <span class="toc-text">实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8-Even-Filter"><span class="toc-number">4.9.2.</span> <span class="toc-text">三，事件过滤器(Even Filter)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">4.10.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.11.</span> <span class="toc-text">类的形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extensive-Reading"><span class="toc-number">4.12.</span> <span class="toc-text">Extensive Reading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%98%E5%9B%BE%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.13.</span> <span class="toc-text">绘图事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%BB%E5%9B%BE"><span class="toc-number">4.14.</span> <span class="toc-text">画图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extensive-Reading-I"><span class="toc-number">4.15.</span> <span class="toc-text">Extensive Reading I</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81QPaintEvent-%E7%BB%98%E5%9B%BE%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.15.1.</span> <span class="toc-text">一、QPaintEvent 绘图事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81paintEvent-%E5%87%BD%E6%95%B0"><span class="toc-number">4.15.1.1.</span> <span class="toc-text">1、paintEvent 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BB%98%E5%9B%BE%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">4.15.1.2.</span> <span class="toc-text">2、绘图函数的调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81QPainter%E5%9F%BA%E7%A1%80"><span class="toc-number">4.15.2.</span> <span class="toc-text">二、QPainter基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-number">4.15.2.1.</span> <span class="toc-text">1、简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.15.2.2.</span> <span class="toc-text">2、常用接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81QPaintEvent-%E7%BB%98%E5%9B%BE%E4%BA%8B%E4%BB%B6-1"><span class="toc-number">4.15.3.</span> <span class="toc-text">一、QPaintEvent 绘图事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81QPainter%E5%9F%BA%E7%A1%80-1"><span class="toc-number">4.15.4.</span> <span class="toc-text">二、QPainter基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8"><span class="toc-number">4.15.5.</span> <span class="toc-text">三、基本应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8-1"><span class="toc-number">4.15.6.</span> <span class="toc-text">三、基本应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%AE%BE%E7%BD%AE%E7%94%BB%E7%AC%94%E6%A0%B7%E5%BC%8F-setPen-%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.15.6.1.</span> <span class="toc-text">1、设置画笔样式 setPen 有三种方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qrect%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="toc-number">4.16.</span> <span class="toc-text">Qrect详细说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%88%E7%8E%B0"><span class="toc-number">4.17.</span> <span class="toc-text">呈现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%90%E6%A0%87"><span class="toc-number">4.18.</span> <span class="toc-text">坐标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">4.19.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.19.1.</span> <span class="toc-text">成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QRect"><span class="toc-number">4.19.1.1.</span> <span class="toc-text">QRect</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QPoint%E7%B1%BB"><span class="toc-number">4.20.</span> <span class="toc-text">QPoint类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-number">4.21.</span> <span class="toc-text">公有成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">4.22.</span> <span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QPoint%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.23.</span> <span class="toc-text">QPoint详细描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%96%87%E6%A1%A3"><span class="toc-number">4.24.</span> <span class="toc-text">成员函数文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0-1"><span class="toc-number">4.25.</span> <span class="toc-text">相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QPen"><span class="toc-number">4.26.</span> <span class="toc-text">QPen</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#enum-Qt-PenJoinStyle"><span class="toc-number">4.26.0.1.</span> <span class="toc-text">enum Qt::PenJoinStyle</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99QFile"><span class="toc-number">4.27.</span> <span class="toc-text">文件读写QFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Extensive-Reading-1"><span class="toc-number">4.27.1.</span> <span class="toc-text">Extensive Reading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QFile%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">4.27.2.</span> <span class="toc-text">QFile文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QFile-QTextStream"><span class="toc-number">4.27.2.1.</span> <span class="toc-text">QFile+QTextStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QFile-QDataStream"><span class="toc-number">4.27.2.2.</span> <span class="toc-text">QFile+QDataStream</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QFileInfo"><span class="toc-number">4.28.</span> <span class="toc-text">QFileInfo</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/25/Net-Experience-report-Using-STMP2SendAEmail/" title="Net-Experience-report Using_STMP2SendAEmail"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Net-Experience-report Using_STMP2SendAEmail"/></a><div class="content"><a class="title" href="/2023/07/25/Net-Experience-report-Using-STMP2SendAEmail/" title="Net-Experience-report Using_STMP2SendAEmail">Net-Experience-report Using_STMP2SendAEmail</a><time datetime="2023-07-25T02:27:52.000Z" title="发表于 2023-07-25 10:27:52">2023-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/13/%E5%8A%A8%E6%89%8B%E6%95%B4%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%8E%A9%E7%8E%A9%EF%BC%881%EF%BC%89/" title="动手整一个操作系统玩玩（1）"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="动手整一个操作系统玩玩（1）"/></a><div class="content"><a class="title" href="/2023/07/13/%E5%8A%A8%E6%89%8B%E6%95%B4%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%8E%A9%E7%8E%A9%EF%BC%881%EF%BC%89/" title="动手整一个操作系统玩玩（1）">动手整一个操作系统玩玩（1）</a><time datetime="2023-07-13T14:41:56.000Z" title="发表于 2023-07-13 22:41:56">2023-07-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/01/LearnCPP-English/" title="LearnCPP (English)"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LearnCPP (English)"/></a><div class="content"><a class="title" href="/2023/07/01/LearnCPP-English/" title="LearnCPP (English)">LearnCPP (English)</a><time datetime="2023-07-01T11:50:41.000Z" title="发表于 2023-07-01 19:50:41">2023-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/07/DeepLearningQt-ReadingDocuments1/" title="DeepLearningQt-ReadingDocuments1"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DeepLearningQt-ReadingDocuments1"/></a><div class="content"><a class="title" href="/2023/06/07/DeepLearningQt-ReadingDocuments1/" title="DeepLearningQt-ReadingDocuments1">DeepLearningQt-ReadingDocuments1</a><time datetime="2023-06-07T03:29:02.000Z" title="发表于 2023-06-07 11:29:02">2023-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/ModernCPP-SmartPointer/" title="ModernCPP-SmartPointer"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ModernCPP-SmartPointer"/></a><div class="content"><a class="title" href="/2023/06/06/ModernCPP-SmartPointer/" title="ModernCPP-SmartPointer">ModernCPP-SmartPointer</a><time datetime="2023-06-06T15:00:39.000Z" title="发表于 2023-06-06 23:00:39">2023-06-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>