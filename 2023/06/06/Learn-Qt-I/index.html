<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Learn_Qt-I | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="QT开发-初探​    注意创建工程路径的时候不要不要不要整到含有中文的路径！ ​        我们下载了 QT 之后，创建信息之后，会发现有三个类： 1）QWeidge 作为父类 2）QMainWindows子类 3）QDialog子类 2，3是1的子类  ​        可以看到，有一个.pro文件，跟VS文件是一样的，他是一个工程文件！  ​        这是一个工程的目录 ​">
<meta property="og:type" content="article">
<meta property="og:title" content="Learn_Qt-I">
<meta property="og:url" content="http://charliechen114514.github.io/2023/06/06/Learn-Qt-I/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="QT开发-初探​    注意创建工程路径的时候不要不要不要整到含有中文的路径！ ​        我们下载了 QT 之后，创建信息之后，会发现有三个类： 1）QWeidge 作为父类 2）QMainWindows子类 3）QDialog子类 2，3是1的子类  ​        可以看到，有一个.pro文件，跟VS文件是一样的，他是一个工程文件！  ​        这是一个工程的目录 ​">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-06-06T14:45:12.000Z">
<meta property="article:modified_time" content="2023-06-06T15:04:36.818Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Qt">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/06/06/Learn-Qt-I/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Learn_Qt-I',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-06 23:04:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Learn_Qt-I</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-06T14:45:12.000Z" title="发表于 2023-06-06 22:45:12">2023-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-06T15:04:36.818Z" title="更新于 2023-06-06 23:04:36">2023-06-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Learn_Qt-I"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="QT开发-初探"><a href="#QT开发-初探" class="headerlink" title="QT开发-初探"></a>QT开发-初探</h1><p>​    注意创建工程路径的时候不要不要不要整到含有中文的路径！</p>
<p>​        我们下载了 QT 之后，创建信息之后，会发现有三个类：</p>
<p>1）QWeidge 作为父类</p>
<p>2）QMainWindows子类</p>
<p>3）QDialog子类</p>
<p>2，3是1的子类</p>
<p><img src="image-20230228192413374.png" alt="image-20230228192413374"></p>
<p>​        可以看到，有一个.pro文件，跟VS文件是一样的，他是一个工程文件！</p>
<p><img src="image-20230228192501749.png" alt="image-20230228192501749"></p>
<p>​        这是一个工程的目录</p>
<p>​        先看主要的显示文件：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;
#include &lt;QApplication&gt; &#x2F;&#x2F; 包含一个应用程序类的文件

&#x2F;&#x2F;argc 命令行变量的数量， *argv[] 是命令行变量的数组
int main(int argc, char *argv[])
&#123;
    &#x2F;&#x2F;应用程序对象，再QT中方，应用程序对像只有一个
    QApplication a(argc, argv);
    
    &#x2F;&#x2F;窗口对象， widget- 父类 -&gt; QWedget
    Widget w;
    &#x2F;&#x2F; 显示窗口
    w.show();

    &#x2F;&#x2F; 让应用程序对象进入消息循环
    return a.exec();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个循环可以被类比成如下的C程序：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;conio.h&gt;
int main()
&#123;
	while(_get() &#x3D;&#x3D; &#39; &#39;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这里，是点击窗口’ X ‘来关闭！</p>
<h2 id="看看工程文件"><a href="#看看工程文件" class="headerlink" title="看看工程文件"></a>看看工程文件</h2><p>​        工程文件自身可以在QT里打开：</p>
<p><img src="image-20230228193538543.png" alt="image-20230228193538543"></p>
<p>​        点击 1.pro 文件，可以看到如下的内容</p>
<p><img src="image-20230228193615493.png" alt="image-20230228193615493"></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">#<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
# <span class="token comment">//工程创建时间</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">Project created by QtCreator <span class="token number">2023</span><span class="token operator">-</span><span class="token number">02</span><span class="token operator">-</span><span class="token number">28</span>T19<span class="token operator">:</span><span class="token number">15</span><span class="token operator">:</span><span class="token number">11</span></span></span>
#
#<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>

QT       <span class="token operator">+=</span> core gui <span class="token comment">// 包含的模块（1）</span>

<span class="token function">greaterThan</span><span class="token punctuation">(</span>QT_MAJOR_VERSION<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">:</span> QT <span class="token operator">+=</span> widgets <span class="token comment">// 大于这个版本才添加模块</span>

TARGET <span class="token operator">=</span> <span class="token number">1</span> <span class="token comment">// 目标 生成的.exe文件的名字（2）不满意名字可以自行更换</span>
TEMPLATE <span class="token operator">=</span> app <span class="token comment">//模板</span>

<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">The following define makes your compiler emit warnings <span class="token keyword">if</span> you use</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">any</span> <span class="token expression">feature of Qt which as been marked as <span class="token function">deprecated</span> <span class="token punctuation">(</span>the exact warnings</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">depend</span> <span class="token expression">on your compiler<span class="token punctuation">)</span><span class="token punctuation">.</span> Please consult the documentation of the</span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">deprecated</span> <span class="token expression">API in order to know how to port your code away from it<span class="token punctuation">.</span></span></span>
DEFINES <span class="token operator">+=</span> QT_DEPRECATED_WARNINGS

<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">You can also make your code fail to compile <span class="token keyword">if</span> you use deprecated APIs<span class="token punctuation">.</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">In order to <span class="token keyword">do</span> so<span class="token punctuation">,</span> uncomment the following line<span class="token punctuation">.</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token expression">You can also select to disable deprecated APIs only up to a certain version of Qt<span class="token punctuation">.</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">DEFINES <span class="token operator">+=</span> QT_DISABLE_DEPRECATED_BEFORE<span class="token operator">=</span><span class="token number">0x060000</span>    # disables all the APIs deprecated before Qt <span class="token number">6.0</span><span class="token number">.0</span></span></span>


SOURCES <span class="token operator">+=</span> \
        main<span class="token punctuation">.</span>cpp \ <span class="token comment">//源文件</span>
        widget<span class="token punctuation">.</span>cpp

HEADERS <span class="token operator">+=</span> \
        widget<span class="token punctuation">.</span>h <span class="token comment">// 头文件</span>

FORMS <span class="token operator">+=</span> \
        widget<span class="token punctuation">.</span>ui<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（1）：</p>
<p><img src="image-20230228193822499.png" alt="image-20230228193822499"></p>
<p>（2）那个exe文件在这里：打开你的工程目录，返回上级会发现：</p>
<p><img src="image-20230228194240791.png" alt="image-20230228194240791"></p>
<p>点击下面的文件夹</p>
<p><img src="image-20230228194256086.png" alt="image-20230228194256086"></p>
<p>点击 debug</p>
<p><img src="image-20230228194315627.png" alt="image-20230228194315627"></p>
<p>就在这里的 1.exe</p>
<h2 id="看看头文件和widget-cpp"><a href="#看看头文件和widget-cpp" class="headerlink" title="看看头文件和widget.cpp"></a>看看头文件和widget.cpp</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef WIDGET_H
#define WIDGET_H

#include &lt;QWidget&gt;

namespace Ui &#123;
class Widget;
&#125;

class Widget : public QWidget
&#123;
    Q_OBJECT &#x2F;&#x2F; 允许类中使用信号和槽的宏，不要轻易改动

public:
    explicit Widget(QWidget *parent &#x3D; 0);&#x2F;&#x2F; 默认构造函数
    ~Widget();

private:
    Ui::Widget *ui;
&#125;;

#endif &#x2F;&#x2F; WIDGET_H
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>​        类名：首字母大写，单词与单词之间首字母大写</p>
<p>​        函数名，变量名称：首字母小写，但单词与单词之间首字母大写</p>
<p>​        快捷键一览：</p>
<p>​        注释：ctrl + /</p>
<p>​        运行：ctrl + r</p>
<p>​        编译：ctrl + b</p>
<p>​        查找：ctrl + f</p>
<p>​        整行移动：ctrl + shift + ↑ 或者 ↓</p>
<p>​        自动对齐：ctrl + i</p>
<p>​        同名的.cpp 和 .h: F4</p>
<h2 id="创建一个按钮"><a href="#创建一个按钮" class="headerlink" title="创建一个按钮"></a>创建一个按钮</h2><p>​        我们查询帮助文档，得到这些信息</p>
<pre class="line-numbers language-none"><code class="language-none">QPushButton Class
The QPushButton widget provides a command button. More...

Header:
#include &lt;QPushButton&gt; 
qmake:
QT +&#x3D; widgets
Inherits:
QAbstractButton
Inherited By:
QCommandLinkButton<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        当然要留意是什么模块，如果 pro 文件里没有，那需要我们手动添加，在</p>
<p><img src="image-20230301221926786.png" alt="image-20230301221926786"></p>
<p>​        的QT += 处 添加模块。</p>
<p>​        当然可以看看函数的功能</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">QPushButton</span><span class="token punctuation">(</span>QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span>

<span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span>

<span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token keyword">const</span> QIcon <span class="token operator">&amp;</span>icon<span class="token punctuation">,</span> <span class="token keyword">const</span> QString <span class="token operator">&amp;</span>text<span class="token punctuation">,</span> QWidget <span class="token operator">*</span>parent <span class="token operator">=</span> Q_NULLPTR<span class="token punctuation">)</span>

<span class="token operator">~</span><span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

bool 
<span class="token function">autoDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>

bool 
<span class="token function">isDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>

bool 
<span class="token function">isFlat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>

QMenu <span class="token operator">*</span>
<span class="token function">menu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>

<span class="token keyword">void</span> 
<span class="token function">setAutoDefault</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span>

<span class="token keyword">void</span> 
<span class="token function">setDefault</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span>

<span class="token keyword">void</span> 
<span class="token function">setFlat</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span>

<span class="token keyword">void</span> 
<span class="token function">setMenu</span><span class="token punctuation">(</span>QMenu <span class="token operator">*</span>menu<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        于是可以在 widget.cpp 中书写如下代码：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include&lt;QPushButton&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    QPushButton* btn &#x3D; new QPushButton;
    btn-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点

    btn-&gt;setText(&quot;hello world&quot;);
&#125;

Widget::~Widget()
&#123;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230301222534315.png" alt="image-20230301222534315"></p>
<p>​        如果我们重新设置一下窗口大小，那就</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> Height<span class="token punctuation">,</span><span class="token keyword">int</span> Width<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        但是如果我们直接创建第二个按钮，那就会覆盖第一个，那怎么办？使用 move 方法！</p>
<pre class="line-numbers language-none"><code class="language-none">btn-&gt;move(int x_pos,int y_pos)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当然啊，我们可以设置窗口的名字：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">setWindowTitle(&quot;My first windows&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        以及可以固定窗口大小：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">setFixedSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> Height<span class="token punctuation">,</span><span class="token keyword">int</span> Width<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230301223238957.png" alt="image-20230301223238957"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;
#include&lt;QPushButton&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    QPushButton* btn &#x3D; new QPushButton;
    btn-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点

    btn-&gt;setText(&quot;hello world&quot;);
    QPushButton* btn2 &#x3D; new QPushButton;
    btn2-&gt;setParent(this); &#x2F;&#x2F; 需要设置窗口对象作为对象书的叶子节点
    btn2-&gt;move(100,100);
    setWindowTitle(&quot;My first Window&quot;);
    resize(600,400);
    setFixedSize(600,400);
&#125;

Widget::~Widget()
&#123;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="QT对象树"><a href="#QT对象树" class="headerlink" title="QT对象树"></a>QT对象树</h2><p>​        我们发现，程序结束后，不需要一个一个手动的释放对象，这是因为，我们调用构造函数指定了一个Parent父对象，其父对象会把我们自己搞的子对象挂到对象树上，</p>
<p><img src="image-20230411202327161.png" alt="image-20230411202327161"></p>
<p>​        （补充：一个类创建时需要调用一个函数来构造初始化这个类，这叫构造函数。当类的什么周期结束时需要调用一个删除函数，释放类占用的空间，这叫析构函数。类默认有这两个函数）于是在QT中只要指定好父对象就会帮助管理！不需要我们手动释放，很是方便</p>
<p>​        现在，我们来创建一个新类：MyPushBtn</p>
<p>​        右键工程-&gt; 添加新文件-&gt;C++ Class -&gt;选择 QWedget就好了。</p>
<p>​        随后，就发现多了一些文件</p>
<p><img src="image-20230411203853556.png" alt="image-20230411203853556"></p>
<p>​        pro文件下多了我们自己定义的类的cpp文件和头文件</p>
<p><img src="image-20230411204458973.png" alt="image-20230411204458973"></p>
<p><img src="image-20230411204545650.png" alt="image-20230411204545650"></p>
<p>​        现在我们调一下自己写的：</p>
<p><img src="image-20230411205908628.png" alt="image-20230411205908628"></p>
<p>​        可以看到我们自己的按钮产生了！</p>
<h2 id="QT-坐标系"><a href="#QT-坐标系" class="headerlink" title="QT 坐标系"></a>QT 坐标系</h2><p>​        QT的坐标原点在窗口的最左上角，这是值得注意的一点，同时：X向右增大，向左减小，而Y 向下增大，向上减小。对于嵌套窗口，则是以父窗口为例子的！</p>
<p>​        </p>
<h2 id="信号与槽的基础概念"><a href="#信号与槽的基础概念" class="headerlink" title="信号与槽的基础概念"></a>信号与槽的基础概念</h2><p>​        我们现在开始关联我们的行为和效果！比若说：我希望点击按钮后就帮我关闭窗口！于是</p>
<p><img src="image-20230412232937449.png" alt="image-20230412232937449"></p>
<p>​        这就是我们分解完后发现就是这样的，现在开始关联他们：</p>
<p>​        英语里：connect就是连接的，结合上图发现，想要表达一个链接，无非就是：</p>
<pre class="line-numbers language-none"><code class="language-none">connect(sender, sendSignal, receiver, slogAsActionReact)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        注意了：注意！我们点击按钮，不一定是去关闭窗口，而窗口关闭了不一定时我点击了按钮导致的</p>
<p>​        于是，信号槽的优点就是：松散耦合的！他们之间本来没啥关联！但是现在我们直接用connect函数来耦合在一起！</p>
<p>​        QT里，就是connect函数完成我们的工作！先来看发送者：按钮！那信号呢？</p>
<p><img src="image-20230412233514694.png" alt="image-20230412233514694"></p>
<p>​        于是找到一个信号clicked. </p>
<p><img src="image-20230412233547084.png" alt="image-20230412233547084"></p>
<p>​        所以传入一个函数的地址！&amp;QPushButton::clicked</p>
<p>​        接收者同理！：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">connect(mine, &amp;QPushButton::clicked,this,&amp;QWidget::close);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这一思想十分重要！还是需要好好消化！</p>
<p>​        现在尝试自己来书写两个类，来建立相应的关系！</p>
<p>​        现在构建程序如下：</p>
<p>​        在最大工程文件之下添加两个类！，首先是 Teacher类。 随后是学生类。假设这一场景！老师要求学生交作业！学生听到老师的要求来拿出作业，老师看到学生拿出作业之后再上前收取。这个行为我们使用 QT 的槽与信号来完成我们的实现。</p>
<p>​        选择新建两个类： Student 和 Teacher. 注意到为了能够使用 QT系统的一些性质，有必要来选择继承QT类。</p>
<p>​        当我们完成了新建，马上就发现，它同我们所想象的不太一样！</p>
<p><img src="image-20230414145816352.png" alt="image-20230414145816352"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef TEACHER_H
#define TEACHER_H

#include &lt;QObject&gt;

class Teacher : public QObject &#x2F;&#x2F; QObject 是 Teacher 的一个基类
&#123;
    Q_OBJECT &#x2F;&#x2F; 这是QObject宏，声明启用Slot - Signals关系的
public:
    explicit Teacher(QObject *parent &#x3D; nullptr);
    
    &#x2F;&#x2F; 只有在有 Q_OBJECT下才生效
signals:
	&#x2F;&#x2F; 我们在这里书写 signals 作为信号函数
public slots:
    
    &#x2F;&#x2F; 我们在这里书写 slots 作为响应信号的槽函数
&#125;;

#endif &#x2F;&#x2F; TEACHER_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意到我们在这里完成槽函数和信号函数的书写！</p>
<p>​        以及这里需要提醒的是：槽函数在这里是一个实现的占位函数，这是在底层的文件中，QT为我们实现了函数了，不要在定义实现文件里再次定义信号函数，否则会发生报错。</p>
<p>​        但是，槽函数需要实现，这是需要在实现文件里自己重写的！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void student::reactions()&#123;

	qDebug() &lt;&lt; &quot;Yep, I think I will help you!&quot;;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        书写完响应之后，我们现在可以来干活了（在Widget.cpp）</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include&quot;student.h&quot;
#include&quot;teacher.h&quot;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;

    Teacher* t &#x3D; new Teacher(this);
    student* s &#x3D; new student(this);
	
    &#x2F;&#x2F; 这里是链接信号和槽，但是这又这样是不行的，英文不是所有的这个函数都是信号，只有当我们认为指定他是信号的时候才需要出发槽函数
    connect(t,&amp;Teacher::announceHungry,s,&amp;s-&gt;reactions);
	&#x2F;&#x2F; 而emit就是声命这是这是一个信号函数且需要调用s-&gt;reactions
    emit t-&gt;announceHungry();


&#125;

Widget::~Widget()
&#123;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样，只要我们一开始运行程序，就会发现</p>
<p><img src="image-20230418202145548.png" alt="image-20230418202145548"></p>
<p>​        嗯，打印了（如果跑的是我的那个demo就是Yep, I think I will help you!）</p>
<h2 id="槽函数的重载版本"><a href="#槽函数的重载版本" class="headerlink" title="槽函数的重载版本"></a>槽函数的重载版本</h2><p>​        下面，我们进一步的探索可以重载版本的槽函数</p>
<p>​        以上一小节的场景为例子，加上槽函数的重载版本！</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; in .h

slots:
	void reactions(QString s); 

&#x2F;&#x2F; .cpp

void student::reactions(QSrting s)&#123;
	qDebug() &lt;&lt; &quot;yep, I think it is&quot; &lt;&lt; s;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，注释掉原先的emit 就可以发现智能提示上函数有重载版本！</p>
<p>​        但是，当我们直接单击运行的时候，QT报错了！原因很简单！QT不知道你要那个回应！于是，我们转向传专门到具体的函数的指针！也就是直接传重载版本的函数指针！</p>
<p>​        但是，我们的信号来源信息是需要从信号函数那里来的，于是还要重载Signal函数</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//.h</span>

signal<span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">announceHungry</span><span class="token punctuation">(</span>QString s<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// .cpp</span>
<span class="token keyword">void</span> <span class="token class-name">Teacher</span><span class="token double-colon punctuation">::</span><span class="token function">announceHungry</span><span class="token punctuation">(</span>QString s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 仍然不实现！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，告诉引发的信号是来自：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">emit t<span class="token operator">-></span><span class="token function">announceHungry</span><span class="token punctuation">(</span><span class="token string">"111"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从这里编译器判断函数类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span class="token punctuation">;</span>
<span class="token function">connect</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>StringOne<span class="token punctuation">,</span>s<span class="token punctuation">,</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230418210445433.png" alt="image-20230418210445433"></p>
<h2 id="令人恼火的是："><a href="#令人恼火的是：" class="headerlink" title="令人恼火的是："></a>令人恼火的是：</h2><p>​        马上强迫症发现了：不对啊，我们的111不应该打印“” 啊！，这是因为类型是QString导致的，这个时候只要我们进行转化就好了</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">toUtf8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
<span class="token comment">// QString -> ByteArray -> const char*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230418211415114.png" alt="image-20230418211415114"></p>
<h2 id="高级一点的信号与槽"><a href="#高级一点的信号与槽" class="headerlink" title="高级一点的信号与槽"></a>高级一点的信号与槽</h2><p>​        现在，让我们点击按钮，连续的触发事件来让样例复杂起来。</p>
<p>​        信号与槽的一个重要的要求就是信号和槽的函数的参数必须一致(有参的信号和QPushButton的clicked信号的参数不匹配就会编译报错)，于是，包装一个Emit函数</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void Widget::Emit()
&#123;
	&#x2F;&#x2F; 预先在Widget里添加成员t，并且初始化
	Emit t-&gt;announcement(&quot;111&quot;)

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，开始关联：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QPushButton<span class="token operator">*</span> btn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"Press me"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
btn<span class="token operator">-></span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">connect</span><span class="token punctuation">(</span>btn<span class="token punctuation">,</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>Widget<span class="token double-colon punctuation">::</span>Emit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span class="token punctuation">;</span>
<span class="token function">connect</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>StringOne<span class="token punctuation">,</span>s<span class="token punctuation">,</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230418213636339.png" alt="image-20230418213636339"></p>
<p>​        对了，信号也可以来连接信号，就是：</p>
<p><img src="image-20230418214613353.png" alt="image-20230418214613353"></p>
<p><img src="image-20230418214631458.png" alt="image-20230418214631458"></p>
<h2 id="断开链接"><a href="#断开链接" class="headerlink" title="断开链接"></a>断开链接</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">disconnect</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>signalF<span class="token punctuation">,</span>sloter<span class="token punctuation">,</span>slotF<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>复习一下：</p>
<p>​        1）信号可以链接信号</p>
<p>​        2）一个信号可以链接多个槽函数</p>
<p>​        3）多个信号可以链接同一个槽函数</p>
<p>​        4）但是信号与槽函数的参数必须一一对应</p>
<p>这是我们练习生活实际是不难发现的！关于四，仔细看看！</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token punctuation">(</span>Teacher<span class="token double-colon punctuation">::</span><span class="token operator">*</span>StringOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>Teacher<span class="token double-colon punctuation">::</span>announceHungry<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span>student<span class="token double-colon punctuation">::</span><span class="token operator">*</span>reacOne<span class="token punctuation">)</span><span class="token punctuation">(</span>QString<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>student<span class="token double-colon punctuation">::</span>reactions<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        可以看到必须一 一对应！</p>
<p>​        5）信号的参数个数是可以多于槽的参数，也就是说，信号携带的信息必须多余槽需要的！</p>
<pre class="line-numbers language-none"><code class="language-none">void(A::*sig)(QString,int) &#x3D; &amp;A::singals;
void(B::*slot)(QString,int) &#x3D; &amp;B::slots;(√)

void(A::*sig)(QString,int) &#x3D; &amp;A::singals;
void(B::*slot)(int，QString) &#x3D; &amp;B::slots;(×)
必须一一对应<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        而在QT4之前，我们使用SIGNAL,SLOT宏链接的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">connect(sig1,SIGNAL(signals()),slot1,SLOT(slot()))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="补充Lambda表达式"><a href="#补充Lambda表达式" class="headerlink" title="补充Lambda表达式"></a>补充Lambda表达式</h2><p>​        这是C++11的产物，我们由此创建一个匿名的函数以简化编程工作：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[capture](parameters)mutable-&gt;return-type&#123;
	
	statements

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        人话：[函数对象参数]（操作符重载函数参数）mutable-&gt;返回值{函数体实现}</p>
<h3 id="1-函数对象参数"><a href="#1-函数对象参数" class="headerlink" title="1.函数对象参数"></a>1.函数对象参数</h3><p>​        [ ]，这标志Lambda表达式的开始，不允许省略！其中，空表示没有使用任何函数对象。</p>
<p>​        [=] : 函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this），并且传递方式是值传递</p>
<p>​        [&amp;]： 函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this），并且传递方式是引用传递。</p>
<p>​        这是一个修改的demo.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[&#x3D;]()&#123;
   btn2-&gt;setText(&quot;Lol&quot;);
&#125;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        最后的（）表示的是当地声明马上调用</p>
<p>​        [this] :函数体内可以使用Lambda所在作用范围下的所有可见的局部变量（包括Lambda表达式所在的类的 this和内部成员的变量），并且传递方式是值传递</p>
<p>​        [varName] 只认识varName，其他都看不见到，用于仅操作一个变量的匿名表达式</p>
<p><img src="image-20230419202055676.png" alt="image-20230419202055676"></p>
<p>​        当然后面的很少使用！</p>
<p>​        mutable关键字：可以修改按值传递进来的拷贝</p>
<p>​        可以观察这个代码</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QPushButton<span class="token operator">*</span> btn2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"this is a btn2"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token function">connect</span><span class="token punctuation">(</span>btn2<span class="token punctuation">,</span><span class="token operator">&amp;</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span><span class="token punctuation">&#123;</span>n<span class="token operator">=</span><span class="token number">110</span><span class="token punctuation">,</span><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
QPushButton<span class="token operator">*</span> btn3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QPushButton</span><span class="token punctuation">(</span><span class="token string">"this is a btn3"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
btn3<span class="token operator">-></span><span class="token function">move</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">connect</span><span class="token punctuation">(</span>btn3<span class="token punctuation">,</span>QPushButton<span class="token double-colon punctuation">::</span>clicked<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span><span class="token punctuation">&#123;</span><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        你会发现，点击btn2之后又点击btn3，发现并没有修改n，说明确实只是更改了拷贝而已！</p>
<p>​        下面来用一下，复盘一下我们学习的知识，那就是设计一个按钮，位于图片中学附近，且点击之后可以使传入的一个值+=10，同时打印信息：From lambda’s reactions!</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
&#123;
    QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);
    resize(640,480);
    btn-&gt;move(320,240);
    connect(btn,&amp;QPushButton::clicked,this,[]()&#123;qDebug()&lt;&lt;&quot;From lambda&#39;s reactions!&quot;;&#125;);
    unsigned int m &#x3D; 10;
    connect(btn,&amp;QPushButton::clicked,this,[m]()mutable&#123;m+&#x3D;10;qDebug()&lt;&lt;m;&#125;);
&#125;

Widget::~Widget()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        返回值：就是在（）后写 -&gt; type随后写实现！</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">[]()-&gt;int&#123;return 1000&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int in &#x3D; 10;
  int res &#x3D; [&#x3D;]()-&gt;int&#123;return in*in;&#125;();
  qDebug() &lt;&lt; res;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        又如点击按钮关闭窗口的demo:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);
resize(640,480);
btn-&gt;move(320,240);
connect(btn,&amp;QPushButton::clicked,this,&amp;Widget::close);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        好吧，那又加一个打印log?转向Lambda就好了</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QPushButton* btn &#x3D; new QPushButton(&quot;this is a btn&quot;,this);
resize(640,480);
btn-&gt;move(320,240);
connect(btn,&amp;QPushButton::clicked,this,[this]()&#123;this-&gt;close();qDebug()&lt;&lt;&quot;Windows is closed!&quot;;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a>QMainWindow</h1><p>​        QMainWindow是一个为用户提供主窗口程序的类，它包含一个菜单栏，多个工具栏，多个铆接部件，一个状态栏和一个中心部件，是多个应用程序的基础，如文本编辑器，图片编辑器等等</p>
<p><img src="image-20230425213236864.png" alt="image-20230425213236864"></p>
<p>​        现在我们尝试创建一个QMainWindow，并运行之：</p>
<p><img src="image-20230425213429856.png" alt="image-20230425213429856"></p>
<p>​        好小！调整一下，在MainWindow里头resize一下完事！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
	resize(640,480);
&#125;

MainWindow::~MainWindow()
&#123;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230425213559077.png" alt="image-20230425213559077"></p>
<p>​        下面创建一个菜单栏，他是QMenuBar类的</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QMenuBar* bar &#x3D; menuBar();

&#x2F;&#x2F; 设置当前窗口的菜单栏

setMenuBar(bar);

&#x2F;&#x2F; 设定名称
&#x2F;&#x2F; 事实上不是这样用的，但是为了展示效果如此
bar-&gt;addMenu(&quot;文件&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230425214129151.png" alt="image-20230425214129151"></p>
<p>​        好吧，事实上是我们是使用一个菜单对象来接受之：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">QMenu<span class="token operator">*</span> fileMenu <span class="token operator">=</span> bar<span class="token operator">-></span><span class="token function">addMenu</span><span class="token punctuation">(</span><span class="token string">"文件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们这样做是为了后续的其他操作！比如说，现在我们想点击它让他下拉一个菜单来，那就</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">fileMenu<span class="token operator">-></span><span class="token function">addAction</span><span class="token punctuation">(</span><span class="token string">"新建"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
<span class="token comment">//添加一个分割符</span>
fileMenu<span class="token operator">-></span><span class="token function">addSeparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
fileMenu<span class="token operator">-></span><span class="token function">addAction</span><span class="token punctuation">(</span><span class="token string">"打开"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230425214843993.png" alt="image-20230425214843993"></p>
<h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;工具栏

 QToolBar* toolBar &#x3D; new QToolBar(this);
 addToolBar(toolBar);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​            这个流程为我们的窗口添加了一个工具栏</p>
<p><img src="image-20230425215242772.png" alt="image-20230425215242772"></p>
<p>​        看到有变化！是的就是我们的工具栏。</p>
<p>​        工具栏是允许有多个的！我们再仔细瞧瞧其他的add重载函数！</p>
<p>​        这个引起了我们的注意</p>
<p><img src="image-20230425215627044.png" alt="image-20230425215627044"></p>
<p>​        这个函数究竟实现了啥功能呢？把这个函数扔进QT  帮助手册里</p>
<p><img src="image-20230425215808333.png" alt="image-20230425215808333"></p>
<p>​        这个地方，点击第一个参数的类去</p>
<p><img src="image-20230425215834180.png" alt="image-20230425215834180"></p>
<p>​        很明显了！就是再说这个工具栏初始时停靠在哪里！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">addToolBar(Qt::LeftToolBarArea,toolBar);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230425215957733.png" alt="image-20230425215957733"></p>
<p>​        这是设计默认区域。总结一下</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include&lt;QMenuBar&gt;
#include&lt;QToolBar&gt;
#include&lt;QDebug&gt;

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
    &#x2F;&#x2F;重置窗口大小
    resize(640,480);


    &#x2F;&#x2F;创建菜单栏，最多只能有一个
    QMenuBar* bar&#x3D; menuBar();
    &#x2F;&#x2F;设置显示窗口为当前窗口
    setMenuBar(bar);
    &#x2F;&#x2F;菜单
    QMenu* fileMenu &#x3D; bar-&gt;addMenu(&quot;文件&quot;);

    QMenu* editMenu &#x3D; bar-&gt;addMenu(&quot;编辑&quot;);
    &#x2F;&#x2F;添加菜单项
    fileMenu-&gt;addAction(&quot;新建&quot;);
    &#x2F;&#x2F;添加分隔符
    fileMenu-&gt;addSeparator();

    fileMenu-&gt;addAction(&quot;打开&quot;);
    &#x2F;&#x2F;添加工具栏
    QToolBar* toolBar &#x3D; new QToolBar(this);
    addToolBar(Qt::LeftToolBarArea,toolBar);
    
    
&#125;

MainWindow::~MainWindow()
&#123;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下面说说它只允许停靠在一个方向。我们可以查看QToolBar的成员函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; constructor
QToolBar(const QString &amp;title, QWidget *parent &#x3D; Q_NULLPTR)

QToolBar(QWidget *parent &#x3D; Q_NULLPTR)
&#x2F;&#x2F; destructor
~QToolBar()
QAction *
actionAt(const QPoint &amp;p) const
QAction *
actionAt(int x, int y) const
QAction *
addAction(const QString &amp;text)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text)
QAction *
addAction(const QString &amp;text, const QObject *receiver, const char *member)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *receiver, const char *member)
QAction *
addAction(const QString &amp;text, const QObject *receiver, PointerToMemberFunction method)
QAction *
addAction(const QString &amp;text, Functor functor)
QAction *
addAction(const QString &amp;text, const QObject *context, Functor functor)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *receiver, PointerToMemberFunction method)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, Functor functor)
QAction *
addAction(const QIcon &amp;icon, const QString &amp;text, const QObject *context, Functor functor)
QAction *
addSeparator()
QAction *
addWidget(QWidget *widget)
Qt::ToolBarAreas 
allowedAreas() const
void 
clear()
QSize 
iconSize() const
QAction *
insertSeparator(QAction *before)
QAction *
insertWidget(QAction *before, QWidget *widget)
bool 
isAreaAllowed(Qt::ToolBarArea area) const
bool 
isFloatable() const
bool 
isFloating() const
bool 
isMovable() const
Qt::Orientation 
orientation() const
void 
setAllowedAreas(Qt::ToolBarAreas areas)
void 
setFloatable(bool floatable)
void 
setMovable(bool movable)
void 
setOrientation(Qt::Orientation orientation)
QAction *
toggleViewAction() const
Qt::ToolButtonStyle 
toolButtonStyle() const
QWidget *
widgetForAction(QAction *action) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        看到</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool 
isAreaAllowed(Qt::ToolBarArea area) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        不正是表明停靠范围！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setAllowedAreas(Qt::RightToolBarArea|Qt::LeftToolBarArea);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        以及设置是否可以浮动：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setFloatable(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        甚至可以设置是否可以移动！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;setMovable(false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        下面设置内容：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;addAction(&quot;这是action 1&quot;);

toolBar-&gt;addAction(&quot;这是action2&quot;);

&#x2F;&#x2F;使用这个方法表明的是跟菜单栏是公用同一个功能的！
&#x2F;&#x2F;需要接受返回值
&#x2F;&#x2F;QAction* newAct &#x3D; fileMenu-&gt;addAction(&quot;新建&quot;);
toolBar-&gt;addAction(openAct);
&#x2F;&#x2F;其他类似
toolBar-&gt;addAction(newAct);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        工具栏也可以添加分割线：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">toolBar-&gt;addSeparator();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        还可以添加控件！！！</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QPushButton* btn &#x3D; new QPushButton(&quot;a btn for the toolBar&quot;,this);

toolBar-&gt;addWidget(btn);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>​        最多也只能有一个</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QStatusBar* stbar &#x3D; statusBar();

setStatusBar(stbar);

QLabel* lab &#x3D; new QLabel(&quot;a mentions&quot;,this);
&#x2F;&#x2F; QLable是Widget控件
stbar-&gt;addWidget(lab);&#x2F;&#x2F; 左侧
QLabel* lab2 &#x3D; new QLabel(&quot;2 mentions&quot;,this);
stbar-&gt;addPermanentWidget(lab2);&#x2F;&#x2F;右侧<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        也可以添加铆接部件，可以有多个</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F;铆接部件（可以一大堆）
QDockWidget* dock &#x3D; new QDockWidget(this);
addDockWidget(Qt::BottomDockWidgetArea,dock);
&#x2F;&#x2F;设置中心部件.可以别让浮动窗口占据窗口
QTextEdit* edit &#x3D; new QTextEdit(this);
setCentralWidget(edit);
dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对于全局者，都是set,只能有一个，反之可以多个（add_）</p>
<p>​        回顾一下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include&lt;QMenuBar&gt;
#include&lt;QToolBar&gt;
#include&lt;QDebug&gt;
#include&lt;QPushButton&gt;
#include&lt;QStatusBar&gt;
#include&lt;QLabel&gt;
#include&lt;QDockWidget&gt;
#include&lt;QTextEdit&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
&#123;
    &#x2F;&#x2F;重置窗口大小
    resize(1640,880);


    &#x2F;&#x2F;创建菜单栏，最多只能有一个
    QMenuBar* bar&#x3D; menuBar();
    &#x2F;&#x2F;设置显示窗口为当前窗口
    setMenuBar(bar);
    &#x2F;&#x2F;菜单
    QMenu* fileMenu &#x3D; bar-&gt;addMenu(&quot;文件&quot;);

    QMenu* editMenu &#x3D; bar-&gt;addMenu(&quot;编辑&quot;);
    &#x2F;&#x2F;添加菜单项
    QAction* newAct&#x3D; fileMenu-&gt;addAction(&quot;新建&quot;);
    &#x2F;&#x2F;添加分隔符
    fileMenu-&gt;addSeparator();

     QAction* openAct&#x3D; fileMenu-&gt;addAction(&quot;打开&quot;);
    &#x2F;&#x2F;添加工具栏
    QToolBar* toolBar &#x3D; new QToolBar(this);
    addToolBar(Qt::LeftToolBarArea,toolBar);
    &#x2F;&#x2F;设置允许停靠区域
    toolBar-&gt;setAllowedAreas(Qt::RightToolBarArea|Qt::LeftToolBarArea);
    &#x2F;&#x2F;设置行为
    toolBar-&gt;addAction(&quot;这是action 1&quot;);

    toolBar-&gt;addAction(&quot;这是action2&quot;);

    toolBar-&gt;addAction(openAct);

    toolBar-&gt;addSeparator();

    toolBar-&gt;addAction(newAct);
    &#x2F;&#x2F;放置控件
    QPushButton* btn &#x3D; new QPushButton(&quot;a btn for the toolBar&quot;,this);

    toolBar-&gt;addWidget(btn);

    &#x2F;&#x2F;状态栏
    QStatusBar* stbar &#x3D; statusBar();

    setStatusBar(stbar);
    &#x2F;&#x2F;加点东西
    QLabel* lab &#x3D; new QLabel(&quot;a mentions&quot;,this);
    &#x2F;&#x2F; QLable是Widget控件
    stbar-&gt;addWidget(lab);
    QLabel* lab2 &#x3D; new QLabel(&quot;2 mentions&quot;,this);
    stbar-&gt;addPermanentWidget(lab2);

    &#x2F;&#x2F;铆接部件（可以一大堆）
    QDockWidget* dock &#x3D; new QDockWidget(this);
    addDockWidget(Qt::BottomDockWidgetArea,dock);

    &#x2F;&#x2F;设置中心部件.可以别让浮动窗口占据窗口
    QTextEdit* edit &#x3D; new QTextEdit(this);
    setCentralWidget(edit);
    dock-&gt;setAllowedAreas(Qt::TopDockWidgetArea);
&#125;

MainWindow::~MainWindow()
&#123;

&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="添加资源文件"><a href="#添加资源文件" class="headerlink" title="添加资源文件"></a>添加资源文件</h2><p>​        我们现在打开UI设计一栏，现在可以直接开始先设计后构建代码逻辑了</p>
<p><img src="image-20230514102111415.png" alt="image-20230514102111415"></p>
<p>​        菜单项必须必须输入英文，这是因为跟变量命名有关，可以后续改动text 值来改变显示</p>
<p><img src="image-20230514101928675.png" alt="image-20230514101928675"></p>
<p>​        其他就不多阐述了，类似的。</p>
<p>​        如何使用代码访问ui呢？会带mainwindow.cpp</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this); &#x2F;&#x2F; 类似于这样的！
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        添加一个图标吧：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;D:&#x2F;QT projects&#x2F;9&#x2F;source&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        首先先把资源放到项目目录路径下，不然肯定找不到！</p>
<p>​        如何快速的在项目中添加文件呢？先去右键项目：添加性文件，选择QT下的Qt resource files</p>
<p>​        然后，添加：会发现要求你写一个前缀，这是为了分类资源文件。可以偷懒直接写一个\</p>
<p>​        在项目中引用只需要按照格式：</p>
<pre class="line-numbers language-none"><code class="language-none">: + prefix + fileName<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        也即是: + 前缀加上文件名即可</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">ui-&gt;actionnew-&gt;setIcon(QIcon(&quot;:&#x2F;source&#x2F;1.png&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p>​            可是我们的点击事件还是没有任何反应。下面使用信号与槽让他动起来</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QDialog&gt;
#include&lt;QDebug&gt;
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F; 点击新建按钮来弹出对话框

    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;
        &#x2F;&#x2F; 对话框 分类
        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）
        QDialog dlg(this);  &#x2F;&#x2F;创建一个
        dlg.exec();

        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;
    &#125;);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230516215248714.png" alt="image-20230516215248714"></p>
<p>​        出现这样的警告，说明是对话框太小了，需要调整</p>
<p><img src="image-20230516215825806.png" alt="image-20230516215825806"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QDialog&gt;
#include&lt;QDebug&gt;
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F; 点击新建按钮来弹出对话框

    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;
        &#x2F;&#x2F; 对话框 分类
        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）
        QDialog dlg(this);
        dlg.resize(100,200);
        dlg.exec();
        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;
    &#125;);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        那我们现在来看一个非模糊的：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QDialog&gt;
#include&lt;QDebug&gt;
MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F; 点击新建按钮来弹出对话框

    connect(ui-&gt;actionnew,&amp;QAction::triggered,[this]()&#123;
        &#x2F;&#x2F; 对话框 分类
        &#x2F;&#x2F; 模态对话框（不可以对其他窗口做操做） 和 非模态对话框（可以对其他窗口做操做）
&#x2F;&#x2F;        QDialog dlg(this);
&#x2F;&#x2F;        dlg.resize(100,200);
&#x2F;&#x2F;        dlg.exec();
        QDialog* dig &#x3D; new QDialog(this); &#x2F;&#x2F; 不可以开栈上，对象一show完就没了！
        dig-&gt;resize(100,200);
        dig-&gt;show();
        qDebug() &lt;&lt; &quot;A dialog ejected\n!&quot;;
    &#125;);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        为了防止用户一直点，一直创建对话框，我们可以设置关闭就删掉的属性</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">dig-&gt;setAttribute(Qt::WA_DeleteOnClose);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h1 id="消息对话框"><a href="#消息对话框" class="headerlink" title="消息对话框"></a>消息对话框</h1><h2 id="消息对话框-1"><a href="#消息对话框-1" class="headerlink" title="消息对话框"></a>消息对话框</h2><p>​        系统自己提供了大量的对话框，如：</p>
<p>​        QColorDialog                选择颜色</p>
<p>​        QFileDialog                    选择文件或者目录</p>
<p>​        QFontDialog                    选择字体</p>
<p>​        QInputDialog                允许用户输入一个值</p>
<p>​        QMessageDialog            模态对话框</p>
<p>​        QPageSetUpDialog        为打印机提供相关选项</p>
<p>​        QPrintDialog                    打印机配置</p>
<p>​        QPrintPreviewDialog        打印预览</p>
<p>​        QProcessDialog                显示操作过程</p>
<p>​        我们现在着重看看消息框是啥情况！在帮助文档下搜索QMessageBox</p>
<p><img src="image-20230519123236586.png" alt="image-20230519123236586"></p>
<p>​        下面显示之。</p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;

QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    ui.setupUi(this);

    QMessageBox::critical(this, &quot;critical&quot;, &quot;666&quot;);
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230519123918761.png" alt="image-20230519123918761"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;

QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    ui.setupUi(this);

    QMessageBox::information(this, &quot;information&quot;, &quot;666&quot;);
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>C++</p>
<p><img src="image-20230519124310043.png" alt="image-20230519124310043"></p>
<pre class="line-numbers language-none"><code class="language-none">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;

QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    ui.setupUi(this);

    QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;);
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230519124401064.png" alt="image-20230519124401064"></p>
<p><img src="image-20230519124448267.png" alt="image-20230519124448267"></p>
<p>​        于是可以更改参数就好了。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;,QMessageBox::Save|QMessageBox::Cancel);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230519124653246.png" alt="image-20230519124653246"></p>
<p>​        这个函数参数是这样的：</p>
<p>​        参数1：父类</p>
<p>​        参数2：标题</p>
<p>​        参数3：提示内容</p>
<p>​        参数4：按键类型</p>
<p>​        参数5：默认回车关联的按键</p>
<p>​        返回参数：用户选择</p>
<p>如：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;
#include&lt;tchar.h&gt;
QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    setLocale(QLocale::AnyLanguage);
    ui.setupUi(this);

    if (QMessageBox::Save &#x3D;&#x3D; QMessageBox::question(this, &quot;question&quot;, &quot;666&quot;, QMessageBox::Save | QMessageBox::Cancel)) &#123;
        qDebug() &lt;&lt; &quot;you clicked the save&quot;;
    &#125;
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        想看Debug信息去项目属性那里更改一下输出为控制台即可！</p>
<p><img src="image-20230519125534877.png" alt="image-20230519125534877"></p>
<p>​        来看看其他demo:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;
#include&lt;qcolordialog.h&gt;
#include&lt;qcolor.h&gt;
QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    setLocale(QLocale::AnyLanguage);
    ui.setupUi(this);

    QColor color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));
    qDebug() &lt;&lt; &quot;r &#x3D; &quot; &lt;&lt; color.red() &lt;&lt; &quot;g &#x3D; &quot; &lt;&lt; color.green() &lt;&lt; &quot;h &#x3D; &quot; &lt;&lt; color.blue() ;
&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;


&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230519125944025.png" alt="image-20230519125944025"></p>
<p><img src="image-20230519125950425.png" alt="image-20230519125950425"></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;QtWidgetsApplication1.h&quot;
#include&lt;qmessagebox.h&gt;
#include&lt;qcolordialog.h&gt;
#include&lt;qcolor.h&gt;
#include&lt;qfile.h&gt;
#include&lt;qfiledialog.h&gt;
QtWidgetsApplication1::QtWidgetsApplication1(QWidget *parent)
    : QMainWindow(parent)
&#123;
    setLocale(QLocale::AnyLanguage);
    ui.setupUi(this);

    &#x2F;*QColor color &#x3D; QColorDialog::getColor(QColor(255, 0, 0));
    qDebug() &lt;&lt; &quot;r &#x3D; &quot; &lt;&lt; color.red() &lt;&lt; &quot;g &#x3D; &quot; &lt;&lt; color.green() &lt;&lt; &quot;h &#x3D; &quot; &lt;&lt; color.blue() ;*&#x2F;

&#125;

QtWidgetsApplication1::~QtWidgetsApplication1()
&#123;
    QFileDialog::getOpenFileName(

        this,&#x2F;&#x2F; 设置父亲
        &quot;open the file&quot;, &#x2F;&#x2F; caption
        &#x2F;&#x2F;目录
        &quot;D:\\&quot;&#x2F;&#x2F;文件夹
        &quot;(*.txt)&quot;&#x2F;&#x2F;过滤器，回忆Linux通配符就好了！
    );

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230519130333549.png" alt="image-20230519130333549"></p>
<p>​        返回的是文件的路径！这个可以注意一下！</p>
<h2 id="登录窗口界面布局介绍"><a href="#登录窗口界面布局介绍" class="headerlink" title="登录窗口界面布局介绍"></a>登录窗口界面布局介绍</h2><p>​        现在使用Widget控件把一些模块分类装之，随后垂直布局，就是这样</p>
<p><img src="image-20230519131530620.png" alt="image-20230519131530620"></p>
<h2 id="QListWidget空间"><a href="#QListWidget空间" class="headerlink" title="QListWidget空间"></a>QListWidget空间</h2><p><img src="image-20230523200845020.png" alt="image-20230523200845020"></p>
<p>​        是的！从这里拖一个QListWidget控件出来！</p>
<p><img src="image-20230523201158972.png" alt="image-20230523201158972"></p>
<p>​        代码里如上图所示，运行：</p>
<p><img src="image-20230523201220072.png" alt="image-20230523201220072"></p>
<p>​        也可以使用类似于list的容器放置一大堆内容：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include &lt;QListWidgetItem&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
&#123;
    ui-&gt;setupUi(this);

    QListWidgetItem* item &#x3D; new QListWidgetItem(&quot;锄禾日当午&quot;);

    ui-&gt;listWidget-&gt;addItem(item);

    item-&gt;setTextAlignment(Qt::AlignHCenter);

    &#x2F;&#x2F; QStringList      List&lt;String&gt;
    QStringList list;
    list &lt;&lt; &quot;锄禾日当午&quot;&lt;&lt;&quot;汗&quot;;
    ui-&gt;listWidget-&gt;addItems(list);
&#125;

MainWindow::~MainWindow()
&#123;
    delete ui;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230523201833675.png" alt="image-20230523201833675"></p>
<h3 id="QListWidget"><a href="#QListWidget" class="headerlink" title="QListWidget"></a>QListWidget</h3><p>​        下面的文段来自QT帮助助手！</p>
<pre><code>Detailed Description
</code></pre><p><img src="image-20230526191818350.png" alt="image-20230526191818350"></p>
<p>​        QListWidget is a convenience class that provides a list view similar to the one supplied by QListView, but with a classic item-based interface for adding and removing items. QListWidget uses an internal model to manage each QListWidgetItem in the list.<br>For a more flexible list view widget, use the QListView class with a standard model.<br>List widgets are constructed in the same way as other widgets:</p>
<pre class="line-numbers language-none"><code class="language-none">QListWidget *listWidget &#x3D; new QListWidget(this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        The selectionMode() of a list widget determines how many of the items in the list can be selected at the same time, and whether complex selections of items can be created. This can be set with the setSelectionMode() function.<br>There are two ways to add items to the list: they can be constructed with the list widget as their parent widget, or they can be constructed with no parent widget and added to the list later. If a list widget already exists when the items are constructed, the first method is easier to use:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">new QListWidgetItem(tr(&quot;Oak&quot;), listWidget);
new QListWidgetItem(tr(&quot;Fir&quot;), listWidget);
new QListWidgetItem(tr(&quot;Pine&quot;), listWidget);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        If you need to insert a new item into the list at a particular position, then it should be constructed without a parent widget. The insertItem() function should then be used to place it within the list. The list widget will take ownership of the item.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem *newItem &#x3D; new QListWidgetItem;
newItem-&gt;setText(itemText);
listWidget-&gt;insertItem(row, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        For multiple items, insertItems() can be used instead. The number of items in the list is found with the count() function. To remove items from the list, use takeItem().<br>​        The current item in the list can be found with currentItem(), and changed with setCurrentItem(). The user can also change the current item by navigating with the keyboard or clicking on a different item. When the current item changes, the currentItemChanged() signal is emitted with the new current item and the item that was previously current.</p>
<p>​        大致就是创建一个长得像那样链表似的一个控件！</p>
<p><img src="image-20230526192003545.png" alt="image-20230526192003545">        在QT 的 UI设计下，常常见这个控件于： List Widget下面。</p>
<p>​        我们这里不对对象名称做什么修改了！默认的情况下——</p>
<pre class="line-numbers language-none"><code class="language-none">ui -&gt; listWidget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        找到它来！</p>
<p>​        为了添加控件，我们有两种方式来进行：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 方式1
QListWidgetItem* item &#x3D; new QListWidgetItem(&quot;卢本伟牛逼&quot;);

ui-&gt;listWidget-&gt;addItem(item);

item-&gt;setTextAlignment(Qt::AlignHCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这就是一种方式——通过包装成 Item 送到Widget里去。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 方式2
QStringList list;
list &lt;&lt; &quot;卢&quot;&lt;&lt;&quot;本&quot;&lt;&lt;&quot;伪&quot;&lt;&lt;&quot;牛&quot;&lt;&lt;&quot;逼&quot;;
ui-&gt;listWidget-&gt;addItems(list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是通过传入String List 链表的方式送数据。</p>
<h2 id="1）添加条目的函数"><a href="#1）添加条目的函数" class="headerlink" title="1）添加条目的函数"></a>1）添加条目的函数</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">void</span> <span class="token class-name static-context">QListWidget</span><span class="token operator">::</span><span class="token function">addItem</span><span class="token punctuation">(</span>QListWidgetItem <span class="token operator">*</span> item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这个添加函数需要实现 new 一个 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 条目对象，然后添加到列表控件末尾，下面小节会专门讲 QListWidgetItem 类。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::addItem(const QString &amp; label)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这第二个添加函数其实更常用，因为更简便，功能是将字符串 label 添加到列表控件末尾显示，其实该函数内部会自动根据字符串 new 一个条目对象添加到列表控件。<br>如果有设置好的字符串列表，那么可以通过如下函数把多个字符串全部添加到列表控件：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::addItems(const QStringList &amp; labels)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>add<em> 函数是将条目添加到末尾，如果要将条目插入到指定行 row 位置，则使用 insert</em> 函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::insertItem(int row, QListWidgetItem * item) &#x2F;&#x2F;插入条目到第 row 行
void QListWidget::insertItem(int row, const QString &amp; label) &#x2F;&#x2F;插入字符串到第 row 行
void QListWidget::insertItems(int row, const QStringList &amp; labels) &#x2F;&#x2F;插入多个字符串到从 row 行开始的多个行。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>获取列表控件里面的条目计数使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QListWidget::count() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（2）删除函数"><a href="#（2）删除函数" class="headerlink" title="（2）删除函数"></a>（2）<strong>删除函数</strong></h2><p>​        因为是基于条目的控件，所以列表控件的删除单个条目函数名字是 <strong>takeItem()</strong>：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::takeItem(int row)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        takeItem() 根据行号从列表控件移除一个条目，并返回该条目指针，如果行号不合法，返回 NULL 指针。<br>​        如果返回的是实际存在的条目，那么需要注意，返回的条目指针需要手动 delete 掉，因为列表控件不再拥有该条目，该条目<strong>不会由列表控件析构时自动删除。</strong><br>​        <strong>takeItem() 函数还有第二个用途，因为列表控件没有直接的调整条目前后顺序的函数，可以先将要调整顺序的条目移出来takeItem()，然后再调用 insertItem() 把这个条目插入到新的位置。</strong>（重点关注之）</p>
<p>​        如果要清空整个列表控件，删除之前添加的所有条目，可以调用槽函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（3）条目访问函数"><a href="#（3）条目访问函数" class="headerlink" title="（3）条目访问函数"></a>（3）<strong>条目访问函数</strong></h2><p>​        根据行号获取条目对象的指针，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::item(int row) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果已知列表控件含有的条目对象指针，反查当前行号，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QListWidget::row(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>在图形界面，如果希望根据列表控件在屏幕显示的相对坐标位置（以列表控件内部左上角为原点）来获取条目，使用如下函数：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::itemAt(const QPoint &amp; p) const

QListWidgetItem * QListWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>反过来，如果根据已知条目，获取这个条目占据的矩形区域，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QRect QListWidget::visualItemRect(const QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（4）当前选中条目的操作"><a href="#（4）当前选中条目的操作" class="headerlink" title="（4）当前选中条目的操作"></a>（4）<strong>当前选中条目的操作</strong></h2><p>获取列表控件当前选中条目的函数如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QListWidgetItem * QListWidget::currentItem() const &#x2F;&#x2F;当前选中 条目
int QListWidget::currentRow() const  &#x2F;&#x2F;当前选中的行号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果当前没有选中的条目，那么返回的指针为 NULL，返回的序号为 -1 ，代码里要注意判断返回值。</p>
<p>设置已存在的某个条目为选中状态，使用函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::setCurrentItem(QListWidgetItem * item)    &#x2F;&#x2F;设置当前选中条目为 item
void QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)
void QListWidget::setCurrentRow(int row, QItemSelectionModel::SelectionFlags command)&#x2F;&#x2F;设置当前选中行为 row
void QListWidget::setCurrentItem(QListWidgetItem * item, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        第二个和第四个设置函数有个 SelectionFlags 类型的参数 command，这个参数决定选中的方式，是要选中QItemSelectionModel::Select ，还是取消选中 QItemSelectionModel::Deselect，还有其他选中方式，等到表格控件一节再详细列出来。<br>如果当前选中的条目发生变化，会触发如下三个信号，可以根据实际用途选择合适的信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::currentItemChanged(QListWidgetItem * current, QListWidgetItem * previous)

void QListWidget::currentRowChanged(int currentRow)

void QListWidget::currentTextChanged(const QString &amp; currentText)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意参数里的指针有可能为空值，序号可能为 -1，字符串也可能是空串，一定要注意判断非法的参数值。</p>
<p>​        本章的三个控件都可以设置选中模式，比如单选模式，一次只能选中一个条目，多选模式，一次可以选中多个条目等等，详细的选中模式在放到表格控件一节讲解，因为表格 中涉及的选中模式较多，一块讲解。本节的列表控件默认情况下，选中模式为单选 。QAbstractItemView::SingleSelection，以上的 <em>current</em> 等函数都是基于默认的单选模式的。</p>
<p>​        如果需要用到多选模式，可以设置 selectionMode 属性为 QAbstractItemView::ExtendedSelection，这种扩展选中模式类似常见的文件资源管理器的选中模式，可以使用 Ctrl 或 Shift 加鼠标点击实现多选：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setSelectionMode(QAbstractItemView::SelectionMode mode)  &#x2F;&#x2F;设置选中模式
QAbstractItemView::SelectionMode    selectionMode() const     &#x2F;&#x2F;获取选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        QAbstractItemView 是本章所有控件的抽象基类，本章后面控件也有类似的选中模式设置，如果把列表控件设置成多选模式，那么可以用如下函数获取同 时选中的多个条目：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QListWidgetItem *&gt; QListWidget::selectedItems() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        不论单选还是多选模式，条目选中情况有任何变化时，会触发如下信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemSelectionChanged()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="（5）条目查找和排序"><a href="#（5）条目查找和排序" class="headerlink" title="（5）条目查找和排序"></a>（5）<strong>条目查找和排序</strong></h2><p>​        如果需要根据文本查找匹配的条目，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QListWidgetItem *&gt; QListWidget::findItems(const QString &amp; text, Qt::MatchFlags flags) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        该函数第一个参数 text 是要查找的模板子串，第二个参数是匹配标志，Qt::MatchFlags 是非常通用的枚举类型，不仅可用于字符串匹配，还能用于其他类型变量的匹配，Qt::MatchFlags 包含关于查找匹配的多种方式的枚举值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>Qt::MatchFlags 枚举常量</strong></th>
<th><strong>数值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::MatchExactly</td>
<td>0</td>
<td>精确匹配，执行基于 QVariant 的匹配。</td>
</tr>
<tr>
<td>Qt::MatchFixedString</td>
<td>8</td>
<td>执行基于字符串的匹配，如果不指定 MatchCaseSensitive，默认是大小写不敏感。</td>
</tr>
<tr>
<td>Qt::MatchContains</td>
<td>1</td>
<td>条目包含要查找的模板子串。</td>
</tr>
<tr>
<td>Qt::MatchStartsWith</td>
<td>2</td>
<td>条目以要查找的模板子串打头。</td>
</tr>
<tr>
<td>Qt::MatchEndsWith</td>
<td>3</td>
<td>条目以要查找的模板子串结尾。</td>
</tr>
<tr>
<td>Qt::MatchCaseSensitive</td>
<td>16</td>
<td>查找时大小写敏感。</td>
</tr>
<tr>
<td>Qt::MatchRegExp</td>
<td>4</td>
<td>根据正则表达式模板子串匹配字符串。</td>
</tr>
<tr>
<td>Qt::MatchWildcard</td>
<td>5</td>
<td>根据通配符模板子串（如 *.txt）匹配字符串。</td>
</tr>
<tr>
<td>Qt::MatchWrap</td>
<td>32</td>
<td>执行回绕查找，当查找到最后一个条目时返回到第一个的条目继续查找，直到所有的条目都检查一遍。</td>
</tr>
<tr>
<td>Qt::MatchRecursive</td>
<td>64</td>
<td>递归查找，遍历所有子条目。</td>
</tr>
</tbody>
</table>
</div>
<p>​        后面两节的表格控件和树形控件也有类似的查找函数 findItems() ，第二个匹配标志参数也是一样的类型。</p>
<p>​        列表控件的自动排序是通过 sortingEnabled 属性来控制，获取和设置函数如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool isSortingEnabled() const
void setSortingEnabled(bool enable)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        列表控件条目默认是不排序的，如果希望自动按照字典序排序，调用 setSortingEnabled(true) 即可。另外还可以手动对列表控件现有条目排序：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::sortItems(Qt::SortOrder order &#x3D; Qt::AscendingOrder)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Qt::AscendingOrder 是按升序排列，Qt::DescendingOrder 是按降序排列。</p>
<h2 id="（6）条目显示和运行时条目编辑"><a href="#（6）条目显示和运行时条目编辑" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）<strong>条目显示和运行时条目编辑</strong></h2><p>​        关于列表控件 QListWidget 和里面的条目 QListWidgetItem，需要注意条目 QListWidgetItem 仅仅是数据，不是控件或子控件，列表控件根据多个 QListWidgetItem 对象，来呈现条目里的数据，<strong>只有列表控件自己是控件实体。</strong><br>列表控件默认以自己的方式呈现条目数据，比如白底黑字的普通条目显示，如果要按照特殊的子控件来显示字符串，比如用 QLabel 对象显示条目数据，可以用如下函 数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::setItemWidget(QListWidgetItem * item, QWidget * widget)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        列表控件会同时拥有 item 数据条目和用于显示 item 的子控件 widget。注意这里的子控件 widget 只有静态显示功能，如果用按钮作为显示子控件，那么按钮是不可点击的。如果希望自己定制一个能交互操作的子条目显示控件，需要使用 QListView 并子类化 QItemDelegate 类，这些复杂的等到模型视图章节再讲。</p>
<p>​        对于本节列表控件，如果要获取 setItemWidget() 函数指定某个条目的显示子控件，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QWidget * QListWidget::itemWidget(QListWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果要删除上面 setItemWidget() 指定的特殊显示控件，使用函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::removeItemWidget(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        特殊的显示子控件移除后，该条目就还按照列表控件原来的普通条目显示。</p>
<p>​        <strong>如果希望在程序运行时编辑列表控件的条目，有两种方式，本小节先讲第一种（第二种是设置条目自身的特性标志），手动打开条目的文本编辑器（这个编辑器是列表控件自 带功能，与 setItemWidget 设置的显示子控件没关系）：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::openPersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>这个函数名是打开条目的持续编辑器，持续的意思是如果不调用关闭函数，该条目的编辑器会一直开启，关闭这个持续编辑器使用如下函数：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::closePersistentEditor(QListWidgetItem * item)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>一般可以在检测到条目激活信号（itemActivated）时调用打开函数 openPersistentEditor() ，在当前条目变化（ currentItemChanged）时调用关闭函数 closePersistentEditor() 。</strong> 使用这一对开关持续编辑器函数涉及到编写多个信号的槽函数，使用比较麻烦，建议用后面第二小节介绍的条目标 志位和 QListWidget::editItem(QListWidgetItem * item) 实现条目的可编辑功能。</p>
<h2 id="（7）其他信号和槽函数"><a href="#（7）其他信号和槽函数" class="headerlink" title="（7）其他信号和槽函数"></a>（7）<strong>其他信号和槽函数</strong></h2><p>除了上面关于当前条目变化和选中条目变化的信号，条目还有激活、单击、双击等信号，罗列如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemActivated(QListWidgetItem * item)  &#x2F;&#x2F;激活信号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当用户点击或双击条目时，条目会被激活，具体哪些操作会激活条目，要根据操作系统设置来定，比如 Windows 一般是双击打开激活，KDE 桌面通常是单击打开激活。另外，系统的快捷键也可以激活条目，如 Windows 和 Linux X11 桌面是回车键激活，Mac OS X 是 Ctrl+0 ，一般激活信号用于开启编辑等操作。</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemChanged(QListWidgetItem * item)   &#x2F;&#x2F;条目内容发生变化<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意这是条目内容变化的信号，不是选中状态变化，程序如果在运行时改变了条目文本内容，比如持续编辑器修改了文本，会触发这个信号。<br>剩下几个单击、双击、进入、按压等信号意义比较直白，不详细解释了：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::itemClicked(QListWidgetItem * item)   &#x2F;&#x2F;条目单击信号
void QListWidget::itemDoubleClicked(QListWidgetItem * item)  &#x2F;&#x2F;条目双击信号
void QListWidget::itemEntered(QListWidgetItem * item)  &#x2F;&#x2F;鼠标追踪时进入条目的信号，一般用不着
void QListWidget::itemPressed(QListWidgetItem * item)  &#x2F;&#x2F;鼠标按键在条目上处于按下状态时发的信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>列表控件的槽函数除了前面讲过的 clear() 槽函数用于清空所有条目，还有个比较实用的条目滚动函数，列表控件自带滚动条，当条目总数超出控件矩形能呈现的数目时，滚动条自动出现，通过滚动条支持更多的条目显示。使 用如下槽函数可 以让列表控件滚动到想显示的某个条目位置：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QListWidget::scrollToItem(const QListWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第一个参数 item 就是想显示出来的条目，第二个参数是滚动显示方式，默认是 QAbstractItemView::EnsureVisible，即保证指定条目显示出来，还有其他的滚动显示方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>QAbstractItemView::ScrollHint 枚举常量</strong></th>
<th><strong>数值</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>QAbstractItemView::EnsureVisible</td>
<td>0</td>
<td>滚动到指定条目能显示出来即可。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtTop</td>
<td>1</td>
<td>滚动直到将指定条目显示到可视区域的顶部。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtBottom</td>
<td>2</td>
<td>滚动直到将指定条目显示到可视区域的底部。</td>
</tr>
<tr>
<td>QAbstractItemView::PositionAtCenter</td>
<td>3</td>
<td>滚动直到将指定条目显示到可视区域的中间。</td>
</tr>
</tbody>
</table>
</div>
<p>原博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kongcheng253/article/details/128615688">[QT_007]Qt学习之QListWidget控件详解_天空之城8020的博客-CSDN博客</a></p>
<h1 id="一些主要控件"><a href="#一些主要控件" class="headerlink" title="一些主要控件"></a>一些主要控件</h1><h2 id="主要控件"><a href="#主要控件" class="headerlink" title="主要控件"></a>主要控件</h2><h3 id="QTreeWidget"><a href="#QTreeWidget" class="headerlink" title="QTreeWidget"></a>QTreeWidget</h3><pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        The QTreeWidget class is a convenience class that provides a standard tree widget with a classic item-based interface similar to that used by the QListView class in Qt 3. This class is based on Qt’s Model/View architecture and uses a default model to hold items, each of which is a QTreeWidgetItem.<br>​        Developers who do not need the flexibility of the Model/View framework can use this class to create simple hierarchical lists very easily. A more flexible approach involves combining a QTreeView with a standard item model. This allows the storage of data to be separated from its representation.<br>​        In its simplest form, a tree widget can be constructed in the following way:</p>
<pre class="line-numbers language-none"><code class="language-none">QTreeWidget *treeWidget &#x3D; new QTreeWidget();
treeWidget-&gt;setColumnCount(1);
QList&lt;QTreeWidgetItem *&gt; items;
for (int i &#x3D; 0; i &lt; 10; ++i)
&#123; 
	items.append(new QTreeWidgetItem(static_cast&lt;QTreeWidget *&gt;\		(nullptr), 
	QStringList(QString(&quot;item: %1&quot;).arg(i))));
&#125;
 treeWidget-&gt;insertTopLevelItems(0, items);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        Before items can be added to the tree widget, the number of columns must be set with setColumnCount(). This allows each item to have one or more labels or other decorations. The number of columns in use can be found with the columnCount() function.<br>The tree can have a header that contains a section for each column in the widget. It is easiest to set up the labels for each section by supplying a list of strings with setHeaderLabels(), but a custom header can be constructed with a QTreeWidgetItem and inserted into the tree with the setHeaderItem() function.<br>​        The items in the tree can be sorted by column according to a predefined sort order. If sorting is enabled, the user can sort the items by clicking on a column header. Sorting can be enabled or disabled by calling setSortingEnabled(). The isSortingEnabled() function indicates whether sorting is enabled.</p>
<p>原博客：</p>
<p>​        <a target="_blank" rel="noopener" href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p>
<p>​        树形控件的节点可以有多层、多个子节点， 如果将子节点全部展开，那么每一行都是一个数据条目。<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QTreeWidgetItem&amp;spm=1001.2101.3001.7020">QTreeWidgetItem</a> 比较特殊，一个条目内部可以有多列数据信息，相当于表格控件一整行的表格单元集成为一个条目，所以树形条目要比前面两节的列表条目和表格条目都复杂。树形控件每行的条目之间可以是兄弟关系或父子关系，含有子节点的条目可以折叠也可以展开，进行遍历时有专门的迭代器 QTreeWidgetItemIterator 实现，也可以自行编写<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=递归算法&amp;spm=1001.2101.3001.7020">递归算法</a>遍历所有条目。</p>
<h3 id="8-3-1-QTreeWidget"><a href="#8-3-1-QTreeWidget" class="headerlink" title="8.3.1 QTreeWidget"></a>8.3.1 QTreeWidget</h3><p>在 Qt 设计师界面可以直接拖动树形控件到窗口里，下图展示树形控件的外观和构成：</p>
<p><img src="1.png" alt="f1ce3ab52d8fb8ed2698fa14a9ddb2b0.png"></p>
<p> 默认情况下，树形控件<strong>最上面是一个树头条目</strong>，<strong><em>\</em>树头条目也是 QTreeWidgetItem 对象**</strong>，可以有<strong>多列内容</strong>。<br>树头下面是真正的树形控件所有条目，在折叠的情况下，如上图所示，每行一个顶级条目，顶级条目也是 QTreeWidgetItem 对象，<strong>顶级条目的父节点指针 QTreeWidgetItem::parent() 为 NULL</strong>。<br>将所有节点展开之后，可以看到每个节点可以有多个子节点：</p>
<p><img src="2d11f9ba73fbaed337db73e2e141f4e7.png" alt="2d11f9ba73fbaed337db73e2e141f4e7.png"></p>
<p>对于包含子节点的父节点，左边会有小的三角形指示器，用于控制折叠或展开父节点。子节点也可以拥有更低级别的子节点（孙节点），以此类推，树形控件没 有限定子节点 的层数。顶级节点和其子孙节点的数据结构一样，都可以有多列数据，只是添加的函数、父节点指针不一样。下面介绍树形控件的函数和功能。</p>
<h3 id="（0）树形控件的构造函数很简单："><a href="#（0）树形控件的构造函数很简单：" class="headerlink" title="（0）树形控件的构造函数很简单："></a>（0）树形控件的构造函数很简单：</h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidget(QWidget * parent &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里只有指定父窗口或父控件的指针 parent 。树形控件在添加条目之前，必须要先设置列数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void setColumnCount(int columns) &#x2F;&#x2F;设置列数
int columnCount() const &#x2F;&#x2F;获取列数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>默认的列数是 1 列</strong>，如果涉及到多列数据，比如文件浏览树，有文件名、文件类型、大小、修改时间等等，就需要设置为多列数据的树。<br>树形控件设置好列数就可以添加相应的顶级条目，添加顶级条目是由树形控件自身的函数实现，而子条目则由 QTreeWidgetItem 的函数实现。本小节主要围绕树形控件和其基类的函数来讲，<strong>树形控件也可以设置和表格控件类似的表头，这里称为树头条目</strong>。</p>
<h3 id="（1）添加和访问顶级条目"><a href="#（1）添加和访问顶级条目" class="headerlink" title="（1）添加和访问顶级条目"></a>（1）添加和访问顶级条目</h3><p>树形控件顶级条目的操作比较类似 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidget&amp;spm=1001.2101.3001.7020">QListWidget</a> 的列表条目操作函数。新建条目之后，可以用如下函数把条目添加到树形控件的顶级条目<strong>列表末尾</strong>：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::addTopLevelItem(QTreeWidgetItem * item) &#x2F;&#x2F;添加一个顶级条目到末尾
void QTreeWidget::addTopLevelItems(const QList&lt;QTreeWidgetItem *&gt; &amp; items) &#x2F;&#x2F;添加多个顶级条目到末尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        如果希望将条目插入到指定顶级条目列表的 index 序号位置，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::insertTopLevelItem(int index, QTreeWidgetItem * item)
void QTreeWidget::insertTopLevelItems(int index, const QList&lt;QTreeWidgetItem *&gt; &amp; items)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>树形控件所有的顶级条目父节点指针都为 NULL</strong> （父节点是指树形层次中的节点关系，<strong>而条目的父控件依然是树形控件本身</strong>）。<br>​        添加了顶级条目之后，可以对顶级条目进行计数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::topLevelItemCount() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（2）移除顶级条目"><a href="#（2）移除顶级条目" class="headerlink" title="（2）移除顶级条目"></a>（2）移除顶级条目</h3><p>​        移除顶级条目的函数也是take*打头：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::takeTopLevelItem(int index)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        index是顶级条目的序号，<strong>该函数只是从树形控件卸下顶级条目，但不会删除条目的内存空间，如果希望彻底删除，那么手动 delete 该函数返回的条目。</strong><br>如果要清空所有的顶级条目和子条目，使用槽函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::clear()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（3）条目访问函数-1"><a href="#（3）条目访问函数-1" class="headerlink" title="（3）条目访问函数"></a>（3）条目访问函数</h3><p>​        对于顶级条目，如果知道顶级条目的序号获取对应的条目：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::topLevelItem(int index) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        反过来，对于已知顶级条目对象，查看其顶级序号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::indexOfTopLevelItem(QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果条目不是顶级条目或者条目不属于该控件，那么会返回 -1。<br>​        树形控件实际运行时，可能既有顶级条目，也有展开后的子孙条目同时显示，<strong>所以某个条目上面或下面的相邻条目不一定是同级别的兄弟条目，有可能是叔辈祖 辈的条目，也 可能是子辈孙辈条目。</strong>获取某个条目的相邻条目函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::itemAbove(const QTreeWidgetItem * item) const &#x2F;&#x2F;上面相邻条目
QTreeWidgetItem * QTreeWidget::itemBelow(const QTreeWidgetItem * item) const &#x2F;&#x2F;下面相邻条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        从屏幕控件显示角度，如果根据树形控件<strong>内部相对坐标</strong>获取条目（树形控件显示区域的左上角为原点），使用下面函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::itemAt(const QPoint &amp; p) const
QTreeWidgetItem * QTreeWidget::itemAt(int x, int y) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这两个函数是一个意思，一<strong>个用 QPoint 对象表示相对坐标，另一个直接用 x 和 y 数值表示坐标，如果对应坐标没有条目，会返回</strong> <strong>NULL</strong>，注意判断 返回值。<br>​        树形控件也是自带滚动条的，如果条目特别多，自动显示滚动条，对于树形控件在屏幕可见的条目，可以根据条目对象获取它的<strong>可视矩形</strong>（树形控件显示区域的 左上角为原 点）：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QRect QTreeWidget::visualItemRect(const QTreeWidgetItem * item) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="（4）当前条目的操作"><a href="#（4）当前条目的操作" class="headerlink" title="（4）当前条目的操作"></a>（4）当前条目的操作</h3><p>​        树形控件的选中操作默认比较像 QListWidget，如果不手动设置，<strong>只能选中一个高亮条目</strong>。<br>获取当前高亮选中条目的函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTreeWidgetItem * QTreeWidget::currentItem() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        树形控件可以有多列，当前条目被点击选中的列号为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTreeWidget::currentColumn() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        树形控件内的条目一般都没有固定行号，<strong>因为条目可以展开也可以折叠，行号是变化的，所以没有基于行号的操作函数。</strong></p>
<p>​        如果要设置某个条目为当前选中的状态：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setCurrentItem(QTreeWidgetItem * item)
void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column)
void QTreeWidget::setCurrentItem(QTreeWidgetItem * item, int column, QItemSelectionModel::SelectionFlags command)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        第一个 setCurrentItem() 函数相当<strong>于设置该条目整行高亮选中</strong>，第二个是设置该条目行的 column <strong>列高亮选中</strong>，第三个函数是<strong>单次选中命令</strong>，参考“8.2.4 选中区域和选中行为”的单次选中命令内容，<strong>只是树形控件是一整行为一个条目，定位到条目的某列数据，就 类似指定表格控件的单元格。</strong><br>如果当前高亮选中的状态发生变化，会触发如下信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::currentItemChanged(QTreeWidgetItem * current, QTreeWidgetItem * previous)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里分别是当前高亮选中的条目，和之前高亮选中的条目，注意指针可能是 NULL，使用指针前一定要判断指针非空</p>
<h3 id="（5）条目查找和排序-1"><a href="#（5）条目查找和排序-1" class="headerlink" title="（5）条目查找和排序"></a>（5）条目查找和排序</h3><p>​        如果要根据模板子串查找某列文本匹配的条目，使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QList&lt;QTreeWidgetItem *&gt; QTreeWidget::findItems(const QString &amp; text, Qt::MatchFlags flags, int column &#x3D; 0) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数里text是模板子串，flags是匹配标志（参看“8.1.1 QListWidget”中的字符串匹配标志表格），第三个参数是指定查找的列。<strong>该函数只查找一列的文本，其他列的文本是不查找的</strong>。如果需要查找所有列数据，那么要根据不同列号逐列查询。</p>
<p>​        类似表格控件，树形控件也可以按照列的文本进行自动排序，自动排序的设置函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool    isSortingEnabled() const          &#x2F;&#x2F;设置是否自动排序
void    setSortingEnabled(bool enable)   &#x2F;&#x2F;查看是否开启自动排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        指定排序的列号和升序降序，使用从基类继承的函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeView::sortByColumn(int column, Qt::SortOrder order)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>在没有开启自动排序的情况下，也可以调用该函数进行一次性的条目排序。</strong></p>
<h3 id="（6）条目显示和运行时条目编辑-1"><a href="#（6）条目显示和运行时条目编辑-1" class="headerlink" title="（6）条目显示和运行时条目编辑"></a>（6）条目显示和运行时条目编辑</h3><p>​        可以为条目的某列“单元格”设置单独的控件来静态显示（控件不具有编辑功能）：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setItemWidget(QTreeWidgetItem * item, int column, QWidget * widget) &#x2F;&#x2F;设置条目列控件
QWidget * QTreeWidget::itemWidget(QTreeWidgetItem * item, int column) const &#x2F;&#x2F;获取条目列控件，不设置就是NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        注意该函数只能在条目添加到树形控件之后*<em>才能调用，否则无效，\并且条目列控件只能用于显示，无法编辑，如果要定制可编辑的“单元格”控件，必须用基类 QTreeView 并继承 QItemDelegate 做代理，这些内容到后面模型视图章节讲解<br>​        再次强调：itemWidget 条目控件，在默认情况下是与条目本身数据完全无关的，是条目数据的替换品，而不是协作模式。<strong>只有手动设置信号与槽，它们才可能关联上。</strong><br>QListWidget 和 QTreeWidget 的条目控件<strong>都是静态显示，不能编辑。</strong><br>​        QTreeWidget 控件的条目列控件 widget 还必须把默认是透明背景<em>*，</em></em>这样控件的内容和内部模型数据（就是条目的列数据）同时显示，文本会重影，效果就糟糕了。<br>删除条目的列控件使用如下函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::removeItemWidget(QTreeWidgetItem * item, int column)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        <strong>这个函数没有返回值，会自动地彻底删除条目列控件。</strong></p>
<p>​        在大多数情况下都用不到 itemWidget ，因为能够为条目设置可编辑标志位，然后调用如下函数开启树形控件自带的文本编辑器：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::editItem(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数 item 是指定的条目，column 是条目的列（类似“单元格”）。在没有为条目设置可编辑标志位的情况下，可以调用下面一对函数进行持续编辑器的开启和关闭：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::openPersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)
void QTreeWidget::closePersistentEditor(QTreeWidgetItem * item, int column &#x3D; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>注意这对函数一开一关，要成对调用，否则编辑完了不会自动关闭持续编辑器。</strong></p>
<h3 id="（7）信号"><a href="#（7）信号" class="headerlink" title="（7）信号"></a>（7）信号</h3><p>​        关于当前高亮选中变化的信号 currentItemChanged() 前面讲过了，这里先列几个常规的信号，然后再将树形控件独有的信号。常规信号就是下面这 几个：（条目列就类似表格控件的单元格）</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void itemActivated(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被激活
void itemChanged(QTreeWidgetItem * item, int column)   &#x2F;&#x2F;条目列的数据发生变化，比如文本或图标修改了
void itemClicked(QTreeWidgetItem * item, int column)  &#x2F;&#x2F;条目列被单击
void itemDoubleClicked(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被双击
void itemEntered(QTreeWidgetItem * item, int column) &#x2F;&#x2F;进入条目列
void itemPressed(QTreeWidgetItem * item, int column) &#x2F;&#x2F;条目列被点 击按下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>树形控件最独特的就是展开和折叠信号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::itemExpanded(QTreeWidgetItem * item)  &#x2F;&#x2F;条目展开时发送信号
void QTreeWidget::itemCollapsed(QTreeWidgetItem * item) &#x2F;&#x2F;条目折叠时发送信号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        如果调用槽函数 expandAll() 展开所有子孙条目，那么不会触发 itemExpanded() 信号，因为触发太多会非常影响性能。<br>​        类似地，如果用槽函数 collapseAll() 折叠所有子孙条目，也不会触发 itemCollapsed() 信号，以免影响性能。<br>举例来说，在文件夹浏览的时候，因为操作系统里的文件太多，没法一次性构建完整的文件树，那么就可以用展开和折叠信号实时枚举某一层次文件夹的内容， 而不是一次性 枚举文件系统所有文件，因为一次性枚举所有文件的性能太糟糕。<br>树形控件还有一个 <strong>itemSelectionChanged</strong>() 信号，一般在多选模式才会用到，稍后讲解。</p>
<h3 id="（8）槽函数"><a href="#（8）槽函数" class="headerlink" title="（8）槽函数"></a>（8）槽函数</h3><p>​        树形控件的槽函数包括四个（基类的另算）：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void clear() &#x2F;&#x2F;清空整个树形控件
void collapseItem(const QTreeWidgetItem * item) &#x2F;&#x2F;折叠指定的条目
void expandItem(const QTreeWidgetItem * item)  &#x2F;&#x2F;展开指定 条目
void scrollToItem(const QTreeWidgetItem * item, QAbstractItemView::ScrollHint hint &#x3D; EnsureVisible) &#x2F;&#x2F;滚动到指定条目<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        滚动函数 scrollToItem() 第二个参数是<strong><em>\</em>滚到到该条目的显示方式**</strong>，参考“8.1.1 QListWidget”QAbstractItemView::  ScrollHint 枚举常量的表格。</p>
<h3 id="（9）基类-QTreeView-的函数"><a href="#（9）基类-QTreeView-的函数" class="headerlink" title="（9）基类 QTreeView 的函数"></a>（9）基类 QTreeView 的函数</h3><p>QTreeView 的功能函数也很多，这里列举几个可能常用的，详细的内容等到模型视图章节讲解。关于列隐藏或显示、设置列宽的函数如下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeView::setColumnHidden(int column, bool hide) &#x2F;&#x2F;设置列隐藏或显示
bool QTreeView::isColumnHidden(int column) const &#x2F;&#x2F;判断列是否隐藏
void QTreeView::hideColumn(int column) &#x2F;&#x2F;槽函数，隐藏指定列
void QTreeView::showColumn(int column) &#x2F;&#x2F;槽函数，显示指定列
void QTreeView::setColumnWidth(int column, int width) &#x2F;&#x2F;设置列宽
int QTreeView::columnWidth(int column) const &#x2F;&#x2F;获取指定列的宽度
void QTreeView::resizeColumnToContents(int column) &#x2F;&#x2F;槽函数，自动调整 指定列的宽度属性 
 &#x2F;&#x2F;indentation 控制显示父子节点的缩进宽度：
int indentation() const    &#x2F;&#x2F;获取父子节点的缩进宽度
void setIndentation(int i) &#x2F;&#x2F;设置缩进宽度
void resetIndentation()    &#x2F;&#x2F;重置缩进宽度为默认值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基类还有几个常用的折叠和展开槽函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void collapseAll() &#x2F;&#x2F;折叠所有子孙节点，这样只能看到顶级节点
void expandAll() &#x2F;&#x2F;展开所有子孙节点，完全展开的树
void expandToDepth(int depth) &#x2F;&#x2F;展开 depth 层级的子节点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        expandToDepth() 函数是指一直展开，直到将第 depth 层级的子节点都展开为止。以顶级条目为第 0 层级，顶级条目的直接子节点为第 1 层级，孙子节点为第 2 层级，依次类推。<br>​        例如 expandToDepth(0) 的效果如下：</p>
<p><img src="c1f8eac3f9ec327ea98347e5abab1354.png" alt="c1f8eac3f9ec327ea98347e5abab1354.png"></p>
<p>​        如果调用 expandToDepth(1) 展开第1级的节点：</p>
<p><img src="590d3ad8a2fcae012d2240bdbe9a012c.png" alt="590d3ad8a2fcae012d2240bdbe9a012c.png"></p>
<p>​        如果把 expandToDepth() <strong>参数设置成负数，那么相当于展开无穷大级别，就是展开所有的子孙节点。</strong></p>
<h3 id="（10）树头条目"><a href="#（10）树头条目" class="headerlink" title="（10）树头条目"></a>（10）树头条目</h3><p>​        树形控件只有一个表头，就是<strong>显示在上面的水平表头，本节也叫树头条目</strong>。设置树头条目的函数为：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTreeWidget::setHeaderItem(QTreeWidgetItem * item) &#x2F;&#x2F;设置树头条目，树头条目可以有多列数据，相当于多列的表头一次性设置了。
void QTreeWidget::setHeaderLabel(const QString &amp; label) &#x2F;&#x2F;只设置第 0 列的表头
void QTreeWidget::setHeaderLabels(const QStringList &amp; labels) &#x2F;&#x2F;设置多列的表头
QTreeWidgetItem * QTreeWidget::headerItem() const &#x2F;&#x2F;获取树头条目
树头条目本质其实也是由 QHeaderView 子控件来显示的，可以在基类找到相关函数：
QHeaderView * QTreeView::header() const &#x2F;&#x2F;获取表头视图控件
void QTreeView::setHeader(QHeaderView * header) &#x2F;&#x2F;设置表头视图， 一般树形控件不需要用这个函数
void QTreeView::setHeaderHidden(bool hide) &#x2F;&#x2F;设置表头是否隐藏
bool QTreeView::isHeaderHidden() const &#x2F;&#x2F;判断是否隐藏了表头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        无论是 QTableWidget 还是 QTreeWidget 的表头，都是 QHeaderView 子控件显示，QHeaderView 参考“8.2.3 表头设置”的内容。</p>
<h3 id="（11）选中行为和选中模式"><a href="#（11）选中行为和选中模式" class="headerlink" title="（11）选中行为和选中模式"></a>（11）选中行为和选中模式</h3><p>​        与 QTableWidget 类似，QTreeWidget也从祖类 QAbstractItemView 继承了选中行为和选中模式的属性：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QAbstractItemView::SelectionBehavior  selectionBehavior() const &#x2F;&#x2F;获取选中行为，按条目选中、整行或整列选中
void setSelectionBehavior(QAbstractItemView::SelectionBehavior behavior) &#x2F;&#x2F;设置选中行为
QAbstractItemView::SelectionMode  selectionMode() const &#x2F;&#x2F;获取选中模式，比如单选、多选、扩展选择
void setSelectionMode(QAbstractItemView::SelectionMode mode) &#x2F;&#x2F;设置选中模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        关于选中模式和选中行为的枚举常量参看“8.2.4 选中区域和选中行为”小节中的枚举常量表格，单次选中命令的函数和枚举常量也参考该小节。</p>
<p>​        默认情况下，树形控件是按照整行选中，并且是单选模式，如果把选中模式改成多选的 QAbstractItemView::ExtendedSelection，那么树形控件也可以使多选的，这时候信号 itemSelectionChanged() 就能派上用场：</p>
<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword type-declaration">void</span> <span class="token class-name static-context">QTreeWidget</span><span class="token operator">::</span><span class="token function">itemSelectionChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        多选状态变化时会触发该信号（单选模式也触发，只是不需要用这个信号），可以关联该信号，监视当前所有选中的条目：</p>
<pre class="line-numbers language-cobol" data-language="cobol"><code class="language-cobol">QList<span class="token operator">&lt;</span>QTreeWidgetItem <span class="token comment">*> QTreeWidget::selectedItems() const</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        注意，<strong>这里的选中条目仅仅是指实际显示的直接选中的条目，不包括折叠隐藏的子孙条目计数</strong>，因为选中父节点与选中其子孙节点没关系，不会递归选中所有子 孙：</p>
<p><img src="c216490e8c65baf4903b5093b2deddcc.png" alt="c216490e8c65baf4903b5093b2deddcc.png"></p>
<p>​        树形控件及其基类没有递归选中子条目的属性或函数，<strong>如果希望递归选中某个节点的所有子孙节点，那么需要自行编写递归函数。</strong>关于树形控件类本身的内容介 绍到这，因为 涉及到父子节点隶属关系、节点展开和折叠，树形控件还有很大一部分功能都是由其条目类 QTreeWidgetItem 的函数实现的.</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include&lt;QListWidgetItem&gt;
#include&lt;QStringList&gt;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
&#123;   
    ui-&gt;treeWidget-&gt;setHeaderLabels(QStringList()&lt;&lt;&quot;卢本伟&quot;&lt;&lt;&quot;牛逼&quot;);
	QTreeWidgetItem* item &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐&quot;);
    QTreeWidgetItem* item2 &#x3D; new QTreeWidgetItem(QStringList()&lt;&lt;&quot;乐2&quot;);
    ui-&gt;treeWidget-&gt;addTopLevelItem(item);
    ui-&gt;treeWidget-&gt;addTopLevelItem(item2);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230526200623971.png" alt="image-20230526200623971"></p>
<h2 id="QTableWidget"><a href="#QTableWidget" class="headerlink" title="QTableWidget"></a>QTableWidget</h2><p><img src="image-20230526200740443.png" alt="image-20230526200740443"></p>
<pre class="line-numbers language-none"><code class="language-none">Detailed Description<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Table widgets provide standard table display facilities for applications. The items in a QTableWidget are provided by QTableWidgetItem.<br>​        If you want a table that uses your own data model you should use QTableView rather than this class.<br>​        Table widgets can be constructed with the required numbers of rows and columns:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">tableWidget &#x3D; new QTableWidget(12, 3, this);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        Alternatively, tables can be constructed without a given size and resized later:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">tableWidget &#x3D; new QTableWidget(this);
tableWidget-&gt;setRowCount(10);
tableWidget-&gt;setColumnCount(5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        Items are created outside the table (with no parent widget) and inserted into the table with setItem():</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem *newItem &#x3D; new QTableWidgetItem(tr(&quot;%1&quot;).arg(\
        								 (row+1)*(column+1)));
tableWidget-&gt;setItem(row, column, newItem);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        If you want to enable sorting in your table widget, do so after you have populated it with items, otherwise sorting may interfere with the insertion order (see setItem() for details).<br>Tables can be given both horizontal and vertical headers. The simplest way to create the headers is to supply a list of strings to the setHorizontalHeaderLabels() and setVerticalHeaderLabels() functions. These will provide simple textual headers for the table’s columns and rows. More sophisticated headers can be created from existing table items that are usually constructed outside the table. For example, we can construct a table item with an icon and aligned text, and use it as the header for a particular column:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem *cubesHeaderItem &#x3D; new QTableWidgetItem(tr(&quot;Cubes&quot;));
cubesHeaderItem-&gt;setIcon(QIcon(QPixmap(&quot;:&#x2F;Images&#x2F;cubed.png&quot;)));
cubesHeaderItem-&gt;setTextAlignment(Qt::AlignVCenter);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        The number of rows in the table can be found with rowCount(), and the number of columns with columnCount(). The table can be cleared with the clear() function.</p>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>​        原博客：</p>
<p>​        <a target="_blank" rel="noopener" href="https://qtguide.ustclug.org/">Qt编程指南，Qt新手教程，Qt Programming Guide</a></p>
<h2 id="QTableWidgetItem"><a href="#QTableWidgetItem" class="headerlink" title="QTableWidgetItem"></a>QTableWidgetItem</h2><p>​        表格控件条目 QTableWidgetItem 与 8.1.2 节 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QListWidgetItem&amp;spm=1001.2101.3001.7020">QListWidgetItem</a> 有很多相似的地方，<br>QTableWidgetItem 也是一个纯数据类，不是控件，没有基类，也就没有信号和槽函数。QTableWidgetItem 可以直接用数据流 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=QDataStream&amp;spm=1001.2101.3001.7020">QDataStream</a> 读写，表格条目不单单有文本，还可以有自己的图标、复选框等特性，表格控件会根据条目对象的丰富特性来呈现数据并进行交互操作。</p>
<h3 id="（1）首先来看看条目的构造函数："><a href="#（1）首先来看看条目的构造函数：" class="headerlink" title="（1）首先来看看条目的构造函数："></a>（1）<strong>首先来看看条目的构造函数：</strong></h3><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem(int type &#x3D; Type)
QTableWidgetItem(const QString &amp; text, int type &#x3D; Type)
QTableWidgetItem(const QIcon &amp; icon, const QString &amp; text, int type &#x3D; Type)
QTableWidgetItem(const QTableWidgetItem &amp; other) &#x2F;&#x2F;复制构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        参数里的 type 一般用于派生类，指定条目独特的分类，对于普通的表格控件条目，通常用默认的数值即可。第二个构造函数是指定了条目的文本，第三个构造函数同 时指定了条目图标和文本。<br>​        在构造函数里不能直接指定所属的表格控件，因为表格控件有行号、列号所以不能简单追加到表格里，而只能用表格控件的 QTableWidget::setItem() 函数把条目设置到指定单元格里。注意一个条目只能设置给表格控件唯一的一个单元格，不能把一个条目设置给多个单元格。如果希望为多个单元格设置相似的条目数据内容，那么可 以用后面介绍的 clone() 函数制造大量新的复制体条目。<br>​        复制构造函数不会复制旧条目的 type() 类型值和tableWidget() 所属表格控件指针，条目其他的内部数据和条目标志都会复制。</p>
<h3 id="（2）复制函数和运算符函数"><a href="#（2）复制函数和运算符函数" class="headerlink" title="（2）复制函数和运算符函数"></a>（2）<strong>复制函数和运算符函数</strong></h3><p>​        除了复制构造函数，还有专门的克隆函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem * QTableWidgetItem::clone() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        克隆函数会新建一个当前条目的复制体，然后返回新复制体条目的指针，如果要构造并添加大量重复内容的条目，这个函数就比较实用。clone() 函数内部会调用复制构造函数创建新条目并返回。<br>​        条目复制还可以用等于号函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        等于号函数复制的内容与复制构造函数差不多，type() 类型值和 tableWidget() 所属表格控件指针也不复制。<br>​        还有个小于号函数，可以比较条目文本的字典序：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidgetItem &amp; QTableWidgetItem::operator&#x3D;(const QTableWidgetItem &amp; other)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果希望使用更多的比较函数，可以直接用 QString 的比较函数。</p>
<h3 id="（3）QTableWidgetItem-的功能函数与内部数据"><a href="#（3）QTableWidgetItem-的功能函数与内部数据" class="headerlink" title="（3）QTableWidgetItem 的功能函数与内部数据"></a>（3）<strong>QTableWidgetItem 的功能函数与内部数据</strong></h3><p>​        QTableWidgetItem 内部的数据也大致分为两类：第一类是以数据角色形式管理的通用数据，这些数据自动参与 QDataStream 数据流的读写；第二类是非通用数据，不参与数据流读写，与 QListWidgetItem 和 QListWidget 自身特性有关。QTableWidgetItem 主要的功能函数也是围绕这两类内部数据展开的。</p>
<p>​        ● <strong>第一类：通用数据及其处理函数</strong><br>​        通用数据是以数据角色与数据变量一一对应的形式存储管理，比如设置文本 setText()、设置图标 setIcon() 等函数，其本质都是根据各自的角色调用通用设置数据的函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">virtual void setData(int role, const QVariant &amp; value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        也可以根据角色来获取各个数据变量：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">virtual QVariant data(int role) const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        查看表格控件的源代码文件可以看到关于图标操作函数的源码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> QIcon <span class="token function">icon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">&#123;</span> 
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">qvariant_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QIcon<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token function">data</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DecorationRole<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">QTableWidgetItem</span><span class="token double-colon punctuation">::</span><span class="token function">setIcon</span><span class="token punctuation">(</span><span class="token keyword">const</span> QIcon <span class="token operator">&amp;</span>aicon<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">setData</span><span class="token punctuation">(</span>Qt<span class="token double-colon punctuation">::</span>DecorationRole<span class="token punctuation">,</span> aicon<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        QTableWidgetItem 的通用数据与 QListWidgetItem 的通用数据一模一样，函数名也一样，列表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>获取函数</strong></th>
<th><strong>设置函数</strong></th>
<th><strong>数据角色</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>text()</td>
<td>setText(const QString &amp;text)</td>
<td>Qt::DisplayRole</td>
<td>条目显示的文本。</td>
</tr>
<tr>
<td>icon()</td>
<td>setIcon(const QIcon &amp;icon)</td>
<td>Qt::DecorationRole</td>
<td>条目显示的图标。</td>
</tr>
<tr>
<td>statusTip()</td>
<td>setStatusTip(const QString &amp;statusTip)</td>
<td>Qt::StatusTipRole</td>
<td>如果主界面有状态栏，鼠标悬停在该条目上时显示该状态信息到状态栏。</td>
</tr>
<tr>
<td>toolTip()</td>
<td>setToolTip(const QString &amp;toolTip)</td>
<td>Qt::ToolTipRole</td>
<td>鼠标悬停在该条目上时显示的工具提示信息。</td>
</tr>
<tr>
<td>whatsThis()</td>
<td>setWhatsThis(const QString &amp;whatsThis)</td>
<td>Qt::WhatsThisRole</td>
<td>如果主界面窗口标题栏有？帮助按钮，点击帮助按钮再点击该条目会显示该帮助信息。</td>
</tr>
<tr>
<td>font()</td>
<td>setFont(const QFont &amp;font)</td>
<td>Qt::FontRole</td>
<td>显示条目文本用的字体。</td>
</tr>
<tr>
<td>textAlignment()</td>
<td>setTextAlignment(int alignment)</td>
<td>Qt::TextAlignmentRole</td>
<td>文本的对齐方式。</td>
</tr>
<tr>
<td>backgroundColor()</td>
<td>setBackgroundColor(const QColor &amp;color)</td>
<td>Qt::BackgroundColorRole</td>
<td>文本背景色。</td>
</tr>
<tr>
<td>textColor()</td>
<td>setTextColor(const QColor &amp;color)</td>
<td>Qt::TextColorRole</td>
<td>文字颜色。</td>
</tr>
<tr>
<td>background()</td>
<td>setBackground(const QBrush &amp;brush)</td>
<td>Qt::BackgroundRole</td>
<td>条目的背景画刷。</td>
</tr>
<tr>
<td>foreground()</td>
<td>setForeground(const QBrush &amp;brush)</td>
<td>Qt::ForegroundRole</td>
<td>条目的前景画刷。</td>
</tr>
<tr>
<td>checkState()</td>
<td>setCheckState(Qt::CheckState state)</td>
<td>Qt::CheckStateRole</td>
<td>条目自带的复选框选中状态，可以是三态复选框。</td>
</tr>
<tr>
<td>sizeHint()</td>
<td>setSizeHint(const QSize &amp;size)</td>
<td>Qt::SizeHintRole</td>
<td>条目显示的建议尺寸。</td>
</tr>
</tbody>
</table>
</div>
<p>​        表格条目 QTableWidgetItem 可以直接用数据流 QDataStream 读写，是通过下面运算符重载函数实现的：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QDataStream &amp;    operator&lt;&lt;(QDataStream &amp; out, const QTableWidgetItem &amp; item)
QDataStream &amp;    operator&gt;&gt;(QDataStream &amp; in, QTableWidgetItem &amp; item)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        使用 &gt;&gt; 和 &lt;&lt; 运算符进行流输入输出比较常见，当然也可以用 QTableWidgetItem 类内部的读写函数进行输入输出：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QTableWidgetItem::read(QDataStream &amp; in)
void QTableWidgetItem::write(QDataStream &amp; out) const<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​         <strong>第二类：非通用数据及其操作函数</strong><br>表格控件的条目也是在构造函数一次性指定条目类型，然后这个类型是只读的：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTableWidgetItem::type() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        类型值一般用于派生类区分不同的条目类型，自定义的条目类型值需要大于等于 QTableWidgetItem::UserType 。<br>​        新条目通过表格控件 QTableWidget::setItem() 函数设置给表格控件之后，条<strong>目会自动保存所属的表格控件指针，</strong>可以用如下函数获取：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">QTableWidget * QTableWidgetItem::tableWidget() const<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        程序运行时，除了可以通过表格控件的 QTableWidget::selectedItems() 获取用户选中的条目列表，每个单元格条目自身也会记录是否 被用户选中，并且能设置自身是否被选中：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">bool QTableWidgetItem::isSelected() const &#x2F;&#x2F;判断条目自身是否高亮选中
void QTableWidgetItem::setSelected(bool select) &#x2F;&#x2F;设置条目自身是 否被选中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        <strong>表格控件条目初始化时也有默认的标志位，并且运行时可以修改条目的特性标志：</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">Qt::ItemFlags QTableWidgetItem::flags() const &#x2F;&#x2F;获取特性标志位
void QTableWidgetItem::setFlags(Qt::ItemFlags flags) &#x2F;&#x2F;设置特性标志位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        QTableWidgetItem 构造<strong>时默认的标志位为</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>QT宏</th>
</tr>
</thead>
<tbody>
<tr>
<td>Qt::ItemIsSelectable</td>
</tr>
<tr>
<td>Qt::ItemIsUserCheckable</td>
</tr>
<tr>
<td>Qt::ItemIsEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsDragEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsDropEnabled</td>
</tr>
<tr>
<td>Qt::ItemIsEditable</td>
</tr>
</tbody>
</table>
</div>
<p>​        因此程序代码生成的所有表格条目默认都是可编辑的，程序运行时用户双击空的单元格时，表格控件会自动创建新条目保存用户编辑内容，这些自动创建的条目也都是可编辑的。如果希望条目是只读的，那么把标志位设置不带Qt::ItemIsEditable 的新标志位即可。</p>
<p>​        Qt::ItemFlags 所有的枚举常量在 8.1.2 节末尾有详细的表格描述，这里不重复贴了。表格条目默认就是支持复选状态的，只是默认没有显示出来，要让表格控件显示条目对应的复选框，可以用下面一句代码实现：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">item-&gt;setCheckState( Qt::Unchecked );  &#x2F;&#x2F;显示复选框<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        对于表格控件和表格条目，自带单行编辑器和复选框功能，因此不需要为单元格添加自定义的单行编辑器或复选框，如果要用到其他更多的输入控件，那才需要定制单元格。<br>​        表格控件条目与 QListWidgetItem 最大的一个区别就是表格条目既有行号，也有列号：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int QTableWidgetItem::row() const &#x2F;&#x2F;获取行号
int QTableWidgetItem::column() const &#x2F;&#x2F;获取列号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        行号和列号也是在 QTableWidget::setItem() 函数里指定的，条目自身并不能修改行号或列号。表格控件条目与 QListWidgetItem 另一个区别是，<strong>表格控件条目没有隐藏函数，所有表格条目都是显示的（只要不被单元格控件QTableWidget::cellWidget() 遮挡）。</strong></p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;设函数列数
    ui-&gt;tableWidget-&gt;setColumnCount(3);

    &#x2F;&#x2F;设置表头
    ui-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;&quot;姓名&quot;&lt;&lt;&quot;性别&quot;&lt;&lt;&quot;年龄&quot;);

    ui-&gt;tableWidget-&gt;setRowCount(10);
    ui-&gt;tableWidget-&gt;setItem(0,0,new QTableWidgetItem(&quot;泰勒&quot;));


&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230526202457563.png" alt="image-20230526202457563"></p>
<h2 id="其他常见的控件一览"><a href="#其他常见的控件一览" class="headerlink" title="其他常见的控件一览"></a>其他常见的控件一览</h2><h3 id="滚动条控件"><a href="#滚动条控件" class="headerlink" title="滚动条控件"></a>滚动条控件</h3><p>​        我们可以在UI界面中找到滚动条控件——Scroll Widget，将大量的控件扔到里面之后，可以得到：</p>
<p><img src="image-20230527100557180.png" alt="image-20230527100557180"></p>
<p>​        可以上下拖拽的那种！</p>
<h3 id="ToolBox"><a href="#ToolBox" class="headerlink" title="ToolBox"></a>ToolBox</h3><p>​        回忆一下，我们的ToolBox，就跟QQ的好友栏一样的</p>
<p><img src="image-20230527100815303.png" alt="image-20230527100815303"></p>
<p>​        这里的Page1 和 Page2单击一下在属性栏的CurrrentPageName里更改就好了</p>
<h3 id="Tab-Widget"><a href="#Tab-Widget" class="headerlink" title="Tab Widget"></a>Tab Widget</h3><p>​        有点像网页那样的东西!</p>
<p><img src="image-20230527101102584.png" alt="image-20230527101102584"></p>
<p>​        当然,我们切换就带上按钮就好了!,使用信号与槽即可</p>
<p><img src="image-20230527101328100.png" alt="image-20230527101328100"></p>
<p>​        等等…</p>
<h3 id="利用QLable显示图片"><a href="#利用QLable显示图片" class="headerlink" title="利用QLable显示图片"></a>利用QLable显示图片</h3><p><img src="image-20230527101714658.png" alt="image-20230527101714658"></p>
<h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><p>​                可以在工程中新建一个QT文件_自定义设计师类&gt;默认的Widget类中!设计好空间之后返回主窗口的UI, 随后点击提升为(本质是换成子对象),将之提升为设计好的Widget的名称后点击提升,运行就可看到效果</p>
<p>​        点击全局提升，下一次直接提升为.</p>
<h2 id="QEvent"><a href="#QEvent" class="headerlink" title="QEvent"></a>QEvent</h2><p>​        下面我们自己写一个Lable，来学习自定义的事件这个模块。</p>
<p>​        首先，我们选择新建一个Widget：回忆下，就是在添加新文件下面——选择QWidget类型后include进来！</p>
<p>​        先不要着急include控件到UI界面下，我们修改几个地方：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef MYLABEL_H
#define MYLABEL_H

#include &lt;QLabel&gt;

class MyLabel : public QLabel &#x2F;&#x2F; here
&#123;
    Q_OBJECT
public:
    explicit MyLabel(QWidget *parent &#x3D; nullptr);

    void enterEvent(QEnterEvent*); &#x2F;&#x2F; add this
    void leaveEvent(QEvent*); &#x2F;&#x2F;add this
signals:

&#125;;

#endif &#x2F;&#x2F; MYLABEL_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;
#include&lt;QDebug&gt;
MyLabel::MyLabel(QWidget *parent)
    : QLabel&#123;parent&#125;
&#123;

&#125;
void MyLabel::enterEvent(QEnterEvent* event)&#123;
    qDebug()&lt;&lt;&quot;111&quot;;
&#125;
void MyLabel::leaveEvent(QEvent*)&#123;
      qDebug()&lt;&lt;&quot;222&quot;;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​         然后在UI界面中添加Label控件，提升为MyLabel。现在：</p>
<p><img src="image-20230528171240039.png" alt="image-20230528171240039"></p>
<p>​        现在，进入正题——鼠标事件的改写。</p>
<p>​        我们添加如下的事件函数：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef MYLABEL_H
#define MYLABEL_H

#include &lt;QLabel&gt;

class MyLabel : public QLabel
&#123;
    Q_OBJECT
public:
    explicit MyLabel(QWidget *parent &#x3D; nullptr);

    void enterEvent(QEnterEvent*);
    void leaveEvent(QEvent*);

    virtual void mousePressEvent(QMouseEvent* ev);
    virtual void mouseReleaseEvent(QMouseEvent* ev);
    virtual void mouseMoveEvent(QMouseEvent* ev);
signals:

&#125;;

#endif &#x2F;&#x2F; MYLABEL_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;
#include&lt;QDebug&gt;
MyLabel::MyLabel(QWidget *parent)
    : QLabel&#123;parent&#125;
&#123;

&#125;
void MyLabel::enterEvent(QEnterEvent* event)&#123;
    qDebug()&lt;&lt;&quot;111&quot;;
&#125;
void MyLabel::leaveEvent(QEvent*)&#123;
      qDebug()&lt;&lt;&quot;222&quot;;
&#125;

void MyLabel::mousePressEvent(QMouseEvent* ev)&#123;
      qDebug()&lt;&lt;&quot;You press your mouse&quot;;
&#125;
void MyLabel::mouseReleaseEvent(QMouseEvent* ev)&#123;
      qDebug() &lt;&lt; &quot;yes, you depress the mouse&quot;;
&#125;
void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;
      qDebug() &lt;&lt; &quot;yes, you move mouse&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230528171807801.png" alt="image-20230528171807801"></p>
<p>​        我们的ev实际上就返回了所有的信息：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;
#include&lt;QDebug&gt;
#include&lt;QMouseEvent&gt;
MyLabel::MyLabel(QWidget *parent)
    : QLabel&#123;parent&#125;
&#123;

&#125;
void MyLabel::enterEvent(QEnterEvent* event)&#123;
    qDebug()&lt;&lt;&quot;111&quot;;
&#125;
void MyLabel::leaveEvent(QEvent*)&#123;
      qDebug()&lt;&lt;&quot;222&quot;;
&#125;

void MyLabel::mousePressEvent(QMouseEvent* ev)&#123;
      qDebug()&lt;&lt;&quot;You press your mouse&quot;;
&#125;
void MyLabel::mouseReleaseEvent(QMouseEvent* ev)&#123;
      qDebug() &lt;&lt; &quot;yes, you depress the mouse&quot;;
&#125;
void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;
      QString str &#x3D; QString(&quot;yes, you move mouse x &#x3D; %1 y &#x3D; %2&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()); &#x2F;&#x2F; QString的格式化
      qDebug() &lt;&lt;str;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230528172343019.png" alt="image-20230528172343019"></p>
<p>​        还有globle的，表明是相对于屏幕的为止！</p>
<p>​        如果是检测是不是：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void MyLabel::mouseMoveEvent(QMouseEvent* ev)&#123;
    if(ev-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;
        QString str &#x3D; QString(&quot;yes, you move mouse x &#x3D; %1 y &#x3D; %2&quot;).arg(ev-&gt;x()).arg(ev-&gt;y()); &#x2F;&#x2F; QString的格式化
      	qDebug() &lt;&lt;str;   
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Qt-Event事件详解"><a href="#Qt-Event事件详解" class="headerlink" title="Qt Event事件详解"></a>Qt Event事件详解</h2><p>​        传送门：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/48f007c2de09">https://www.jianshu.com/p/48f007c2de09</a></p>
<p>​        <strong>在与用户交互时发生</strong>。比如按下鼠标（mousePressEvent），敲击键盘（keyPressEvent）等。<br>​        <strong>系统自动发生</strong>，比如计时器事件（timerEvent）等。<br>在发生事件时（比如说上面说的按下鼠标），就会产生一个QEvent对象（这里是QMouseEvent，为QEvent的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=子类&amp;spm=1001.2101.3001.7020">子类</a>），这个QEvent对象会传给当前组件的event函数。如果当前组件没有安装事件过滤器（这个下文会提到），则会被event函数发放到相应的xxxEvent函数中（这里是mousePressEvent函数）。</p>
<p>​        Qt中所有的事件类都继承于QEvent类</p>
<p>​        这个QEvent对象会有各种各样的属性，这是由用户与界面交互时产生的。xxxEvent函数可以对其进行不同的处理（比如说是鼠标左键按下还是右键？）。查看帮助文档，可以看到QMouseEvent类有以下枚举。<br>在QtCreator中查看帮助文档<br>那么就可以在mousePressEvent中根据这个QEvent对象的这些枚举值来进行不同的处理，比如</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">myLabel</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QLabel</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">mousePressEvent</span><span class="token punctuation">(</span>QMouseEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> myLabel<span class="token double-colon punctuation">::</span><span class="token function">mousePressEvent</span><span class="token punctuation">(</span>QMouseEvent <span class="token operator">*</span>event<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>event<span class="token operator">-></span>Buttons <span class="token operator">==</span> LeftButton<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">//do sth</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>event<span class="token operator">-></span>Buttons <span class="token operator">==</span> RightButton<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token comment">//do sth</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        可以看到，我们首先需要先创建一个自己的QLabel类，并继承于Qt的QLabel类，然后并重写相应的xxxEvent函数（这些事件处理函数都是虚函数）。</p>
<p>​        Qt程序的main函数中需要创建一个QApplication对象，然后调用exec函数。这将令程序进入一个死循环，并不断监听应用程序的事件，发生事件时就生成一个QEvent对象。这又称为事件循环。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;QApplication></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"mainwindow.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    QApplication <span class="token function">app</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    MainWindow window<span class="token punctuation">;</span>
    window<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> app<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="二、事件的分发：event函数"><a href="#二、事件的分发：event函数" class="headerlink" title="二、事件的分发：event函数"></a>二、事件的分发：event函数</h3><p>​        上面提到的xxxEvent函数，称为事件处理器（event handler）。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听某个按键的按下。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myWidget<span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>QEvent <span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        <span class="token comment">//将QEvent对象转换为真正的QKeyEvent对象</span>
        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span> 
        <span class="token punctuation">&#123;</span>
            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//按照原来的流程来进行事件的分发</span>
    <span class="token keyword">return</span> <span class="token class-name">QWidget</span><span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在上面的程序中，myWidget是QWidget的子类。同样的，它的event函数是一个虚函数，带有一个QEvent类型的参数。当系统产生QEvent对象时，就会传入这个函数并调用。函数的返回值是bool类型，返回值不同有不同的意义。</p>
<p>​        如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。<br><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODczOTU5OA==,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p>
<p>​        Qt系统在处理事件时，有一种机制叫事件传播机制。也就是说，在子组件（比如说一个QButton）中发生的事件，调用了子组件的event函数之后，还会调用父组件（比如说QWidget）的event函数。event函数的返回值就用于控制这样的一个过程。</p>
<p>​        需要注意的是，重写event函数之后最好返回父类的event函数来处理其他的事件分发，不然就只能处理自己定义的事件。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myTextEdit<span class="token double-colon punctuation">::</span><span class="token function">event</span><span class="token punctuation">(</span>QEvent <span class="token operator">*</span>e<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        <span class="token comment">//将QEvent对象转换为真正的QKeyEvent对象</span>
        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span> 
        <span class="token punctuation">&#123;</span>
            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//直接返回false</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        在这个例子中，因为没有调用父类QTextEdit的event函数，所以只能处理Tab的情况，你再按其他按键就啥反应都没有了。同样，事件也不能进行传播。</p>
<h3 id="三、事件过滤器（Even-Filter）"><a href="#三、事件过滤器（Even-Filter）" class="headerlink" title="三、事件过滤器（Even Filter）"></a>三、事件过滤器（Even Filter）</h3><p>​        某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器（evenFilter）。</p>
<p>​        QObject有一个虚函数，原型如下</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token class-name">QObject</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> watched<span class="token punctuation">,</span> QEvent <span class="token operator">*</span> event <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件（产生的QEvent对象）。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p>
<p>​        实际使用中，我们需要对QObject组件调用installEvenFilter函数，即为组件安装过滤器，才能使用事件过滤器这个机制。这样，该组件及其子组件的事件就会被监听。这个机制的好处在于不用像重写QEvent和xxxEvent函数一样需要继承Qt的内置类。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">QObject</span><span class="token double-colon punctuation">::</span><span class="token function">installEventFilter</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> filterObj <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        下面举一个例子。MainWindow中有一个QTextEdit控件，我们拦截它的键盘按下的事件。这样处理之后，会在输出窗口打印出按下的键位，但不会在控件上显示。这表明事件已被拦截，不会去调用even函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MainWindow</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QMainWindow</span></span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">MainWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>obj<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    QTextEdit <span class="token operator">*</span>textEdit<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
 
<span class="token class-name">MainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">MainWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    textEdit <span class="token operator">=</span> <span class="token keyword">new</span> QTextEdit<span class="token punctuation">;</span>
    <span class="token function">setCentralWidget</span><span class="token punctuation">(</span>textEdit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    textEdit<span class="token operator">-></span><span class="token function">installEventFilter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
 
<span class="token keyword">bool</span> <span class="token class-name">MainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>obj<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> textEdit<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span> 
        <span class="token punctuation">&#123;</span>
            QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"you press"</span> <span class="token operator">&lt;&lt;</span> keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//事件不再进行传播，拦截</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> 
        <span class="token keyword">else</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment">//继续传播</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> 
    <span class="token keyword">else</span> 
    <span class="token punctuation">&#123;</span>
        <span class="token comment">//当不确定是否继续传播时，按照父类的方法来处理</span>
        <span class="token comment">//即调用父类的evenFilter函数</span>
        <span class="token keyword">return</span> <span class="token class-name">QMainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样的，even函数能干的事情，evenFilter也能干。比如说上面的处理键盘按下Tab键。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> myObject<span class="token double-colon punctuation">::</span><span class="token function">eventFilter</span><span class="token punctuation">(</span>QObject <span class="token operator">*</span>object<span class="token punctuation">,</span> QEvent <span class="token operator">*</span>event<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> target <span class="token operator">&amp;&amp;</span> event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> QEvent<span class="token double-colon punctuation">::</span>KeyPress<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span>
        QKeyEvent <span class="token operator">*</span>keyEvent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>QKeyEvent <span class="token operator">*</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>keyEvent<span class="token operator">-></span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Qt<span class="token double-colon punctuation">::</span>Key_Tab<span class="token punctuation">)</span> 
        <span class="token punctuation">&#123;</span>
            <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"You press tab."</span><span class="token punctuation">;</span>
            <span class="token comment">//拦截</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> 
        <span class="token keyword">else</span> 
        <span class="token punctuation">&#123;</span>
            <span class="token comment">//不进行拦截</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//不进行拦截</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们可以对QApplication或者QCoreApplication对象添加事件过滤器。这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。这种行为会严重降低整个应用程序的事件分发效率，要看具体情况使用。</p>
<p>​        事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</p>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>Qt中使用事件机制，每一种事件对应一个事件处理器，比如：</p>
<ul>
<li>mouseEvent()</li>
<li>keyPressEvent()</li>
<li>etc…<br>发生事件时会生成一个QEvent对象，则需要even函数进行分发，来调用相应的事件处理器</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token operator">-></span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token punctuation">&#123;</span>
    <span class="token keyword">case</span> QEvent<span class="token double-colon punctuation">::</span>MouseMove<span class="token operator">:</span>
        <span class="token function">mouseMoveEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>QMouseEvent<span class="token operator">*</span><span class="token punctuation">)</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        事件过滤器（evenFilter）可以令事件进行拦截，阻止其传播，从而实现某些功能。</p>
<p>另外，有一种一般很少使用的方法，即去重写这么一个函数</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">virtual</span> <span class="token keyword">bool</span> <span class="token class-name">QCoreApplication</span><span class="token double-colon punctuation">::</span><span class="token function">notify</span> <span class="token punctuation">(</span> QObject <span class="token operator">*</span> receiver<span class="token punctuation">,</span> QEvent <span class="token operator">*</span> event <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该函数原实现相当于让组件调用even函数，即receiver-&gt;event(event)。这相当于全局的事件过滤器，且不会受到多线程的限制。</p>
<p>那么，在使用Qt的事件机制时，应该按照以下思路进行</p>
<ul>
<li>重写paintEvent、mousePressEvent等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</li>
<li>重写event函数。event函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</li>
<li>在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</li>
<li>在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，但会有多线程问题。</li>
<li>重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。</li>
</ul>
<h2 id="鼠标事件（QMouseEvent）"><a href="#鼠标事件（QMouseEvent）" class="headerlink" title="鼠标事件（QMouseEvent）"></a>鼠标事件（QMouseEvent）</h2><p>传送门：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44386034/article/details/125637737">https://blog.csdn.net/qq_44386034/article/details/125637737</a></p>
<p>​        常用的鼠标事件：(本篇处理事件用的是方法一：重写鼠标事件)</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void mousePressEvent(QMouseEvent *event);           &#x2F;&#x2F;单击
void mouseReleaseEvent(QMouseEvent *event);       &#x2F;&#x2F;释放
void mouseDoubleClickEvent(QMouseEvent *event); &#x2F;&#x2F;双击
void mouseMoveEvent(QMouseEvent *event);           &#x2F;&#x2F;移动
void wheelEvent(QWheelEvent *event);                      &#x2F;&#x2F;滑轮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        鼠标事件使用的时候，加头文件：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;QMouseEvent&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>重写事件框架：</p>
<pre class="line-numbers language-none"><code class="language-none">鼠标按下事件
void Widget::mousePressEvent(QMouseEvent *event)
&#123;
    &#x2F;&#x2F; 如果是鼠标左键按下   
    if(event-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;
        ···
    &#125;
    &#x2F;&#x2F; 如果是鼠标右键按下
    else if(event-&gt;button() &#x3D;&#x3D; Qt::RightButton)&#123;
       ···
    &#125;
&#125;

鼠标移动事件

void Widget::mouseMoveEvent(QMouseEvent *event)
&#123;
    &#x2F;&#x2F; 这里必须使用buttons()
    if(event-&gt;buttons() &amp; Qt::LeftButton)&#123;  &#x2F;&#x2F;进行的按位与
       ···
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        默认情况下，触发事件需要点击一下，才能触发。可设置为自动触发:</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">setMouseTracking(true); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">鼠标释放事件

void Widget::mouseReleaseEvent(QMouseEvent *event)
&#123;
   ···
&#125;

鼠标双击事件

void Widget::mouseDoubleClickEvent(QMouseEvent *event)
&#123;
    &#x2F;&#x2F; 如果是鼠标左键按下
    if(event-&gt;button() &#x3D;&#x3D; Qt::LeftButton)&#123;
      

        ···
    &#125;

&#125;

滚轮事件

void Widget::wheelEvent(QWheelEvent *event)
&#123;
    &#x2F;&#x2F; 当滚轮远离使用者时
    if(event-&gt;delta() &gt; 0)&#123;
        ···
    &#125;else&#123;&#x2F;&#x2F;当滚轮向使用者方向旋转时
        ···
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实例演示-在label控件中，移动鼠标获取实时位置，并显示在界面上"><a href="#实例演示-在label控件中，移动鼠标获取实时位置，并显示在界面上" class="headerlink" title="实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)"></a>实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)</h3><p>​        创建mylabel类，基类设置为QLabel <img src="b63f2e133baf5913fe5393dc477bfe20.png" alt="img"></p>
<pre><code>     这里用了类似自定义控件的方法，对Mylabel类进行封装。设置基类QLabel 是为了在ui界面中提升label控件(即将label控件和Mylabel关联，提升时候必须二者基类相同)
</code></pre><p>​        在mylabel.h中声明鼠标事件</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#pragma once
#include &lt;qlabel.h&gt;

class mylabel : public QLabel
&#123;
public:
    mylabel(QWidget* parent &#x3D; 0);
    ~mylabel();
public:
    &#x2F;&#x2F;鼠标移动事件
    void mouseMoveEvent(QMouseEvent* event);
    &#x2F;&#x2F;鼠标按下事件
    void mousePressEvent(QMouseEvent* event);
    &#x2F;&#x2F;鼠标释放事件
    void mouseReleaseEvent(QMouseEvent* event);
&#125;;

在mylabel.cpp中重写事件
#include &quot;mylabel.h&quot;
#include&quot;QMouseEvent&quot;


mylabel::mylabel(QWidget* parent) :QLabel(parent)
&#123;
    
&#125;
mylabel::~mylabel()
&#123;

&#125;
&#x2F;&#x2F;鼠标移动显示坐标
void mylabel::mouseMoveEvent(QMouseEvent* event)
&#123;
    if (event-&gt;buttons() &amp; Qt::LeftButton)  &#x2F;&#x2F;进行的按位与(只有左键点击移动才满足)
    &#123; 
        QString str &#x3D; QString(&quot;Move:(X:%1,Y:%2)&quot;).arg(event-&gt;x()).arg(event-&gt;y());
         this-&gt;setText(str);
         

    &#125;

&#125;
&#x2F;&#x2F;鼠标按下显示“ok，mouse is press”
void mylabel::mousePressEvent(QMouseEvent* event)
&#123;
    setText(&quot;Ok, mouse is press&quot;);

&#125;
&#x2F;&#x2F;鼠标释放清除显示
void mylabel::mouseReleaseEvent(QMouseEvent* event)
&#123;
    setText(&quot; &quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在主函数(QTest.cpp)中声明mylabel的类对象(即声明一个mylabel类的label控件)</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;qtest.h&quot;

QTest::QTest(QWidget *parent)
    : QWidget(parent)
&#123;
    ui.setupUi(this);
    &#x2F;&#x2F;声明mylabel类的控件
    mylabel* label1 &#x3D; new mylabel(this);
    label1-&gt;setGeometry(QRect(130, 100, 271, 161));
    &#x2F;&#x2F;设置边框
    label1-&gt;setFrameShape(QFrame::Panel);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>     ![img](D:\My notebook project\Program language\C++\QT\QT new 13\2b78bd5ca82261a28798c809af0ef282.gif)
</code></pre><p>​        另外，当调用setMouseTracking(true);时(即设置鼠标状态为自动触发)，需要将鼠标移动事件的if语句去掉(因为不需要点击触发了)</p>
<p>​        修改maylabel.cpp事件：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;mylabel.h&quot;
#include&quot;QMouseEvent&quot;


mylabel::mylabel(QWidget* parent) :QLabel(parent)
&#123;
    &#x2F;&#x2F;设置鼠标状态(自动触发)
    setMouseTracking(true);
&#125;
mylabel::~mylabel()
&#123;

&#125;
&#x2F;&#x2F;鼠标移动显示坐标
void mylabel::mouseMoveEvent(QMouseEvent* event)
&#123;
   QString str &#x3D; QString(&quot;Move:(X:%1,Y:%2)&quot;).arg(event-&gt;x()).arg(event-&gt;y());
   this-&gt;setText(str);
&#125;
&#x2F;&#x2F;鼠标按下显示“ok，mouse is press”
void mylabel::mousePressEvent(QMouseEvent* event)
&#123;
    setText(&quot;Ok, mouse is press&quot;);

&#125;
&#x2F;&#x2F;鼠标释放清除显示
void mylabel::mouseReleaseEvent(QMouseEvent* event)
&#123;
    setText(&quot; &quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>效果展示：</p>
<p><img src="0c83943e6ee8c74e39d09db4a899b2c6.gif" alt="img"></p>
<p>​        这里用的是代码创建label控件，那么能不能用ui界面编辑然后在对label控件提升呢？</p>
<p>答案是可以的，但是需要注意的是：此处不能选择全局包含</p>
<p><img src="4cb8112d483f6e94c8fe196258871445.png" alt="img"></p>
<p> 否则会出现：</p>
<p><img src="e7df65e65f36ed436c5ec6ab7c41f417.png" alt="img"></p>
<p>​        我想其中的原因主要是因为：</p>
<p>​        本实例是新建了一个mylabel类，而不是像QT常用控件(三)——自定义控件封装 - 唯有自己强大 - 博客园 (cnblogs.com)这篇博文中直接新添加了一个设计师界面类(即包含ui .h .cpp)。当选择全局包含时，就包含了主类。</p>
<p>​        其实也有解决的办法：需要在提升界面的头文件处，将工程目录下自定义控件的地址放于此处(本篇地址：C:/Users/WFD/Desktop/QTest/QTest/mylabel.h)</p>
<p><img src="c3a41a90d53c14e6f9e28ea56aa4c497.png" alt="img"></p>
<p> 二，事件的分发：event函数<br>        上面提到的xxxEvent函数，称为事件处理器(event handler)。而event函数的作用就在于事件的分发。如果想在事件的分发之前就进行一些操作，比如监听(阻塞)鼠标按下事件。</p>
<pre><code>     如果希望在事件分发之前做一些操作，就可以重写这个 event()函数了。比如我们希望阻塞鼠标按下事件，那么我们就在新建的Mylabel类中重写event()函数(该类的父类是QLabel)
</code></pre><p>在Mylabel.h中声明event事件</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&quot;qlabel.h&quot;
class Mylabel : public QLabel
&#123;
public:
    explicit Mylabel(QWidget* parent &#x3D; 0);

    &#x2F;&#x2F;鼠标按下事件
    void mousePressEvent(QMouseEvent* event); 
    &#x2F;&#x2F;鼠标释放事件
    void mouseReleaseEvent(QMouseEvent* event);
    &#x2F;&#x2F;声明event事件
    bool event(QEvent* e);

&#125;;

在Mylabel.cpp中重写event事件。
#include &quot;Mylabel.h&quot;
#include&quot;QMouseEvent&quot;

Mylabel::Mylabel(QWidget* parent) :QLabel(parent)
&#123;

&#125;

&#x2F;&#x2F;重写鼠标按下事件
void Mylabel::mousePressEvent(QMouseEvent* event)
&#123;
    this-&gt;setText(QString(&quot;mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
&#125;
&#x2F;&#x2F;重写鼠标释放事件
void Mylabel::mouseReleaseEvent(QMouseEvent* event)
&#123;
    this-&gt;setText(&quot;mouse is release &quot;);
&#125;
&#x2F;&#x2F;重写event事件
bool Mylabel::event(QEvent* e)
&#123;
    &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截
    if (e-&gt;type()&#x3D;&#x3D;QEvent::MouseButtonPress)
    &#123;
        &#x2F;&#x2F;静态转换(将QEvent的对象转换为QMouseEvent对象)
        QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);
        this-&gt;setText(QString(&quot;event mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
        return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)
    &#125;
    return QLabel::event(e);
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        <img src="06ef2891b59dcc3d4f1953b7e3404c5e.png" alt="img"></p>
<p>​        点击鼠标可以看到，触发的是event的事件(即阻塞了mousePressEvent的事件)。特别需要注意的是：在将不需要阻塞分发的时候，需要分发给父类的event函数处理。即(return QLable::event(e)；)</p>
<p>​        由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个 event()函数，通过 QEvent::type()判断不同的事件。鉴于重写 event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器(当然，也必须记得是不是应该调用父类的同名处理器)。</p>
<h3 id="三，事件过滤器-Even-Filter"><a href="#三，事件过滤器-Even-Filter" class="headerlink" title="三，事件过滤器(Even Filter)"></a>三，事件过滤器(Even Filter)</h3><p>​         某些应用场景下，需要拦截某个组件发生的事件，让这个事件不再向其他组件进行传播，这时候可以为这个组件或其父组件安装一个事件过滤器，该过滤器在event分发之前进行拦截。</p>
<p>事件的过滤有两个步骤：</p>
<p>​        对QObject组件安装过滤器(调用installEvenFilter函数)</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void QObject::installEventFilter ( QObject * filterObj );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        参数filterobj 是指谁为组件安装过滤器(一般是父类)</p>
<p>​        这个函数接受一个 QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是 QObject 的一个成员函数，因此，任意 QObject 都可以作为事件过滤器(问题在于，如果你没有重写 eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤)。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。<br>我们可以向一个对象上面安装多个事件处理器 ，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。<br>​        事件过滤器的重写(evenFilter函数)</p>
<pre class="line-numbers language-none"><code class="language-none">virtual bool QObject::eventFilter ( QObject * watched, QEvent * event );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        可以看到，函数有两个参数，一个为具体发生事件的组件，一个为发生的事件(产生的QEvent对象)。当事件是我们感兴趣的类型，可以就地进行处理，并令其不再转发给其他组件。函数的返回值也是bool类型，作用跟even函数类似，返回true为不再转发，false则让其继续被处理。</p>
<p>​        实例：通过事件过滤器阻塞上面代码中的鼠标按下事件</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;qtest.h&quot;
#include&quot;qmouseevent&quot;

QTest::QTest(QWidget *parent)
    : QWidget(parent)
&#123;
    ui.setupUi(this);
    &#x2F;&#x2F;第一步：给label添加过滤器
    ui.label-&gt;installEventFilter(this);


&#125;
&#x2F;&#x2F;第二步：重写过滤事件
bool QTest::eventFilter(QObject* obj, QEvent* e)
&#123;
    if (obj &#x3D;&#x3D; ui.label)
    &#123;
        &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截
        if (e-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress)
        &#123;
            QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);
            ui.label-&gt;setText(QString(&quot;eventfilter mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
            return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)
        &#125;
    &#125;
    return QWidget::eventFilter(obj, e);
&#125;

&#x2F;&#x2F;重写鼠标按下事件
void QTest::mousePressEvent(QMouseEvent* event)
&#123;
    ui.label-&gt;setText(QString(&quot;mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
&#125;

&#x2F;&#x2F;重写事件分发
bool QTest::event(QEvent* e)
&#123;
    &#x2F;&#x2F;如果鼠标按下，再事件分发中做拦截
    if (e-&gt;type() &#x3D;&#x3D; QEvent::MouseButtonPress)
    &#123;
        QMouseEvent* event &#x3D; static_cast&lt;QMouseEvent*&gt;(e);
        ui.label-&gt;setText(QString(&quot;event mouse is press x:%1,y:%2&quot;).arg(event-&gt;x()).arg(event-&gt;y()));
        return true;&#x2F;&#x2F;返回ture，说明用户自己处理事件，不往下分发(即拦截上面的按下事件)
    &#125;
    return QWidget::event(e);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行结果：<img src="09dd8a5f89d61fa32b9e3800fe5fff9a.png" alt="img"></p>
<p>可以看到在过滤器事件中就监听了鼠标按压(即阻塞了后面的事件分发和鼠标按压)</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>​        我们的定时器可以做到随着事件的事件流逝触发事件。</p>
<p>​        我们的办法是：添加窗口的代码，从而实现计时器。</p>
<p>​        在窗口中添加两个label:</p>
<p>​        随后改写事件：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#ifndef WIDGET_H
#define WIDGET_H

#include &lt;QWidget&gt;

QT_BEGIN_NAMESPACE
namespace Ui &#123; class Widget; &#125;
QT_END_NAMESPACE

class Widget : public QWidget
&#123;
    Q_OBJECT

public:
    Widget(QWidget *parent &#x3D; nullptr);
    ~Widget();
    void timerEvent(QTimerEvent*);

    int id1;
    int id2;
private:
    Ui::Widget *ui;
&#125;;
#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;启动定时器
    id1  &#x3D; startTimer(1000);&#x2F;&#x2F;1,间隔, 单位是毫秒

    id2 &#x3D; startTimer(2000);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;

void Widget::timerEvent(QTimerEvent* ev)&#123;
    if(ev-&gt;timerId() &#x3D;&#x3D; id1)&#123;

        static int num &#x3D; 1;
        ui-&gt;label_2-&gt;setText(QString::number(num++));

    &#125;
     if(ev-&gt;timerId() &#x3D;&#x3D; id2)
    &#123;
        static int num2 &#x3D; 1;
        ui-&gt;label_3-&gt;setText(QString::number(num2++));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意到，对于多个计时器需要接受返回ID并加之以判断才好！</p>
<h2 id="类的形式"><a href="#类的形式" class="headerlink" title="类的形式"></a>类的形式</h2><p>​        这个形式简单的多!直接一个类解决所有的问题!</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &quot;widget.h&quot;
#include &quot;ui_widget.h&quot;
#include&lt;QTimer&gt;
Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;启动定时器
    id1  &#x3D; startTimer(1000);&#x2F;&#x2F;1,间隔, 单位是毫秒

    id2 &#x3D; startTimer(2000);

    QTimer* timer &#x3D; new QTimer(this);

    timer-&gt;start(500); &#x2F;&#x2F; 到0.5秒发出信号

    connect(timer,&amp;QTimer::timeout,[&#x3D;]()&#123;
        static int num &#x3D; 1;
        ui-&gt;label_4-&gt;setText(QString::number(num++));

    &#125;);

    &#x2F;&#x2F;

    connect(ui-&gt;pushButton,&amp;QPushButton::clicked,[&#x3D;]()&#123;
        timer-&gt;stop();

    &#125;);
&#125;

Widget::~Widget()
&#123;
    delete ui;
&#125;

void Widget::timerEvent(QTimerEvent* ev)&#123;
    if(ev-&gt;timerId() &#x3D;&#x3D; id1)&#123;

        static int num &#x3D; 1;
        ui-&gt;label_2-&gt;setText(QString::number(num++));

    &#125;
     if(ev-&gt;timerId() &#x3D;&#x3D; id2)
    &#123;
        static int num2 &#x3D; 1;
        ui-&gt;label_3-&gt;setText(QString::number(num2++));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Extensive-Reading"><a href="#Extensive-Reading" class="headerlink" title="Extensive Reading"></a>Extensive Reading</h2><p>​        传送门：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Mountain_tai_li/article/details/130529628">https://blog.csdn.net/Mountain_tai_li/article/details/130529628</a></p>
<p>​        QTimer 类提供重复和单次计时器。</p>
<p>​        QTimer 类为计时器提供了一个高级编程接口。要使用它，首先创建一个 QTimer实例，将其 timeout() 信号连接到相应的插槽，然后调用 start()。从那时起，它将以恒定的间隔发出 timeout() 信号。</p>
<p>​        一秒（1000毫秒）计时器的示例（来自模拟时钟示例）：</p>
<pre class="line-numbers language-none"><code class="language-none">QTimer *timer &#x3D; new QTimer(this);
connect(timer, SIGNAL(timeout()), this, SLOT(update()));
timer-&gt;start(1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        从那时起，每秒调用一次 update() 槽函数。</p>
<p>​        也可以通过调用 setSingleShot（true） 将计时器设置为仅超时一次。您还可以使用静态 QTimer::singleShot() 函数在指定的时间间隔后调用槽函数：</p>
<p>​        QTimer::singleShot(200, this, SLOT(updateCaption()));<br>​        在多线程应用程序中，可以在任何具有事件循环的线程中使用 QTimer。要从非 GUI 线程启动事件循环，使用 QThread::exec()。Qt使用计时器的线程亲和力来确定哪个线程将发出timeout()信号。因此，您必须在其线程中启动和停止计时器;无法从另一个线程启动计时器。作为特殊情况timeout 为 0 的 QTimer 将在窗口系统的事件队列中的所有事件都得到处理后立即timeout。这可用于完成繁重的工作，同时提供活泼的用户界面：</p>
<pre class="line-numbers language-none"><code class="language-none">QTimer *timer &#x3D; new QTimer(this);
connect(timer, SIGNAL(timeout()), this, SLOT(processOneThing()));
timer-&gt;start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        从那时起，processOneThing()槽函数将被重复调用。它应该以这样一种方式编写，即它总是快速返回（通常在处理一个数据项之后），以便Qt可以将事件传递到用户界面，并在完成所有工作后立即停止计时器。这是在GUI应用程序中实现繁重工作的传统方式，但随着多线程在越来越多的平台上变得可用，我们预计零毫秒QTimer对象将逐渐被QThreads取代。</p>
<p>​        定时器精度和分辨率<br>​        计时器的准确性取决于底层操作系统和硬件。大多数平台都支持 1 毫秒的分辨率，尽管在许多现实情况下，计时器的精度不会等于此分辨率。</p>
<p>​        精度还取决于计时器类型。对于Qt::PreciseTimer，QTimer将尝试将精度保持在1毫秒。精确的计时器也不会比预期早超时。对于 Qt::CoarseTimer 和 Qt::VeryCoarseTimer 类型，QTimer 可能会比预期更早timeout，在这些类型的范围内：Qt::CoarseTimer 的间隔为 5%，Qt::VeryCoarseTimer 的间隔为 500 毫秒。如果系统繁忙或无法提供请求的准确性，则所有计时器类型都可能晚于预期超时。在timeout 溢出的情况下，Qt只会发出一次active()，即使多个超时已经过期，然后恢复原始间隔。 </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/06/06/Learn-Qt-I/">http://charliechen114514.github.io/2023/06/06/Learn-Qt-I/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Qt/">Qt</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/06/Learn-ROS-I/" title="Learn_ROS-I"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Learn_ROS-I</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/06/Learn-Windows-API-Semester-I/" title="Learn_Windows_API-Semester-I"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Learn_Windows_API-Semester-I</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/07/DeepLearningQt-ReadingDocuments1/" title="DeepLearningQt-ReadingDocuments1"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-07</div><div class="title">DeepLearningQt-ReadingDocuments1</div></div></a></div><div><a href="/2023/02/09/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89string-h%E7%B3%BB%E5%88%97/" title="C语言常用函数（1）string.h系列"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="title">C语言常用函数（1）string.h系列</div></div></a></div><div><a href="/2023/04/17/High-Quality-of-C-Cpp-programming-in-formats-1/" title="High Quality of C_Cpp programming in formats(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-17</div><div class="title">High Quality of C_Cpp programming in formats(1)</div></div></a></div><div><a href="/2023/06/06/Algorithm-in-C-1/" title="Algorithm_in_C(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_in_C(1)</div></div></a></div><div><a href="/2023/06/06/Opencv-learning-CPP/" title="Opencv_learning_CPP"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Opencv_learning_CPP</div></div></a></div><div><a href="/2023/06/06/CPP-ExtensiveReadingNotes-1-EssentialCPP/" title="CPP_ExtensiveReadingNotes-1-EssentialCPP"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">CPP_ExtensiveReadingNotes-1-EssentialCPP</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#QT%E5%BC%80%E5%8F%91-%E5%88%9D%E6%8E%A2"><span class="toc-number">1.</span> <span class="toc-text">QT开发-初探</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E7%9C%8B%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">看看工程文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E7%9C%8B%E5%A4%B4%E6%96%87%E4%BB%B6%E5%92%8Cwidget-cpp"><span class="toc-number">1.2.</span> <span class="toc-text">看看头文件和widget.cpp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">1.3.</span> <span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE"><span class="toc-number">1.4.</span> <span class="toc-text">创建一个按钮</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QT%E5%AF%B9%E8%B1%A1%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">QT对象树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QT-%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">1.6.</span> <span class="toc-text">QT 坐标系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.</span> <span class="toc-text">信号与槽的基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A7%BD%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%E7%89%88%E6%9C%AC"><span class="toc-number">1.8.</span> <span class="toc-text">槽函数的重载版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A4%E4%BA%BA%E6%81%BC%E7%81%AB%E7%9A%84%E6%98%AF%EF%BC%9A"><span class="toc-number">1.9.</span> <span class="toc-text">令人恼火的是：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E4%B8%80%E7%82%B9%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E6%A7%BD"><span class="toc-number">1.10.</span> <span class="toc-text">高级一点的信号与槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E9%93%BE%E6%8E%A5"><span class="toc-number">1.11.</span> <span class="toc-text">断开链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.12.</span> <span class="toc-text">补充Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0"><span class="toc-number">1.12.1.</span> <span class="toc-text">1.函数对象参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QMainWindow"><span class="toc-number">2.</span> <span class="toc-text">QMainWindow</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="toc-number">2.1.</span> <span class="toc-text">工具栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A0%8F"><span class="toc-number">2.2.</span> <span class="toc-text">状态栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">添加资源文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">2.4.</span> <span class="toc-text">对话框</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">3.</span> <span class="toc-text">消息对话框</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86-1"><span class="toc-number">3.1.</span> <span class="toc-text">消息对话框</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E7%AA%97%E5%8F%A3%E7%95%8C%E9%9D%A2%E5%B8%83%E5%B1%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.</span> <span class="toc-text">登录窗口界面布局介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QListWidget%E7%A9%BA%E9%97%B4"><span class="toc-number">3.3.</span> <span class="toc-text">QListWidget空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QListWidget"><span class="toc-number">3.3.1.</span> <span class="toc-text">QListWidget</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%9D%A1%E7%9B%AE%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">1）添加条目的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">（2）删除函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9D%A1%E7%9B%AE%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">（3）条目访问函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%BD%93%E5%89%8D%E9%80%89%E4%B8%AD%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.7.</span> <span class="toc-text">（4）当前选中条目的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">3.8.</span> <span class="toc-text">（5）条目查找和排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%98%BE%E7%A4%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%A1%E7%9B%AE%E7%BC%96%E8%BE%91"><span class="toc-number">3.9.</span> <span class="toc-text">（6）条目显示和运行时条目编辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E5%85%B6%E4%BB%96%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E5%87%BD%E6%95%B0"><span class="toc-number">3.10.</span> <span class="toc-text">（7）其他信号和槽函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E4%B8%BB%E8%A6%81%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">一些主要控件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">主要控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QTreeWidget"><span class="toc-number">4.1.1.</span> <span class="toc-text">QTreeWidget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-QTreeWidget"><span class="toc-number">4.1.2.</span> <span class="toc-text">8.3.1 QTreeWidget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%880%EF%BC%89%E6%A0%91%E5%BD%A2%E6%8E%A7%E4%BB%B6%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BE%88%E7%AE%80%E5%8D%95%EF%BC%9A"><span class="toc-number">4.1.3.</span> <span class="toc-text">（0）树形控件的构造函数很简单：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%B7%BB%E5%8A%A0%E5%92%8C%E8%AE%BF%E9%97%AE%E9%A1%B6%E7%BA%A7%E6%9D%A1%E7%9B%AE"><span class="toc-number">4.1.4.</span> <span class="toc-text">（1）添加和访问顶级条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%A7%BB%E9%99%A4%E9%A1%B6%E7%BA%A7%E6%9D%A1%E7%9B%AE"><span class="toc-number">4.1.5.</span> <span class="toc-text">（2）移除顶级条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%9D%A1%E7%9B%AE%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0-1"><span class="toc-number">4.1.6.</span> <span class="toc-text">（3）条目访问函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E5%BD%93%E5%89%8D%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.7.</span> <span class="toc-text">（4）当前条目的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%885%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F-1"><span class="toc-number">4.1.8.</span> <span class="toc-text">（5）条目查找和排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%886%EF%BC%89%E6%9D%A1%E7%9B%AE%E6%98%BE%E7%A4%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%A1%E7%9B%AE%E7%BC%96%E8%BE%91-1"><span class="toc-number">4.1.9.</span> <span class="toc-text">（6）条目显示和运行时条目编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%887%EF%BC%89%E4%BF%A1%E5%8F%B7"><span class="toc-number">4.1.10.</span> <span class="toc-text">（7）信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%888%EF%BC%89%E6%A7%BD%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.11.</span> <span class="toc-text">（8）槽函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%889%EF%BC%89%E5%9F%BA%E7%B1%BB-QTreeView-%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.12.</span> <span class="toc-text">（9）基类 QTreeView 的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%8810%EF%BC%89%E6%A0%91%E5%A4%B4%E6%9D%A1%E7%9B%AE"><span class="toc-number">4.1.13.</span> <span class="toc-text">（10）树头条目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%8811%EF%BC%89%E9%80%89%E4%B8%AD%E8%A1%8C%E4%B8%BA%E5%92%8C%E9%80%89%E4%B8%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.14.</span> <span class="toc-text">（11）选中行为和选中模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QTableWidget"><span class="toc-number">4.2.</span> <span class="toc-text">QTableWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.3.</span> <span class="toc-text">详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QTableWidgetItem"><span class="toc-number">4.4.</span> <span class="toc-text">QTableWidgetItem</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A6%96%E5%85%88%E6%9D%A5%E7%9C%8B%E7%9C%8B%E6%9D%A1%E7%9B%AE%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">4.4.1.</span> <span class="toc-text">（1）首先来看看条目的构造函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%A4%8D%E5%88%B6%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.2.</span> <span class="toc-text">（2）复制函数和运算符函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89QTableWidgetItem-%E7%9A%84%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0%E4%B8%8E%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">4.4.3.</span> <span class="toc-text">（3）QTableWidgetItem 的功能函数与内部数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%A7%E4%BB%B6%E4%B8%80%E8%A7%88"><span class="toc-number">4.5.</span> <span class="toc-text">其他常见的控件一览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.5.1.</span> <span class="toc-text">滚动条控件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ToolBox"><span class="toc-number">4.5.2.</span> <span class="toc-text">ToolBox</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tab-Widget"><span class="toc-number">4.5.3.</span> <span class="toc-text">Tab Widget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8QLable%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87"><span class="toc-number">4.5.4.</span> <span class="toc-text">利用QLable显示图片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.6.</span> <span class="toc-text">自定义控件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QEvent"><span class="toc-number">4.7.</span> <span class="toc-text">QEvent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Qt-Event%E4%BA%8B%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.8.</span> <span class="toc-text">Qt Event事件详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91%EF%BC%9Aevent%E5%87%BD%E6%95%B0"><span class="toc-number">4.8.1.</span> <span class="toc-text">二、事件的分发：event函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Even-Filter%EF%BC%89"><span class="toc-number">4.8.2.</span> <span class="toc-text">三、事件过滤器（Even Filter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">4.8.3.</span> <span class="toc-text">四、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%EF%BC%88QMouseEvent%EF%BC%89"><span class="toc-number">4.9.</span> <span class="toc-text">鼠标事件（QMouseEvent）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA-%E5%9C%A8label%E6%8E%A7%E4%BB%B6%E4%B8%AD%EF%BC%8C%E7%A7%BB%E5%8A%A8%E9%BC%A0%E6%A0%87%E8%8E%B7%E5%8F%96%E5%AE%9E%E6%97%B6%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%B9%B6%E6%98%BE%E7%A4%BA%E5%9C%A8%E7%95%8C%E9%9D%A2%E4%B8%8A"><span class="toc-number">4.9.1.</span> <span class="toc-text">实例演示(在label控件中，移动鼠标获取实时位置，并显示在界面上)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%EF%BC%8C%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8-Even-Filter"><span class="toc-number">4.9.2.</span> <span class="toc-text">三，事件过滤器(Even Filter)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">4.10.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">4.11.</span> <span class="toc-text">类的形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Extensive-Reading"><span class="toc-number">4.12.</span> <span class="toc-text">Extensive Reading</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/07/DeepLearningQt-ReadingDocuments1/" title="DeepLearningQt-ReadingDocuments1"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DeepLearningQt-ReadingDocuments1"/></a><div class="content"><a class="title" href="/2023/06/07/DeepLearningQt-ReadingDocuments1/" title="DeepLearningQt-ReadingDocuments1">DeepLearningQt-ReadingDocuments1</a><time datetime="2023-06-07T03:29:02.000Z" title="发表于 2023-06-07 11:29:02">2023-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/ModernCPP-SmartPointer/" title="ModernCPP-SmartPointer"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ModernCPP-SmartPointer"/></a><div class="content"><a class="title" href="/2023/06/06/ModernCPP-SmartPointer/" title="ModernCPP-SmartPointer">ModernCPP-SmartPointer</a><time datetime="2023-06-06T15:00:39.000Z" title="发表于 2023-06-06 23:00:39">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/Algorithm-RecursionSpecial/" title="Algorithm_RecursionSpecial"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Algorithm_RecursionSpecial"/></a><div class="content"><a class="title" href="/2023/06/06/Algorithm-RecursionSpecial/" title="Algorithm_RecursionSpecial">Algorithm_RecursionSpecial</a><time datetime="2023-06-06T14:55:23.000Z" title="发表于 2023-06-06 22:55:23">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/Learn-ROS-I/" title="Learn_ROS-I"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Learn_ROS-I"/></a><div class="content"><a class="title" href="/2023/06/06/Learn-ROS-I/" title="Learn_ROS-I">Learn_ROS-I</a><time datetime="2023-06-06T14:51:31.000Z" title="发表于 2023-06-06 22:51:31">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/Learn-Qt-I/" title="Learn_Qt-I"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Learn_Qt-I"/></a><div class="content"><a class="title" href="/2023/06/06/Learn-Qt-I/" title="Learn_Qt-I">Learn_Qt-I</a><time datetime="2023-06-06T14:45:12.000Z" title="发表于 2023-06-06 22:45:12">2023-06-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>