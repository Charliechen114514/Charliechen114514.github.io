<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Linux漫游——文件IO操作 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux漫游- 文件 I&#x2F;O：通用的 I&#x2F;O 模型概述​        我们下面开始正式的开启Linux系统编程之路。我们首先解决一个问题——那就是我们如何对文件进行IO操作呢？本章就是解决这个问题的。Unix-Linux由一套通用的IO操作方法，这让我们可以通用的视一切为文件进行操作 ​        首先，我们需要拿到文件——在系统编程中，我们以文件描述符来代表文件。有三个文件描述符，总是被">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux漫游——文件IO操作">
<meta property="og:url" content="http://charliechen114514.github.io/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="Linux漫游- 文件 I&#x2F;O：通用的 I&#x2F;O 模型概述​        我们下面开始正式的开启Linux系统编程之路。我们首先解决一个问题——那就是我们如何对文件进行IO操作呢？本章就是解决这个问题的。Unix-Linux由一套通用的IO操作方法，这让我们可以通用的视一切为文件进行操作 ​        首先，我们需要拿到文件——在系统编程中，我们以文件描述符来代表文件。有三个文件描述符，总是被">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-08-19T03:07:37.000Z">
<meta property="article:modified_time" content="2023-08-23T04:39:16.811Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++. Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux漫游——文件IO操作',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-23 12:39:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux漫游——文件IO操作</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-19T03:07:37.000Z" title="发表于 2023-08-19 11:07:37">2023-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-23T04:39:16.811Z" title="更新于 2023-08-23 12:39:16">2023-08-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux漫游——文件IO操作"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux漫游-文件-I-O：通用的-I-O-模型"><a href="#Linux漫游-文件-I-O：通用的-I-O-模型" class="headerlink" title="Linux漫游- 文件 I/O：通用的 I/O 模型"></a>Linux漫游- 文件 I/O：通用的 I/O 模型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        我们下面开始正式的开启Linux系统编程之路。我们首先解决一个问题——那就是我们如何对文件进行IO操作呢？本章就是解决这个问题的。Unix-Linux由一套通用的IO操作方法，这让我们可以通用的视一切为文件进行操作</p>
<p>​        首先，我们需要拿到文件——在系统编程中，我们以<strong>文件描述符</strong>来代表文件。有三个文件描述符，总是被分配且有自己特殊的含义的。那就是标准IO流</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>用途</th>
<th>POSIX名称</th>
<th>stdio流</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>标准输入</td>
<td><code>STDIN_FILENO</code></td>
<td><code>stdin</code></td>
</tr>
<tr>
<td>1</td>
<td>标准输出</td>
<td><code>STDOUT_FILENO</code></td>
<td><code>stdout</code></td>
</tr>
<tr>
<td>2</td>
<td>标准错误</td>
<td><code>STDERR_FILENO</code></td>
<td><code>stderr</code></td>
</tr>
</tbody>
</table>
</div>
<p>​        在程序中指代这些文件描述符时，可以使用数字（0、1、2）表示，或者采用<unistd.h>所定义的 POSIX 标准名称—此方法更为可取。</p>
<p>​        虽然 stdin、stdout 和 stderr 变量在程序初始化时用于指代进程的标准输入、标准输出和标准错误，但是调用 freopen()库函数可以使这些变量指代其他任何文件对象。作为其操作的一部分，freopen()可以在将流（stream）重新打开之际一并更换隐匿其中的文件描述符。换言之，针对 stdout 调用 freopen()函数后，无法保证 stdout 变量值仍然为 1。（不建议使用具体的数字而是预定义变量！）</p>
<h2 id="四个主流的IO操作"><a href="#四个主流的IO操作" class="headerlink" title="四个主流的IO操作"></a>四个主流的IO操作</h2><p>​        我们操作文件，首先就是——拿到文件（open），读文件（read），写文件(write)，把文件关了（是不是很像你编写word文档那样？）</p>
<ul>
<li>fd = open(pathname, flags, mode) 函数打开 pathname 所标识的文件，并返回文件描述符，用以在后续函数调用中指代打开的文件。<strong>如果文件不存在，open()函数可以创建之，这取决于对位掩码参数 flags 的设置。</strong>flags 参数还可指定文件的打开方式：<strong>只读、只写亦或是读写方式。mode 参数则指定了由 open()调用创建文件的访问权限，如果 open()函数并未创建文件，那么可以忽略或省略 mode 参数。</strong></li>
<li>numread = read(fd, buffer, count) 调用从 fd 所指代的打开文件中读取至多 count 字节的数据，并存储到 buffer 中。read()调用的返回值为实际读取到的字节数。如果再无字节可读（例如：读到文件结尾符 EOF 时），则返回值为 0。</li>
<li>numwritten = write(fd, buffer, count) 调用从 buffer 中读取多达 count 字节的数据写入由fd 所指代的已打开文件中。write()调用的返回值为实际写入文件中的字节数，且有可能小于 count。</li>
<li>status = close(fd)在所有输入/输出操作完成后，调用 close()，释放文件描述符 fd 以及与之相关的内核资源。</li>
</ul>
<p>​        可以使用这些操作完成一个简单的cp程序</p>
<p><img src="image-20230803170335161.png" alt="image-20230803170335161"></p>
<p><img src="image-20230803170341322.png" alt="image-20230803170341322"></p>
<h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p>​        open()调用既能打开一个业已存在的文件，也能创建并打开一个新文件。</p>
<pre class="line-numbers language-none"><code class="language-none">extern int open (const char *__file, int __oflag, ...) __nonnull ((1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        要打开的文件由参数 pathname 来标识。<strong>如果 pathname 是一符号链接，会对其进行解引用。如果调用成功，open()将返回一文件描述符，用于在后续函数调用中指代该文件。</strong>若发生错误，则返回−1，并将 errno 置为相应的错误标志。参数 flags 为位掩码，用于指定文件的访问模式</p>
<pre class="line-numbers language-none"><code class="language-none">早期的 UNIX 实现中使用数字 0、1、2，而非表 4-2 中所列的常量名称。大多数现代UNIX 实现将这些常量定义为上述相应数字（以期与早期系统保持兼容）。由此可见，O_RDWR 并不等同于 O_RDONLY | O_WRONLY，后者（或组合）属于逻辑错误。(请务必注意！！！)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当调用 open()创建新文件时，位掩码参数 mode 指定了文件的访问权限。（SUSv3 规定，mode的数据类型 mode_t 属于整数类型。）</p>
<p>​        如果 open()并未指定 O_CREAT 标志，则可以省略 mode 参数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>访问模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code></td>
<td>只读方式打开文件</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td>只写方式打开文件</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td>以读写方式打开文件</td>
</tr>
</tbody>
</table>
</div>
<p><img src="image-20230803170532396.png" alt="image-20230803170532396"></p>
<p>​        如果调用 open()成功，必须保证其返回值为进程未用文件描述符中数值最小者。可以利用该特性以特定文件描述符打开某一文件。例如，如下代码序列就会确保使用标准输入（文件描述符 0）打开一文件。</p>
<p><img src="image-20230803170606375.png" alt="image-20230803170606375"></p>
<p>​        由于文件描述符 0 未用，所以 open()调用势必使用此描述符打开文件。5.5 节中所论及的dup2()和 fcntl()也可实现类似功能，但对于文件描述符的控制更加灵活。</p>
<h3 id="open-调用中的-flags-参数"><a href="#open-调用中的-flags-参数" class="headerlink" title="open()调用中的 flags 参数"></a>open()调用中的 flags 参数</h3><p>对于<code>flags</code>:</p>
<ul>
<li>文件访问模式标志：先前描述的 O_RDONLY、O_WRONLY 和 O_RDWR 标志均在此列，调用 open()时，上述三者在 flags 参数中不能同时使用，只能指定其中一种。调用fcntl()的 F_GETFL 操作能够检索文件的访问模式（见 5.3 节）。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参  数</th>
<th>说  明</th>
<th>参  数</th>
<th>说  明</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_RDONLY</td>
<td>以只读方式打开文件</td>
<td>O_RDWR</td>
<td>以可读写方式打开文件</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>以只写方式打开文件</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>文件创建标志：这些标志在表 4-3 中位于第二部分，其控制范围不拘于 open()调用行为的方方面面，还涉及后续 I/O 操作的各个选项。这些标志不能检索，也无法修改。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参  数</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_CLOEXEC</code></td>
<td>设置close-on-exec标志</td>
</tr>
<tr>
<td><code>O_CREAT</code></td>
<td>若路径中的文件不存在则自动建立该文件</td>
</tr>
<tr>
<td><code>O_DIRECT</code></td>
<td>无缓冲的输入输出</td>
</tr>
<tr>
<td><code>O_DIRECTORY</code></td>
<td>如果pathname不是目录则会失败</td>
</tr>
<tr>
<td><code>O_EXCL</code></td>
<td>如果与O_CREAT同时设置，此指令会去检查文件是否存在，文件若不存在则建立该文件，否则将导致打开文件错误。此外，若O_CREAT与O_EXCL同时设置，并且将要打开的文件为符号连接，则将导致打开文件失败</td>
</tr>
<tr>
<td><code>O_LARGEFILE</code></td>
<td>在32位系统上用之打开大文件</td>
</tr>
<tr>
<td><code>O_NOATIME</code></td>
<td>调用read时候不修改文件最近的访问时间</td>
</tr>
<tr>
<td><code>O_NOCTTY</code></td>
<td>不要让pathname（所指向的终端设备）成为控制终端</td>
</tr>
<tr>
<td><code>O_NOFOLLOW</code></td>
<td>对链接符号不予解引用</td>
</tr>
<tr>
<td><code>O_TRUNC</code></td>
<td>若文件存在并且以可写的方式打开时，此标志会将文件长度清为0，而原来存于该文件的资料也会消失</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>已打开文件的状态标志：这些标志是表 4-3 中的剩余部分，使用 fcntl()的 F_GETFL 和F_SETFL 操作可以分别检索和修改此类标志。有时干脆将其称之为<strong>文件状态标志</strong>。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参  数</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_APPEND</code></td>
<td>读写文件从文件尾部开始移动，所写入的数据追加到文件尾</td>
</tr>
<tr>
<td><code>O_ASYNC</code></td>
<td>当IO操作可行时，产生信号通知进程</td>
</tr>
<tr>
<td><code>O_DSYNC</code></td>
<td>提供同步的IO数据完整性</td>
</tr>
<tr>
<td><code>O_NONBLOCK</code></td>
<td>以非阻塞的方式打开</td>
</tr>
<tr>
<td><code>O_SYNC</code></td>
<td>以同步方式写入文件</td>
</tr>
</tbody>
</table>
</div>
<h4 id="O-APPEND"><a href="#O-APPEND" class="headerlink" title="O_APPEND"></a>O_APPEND</h4><p>​        总是在文件尾部追加数据，5.1 节将讨论此标志的意义。</p>
<h4 id="O-ASYNC"><a href="#O-ASYNC" class="headerlink" title="O_ASYNC"></a>O_ASYNC</h4><p>​        当对于 open()调用所返回的文件描述符可以实施 I/O 操作时，系统会产生一个信号通知进程。这一特性，也被称为信号驱动 I/O，仅对特定类型的文件有效，诸如终端、FIFOS 及 socket。（在 SUSv3 中并未规定 O_ASYNC 标志，但大多数 UNIX 实现都支持此标志或者老版本中与其等效的 FASYNC 标志。）在 Linux 中，调用 open()时指定 O_ASYNC 标志没有任何实质效果。要启用信号驱动 I/O 特性，必须调用 fcntl()的 F_SETFL 操作来设置 O_ASYNC 标志（见 5.3 节）。（其他一些 UNIX 系统的实现有类似行为。）关于 O_ASYNC 标志的更多内容请参考 63.3 节。</p>
<h4 id="O-CLOEXEC（自-Linux-2-6-23-版本开始支持）"><a href="#O-CLOEXEC（自-Linux-2-6-23-版本开始支持）" class="headerlink" title="O_CLOEXEC（自 Linux 2.6.23 版本开始支持）"></a>O_CLOEXEC（自 Linux 2.6.23 版本开始支持）</h4><p>​        为新（创建）的文件描述符启用 close-on-flag 标志（FD_CLOEXEC）。27.4 节将描述 FD_ CLOEXEC 标志。使用 O_CLOEXEC 标志（打开文件），可以免去程序执行 fcntl()的 F_GETFD和 F_SETFD 操作来设置 close-on-exec 标志的额外工作。在多线程程序中执行 fcntl() 的 F_GETFD和 F_SETFD 操作有可能导致竞争状态，而使用 O_CLOEXEC 标志则能够避免这一点。可能引发竞争的场景是：线程某甲打开一文件描述符，尝试为该描述符标记 close-on-exec 标志，于此同时，线程某乙执行 fork()调用，然后调用 exec()执行任意一个程序。（假设在某甲打开文件描述符和调用fcntl()设置 close-on-exec 标志之间，某乙成功地执行了 fork()和 exec()操作。）此类竞争可能会在无意间将打开的文件描述符泄露给不安全的程序。（更多关于竞争状态的内容请参考 5.1 节。）</p>
<h4 id="O-CREAT"><a href="#O-CREAT" class="headerlink" title="O_CREAT"></a>O_CREAT</h4><p>如果文件不存在，将创建一个新的空文件。即使文件以只读方式打开，此标志依然有效。如果在 open()调用中指定 O_CREAT 标志，那么还需要提供 mode 参数，否则，会将新文件的权限设置为栈中的某个随机值。</p>
<h4 id="O-DIRECT"><a href="#O-DIRECT" class="headerlink" title="O_DIRECT"></a>O_DIRECT</h4><p>​        无系统缓冲的文件 I/O 操作。该特性将在 13.6 节中详述。为使 O_DIRECT 标志的常量定义在<fcntl.h>中有效，必须定义_GNU_SOURCE 功能测试宏。</p>
<h4 id="O-DIRECTORY"><a href="#O-DIRECTORY" class="headerlink" title="O_DIRECTORY"></a>O_DIRECTORY</h4><p>​        如果 pathname 参数并非目录，将返回错误（错误号 errno 为 ENOTDIR）。这一标志是专为实现 opendir()函数（18.8 节）而设计的扩展标志。为使 O_DIRECTORY 标志的常量定义在<fcntl.h>中有效，必须定义_GNU_SOURCE 功能测试宏. _</p>
<h4 id="O-DSYNC（自-Linux-2-6-33-版本开始支持）"><a href="#O-DSYNC（自-Linux-2-6-33-版本开始支持）" class="headerlink" title="O_DSYNC（自 Linux 2.6.33 版本开始支持）"></a>O_DSYNC（自 Linux 2.6.33 版本开始支持）</h4><p>​        根据同步 I/O 数据完整性的完成要求1来执行文件写操作。参见 13.3 节中关于内核 I/O 缓冲的讨论。</p>
<h4 id="O-EXCL"><a href="#O-EXCL" class="headerlink" title="O_EXCL"></a>O_EXCL</h4><p>​        此标志与 O_CREAT 标志结合使用表明如果文件已经存在，则不会打开文件，且 open()调用失败，并返回错误，错误号 errno 为 EEXIST。换言之，此标志确保了调用者（open( )的调用进程）就是创建文件的进程。检查文件存在与否和创建文件这两步属于同一原子操作。5.1 节将讨论原子操作的概念。如果在 flags 参数中同时指定了 O_CREAT 和 O_EXCL 标志，且 pathname参数是符号链接，则 open()函数调用失败（错误号 errno 为 EEXIST）。SUSv3 之所以如此规定，是要求有特权的应用程序在已知目录下创建文件，从而消除了如下安全隐患，使用符号链接打开文件会导致在另一位置创建文件（例如，系统目录）。</p>
<h4 id="O-LARGEFILE"><a href="#O-LARGEFILE" class="headerlink" title="O_LARGEFILE"></a>O_LARGEFILE</h4><p>​        支持以大文件方式打开文件。在 32 位操作系统中使用此标志，以支持大文件操作。尽管在 SUSv3 中没有规定这一标志，但其他一些 UNIX 实现都支持这一特性。此标志在诸如 Alpha、IA-64 之类的 64 位 Linux 实现中是无效的。更多的内容将在 5.10 节中讨论。</p>
<h4 id="O-NOATIME（自-Linux-2-6-8-版本开始）"><a href="#O-NOATIME（自-Linux-2-6-8-版本开始）" class="headerlink" title="O_NOATIME（自 Linux 2.6.8 版本开始）"></a>O_NOATIME（自 Linux 2.6.8 版本开始）</h4><p>​        在读文件时，不更新文件的最近访问时间（15.1 节中所描述的 st_atime 属性）。要使用该标志，要么调用进程的有效用户 ID 必须与文件的拥有者相匹配，要么进程需要拥有特权（CAP_FOWNER）。否则，open()调用失败，并返回错误，错误号 errno 为 EPERM。（事实上，如 9.5 节所述，对于非特权进程，当以 O_NOATIME 标志打开文件时，与文件用户 ID 必须匹配的是进程的文件系统用户 ID，而非进程的有效用户 ID。）此标志是 Linux 特有的非标准扩展。要从<fcntl.h>中启用此标志，必须定义_GNU_SOURCE 功能测试宏。O_NOATIME 标志的设计旨在为索引和备份程序服务。该标志的使用能够显著减少磁盘的活动量，省却了既要读取文件内容，又要更新文件 i-node 结构中最近访问时间的繁琐，进而节省了磁头在磁盘上的反复寻道时间（14.4 节）。mount()函数中 MS_ NOATIME 标志（14.8.1 节）和 FS_NOATIME_ FL 标志（15.5 节）与 O_NOATIME 标志功能相似。</p>
<h4 id="O-NOCTTY"><a href="#O-NOCTTY" class="headerlink" title="O_NOCTTY"></a>O_NOCTTY</h4><p>​        如果正在打开的文件属于终端设备，O_NOCTTY 标志防止其成为控制终端。34.4 节将讨论控制终端。如果正在打开的文件不是终端设备，则此标志无效。</p>
<h4 id="O-NOFOLLOW"><a href="#O-NOFOLLOW" class="headerlink" title="O_NOFOLLOW"></a>O_NOFOLLOW</h4><p>​        通常，如果 pathname 参数是符号链接，open()函数将对 pathname 参数进行解引用。一旦在 open()函数中指定了 O_NOFOLLOW 标志，且 pathname 参数属于符号链接，则 open()函数将返回失败（错误号 errno 为 ELOOP）。此标志在特权程序中极为有用，能够确保 open()函数不对符号链接进行解引用。为使 O_NOFOLLOW 标志在<fcntl.h>中有效，必须定义_GNU_SOURCE功能测试宏。_</p>
<h4 id="O-NONBLOCK"><a href="#O-NONBLOCK" class="headerlink" title="O_NONBLOCK"></a>O_NONBLOCK</h4><p>以非阻塞方式打开文件，参照 5.9 节。</p>
<h4 id="O-SYNC"><a href="#O-SYNC" class="headerlink" title="O_SYNC"></a>O_SYNC</h4><p>以同步 I/O 方式打开文件，参见 13.3 节针对内核 I/O 缓冲的讨论。</p>
<h4 id="O-TRUNC"><a href="#O-TRUNC" class="headerlink" title="O_TRUNC"></a>O_TRUNC</h4><p>​        如果文件已经存在且为普通文件，那么将清空文件内容，将其长度置 0。在 Linux 下使用此标志，无论以读、写方式打开文件，都可清空文件内容（在这两种情况下，都必须拥有对文件的写权限）。SUSv3 对 O_RDONLY 与 O_TRUNC 标志的组合未作规定，但多数其他 UNIX实现与 Linux 的处理方式相同。</p>
<h3 id="open可能抛出的异常"><a href="#open可能抛出的异常" class="headerlink" title="open可能抛出的异常"></a>open可能抛出的异常</h3><p>​        若打开文件时发生错误，open()将返回−1，错误号 errno 标识错误原因。以下是一些可能发生的错误（除了在上节参数描述中已经提及的错误之外）。</p>
<h4 id="EACCES"><a href="#EACCES" class="headerlink" title="EACCES"></a>EACCES</h4><p>​        文件权限不允许调用进程以 flags 参数指定的方式打开文件。无法访问文件，其可能的原因有目录权限的限制、文件不存在并且也无法创建该文件。</p>
<h4 id="EISDIR"><a href="#EISDIR" class="headerlink" title="EISDIR"></a>EISDIR</h4><p>​        所指定的文件属于目录，而调用者企图打开该文件进行写操作。不允许这种用法。（另一方面，在某些场合中，打开目录进行读操作是必要的。18.11 节将举例说明。）</p>
<h4 id="EMFILE"><a href="#EMFILE" class="headerlink" title="EMFILE"></a>EMFILE</h4><p>​        进程已打开的文件描述符数量达到了进程资源限制所设定的上限（在 36.3 节将描述RLIMIT_NOFILE 参数）。ENFILE 文件打开数量已经达到系统允许的上限。</p>
<h4 id="ENOENT"><a href="#ENOENT" class="headerlink" title="ENOENT"></a>ENOENT</h4><p>​        要么文件不存在且未指定 O_CREAT 标志，要么指定了 O_CREAT 标志，但 pathname 参数所指定路径的目录之一不存在，或者 pathname 参数为符号链接，而该链接指向的文件不存在（空链接）。</p>
<h4 id="EROFS"><a href="#EROFS" class="headerlink" title="EROFS"></a>EROFS</h4><p>​        所指定的文件隶属于只读文件系统，而调用者企图以写方式打开文件。</p>
<h4 id="ETXTBSY"><a href="#ETXTBSY" class="headerlink" title="ETXTBSY"></a>ETXTBSY</h4><p>​        所指定的文件为可执行文件（程序），且正在运行。系统不允许修改正在运行的程序（比如以写方式打开文件）。（必须首先终止程序运行，然后方可修改可执行文件。）后续在描述其他系统调用或库函数时，一般不会再以上述方式展现可能发生的一系列错误。（每个系统调用或库函数的错误列表可从相关操作手册中查询获得。）采用上述方式原因有二，一是因为 open()是本书详细描述的首个系统调用，而上述列表表明任一原因都有可能导致系统调用或库函数的调用失败。二是 open()调用失败的具体原因列表本身就颇为值得玩味，它展示了影响文件访问的若干因素，以及访问文件时系统所执行的一系列检查。（上述错误列表并不完整，更多 open()调用失败的错误原因请查看 open(2)的操作手册。）</p>
<h2 id="read读文件"><a href="#read读文件" class="headerlink" title="read读文件"></a>read读文件</h2><p>​        read()系统调用从文件描述符 fd 所指代的打开文件中读取数据。</p>
<pre class="line-numbers language-none"><code class="language-none">extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __wur;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        count 参数指定最多能读取的字节数。（size_t 数据类型属于无符号整数类型。）buffer 参数提供用来存放输入数据的内存缓冲区地址。缓冲区至少应有 count 个字节。</p>
<p>​        <strong>如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。</strong>ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。</p>
<p>​        一次 read()调用所读取的字节数可以小于请求的字节数。对于普通文件而言，这有可能是因为当前读取位置靠近文件尾部。（不难理解，一个只有10b的文件读它个20b，那么实际上就会读取10b）</p>
<p>​        当 read()应用于其他文件类型时，比如管道、FIFO、socket 或者终端，在不同环境下也会出现 read()调用读取的字节数小于请求字节数的情况。例如，默认情况下从终端读取字符，一遇到换行符（\n），read()调用就会结束。</p>
<p>​        值得注意的是：有必要在read的东西加上一个\0以示终止，因为 read()调用没有在 字符串尾部添加一个表示终止的空字符。为什么不加呢？read()无从区分这些数据，故而也无法遵从 C 语言对字符串处理的约定，在字符串尾部追加标识字符串结束的空字符。如果输入缓冲区的结尾处需要一个表示终止的空字符，必须显式追加。</p>
<h2 id="write写文件"><a href="#write写文件" class="headerlink" title="write写文件"></a>write写文件</h2><pre class="line-numbers language-none"><code class="language-none">extern ssize_t write (int __fd, const void *__buf, size_t __n) __wur;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        write()系统调用将数据写入一个已打开的文件中。write()调用的参数含义与 read()调用相类似。buffer 参数为要写入文件中数据的内存地址，count参数为欲从 buffer 写入文件的数据字节数，fd 参数为一文件描述符，指代数据要写入的文件。</p>
<p>​        如果 write()调用成功，将返回实际写入文件的字节数，该返回值可能小于 count 参数值。这被称为“部分写”。对磁盘文件来说，造成“部分写”的原因可能是由于磁盘已满，或是因为进程资源对文件大小的限制。（相关的限制为 RLIMIT_FSIZE，将在 36.3 节描述。）</p>
<p>​        对磁盘文件执行 I/O 操作时，write()调用成功并不能保证数据已经写入磁盘。因为为了减少磁盘活动量和加快 write()系统调用，内核会缓存磁盘的 I/O 操作</p>
<h2 id="close-关闭文件"><a href="#close-关闭文件" class="headerlink" title="close() 关闭文件"></a>close() 关闭文件</h2><p>​        close()系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。</p>
<pre class="line-numbers language-none"><code class="language-none">extern int close (int __fd);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当一进程终止时，将自动关闭其已打开的所有文件描述符。</p>
<p>​        显式关闭不再需要的文件描述符往往是良好的编程习惯，会使代码在后续修改时更具可读性，也更可靠。进而言之，文件描述符属于有限资源，因此文件描述符关闭失败可能会导致一个进程将文件描述符资源消耗殆尽。在编写需要长期运行并处理大量文件的程序时，比如 shell 或者网络服务器软件，需要特别加以关注。<strong>像其他所有系统调用一样，应对 close()的调用进行错误检查</strong></p>
<pre class="line-numbers language-none"><code class="language-none">if(close(fd) &#x3D;&#x3D; -1)&#123;
	exit(-1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        上述代码能够捕获的错误有：<strong>企图关闭一个未打开的文件描述符，或者两次关闭同一文件描述符，也能捕获特定文件系统在关闭操作中诊断出的错误条件</strong>。针对特定文件系统的错误，NFS（网络文件系统）就是一例。如果 NFS 出现提交失败，这意味着数据没有抵达远程磁盘，随之将这一错误作为 close()调用失败的原因传递给应用系统。</p>
<h2 id="lseek-改变文件偏移量"><a href="#lseek-改变文件偏移量" class="headerlink" title="lseek()改变文件偏移量"></a>lseek()改变文件偏移量</h2><p>​        对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指<strong>执行下一个 read()或 write()操作的文件起始位置</strong>，会以相对于文件头部起始点的文件当前位置来表示。<strong>文件第一个字节的偏移量为 0。</strong></p>
<p>​        文件打开时，会将文件偏移量设置为指向文件开始，以后每次 read()或 write()调用将自动对其进行调整，以指向已读或已写数据后的下一字节。因此，连续的 read()和 write()调用将按顺序递进，对文件进行操作。</p>
<p>​        针对文件描述符 fd 参数所指代的已打开文件，lseek()系统调用依照 offset 和 whence 参数值调整该文件的偏移量。</p>
<pre class="line-numbers language-none"><code class="language-none">extern __off_t lseek (int __fd, __off_t __offset, int __whence) __THROW;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        offset 参数指定了一个以字节为单位的数值。（SUSv3 规定 off_t 数据类型为有符号整型数。）whence 参数则表明应参照哪个基点来解释 offset 参数，应为下列其中之一：</p>
<ul>
<li>SEEK_SET   将文件偏移量设置为从文件头部起始点开始的 offset 个字节。</li>
<li>SEEK_CUR 相对于当前文件偏移量，将文件偏移量调整 offset 个字节1。</li>
<li>SEEK_END 将文件偏移量设置为起始于文件尾部的 offset 个字节。也就是说，offset 参数应该从文件最后一个字节之后的下一个字节算起。</li>
</ul>
<p><img src="image-20230803172531005.png" alt="image-20230803172531005"></p>
<p>​        lseek()并不适用于所有类型的文件。不允许将 lseek()应用于管道、FIFO、socket 或者终端。一旦如此，调用将会失败，并将 errno 置为 ESPIPE。</p>
<p>​        另一方面，只要合情合理，也可以将 lseek()应用于设备。例如，在磁盘或者磁带上查找一处具体位置。lseek()调用名中的 l 源于这样一个事实：offset 参数和调用返回值的类型起初都是 long型。早期的 UNIX 系统还提供了 seek()系统调用，当时这两个值的类型为 int 型。</p>
<h3 id="文件空洞"><a href="#文件空洞" class="headerlink" title="文件空洞"></a>文件空洞</h3><p>​        对于我们想要执行写操作——我们打算在文件偏移量已经大于文件长度的情况下去写东西会如何呢？</p>
<p>​        答案是——不会报错！相反，会将中间的部分填充0后再准备写想写的东西。从文件结尾后到新写入数据间的这段空间被称为文件空洞。从编程角度看，文件空洞中是存在字节的，读取空洞将返回以 0（空字节）填充的缓冲区。</p>
<p>​        然而，文件空洞不占用任何磁盘空间。直到后续某个时点，在文件空洞中写入了数据，文件系统才会为之分配磁盘块。文件空洞的主要优势在于，与为实际需要的空字节分配磁盘块相比，稀疏填充的文件会占用较少的磁盘空间。核心转储文件（core dump）（见 22.1 节）是包含空洞文件的常见例子。</p>
<h2 id="4-9-总结"><a href="#4-9-总结" class="headerlink" title="4.9 总结"></a>4.9 总结</h2><p>​        为了对普通文件执行 I/O 操作，首先必须调用 open()以获得一个文件描述符。随之使用read()和 write()执行文件的 I/O 操作，然后应使用 close()释放文件描述符及相关资源。这些系统调用可对所有类型的文件执行 I/O 操作。所有类型的文件和设备驱动都实现了相同的 I/O 接口，这保证了 I/O 操作的通用性，同时也意味着在无需针对特定文件类型编写代码的情况下，程序通常就能操作所有类型的文件。对于已打开的每个文件，内核都维护有一个文件偏移量，这决定了下一次读或写操作的起始位置。读和写操作会隐式修改文件偏移量。使用 lseek()函数可以显式地将文件偏移量置为文件中或文件结尾后的任一位置。在文件原结尾处之后的某一位置写入数据将导致文件空洞。从文件空洞处读取文件将返回全 0 字节。对于未纳入标准 I/O 模型的所有设备和文件操作而言，ioctl()系统调用是个“百宝箱”。</p>
<h1 id="扩展：传统的-System-Call-I-O"><a href="#扩展：传统的-System-Call-I-O" class="headerlink" title="扩展：传统的 System Call I/O"></a>扩展：传统的 System Call I/O</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/435406445">Linux系统中I/O操作的数据读写流程介绍 - 知乎 (zhihu.com)</a></p>
<p>​        在 Linux 系统中，<strong>传统的访问方式是通过 write() 和 read() 两个系统调用实现的，通过 read() 函数读取文件到到缓存区中，然后通过 write() 方法把缓存中的数据输出到网络端口</strong>。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">read(file_fd, tmp_buf, len);
write(socket_fd, tmp_buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        下图分别对应传统 I/O 操作的数据读写流程，整个过程涉及 2 次 CPU 拷贝、2 次 DMA 拷贝，总共 4 次拷贝，以及 4 次上下文切换。</p>
<ul>
<li><strong>CPU 拷贝</strong>：由 CPU 直接处理数据的传送，数据拷贝时会一直占用 CPU 的资源。</li>
<li><strong>DMA 拷贝</strong>：由 CPU 向DMA磁盘控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，从而减轻了 CPU 资源的占有率。</li>
<li><strong>上下文切换</strong>：当用户程序向内核发起系统调用时，CPU 将用户进程从用户态切换到内核态；当系统调用返回时，CPU 将用户进程从内核态切换回用户态。</li>
</ul>
<h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>​        当应用程序执行 read 系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据。</p>
<p>​        如果数据不存在，则先将数据从磁盘加载数据到内核空间的读缓存（Read Buffer）中，再从读缓存拷贝到用户进程的页内存中。</p>
<p><img src="v2-c4ffd5334a977af27f18b3b6eac6f65c_1440w.webp" alt="img"></p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">read(file_fd, tmp_buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        基于传统的 I/O 读取方式，read 系统调用会触发 2 次上下文切换，1 次 DMA 拷贝和 1 次 CPU 拷贝。</p>
<p><strong>发起数据读取的流程如下：</strong></p>
<ol>
<li>用户进程通过 read() 函数向 Kernel 发起 System Call，上下文从 user space 切换为 kernel space。</li>
<li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到 kernel space 的读缓冲区（Read Buffer）。</li>
<li>CPU 将读缓冲区（Read Buffer）中的数据拷贝到 user space 的用户缓冲区（User Buffer）。</li>
<li>上下文从 kernel space 切换回用户态（User Space），read 调用执行返回。</li>
</ol>
<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>​        当应用程序准备好数据，执行 write 系统调用发送网络数据时，先将数据从用户空间的页缓存拷贝到内核空间的网络缓冲区（Socket Buffer）中，然后再将写缓存中的数据拷贝到网卡设备完成数据发送。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">write(socket_fd, tmp_buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        基于传统的 I/O 写入方式，write() 系统调用会触发 2 次上下文切换，1 次 CPU 拷贝和 1 次 DMA 拷贝。</p>
<p>​        <strong>用户程序发送网络数据的流程如下：</strong></p>
<ol>
<li>用户进程通过 write() 函数向 kernel 发起 System Call，上下文从 user space 切换为 kernel space。</li>
<li>CPU 将用户缓冲区（User Buffer）中的数据拷贝到 kernel space 的网络缓冲区（Socket Buffer）。</li>
<li>CPU 利用 DMA 控制器将数据从网络缓冲区（Socket Buffer）拷贝到 NIC 进行数据传输。</li>
<li>上下文从 kernel space 切换回 user space，write 系统调用执行返回。</li>
</ol>
<h2 id="网络-I-O"><a href="#网络-I-O" class="headerlink" title="网络 I/O"></a>网络 I/O</h2><p><img src="v2-a0bbc8704096e91fd1ab2546d5dedfde_1440w.webp" alt="img"></p>
<h2 id="磁盘-I-O"><a href="#磁盘-I-O" class="headerlink" title="磁盘 I/O"></a>磁盘 I/O</h2><p><img src="v2-6a02810aa6d653bae2d27784d1f79995_1440w.webp" alt="img"></p>
<h2 id="高性能优化的-I-O"><a href="#高性能优化的-I-O" class="headerlink" title="高性能优化的 I/O"></a>高性能优化的 I/O</h2><ol>
<li><strong>零拷贝技术。</strong></li>
<li><strong>多路复用技术。</strong></li>
<li><strong>页缓存（PageCache）技术。</strong></li>
</ol>
<p>其中，<strong>页缓存（PageCache）</strong>是操作系统对文件的缓存，用来减少对磁盘的 I/O 操作，以页为单位的，内容就是磁盘上的物理块，页缓存能帮助程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于 OS 使用 PageCache 机制对读写访问操作进行了性能优化。</p>
<p><strong>页缓存读取策略</strong>：当进程发起一个读操作 （比如，进程发起一个 read() 系统调用），它首先会检查需要的数据是否在页缓存中：</p>
<ul>
<li><strong>如果在</strong>，则放弃访问磁盘，而直接从页缓存中读取。</li>
<li><strong>如果不在</strong>，则内核调度块 I/O 操作从磁盘去读取数据，并读入紧随其后的少数几个页面（不少于一个页面，通常是三个页面），然后将数据放入页缓存中。</li>
</ul>
<p><img src="v2-222d29b87f50973806ed9c1a7633819f_1440w.webp" alt="img"></p>
<p><strong>页缓存写策略</strong>：当进程发起 write 系统调用写数据到文件中，先写到页缓存，然后方法返回。此时数据还没有真正的保存到文件中去，Linux 仅仅将页缓存中的这一页数据标记为 “脏”，并且被加入到脏页链表中。</p>
<p>然后，由 flusher 回写线程周期性将脏页链表中的页写到磁盘，让磁盘中的数据和内存中保持一致，最后清理“脏”标识。</p>
<p><strong>在以下三种情况下，脏页会被写回磁盘：</strong></p>
<ol>
<li>空闲内存低于一个特定阈值。</li>
<li>脏页在内存中驻留超过一个特定的阈值时。</li>
<li>当用户进程调用 sync() 和 fsync() 系统调用时。</li>
</ol>
<h2 id="存储设备的-I-O-栈"><a href="#存储设备的-I-O-栈" class="headerlink" title="存储设备的 I/O 栈"></a>存储设备的 I/O 栈</h2><p><img src="v2-c5c7c058af6239bbb2f86fe9da0f33f9_1440w.webp" alt="img"></p>
<p><strong>由图可见，从系统调用的接口再往下，Linux 下的 IO 栈致大致有三个层次：</strong></p>
<ol>
<li><strong>文件系统层</strong>，以 write 为例，内核拷贝了 write 参数指定的用户态数据到文件系统 Cache 中，并适时向下层同步。</li>
<li><strong>块层</strong>，管理块设备的 IO 队列，对 IO 请求进行合并、排序（还记得操作系统课程学习过的 IO 调度算法吗？）。</li>
<li><strong>设备层</strong>，通过 DMA 与内存直接交互，完成数据和具体设备之间的交互。</li>
</ol>
<p>结合这个图，想想 Linux 系统编程里用到的 <strong>Buffered IO</strong>、<strong>mmap</strong>、<strong>Direct IO</strong>，这些机制怎么和<strong>Linux I/O栈</strong>联系起来呢？上面的图有点复杂，我画一幅简图，把这些机制所在的位置添加进去：</p>
<p><img src="v2-50b7e6e5b531ab5fc8c294bc6cfa125a_1440w.webp" alt="img"></p>
<h2 id="Linux-IO系统"><a href="#Linux-IO系统" class="headerlink" title="Linux IO系统"></a><strong>Linux IO系统</strong></h2><p>​        这下一目了然了吧？<strong>传统的 Buffered IO</strong> 使用 read 读取文件的过程什么样的？假设要去读一个冷文件（Cache 中不存在），open 打开文件内核后建立了一系列的数据结构，接下来调用 read，到达文件系统这一层，发现 <strong>Page Cache</strong> 中不存在该位置的磁盘映射，然后创建相应的 Page Cache 并和相关的扇区关联。然后请求继续到达块设备层，在 IO 队列里排队，接受一系列的调度后到达设备驱动层，此时一般使用 <strong>DMA</strong> 方式读取相应的磁盘扇区到 Cache 中，然后 read 拷贝数据到用户提供的<strong>用户态 buffer</strong> 中去（read 的参数指出的）。</p>
<p>​        <strong>整个过程有几次拷贝？</strong>从磁盘到 Page Cache 算第一次的话，从 Page Cache 到用户态 buffer 就是第二次了。而 mmap 做了什么？mmap 直接把 Page Cache 映射到了用户态的地址空间里了，所以 mmap 的方式读文件是没有第二次拷贝过程的。</p>
<p>​        <strong>那 Direct IO 做了什么？</strong>这个机制更狠，直接让用户态和块 IO 层对接，直接放弃 Page Cache，从磁盘直接和用户态拷贝数据。好处是什么？写操作直接映射进程的buffer到磁盘扇区，以 DMA 的方式传输数据，减少了原本需要到 Page Cache 层的一次拷贝，提升了写的效率。对于读而言，第一次肯定也是快于传统的方式的，但是之后的读就不如传统方式了（当然也可以在用户态自己做 Cache，有些商用数据库就是这么做的）。</p>
<p>除了传统的 Buffered IO 可以比较自由的用偏移+长度的方式读写文件之外，<strong>mmap</strong> 和 Direct IO 均有数据按页对齐的要求，Direct IO 还限制读写必须是底层存储设备块大小的整数倍（甚至 Linux 2.4 还要求是文件系统逻辑块的整数倍）。所以接口越来越底层，换来表面上的效率提升的背后，需要在应用程序这一层做更多的事情。所以想用好这些高级特性，除了深刻理解其背后的机制之外，也要在系统设计上下一番功夫。</p>
<h2 id="I-O-Buffering"><a href="#I-O-Buffering" class="headerlink" title="I/O Buffering"></a>I/O Buffering</h2><p><img src="v2-5ac443941b2d427d34d958db72480d9e_1440w.webp" alt="img"></p>
<p>​        如图，当程序调用各类文件操作函数后，用户数据（User Data）到达磁盘（Disk）的流程如图所示。</p>
<p>​        图中描述了 Linux 下文件操作函数的层级关系和内存缓存层的存在位置。中间的黑色实线是用户态和内核态的分界线。</p>
<p><strong>从上往下分析这张图：</strong></p>
<p>​        <strong>1.</strong> 首先是 C 语言 stdio 库定义的相关文件操作函数，这些都是用户态实现的跨平台封装函数。stdio 中实现的文件操作函数有自己的 stdio buffer，这是在用户态实现的缓存。此处使用缓存的原因很简单 — 系统调用总是昂贵的。如果用户代码以较小的 size 不断的读或写文件的话，stdio 库将多次的读或者写操作通过 buffer 进行聚合是可以提高程序运行效率的。stdio 库同时也支持 fflush 函数来主动的刷新 buffer，主动的调用底层的系统调用立即更新 buffer 里的数据。特别地，setbuf 函数可以对 stdio 库的用户态 buffer 进行设置，甚至取消 buffer 的使用。</p>
<p>​        <strong>2.</strong> <strong>系统调用的 read/write 和真实的磁盘读写之间也存在一层 buffer</strong>，这里用术语 Kernel buffer cache 来指代这一层缓存。在 Linux 下，文件的缓存习惯性的称之为 Page Cache，而更低一级的设备的缓存称之为 Buffer Cache。这两个概念很容易混淆，这里简单的介绍下概念上的区别：Page Cache 用于缓存文件的内容，和文件系统比较相关。文件的内容需要映射到实际的物理磁盘，这种映射关系由文件系统来完成；Buffer Cache 用于缓存存储设备块（比如磁盘扇区）的数据，而不关心是否有文件系统的存在（文件系统的元数据缓存在 Buffer Cache 中）。</p>
<h1 id="深入探究文件IO"><a href="#深入探究文件IO" class="headerlink" title="深入探究文件IO"></a>深入探究文件IO</h1><h2 id="原子操作和竞争条件"><a href="#原子操作和竞争条件" class="headerlink" title="原子操作和竞争条件"></a>原子操作和竞争条件</h2><p>​        我们下面要要谈到的是高级一些的文件IO，这里，我们就需要考虑到原子操作和竞争条件.也就是说,我们现在来考虑一下多进程下的文件IO函数行为</p>
<h3 id="举个例子-以独占方式创建一个文件"><a href="#举个例子-以独占方式创建一个文件" class="headerlink" title="举个例子:以独占方式创建一个文件"></a>举个例子:以独占方式创建一个文件</h3><p>​        当同时指定 O_EXCL 与 O_CREAT 作为 open()的标志位时，如果要打开的文件已然存在，则 open()将返回一个错误。这提供了一种机制，保证进程是打开文件的创建者。</p>
<p>​        下面的这个程序是有问题的:</p>
<p><img src="image-20230803174458278.png" alt="image-20230803174458278"></p>
<p>​        在多进程条件下,我们如果不加原子操作,非文件开创的进程会认为是自己开创的进程.</p>
<p><img src="image-20230803174619051.png" alt="image-20230803174619051"></p>
<p>​        从而埋下隐患.结合 O_CREAT 和 O_EXCL 标志来一次性地调用 open()可以防止这种情况，因为这确保了检查文件和创建文件的步骤属于一个单一的原子（即不可中断的）操作。</p>
<h3 id="再举个例子-向文件尾部追加数据"><a href="#再举个例子-向文件尾部追加数据" class="headerlink" title="再举个例子:向文件尾部追加数据"></a>再举个例子:向文件尾部追加数据</h3><p>​        还有一个例子,就是多个进程同时向某一个文件追加数据</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if(lseek(fd, 0, SEEK_END) &#x3D;&#x3D; -1)&#123;
    errExit(-1);
&#125;
if(write(fd,buf,len) !&#x3D; len)&#123;
    fatal(&quot;Partially write or failed write!&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但是，这段代码存在的缺陷与前一个例子如出一辙。<strong>如果第一个进程执行到 lseek()和 write()之间，被执行相同代码的第二个进程所中断，那么这两个进程会在写入数据前，将文件偏移量设为相同位置，而当第一个进程再次获得调度时，会覆盖第二个进程已写入的数据。此时再次出现了竞争状态，因为执行的结果依赖于内核对两个进程的调度顺序。</strong></p>
<p>​        需要将文件偏移量的移动与数据写操作纳入同一原子操作。在打开文件时加入 O_APPEND 标志就可以保证这一点。有些文件系统（例如 NFS）不支持 O_APPEND 标志。</p>
<h2 id="文件控制操作：fcntl"><a href="#文件控制操作：fcntl" class="headerlink" title="文件控制操作：fcntl()"></a>文件控制操作：fcntl()</h2><p>​    fcntl()系统调用对一个打开的文件描述符执行一系列控制操作。</p>
<p><img src="image-20230803174720241.png" alt="image-20230803174720241"></p>
<p>​        cmd 参数所支持的操作范围很广。本章随后各节会对其中的部分操作加以研讨，剩下的操作将在后续各章中进行论述。</p>
<p>​        fcntl()的第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省略。内核会依据 cmd 参数（如果有的话）的值来确定该参数的数据类型。</p>
<h2 id="打开文件的状态标志"><a href="#打开文件的状态标志" class="headerlink" title="打开文件的状态标志"></a>打开文件的状态标志</h2><p>​        这个函数有一个用途:<strong>针对打开的文件,获取或修改其访问模式和状态标志（这些值是通过指定 open()调用的 flag 参数来设置的）。要获取这些设置，应将 fcntl()的 cmd 参数设置为F_GETFL。</strong></p>
<p><img src="image-20230803174744205.png" alt="image-20230803174744205"></p>
<p>​        在上述代码之后，可以以如下代码测试文件是否以同步写方式打开：</p>
<p><img src="image-20230803174814491.png" alt="image-20230803174814491"></p>
<p>​        当然,判断访问模式就有些复杂了</p>
<p>​        这是因为 O_RDONLY(0)、O_WRONLY(1)和 O_RDWR(2)这 3 个常量并不与打开文件状态标志中的单个比特位对应。因此，要判定访问模式，需使用掩码 O_ACCMODE 与 flag 相与，将结果与 3 个常量进行比对，示例代码如下：</p>
<p><img src="image-20230803174834715.png" alt="image-20230803174834715"></p>
<p>​        可以使用 fcntl()的 F_SETFL 命令来修改打开文件的某些状态标志。允许更改的标志有O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC 和 O_DIRECT。系统将忽略对其他标志的修改操作。（有些其他的 UNIX 实现允许 fcntl()修改其他标志，如 O_SYNC。）使用 fcntl()修改文件状态标志，尤其适用于如下场景。</p>
<ul>
<li>文件不是由调用程序打开的，所以程序也无法使用 open()调用来控制文件的状态标志（例如，文件是 3 个标准输入输出描述符中的一员，这些描述符在程序启动之前就被打开）。</li>
<li>文件描述符的获取是通过 open()之外的系统调用。比如 pipe()调用，该调用创建一个管道，并返回两个文件描述符分别对应管道的两端。再比如 socket()调用，该调用创建一个套接字并返回指向该套接字的文件描述符。</li>
</ul>
<p>​        为了修改打开文件的状态标志，可以使用 fcntl()的 F_GETFL 命令来获取当前标志的副本，然后修改需要变更的比特位，最后再次调用 fcntl()函数的 F_SETFL 命令来更新此状态标志。因此，为了添加 O_APPEND 标志，可以编写如下代码：</p>
<p><img src="image-20230803174904937.png" alt="image-20230803174904937"></p>
<h2 id="文件描述符和打开文件之间的关系"><a href="#文件描述符和打开文件之间的关系" class="headerlink" title="文件描述符和打开文件之间的关系"></a>文件描述符和打开文件之间的关系</h2><p>​        多个文件描述符当然可以指向同一个文件</p>
<p>这些文件描述符可在相同或不同的进程中打开。要理解具体情况如何，需要查看由内核维护的 3 个数据结构。</p>
<ul>
<li>进程级的文件描述符表。</li>
<li>系统级的打开文件表。</li>
<li>文件系统的 i-node 表。</li>
</ul>
<p>​        针对每个进程，<strong>内核为其维护打开文件的描述符（open file descriptor）表</strong>。该表的每一条目都记录了单个文件描述符的相关信息，如下所示。</p>
<ul>
<li><strong>控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即 close-on-exec 标志，将在 27.4 节予以介绍。）</strong></li>
<li><strong>对打开文件句柄的引用。</strong></li>
</ul>
<p>​        内核对所有打开的文件维护有一个系统级的描述表格（open file description table）。<strong>有时，也称之为打开文件表（open file table），并将表中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示。</strong></p>
<ul>
<li>当前文件偏移量（调用 read()和 write()时更新，或使用 lseek()直接修改）。</li>
<li>打开文件时所使用的状态标志（即，open()的 flags 参数）。</li>
<li>文件访问模式（如调用 open()时所设置的只读模式、只写模式或读写模式）。</li>
<li>与信号驱动 I/O 相关的设置（见 63.3 节）。</li>
<li>对该文件 i-node 对象的引用。</li>
</ul>
<p>​        每个文件系统都会为驻留其上的所有文件建立一个 i-node 表。第 14 章将详细讨论 i-node 结构和文件系统的总体结构。这里只是列出每个文件的 i-node 信息，具体如下。</p>
<ul>
<li>文件类型（例如，常规文件、套接字或 FIFO）和访问权限。</li>
<li>一个指针，指向该文件所持有的锁的列表。</li>
<li>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳。</li>
</ul>
<p>​        打开的文件句柄以及 i-node 之间的关系。在下图中，两个进程拥有诸多打开的文件描述符。在进程 A 中，文件描述符 1 和 20 都指向同一个打开的文件句柄（标号为 23）。这可能是通过调用 dup()、dup2()或 fcntl()而形成的（参见 5.5 节）。进程A的文件描述符2和进程B的文件描述符2都指向同一个打开的文件句柄（标号为73）。这种情形可能在调用 fork()后出现（即，进程 A 与进程 B 之间是父子关系），或者当某进程通过UNIX 域套接字将一个打开的文件描述符传递给另一进程时，也会发生（参见 61.13.3 节）。此外，进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件句柄，但这些句柄均指向 i-node 表中的相同条目（1976），换言之，指向同一文件。发生这种情况是因为每个进程各自对同一文件发起了 open()调用。同一个进程两次打开同一文件，也会发生类似情况。上述讨论揭示出如下要点。</p>
<ul>
<li>两个不同的文件描述符，若指向同一打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用 read()、write()或 lseek()所致），那么从另一文件描述符中也会观察到这一变化。无论这两个文件描述符分属于不同进程，还是同属于一个进程，情况都是如此。</li>
<li>要获取和修改打开的文件标志（例如，O_APPEND、O_NONBLOCK 和 O_ASYNC），可执行 fcntl()的 F_GETFL 和 F_SETFL 操作，其对作用域的约束与上一条颇为类似。</li>
<li>相形之下，文件描述符标志（亦即，close-on-exec 标志）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符。</li>
</ul>
<p><img src="image-20230803175434477.png" alt="image-20230803175434477"></p>
<h2 id="复制文件描述符"><a href="#复制文件描述符" class="headerlink" title="复制文件描述符"></a>复制文件描述符</h2><p>​        Bourne shell 的 I/O 重定向语法 2&gt;&amp;1，意在通知 shell 把标准错误（文件描述符 2）重定向到标准输出（文件描述符 1）。因此，下列命令将把（因为 shell 按从左至右的顺序处理 I/O 重定向语句）标准输出和标准错误写入 result.log 文件：</p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;myscript 2&gt;&amp;1 | less<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        shell 通过复制文件描述符 21实现了标准错误的重定向操作，因此文件描述符 2 与文件描述符 1 指向同一个打开文件句柄（类似于图 5-2 中进程 A 的描述符 1 和 20 指向同一打开文件句柄的情况）。可以通过调用 dup()和 dup2()来实现此功能。</p>
<p>​        请注意，要满足 shell 的这一要求，仅仅简单地打开 results.log 文件两次是远远不够的（第一次在描述符 1 上打开，第二次在描述符 2 上打开）。首先两个文件描述符不能共享相同的文件偏移量指针，因此有可能导致相互覆盖彼此的输出。再者打开的文件不一定就是磁盘文件。在如下命令中，标准错误就将和标准输出一起送达同一管道：</p>
<p><img src="image-20230803175629749.png" alt="image-20230803175629749"></p>
<p>​        <strong>dup()调用复制一个打开的文件描述符 oldfd，并返回一个新描述符，二者都指向同一打开的文件句柄。系统会保证新描述符一定是编号值最低的未用文件描述符。</strong></p>
<p><img src="image-20230803175616029.png" alt="image-20230803175616029"></p>
<p>​        假设发起如下调用：</p>
<pre class="line-numbers language-none"><code class="language-none">newfd &#x3D; dup(1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        再假定在正常情况下，shell 已经代表程序打开了文件描述符 0、1 和 2，且没有其他描述符在用，dup()调用会创建文件描述符 1 的副本，返回的文件描述符编号值为 3。如果希望返回文件描述符 2，可以使用如下技术：</p>
<p><img src="image-20230803175648334.png" alt="image-20230803175648334"></p>
<p>​        <strong>只有当描述符 0 已经打开时，这段代码方可工作。如果想进一步简化上述代码，同时总是能获得所期望的文件描述符，可以调用 dup2()。</strong></p>
<p><img src="image-20230803175701621.png" alt="image-20230803175701621"></p>
<p>​        dup2()系统调用会为 oldfd 参数所指定的文件描述符创建副本，其编号由 newfd 参数指定。<strong>如果由 newfd 参数所指定编号的文件描述符之前已经打开，那么 dup2()会首先将其关闭。（dup2()调用会默然忽略 newfd 关闭期间出现的任何错误。</strong>故此，编码时更为安全的做法是：<strong>在调用dup2()之前，若 newfd 已经打开，则应显式调用 close()将其关闭。</strong>）</p>
<p>​        前述调用 close()和 dup()的代码可以简化为：</p>
<pre class="line-numbers language-none"><code class="language-none">dup2(1,2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        若调用 dup2()成功，则将返回副本的文件描述符编号（即 newfd 参数指定的值）。如果 oldfd 并非有效的文件描述符，那么 dup2()调用将失败并返回错误 EBADF，且不关闭 newfd。如果 oldfd 有效，且与 newfd 值相等，那么 dup2()将什么也不做，不关闭 newfd，并将其作为调用结果返回。</p>
<p>​        fcntl()的 F_DUPFD 操作是复制文件描述符的另一接口，更具灵活性。</p>
<p>​        该调用为 oldfd 创建一个副本，且将使用大于等于 startfd 的最小未用值作为描述符编号。该调用还能保证新描述符（newfd）编号落在特定的区间范围内。总是能将 dup()和 dup2()调用改写为对 close()和 fcntl()的调用，虽然前者更为简洁。（还需注意，正如手册页中所描述的，dup2()和 fcntl()二者返回的 errno 错误码存在一些差别。）</p>
<p>​        由图 5-2 可知，文件描述符的正、副本之间共享同一打开文件句柄所含的文件偏移量和状态标志。然而，新文件描述符有其自己的一套文件描述符标志，且其 close-on-exec 标志（FD_CLOEXEC）总是处于关闭状态。下面将要介绍的接口，可以直接控制新文件描述符的close-on-exec 标志。</p>
<p>​        <strong>dup3()系统调用完成的工作与 dup2()相同，只是新增了一个附加参数 flag，这是一个可以修改系统调用行为的位掩码。</strong></p>
<p><img src="image-20230803181405591.png" alt="image-20230803181405591"></p>
<p>​        目前，dup3()只支持一个标志 O_CLOEXEC，这将促使内核为新文件描述符设置 close-on-exec标志（FD_CLOEXEC）。设计该标志的缘由，类似于 4.3.1 节对 open()调用中 O_CLOEXEC 标志的描述。dup3()系统调用始见于 Linux 2.6.27，为 Linux 所特有。Linux 从 2.6.24 开始支持 fcntl()用于复制文件描述符的附加命令：F_DUPFD_CLOEXEC。该标志不仅实现了与 F_DUPFD 相同的功能，还为新文件描述符设置 close-on-exec 标志。同样，此命令之所以得以一显身手，其原因也类似于 open()调用中的 O_CLOEXEC 标志。SUSv3 并未论及 F_DUPFD_CLOEXEC 标志，但 SUSv4 对其作了规范。</p>
<h2 id="在文件特定偏移量处的-I-O：pread-和-pwrite"><a href="#在文件特定偏移量处的-I-O：pread-和-pwrite" class="headerlink" title="在文件特定偏移量处的 I/O：pread()和 pwrite()"></a>在文件特定偏移量处的 I/O：pread()和 pwrite()</h2><p>​        系统调用 pread()和 pwrite()完成与 read()和 write()相类似的工作，只是前两者会在 offset 参数所指定的位置进行文件 I/O 操作，而非始于文件的当前偏移量处，且它们不会改变文件的当前偏移量。</p>
<p><img src="image-20230803181548445.png" alt="image-20230803181548445"></p>
<p>​        pread()调用等同于将如下调用纳入同一原子操作：对 pread()和 pwrite()而言，fd 所指代的文件必须是可定位的（即允许对文件描述符执行lseek()调用）。</p>
<p>​        多线程应用为这些系统调用提供了用武之地。正如第 29 章所述，进程下辖的所有线程将共享同一文件描述符表。这也意味着每个已打开文件的文件偏移量为所有线程所共享。当调用pread()或 pwrite()时，多个线程可同时对同一文件描述符执行 I/O 操作，且不会因其他线程修改文件偏移量而受到影响。如果还试图使用 lseek()和 read()(或 write())来代替 pread()（或pwrite()），那么将引发竞争状态，这类似于 5.1 节讨论 O_APPEND 标志时的描述（当多个进程的文件描述符指向相同的打开文件句柄时，使用 pread()和 pwrite()系统调用同样能够避免进程间出现竞争状态）。</p>
<pre class="line-numbers language-none"><code class="language-none">如果需要反复执行 lseek()，并伴之以文件 I&#x2F;O，那么 pread()和 pwrite()系统调用在某些情况下是具有性能优势的。这是因为执行单个 pread()（或 pwrite()）系统调用的成本要低于执行 lseek()和 read()（或 write()）两个系统调用。然而，较之于执行 I&#x2F;O 实际所需的时间，系统调用的开销就有些相形见绌了。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="分散输入和集中输出（Scatter-Gather-I-O）：readv-和-writev"><a href="#分散输入和集中输出（Scatter-Gather-I-O）：readv-和-writev" class="headerlink" title="分散输入和集中输出（Scatter-Gather I/O）：readv() 和 writev()"></a>分散输入和集中输出（Scatter-Gather I/O）：readv() 和 writev()</h2><p>​        readv()和 writev()系统调用分别实现了分散输入和集中输出的功能。</p>
<p><img src="image-20230803181750097.png" alt="image-20230803181750097"></p>
<p>​        这些系统调用并非只对单个缓冲区进行读写操作，而是一次即可传输多个缓冲区的数据。数组 iov 定义了一组用来传输数据的缓冲区。整型数 iovcnt 则指定了 iov 的成员个数。iov 中的每个成员都是如下形式的数据结构。</p>
<p><img src="image-20230803181801884.png" alt="image-20230803181801884"></p>
<pre class="line-numbers language-none"><code class="language-none">SUSv3 标准允许系统实现对 iov 中的成员个数加以限制。系统实现可以通过定义&lt;limits.h&gt;文件中 IOV_MAX 来通告这一限额，程序也可以在系统运行时调用 sysconf (_SC_ IOV_MAX)来获取这一限额。（11.2 节将介绍 sysconf()。）SUSv3 要求该限额不得少于 16。Linux将 IOV_MAX 的值定义为 1024，这是与内核对该向量大小的限制（由内核常量 UIO_MAXIOV定义）相对应的。然而，glibc 对 readv()和 writev()的封装函数1还悄悄做了些额外工作。若系统调用因iovcnt 参数值过大而失败，外壳函数将临时分配一块缓冲区，其大小足以容纳 iov 参数所有成员所描述的数据缓冲区，随后再执行 read()或 write()调用（参见后文对使用 write()实现writev()功能的讨论）。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>图 5-3 展示的是一个关于 iov、iovcnt 以及 iov 指向缓冲区之间关系的示例。</p>
<p><img src="image-20230803181844559.png" alt="image-20230803181844559"></p>
<h4 id="分散输入"><a href="#分散输入" class="headerlink" title="分散输入"></a>分散输入</h4><p>​        readv()系统调用实现了分散输入的功能：从文件描述符 fd 所指代的文件中读取一片连续的字节，然后将其散置（“分散放置”）于 iov 指定的缓冲区中。这一散置动作从 iov[0]开始，依次填满每个缓冲区。原子性是 readv()的重要属性。换言之，从调用进程的角度来看，当调用 readv()时，内核在 fd 所指代的文件与用户内存之间一次性地完成了数据转移。这意味着，假设即使有另一进程（或线程）与其共享同一文件偏移量，且在调用 readv()的同时企图修改文件偏移量，readv()所读取的数据仍将是连续的。调用 readv()成功将返回读取的字节数，若文件结束1将返回 0。调用者必须对返回值进行检查，以验证读取的字节数是否满足要求。若数据不足以填充所有缓冲区，则只会占用2部分缓冲区，其中最后一个缓冲区可能只存有部分数据。程序清单 5-2 展示了 readv()的用法。在本书中，当以函数名称冠以“t_”来命名示例程序时（例如：程序清单 5-2 中的程序t_readv.c），意在表明该程序主要用于展示单个系统调用或库函数的用法。程序清单 5-2：使用 readv()执行分散输入 _</p>
<p><img src="image-20230803181920503.png" alt="image-20230803181920503"></p>
<p><img src="image-20230803181925983.png" alt="image-20230803181925983"></p>
<h4 id="集中输出"><a href="#集中输出" class="headerlink" title="集中输出"></a>集中输出</h4><p>​        writev()系统调用实现了集中输出：将 iov 所指定的所有缓冲区中的数据拼接（“集中”）起来，然后以连续的字节序列写入文件描述符 fd 指代的文件中。对缓冲区中数据的“集中”始于iov[0]所指定的缓冲区，并按数组顺序展开。像 readv()调用一样，writev()调用也属于原子操作，即所有数据将一次性地从用户内存传输到 fd 指代的文件中。因此，在向普通文件写入数据时，writev()调用会把所有的请求数据连续写入文件，而不会在其他进程（或线程）写操作的影响下1分散地写入文件2。</p>
<p>​        如同 write()调用，writev()调用也可能存在部分写的问题。因此，必须检查 writev()调用的返回值，以确定写入的字节数是否与要求相符。</p>
<p>​        readv()调用和 writev()调用的主要优势在于便捷。如下两种方案，任选其一都可替代对writev()的调用。</p>
<ul>
<li>编码时，首先分配一个大缓冲区，随即再从进程地址空间的其他位置将数据复制过来，最后调用 write()输出其中的所有数据。</li>
<li>发起一系列 write()调用，逐一输出每个缓冲区中的数据。</li>
</ul>
<p>​        尽管方案一在语义上等同于 writev()调用，但需要在用户空间内分配缓冲区，进行数据复制，很不方便（效率也低）。方案二在语义上就不同于单次的 writev()调用，因为发起多次 write()调用将无法保证原子性。更何况，执行一次 writev()调用比执行多次 write()调用开销要小（参见 3.1 节关于系统调用的讨论）。</p>
<h4 id="在指定的文件偏移量处执行分散输入-集中输出"><a href="#在指定的文件偏移量处执行分散输入-集中输出" class="headerlink" title="在指定的文件偏移量处执行分散输入/集中输出"></a>在指定的文件偏移量处执行分散输入/集中输出</h4><p>​        Linux 2.6.30 版本新增了两个系统调用：preadv()、pwritev()，将分散输入/集中输出和于指定文件偏移量处的 I/O 二者集于一身。它们并非标准的系统调用，但获得了现代 BSD 的支持。 </p>
<p><img src="image-20230803182034792.png" alt="image-20230803182034792"></p>
<p>​        preadv()和 pwritev()系统调用所执行的任务与 readv()和 writev()相同，但执行 I/O 的位置将由 offset 参数指定（类似于 pread()和 pwrite()系统调用）1。对于那些既想从分散-集中 I/O 中受益，又不愿受制于当前文件偏移量的应用程序（比如，多线程的应用程序）而言，这些系统调用恰好可以派上用场。</p>
<h2 id="截断文件：truncate-和-ftruncate-系统调用"><a href="#截断文件：truncate-和-ftruncate-系统调用" class="headerlink" title="截断文件：truncate()和 ftruncate()系统调用"></a>截断文件：truncate()和 ftruncate()系统调用</h2><p>​        truncate()和 ftruncate()系统调用将文件大小设置为 length 参数指定的值。</p>
<p><img src="image-20230803183805730.png" alt="image-20230803183805730"></p>
<p>​        <strong>若文件当前长度大于参数 length，调用将丢弃超出部分，若小于参数 length，调用将在文件尾部添加一系列空字节或是一个文件空洞。</strong>两个系统调用之间的差别在于如何指定操作文件。truncate()以路径名字符串来指定文件，并要求可访问该文件2，且对文件拥有写权限。若文件名为符号链接，那么调用将对其进行解引用。而调用 ftruncate()之前，需以可写方式打开操作文件，获取其文件描述符以指代该文件，该系统调用不会修改文件偏移量。若 ftruncate()的 length 参数值超出文件的当前大小，SUSv3 允许两种行为：要<strong>么扩展该文件（如 Linux），要么返回错误。而符合 XSI 标准的系统则必须采取前一种行为。相同的情况，对于 truncate()系统调用，SUSv3 则要求总是能扩展文件。truncate()无需先以 open()（或是一些其他方法）来获取文件描述符，却可修改文件内容，在系统调用中可谓独树一帜。</strong></p>
<h2 id="非阻塞-I-O"><a href="#非阻塞-I-O" class="headerlink" title="非阻塞 I/O"></a>非阻塞 I/O</h2><p>​        在打开文件时指定 O_NONBLOCK 标志，目的有二。</p>
<ul>
<li>若 open()调用未能立即打开文件，则返回错误，而非陷入阻塞。有一种情况属于例外，调用 open()操作 FIFO 可能会陷入阻塞（参见 44.7 节）。</li>
<li>调用 open()成功后，后续的 I/O 操作也是非阻塞的。若 I/O 系统调用未能立即完成，则可能会只传输部分数据，或者系统调用失败，并返回 EAGAIN 或 EWOULDBLOCK 错误。具体返回何种错误将依赖于系统调用。Linux 系统与许多 UNIX 实现一样，将两个错误常量视为同义。</li>
</ul>
<p>​        管道、FIFO、套接字、设备（比如终端、伪终端）都支持非阻塞模式。（因为无法通过 open()来获取管道和套接字的文件描述符，所以要启用非阻塞标志，就必须使用 5.3 节所述 fcntl()的F_SETFL 命令。）正如 13.1 节所述，由于内核缓冲区保证了普通文件 I/O 不会陷入阻塞，故而打开普通文件时一般会忽略 O_NONBLOCK 标志。然而，当使用强制文件锁时（55.4 节），O_NONBLOCK标志对普通文件也是起作用的。更多关于非阻塞 I/O 的信息请参见 44.9 节和第 63 章。</p>
<pre class="line-numbers language-none"><code class="language-none">历史上，派生自 System V 的系统提供有 O_NDELAY 标志，语义上类似于 O_ NONBLOCK标志。二者主要的区别在于：在 System V 系统中，若非阻塞的 write()调用未能完成写操作，或者非阻塞的 read()调用无输入数据可读时，则两个调用将返回 0。这对于 read()调用来说会有问题，因为程序将无法区分返回 0 的 read()到底是没有可用的输入数据，还是遇到了文件结尾1。故而 POSIX.1 标准在初版中引入了 O_NONBLOCLK 标志。有些UNIX 实现一直还在支持旧语义的 O_NDELAY 标志。Linux 系统虽然也定义了 O_NDELAY常量，但其与 O_NONBLOCK 标志同义。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="5-10-大文件-I-O"><a href="#5-10-大文件-I-O" class="headerlink" title="5.10 大文件 I/O"></a>5.10 大文件 I/O</h2><p>​        通常将存放文件偏移量的数据类型 off_t 实现为一个有符号的长整型。（之所以采用有符号数据类型，是要以−1 来表示错误情况。）在 32 位体系架构中（比如 x86-32），这将文件大小置于 $2^{31}−1 $个字节（即 2GB）的限制之下。</p>
<p>​        然而，磁盘驱动器的容量早已超出这一限制，因此 32 位 UNIX 实现有处理超过 2GB 大小文件的需求，这也在情理之中。由于问题较为普遍，UNIX 厂商联盟在大型文件峰会（Large File Summit）上就此进行了协商，并针对必需的大文件访问功能，形成了对 SUSv2 规范的扩展。</p>
<p>​        始于内核版本 2.4，32 位 Linux 系统开始提供对 LFS 的支持（glibc 版本必须为 2.2 或更高）。另一个前提是，相应的文件系统也必须支持大文件操作。大多数“原生”Linux 文件系统提供了 LFS 支持，但一些“非原生”文件系统则未提供该功能（微软的 VFAT 和 NFSv2 系统是其中较为知名的范例，无论系统是否启用了 LFS 扩展功能，2GB 的文件大小限制都是硬杠杠）。</p>
<pre class="line-numbers language-none"><code class="language-none">由于 64 位系统架构（例如，Alpha、IA-64）的长整型类型长度为 64 位，故而 LFS 增强特性所要突破的限制对其而言并不是问题。然而，即便在64 位系统中，一些“原生”Linux 文件系统的实现细节还是将文件大小的理论值默认为不会超过 2^63−1 个字节。在大多数情况下，此限额远远超出了目前的磁盘容量，故而这一对文件大小的限制并无实际意义。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        应用程序可使用如下两种方式之一以获得 LFS 功能。</p>
<ul>
<li>使用支持大文件操作的备选 API。该 API 由 LFS 设计，意在作为 SUS 规范的“过渡型扩展”。因此，尽管大部分系统都支持这一 API，但这对于符合 SUSv2 或 SUSv3 规范的系统其实并非必须。这一方法现已过时。</li>
<li>在编译应用程序时，将宏_FILE_OFFSET_BITS 的值定义为 64。这一方法更为可取，因为符合 SUS 规范的应用程序无需修改任何源码即可获得 LFS 功能。</li>
</ul>
<h4 id="过渡型-LFS-API"><a href="#过渡型-LFS-API" class="headerlink" title="过渡型 LFS API"></a>过渡型 LFS API</h4><p>​        要使用过渡型的 LFS API，必须在编译程序时定义_LARGEFILE64_SOURCE 功能测试宏，该定义可以通过命令行指定，也可以定义于源文件中包含所有头文件之前的位置。该 API 所属函数具有处理 64 位文件大小和文件偏移量的能力。这些函数与其 32 位版本命名相同，只是尾部缀以 64 以示区别。其中包括：fopen64()、open64()、lseek64()、truncate64()、stat64()、mmap64()和 setrlimit64()。（针对这些函数的 32 位版本，本书前面已然讨论了一部分，还有一些将在后续章节中描述。）要访问大文件，可以使用这些函数的 64 位版本。例如，打开大文件的编码示例如下：调用 open64()，相当于在调用 open()时指定 O_LARGEFILE 标志。</p>
<p><img src="image-20230803184224033.png" alt="image-20230803184224033"></p>
<p>​        若调用 open()时未指定此标志，且欲打开的文件大小大于 2GB，那么调用将返回错误。另外，除去上述提及的函数之外，过渡型 LFS API 还增加了一些新的数据类型，如下所示 </p>
<p>struct stat64：类似于 stat 结构（参见 15.1 节），支持大文件尺寸。</p>
<p>off64_t：64 位类型，用于表示文件偏移量。</p>
<p>​        如程序清单 5-3 所示，除去使用了该 API 中的其他 64 位函数之外，lseek64()就用到了数据类型 off64_t。该程序接受两个命令行参数：欲打开的文件名称和给定的文件偏移量（整型）值。程序首先打开指定的文件，然后检索至给定的文件偏移量处，随即写入一串字符。如下所示的 shell会话中，程序检索到一个超大的文件偏移量处（超过 10GB），再写入一些字节：</p>
<p><img src="image-20230803184308492.png" alt="image-20230803184308492"></p>
<p>​        程序清单 5-3：访问大文件 </p>
<p><img src="image-20230803184333790.png" alt="image-20230803184333790"></p>
<p><img src="image-20230803184344338.png" alt="image-20230803184344338"></p>
<h4 id="FILE-OFFSET-BITS-宏"><a href="#FILE-OFFSET-BITS-宏" class="headerlink" title="_FILE_OFFSET_BITS 宏"></a>_FILE_OFFSET_BITS 宏</h4><p>​        要获取 LFS 功能，推荐的作法是：在编译程序时，将宏_FILE_OFFSET_BITS 的值定义为64。做法之一是利用 C 语言编译器的命令行选项：</p>
<p><img src="image-20230803184359092.png" alt="image-20230803184359092"></p>
<p>另外一种方法，是在 C 语言的源文件中，在包含所有头文件之前添加如下宏定义：</p>
<p><img src="image-20230803184405206.png" alt="image-20230803184405206"></p>
<p>​        所有相关的 32 位函数和数据类型将自动转换为 64 位版本。因而，例如，实际会将 open()转换为 open64()，数据类型 off_t 的长度也将转而定义为 64 位。换言之，无需对源码进行任何修改，只要对已有程序进行重新编译，就能够实现大文件操作。</p>
<p>​        显然，使用宏_FILE_OFFSET_BITS 要比采用过渡型的 LFS API 更为简单，但这也要求应用程序的代码编写必须规范（例如，声明用于放置文件偏移量的变量，应正确地使用 off_t，而不能使用“原生”的 C 语言整型）。</p>
<p>​        LFS 规范对于支持_FILE_OFFSET_BITS 宏未作硬性规定，仅仅提及将该宏作为指定数据类型 off_t 大小的可选方案。一些 UNIX 实现使用不同的特性测试宏来获取此功能。</p>
<pre class="line-numbers language-none"><code class="language-none">若试图使用 32 位函数访问大文件（即在编译程序时，未将宏_FILE_OFFSET_BITS 的值设置为 64），调用可能会返回 EOVERFLOW 错误。例如，为获取大小超过 2G 文件的信息，若使用 stat 的 32 位版本时就会遇到这一错误。_<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="向-printf-调用传递-off-t-值"><a href="#向-printf-调用传递-off-t-值" class="headerlink" title="向 printf()调用传递 off_t 值"></a>向 printf()调用传递 off_t 值</h4><p>​        LFS 扩展功能没有解决的问题之一是，如何向 printf()调用传递 off_t 值。3.6.2 节曾特别指出，对于预定义的系统数据类型（诸如 pid_t、uid_t），展示其值的可移植方法是将该值强制转换为 long 型，并在 printf()中使用限定符%ld。然而，一旦使用了 LFS 扩展功能，%ld 将不足以处理 off_t 数据类型，因为对该数据类型的定义可能会超出 long 类型的范围，一般为 long long类型。据此，若要显示 off_t 类型的值，则先要将其强制转换为 long long 类型，然后使用 printf()函数的%lld 限定符显示，如下所示：</p>
<p><img src="image-20230803184515230.png" alt="image-20230803184515230"></p>
<p>​        在处理 stat 结构所使用的 blkcnt_t 数据类型时，也应予以类似关注（参见 15.1 节的描述）。如需在独立的编译模块之间传递 off_t 或 stat 类型的参数值，则需确保在所有模块中，这些数据类型的大小相同（即编译这些模块时，要么将宏_FILE_OFFSET_BITS 的值都定义为 64，要么都不做定义）。</p>
<h2 id="dev-fd-目录"><a href="#dev-fd-目录" class="headerlink" title="/dev/fd 目录"></a>/dev/fd 目录</h2><p>​        对于每个进程，内核都提供有一个特殊的虚拟目录/dev/fd。该目录中包含“/dev/fd/n”形式的文件名，其中 n 是与进程中的打开文件描述符相对应的编号。因此，例如，/dev/fd/0 就对应于进程的标准输入。（SUSv3 对/dev/fd 特性未做规定，但有些其他的 UNIX 实现也提供了这一特性。）</p>
<p>​        打开/dev/fd 目录中的一个文件等同于复制相应的文件描述符，所以下列两行代码是等价的：</p>
<p><img src="image-20230803184537756.png" alt="image-20230803184537756"></p>
<p>​        在为 open()调用设置 flag 参数时，需要注意将其设置为与原描述符相同的访问模式。这一场景下，在 flag 标志的设置中引入其他标志，诸如 O_CREAT，是毫无意义的（系统会将其忽略）。</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;dev&#x2F;fd 实际上是一个符号链接，链接到 Linux 所专有的&#x2F;proc&#x2F;self&#x2F;fd 目录。后者又是 Linux特有的&#x2F;proc&#x2F;PID&#x2F;fd 目录族的特例之一，此目录族中的每一目录都包含有符号链接，与一进程所打开的所有文件相对应。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        程序中很少会使用/dev/fd 目录中的文件。其主要用途在 shell 中。许多用户级 shell 命令将文件名作为参数，有时需要将命令输出至管道，并将某个参数替换为标准输入或标准输出。出于这一目的，有些命令（例如，diff、ed、tar 和 comm）提供了一个解决方法，使用“-”符号作为命令的参数之一，用以表示标准输入或输出（视情况而定）。所以，要比较 ls 命令输出的文件名列表与之前生成的文件名列表，命令就可以写成：</p>
<pre class="line-numbers language-none"><code class="language-none">ls | diff - oldfilelist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这种方法有不少问题。首先，该方法要求每个程序都对“-”符号做专门处理，但是许多程序并未实现这样的功能，这些命令只能处理文件，不支持将标准输入或输出作为参数。</p>
<p>​        其次，有些程序还将单个“-”符解释为表征命令行选项结束的分隔符。使用/dev/fd 目录，上述问题将迎刃而解，可以把标准输入、标准输出和标准错误作为文件名参数传递给任何需要它们的程序。所以，可以将前一个 shell 命令改写成如下形式：</p>
<pre class="line-numbers language-none"><code class="language-none">ls | diff &#x2F;dev&#x2F;fd&#x2F;0 oldfilelist<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        方便起见，系统还提供了 3 个符号链接：/dev/stdin、/dev/stdout 和/dev/stderr，分别链接到/dev/fd/0、/dev/fd/1 和/dev/fd/2。</p>
<h2 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h2><p>​        有些程序需要创建一些临时文件，仅供其在运行期间使用，程序终止后即行删除。例如，很多编译器程序会在编译过程中创建临时文件。GNU C 语言函数库为此而提供了一系列库函数。（之所以有“一系列”的库函数，部分原因是由于这些函数分别继承自各种 UNIX 实现。）本节将介绍其中的两个函数：mkstemp()和 tmpfile()。</p>
<p>​        <strong>基于调用者提供的模板，mkstemp()函数生成一个唯一文件名并打开该文件，返回一个可用于 I/O 调用的文件描述符。</strong></p>
<p><img src="image-20230803184721401.png" alt="image-20230803184721401"></p>
<p>​        模板参数采用路径名形式，其中最后 6 个字符必须为 XXXXXX。这 6 个字符将被替换，以保证文件名的唯一性，且修改后的字符串将通过 template 参数传回。因为会对传入的 template参数进行修改，所以必须将其指定为字符数组，而非字符串常量。</p>
<p>​        文件拥有者对 mkstemp()函数建立的文件拥有读写权限（其他用户则没有任何操作权限），且打开文件时使用了 O_EXCL 标志，以保证调用者以独占方式访问文件。</p>
<p>​        通常，打开临时文件不久，程序就会使用 unlink 系统调用（参见 18.3 节）将其删除。故而，mkstemp()函数的示例代码如下所示：</p>
<p><img src="image-20230803184801020.png" alt="image-20230803184801020"></p>
<p>​        使用 tmpnam()、tempnam()和 mktemp()函数也能生成唯一的文件名。然而，由于这会导致应用程序出现安全漏洞，应当避免使用这些函数。关于这些函数的进一步细节请参考手册页。tmpfile()函数会创建一个名称唯一的临时文件，并以读写方式将其打开。（打开该文件时使用了 O_EXCL 标志，以防一个可能性极小的冲突，即另一个进程已经创建了一个同名文件。）tmpfile()函数执行成功，将返回一个文件流供 stdio 库函数使用。文件流关闭后将自动删除临时文件。为达到这一目的，tmpfile()函数会在打开文件后，从内部立即调用 unlink()来删除该文件名1。 1 译者注：进程终止时会关闭所有打开的文件描述符，关闭文件就会删除这些临时文件（参考 mkstmp 代码示例中的注释），由此可以推导出，进程退出时将自动删除临时文件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        本章介绍了原子操作的概念，这对于一些系统调用的正确操作至关重要。特别是，指定O_EXCL 标志调用 open()，这确保了调用者就是文件的创建者。而指定 O_APPEND 标志来调用 open()，还确保了多个进程在对同一文件追加数据时不会覆盖彼此的输出。系统调用 fcntl()可以执行许多文件控制操作，其中包括：修改打开文件的状态标志、复制文件描述符。使用 dup()和 dup2()系统调用也能实现文件描述符的复制功能。本章接着研究了文件描述符、打开文件句柄和文件 i-node 之间的关系，并特别指出这 3个对象各自包含的不同信息。文件描述符及其副本指向同一个打开文件句柄，所以也将共享打开文件的状态标志和文件偏移量。之后描述的诸多系统调用，是对常规 read()和 write()系统调用的功能扩展。pread()和pwrite()系统调用可在文件的指定位置处执行 I/O 功能，且不会修改文件偏移量。readv()和writev()系统调用实现了分散输入和集中输出的功能。preadv()和 pwritev()系统调用则集上述两对系统调用的功能于一身。使用 truncate() 和 ftruncate()系统调用，既可以丢弃多余的字节以缩小文件大小，又能使用填充为 0 的文件空洞来增加文件大小。本章还简单介绍了非阻塞 I/O 的概念，后续章节中还将继续讨论。LFS 规范定义了一套扩展功能，允许在 32 位系统中运行的进程来操作无法以 32 位表示的大文件。运用虚拟目录/dev/fd 中的编号文件，进程就可以通过文件描述符编号来访问自己打开的文件，这在 shell 命令中尤其有用。mkstemp()和 tmpfile()函数允许应用程序去创建临时文件。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/">http://charliechen114514.github.io/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C-Linux/">C/C++. Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/19/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA%E4%B8%8E%E4%B8%89%E7%A7%8D%E5%8D%8F%E8%AE%AE/" title="Unix网络编程——导论与三种协议"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unix网络编程——导论与三种协议</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/17/Unix-network-programming-Guidance/" title="Unix网络编程 - 1"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unix网络编程 - 1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/30/Linux%E6%BC%AB%E6%B8%B8-%E6%9B%B4%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%9A%84%E6%96%87%E4%BB%B6IO/" title="Linux漫游 更深层次的文件IO"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">Linux漫游 更深层次的文件IO</div></div></a></div><div><a href="/2023/08/15/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA/" title="Linux漫游——导论"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-15</div><div class="title">Linux漫游——导论</div></div></a></div><div><a href="/2023/08/16/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="Linux漫游——系统调用"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-16</div><div class="title">Linux漫游——系统调用</div></div></a></div><div><a href="/2023/08/30/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E4%B8%8E%E7%B3%BB%E7%BB%9F%E9%99%90%E5%88%B6/" title="Linux漫游——时间与系统限制"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">Linux漫游——时间与系统限制</div></div></a></div><div><a href="/2023/08/30/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%87%AD%E8%AF%81/" title="Linux漫游——用户与组，进程凭证"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">Linux漫游——用户与组，进程凭证</div></div></a></div><div><a href="/2023/08/30/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/" title="Linux漫游——进程"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">Linux漫游——进程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E6%BC%AB%E6%B8%B8-%E6%96%87%E4%BB%B6-I-O%EF%BC%9A%E9%80%9A%E7%94%A8%E7%9A%84-I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">Linux漫游- 文件 I&#x2F;O：通用的 I&#x2F;O 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E4%B8%BB%E6%B5%81%E7%9A%84IO%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">四个主流的IO操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#open"><span class="toc-number">1.3.</span> <span class="toc-text">open</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#open-%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84-flags-%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">open()调用中的 flags 参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#O-APPEND"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">O_APPEND</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-ASYNC"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">O_ASYNC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-CLOEXEC%EF%BC%88%E8%87%AA-Linux-2-6-23-%E7%89%88%E6%9C%AC%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81%EF%BC%89"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">O_CLOEXEC（自 Linux 2.6.23 版本开始支持）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-CREAT"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">O_CREAT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-DIRECT"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">O_DIRECT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-DIRECTORY"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">O_DIRECTORY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-DSYNC%EF%BC%88%E8%87%AA-Linux-2-6-33-%E7%89%88%E6%9C%AC%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81%EF%BC%89"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">O_DSYNC（自 Linux 2.6.33 版本开始支持）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-EXCL"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">O_EXCL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-LARGEFILE"><span class="toc-number">1.3.1.9.</span> <span class="toc-text">O_LARGEFILE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-NOATIME%EF%BC%88%E8%87%AA-Linux-2-6-8-%E7%89%88%E6%9C%AC%E5%BC%80%E5%A7%8B%EF%BC%89"><span class="toc-number">1.3.1.10.</span> <span class="toc-text">O_NOATIME（自 Linux 2.6.8 版本开始）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-NOCTTY"><span class="toc-number">1.3.1.11.</span> <span class="toc-text">O_NOCTTY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-NOFOLLOW"><span class="toc-number">1.3.1.12.</span> <span class="toc-text">O_NOFOLLOW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-NONBLOCK"><span class="toc-number">1.3.1.13.</span> <span class="toc-text">O_NONBLOCK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-SYNC"><span class="toc-number">1.3.1.14.</span> <span class="toc-text">O_SYNC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-TRUNC"><span class="toc-number">1.3.1.15.</span> <span class="toc-text">O_TRUNC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#open%E5%8F%AF%E8%83%BD%E6%8A%9B%E5%87%BA%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.2.</span> <span class="toc-text">open可能抛出的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EACCES"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">EACCES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EISDIR"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">EISDIR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EMFILE"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">EMFILE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ENOENT"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">ENOENT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EROFS"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">EROFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ETXTBSY"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">ETXTBSY</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">read读文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">write写文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#close-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">close() 关闭文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lseek-%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">1.7.</span> <span class="toc-text">lseek()改变文件偏移量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%A9%BA%E6%B4%9E"><span class="toc-number">1.7.1.</span> <span class="toc-text">文件空洞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">4.9 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E4%BC%A0%E7%BB%9F%E7%9A%84-System-Call-I-O"><span class="toc-number">2.</span> <span class="toc-text">扩展：传统的 System Call I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">读操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">写操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-I-O"><span class="toc-number">2.3.</span> <span class="toc-text">网络 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98-I-O"><span class="toc-number">2.4.</span> <span class="toc-text">磁盘 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84-I-O"><span class="toc-number">2.5.</span> <span class="toc-text">高性能优化的 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E7%9A%84-I-O-%E6%A0%88"><span class="toc-number">2.6.</span> <span class="toc-text">存储设备的 I&#x2F;O 栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-IO%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.7.</span> <span class="toc-text">Linux IO系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-Buffering"><span class="toc-number">2.8.</span> <span class="toc-text">I&#x2F;O Buffering</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6%E6%96%87%E4%BB%B6IO"><span class="toc-number">3.</span> <span class="toc-text">深入探究文件IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8C%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">原子操作和竞争条件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90-%E4%BB%A5%E7%8B%AC%E5%8D%A0%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">举个例子:以独占方式创建一个文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90-%E5%90%91%E6%96%87%E4%BB%B6%E5%B0%BE%E9%83%A8%E8%BF%BD%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">3.1.2.</span> <span class="toc-text">再举个例子:向文件尾部追加数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E6%93%8D%E4%BD%9C%EF%BC%9Afcntl"><span class="toc-number">3.2.</span> <span class="toc-text">文件控制操作：fcntl()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97"><span class="toc-number">3.3.</span> <span class="toc-text">打开文件的状态标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.4.</span> <span class="toc-text">文件描述符和打开文件之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.5.</span> <span class="toc-text">复制文件描述符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%96%87%E4%BB%B6%E7%89%B9%E5%AE%9A%E5%81%8F%E7%A7%BB%E9%87%8F%E5%A4%84%E7%9A%84-I-O%EF%BC%9Apread-%E5%92%8C-pwrite"><span class="toc-number">3.6.</span> <span class="toc-text">在文件特定偏移量处的 I&#x2F;O：pread()和 pwrite()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E8%BE%93%E5%85%A5%E5%92%8C%E9%9B%86%E4%B8%AD%E8%BE%93%E5%87%BA%EF%BC%88Scatter-Gather-I-O%EF%BC%89%EF%BC%9Areadv-%E5%92%8C-writev"><span class="toc-number">3.7.</span> <span class="toc-text">分散输入和集中输出（Scatter-Gather I&#x2F;O）：readv() 和 writev()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%95%A3%E8%BE%93%E5%85%A5"><span class="toc-number">3.7.0.1.</span> <span class="toc-text">分散输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E8%BE%93%E5%87%BA"><span class="toc-number">3.7.0.2.</span> <span class="toc-text">集中输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F%E5%A4%84%E6%89%A7%E8%A1%8C%E5%88%86%E6%95%A3%E8%BE%93%E5%85%A5-%E9%9B%86%E4%B8%AD%E8%BE%93%E5%87%BA"><span class="toc-number">3.7.0.3.</span> <span class="toc-text">在指定的文件偏移量处执行分散输入&#x2F;集中输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%AA%E6%96%AD%E6%96%87%E4%BB%B6%EF%BC%9Atruncate-%E5%92%8C-ftruncate-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.8.</span> <span class="toc-text">截断文件：truncate()和 ftruncate()系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E-I-O"><span class="toc-number">3.9.</span> <span class="toc-text">非阻塞 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10-%E5%A4%A7%E6%96%87%E4%BB%B6-I-O"><span class="toc-number">3.10.</span> <span class="toc-text">5.10 大文件 I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1%E5%9E%8B-LFS-API"><span class="toc-number">3.10.0.1.</span> <span class="toc-text">过渡型 LFS API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FILE-OFFSET-BITS-%E5%AE%8F"><span class="toc-number">3.10.0.2.</span> <span class="toc-text">_FILE_OFFSET_BITS 宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91-printf-%E8%B0%83%E7%94%A8%E4%BC%A0%E9%80%92-off-t-%E5%80%BC"><span class="toc-number">3.10.0.3.</span> <span class="toc-text">向 printf()调用传递 off_t 值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dev-fd-%E7%9B%AE%E5%BD%95"><span class="toc-number">3.11.</span> <span class="toc-text">&#x2F;dev&#x2F;fd 目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-number">3.12.</span> <span class="toc-text">创建临时文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.13.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/04/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/" title="重新学习Linux系统编程 1"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="重新学习Linux系统编程 1"/></a><div class="content"><a class="title" href="/2024/01/04/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-1/" title="重新学习Linux系统编程 1">重新学习Linux系统编程 1</a><time datetime="2024-01-04T11:51:35.000Z" title="发表于 2024-01-04 19:51:35">2024-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B04-Prototype/" title="设计模式小记4 Prototype"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式小记4 Prototype"/></a><div class="content"><a class="title" href="/2024/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B04-Prototype/" title="设计模式小记4 Prototype">设计模式小记4 Prototype</a><time datetime="2024-01-04T02:56:34.000Z" title="发表于 2024-01-04 10:56:34">2024-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B03-Factory-Mode/" title="设计模式小记3 Factory_Mode"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式小记3 Factory_Mode"/></a><div class="content"><a class="title" href="/2024/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B03-Factory-Mode/" title="设计模式小记3 Factory_Mode">设计模式小记3 Factory_Mode</a><time datetime="2024-01-04T02:56:23.000Z" title="发表于 2024-01-04 10:56:23">2024-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/02/CMake%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0-2/" title="CMake使用小记 2"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMake使用小记 2"/></a><div class="content"><a class="title" href="/2024/01/02/CMake%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0-2/" title="CMake使用小记 2">CMake使用小记 2</a><time datetime="2024-01-02T10:40:41.000Z" title="发表于 2024-01-02 18:40:41">2024-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B02-Builder/" title="设计模式小记2 Builder"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式小记2 Builder"/></a><div class="content"><a class="title" href="/2024/01/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B02-Builder/" title="设计模式小记2 Builder">设计模式小记2 Builder</a><time datetime="2024-01-02T08:43:18.000Z" title="发表于 2024-01-02 16:43:18">2024-01-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>