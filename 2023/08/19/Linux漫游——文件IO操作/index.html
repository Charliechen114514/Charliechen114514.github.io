<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Linux漫游——文件IO操作 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux漫游- 文件 I&#x2F;O：通用的 I&#x2F;O 模型概述​        我们下面开始正式的开启Linux系统编程之路。我们首先解决一个问题——那就是我们如何对文件进行IO操作呢？本章就是解决这个问题的。Unix-Linux由一套通用的IO操作方法，这让我们可以通用的视一切为文件进行操作 ​        首先，我们需要拿到文件——在系统编程中，我们以文件描述符来代表文件。有三个文件描述符，总是被">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux漫游——文件IO操作">
<meta property="og:url" content="http://charliechen114514.github.io/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="Linux漫游- 文件 I&#x2F;O：通用的 I&#x2F;O 模型概述​        我们下面开始正式的开启Linux系统编程之路。我们首先解决一个问题——那就是我们如何对文件进行IO操作呢？本章就是解决这个问题的。Unix-Linux由一套通用的IO操作方法，这让我们可以通用的视一切为文件进行操作 ​        首先，我们需要拿到文件——在系统编程中，我们以文件描述符来代表文件。有三个文件描述符，总是被">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-08-19T03:07:37.000Z">
<meta property="article:modified_time" content="2023-08-19T03:08:24.260Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++. Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux漫游——文件IO操作',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-19 11:08:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux漫游——文件IO操作</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-19T03:07:37.000Z" title="发表于 2023-08-19 11:07:37">2023-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-19T03:08:24.260Z" title="更新于 2023-08-19 11:08:24">2023-08-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux漫游——文件IO操作"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux漫游-文件-I-O：通用的-I-O-模型"><a href="#Linux漫游-文件-I-O：通用的-I-O-模型" class="headerlink" title="Linux漫游- 文件 I/O：通用的 I/O 模型"></a>Linux漫游- 文件 I/O：通用的 I/O 模型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        我们下面开始正式的开启Linux系统编程之路。我们首先解决一个问题——那就是我们如何对文件进行IO操作呢？本章就是解决这个问题的。Unix-Linux由一套通用的IO操作方法，这让我们可以通用的视一切为文件进行操作</p>
<p>​        首先，我们需要拿到文件——在系统编程中，我们以<strong>文件描述符</strong>来代表文件。有三个文件描述符，总是被分配且有自己特殊的含义的。那就是标准IO流</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>用途</th>
<th>POSIX名称</th>
<th>stdio流</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>标准输入</td>
<td><code>STDIN_FILENO</code></td>
<td><code>stdin</code></td>
</tr>
<tr>
<td>1</td>
<td>标准输出</td>
<td><code>STDOUT_FILENO</code></td>
<td><code>stdout</code></td>
</tr>
<tr>
<td>2</td>
<td>标准错误</td>
<td><code>STDERR_FILENO</code></td>
<td><code>stderr</code></td>
</tr>
</tbody>
</table>
</div>
<p>​        在程序中指代这些文件描述符时，可以使用数字（0、1、2）表示，或者采用<unistd.h>所定义的 POSIX 标准名称—此方法更为可取。</p>
<p>​        虽然 stdin、stdout 和 stderr 变量在程序初始化时用于指代进程的标准输入、标准输出和标准错误，但是调用 freopen()库函数可以使这些变量指代其他任何文件对象。作为其操作的一部分，freopen()可以在将流（stream）重新打开之际一并更换隐匿其中的文件描述符。换言之，针对 stdout 调用 freopen()函数后，无法保证 stdout 变量值仍然为 1。（不建议使用具体的数字而是预定义变量！）</p>
<h2 id="四个主流的IO操作"><a href="#四个主流的IO操作" class="headerlink" title="四个主流的IO操作"></a>四个主流的IO操作</h2><p>​        我们操作文件，首先就是——拿到文件（open），读文件（read），写文件(write)，把文件关了（是不是很像你编写word文档那样？）</p>
<ul>
<li>fd = open(pathname, flags, mode) 函数打开 pathname 所标识的文件，并返回文件描述符，用以在后续函数调用中指代打开的文件。<strong>如果文件不存在，open()函数可以创建之，这取决于对位掩码参数 flags 的设置。</strong>flags 参数还可指定文件的打开方式：<strong>只读、只写亦或是读写方式。mode 参数则指定了由 open()调用创建文件的访问权限，如果 open()函数并未创建文件，那么可以忽略或省略 mode 参数。</strong></li>
<li>numread = read(fd, buffer, count) 调用从 fd 所指代的打开文件中读取至多 count 字节的数据，并存储到 buffer 中。read()调用的返回值为实际读取到的字节数。如果再无字节可读（例如：读到文件结尾符 EOF 时），则返回值为 0。</li>
<li>numwritten = write(fd, buffer, count) 调用从 buffer 中读取多达 count 字节的数据写入由fd 所指代的已打开文件中。write()调用的返回值为实际写入文件中的字节数，且有可能小于 count。</li>
<li>status = close(fd)在所有输入/输出操作完成后，调用 close()，释放文件描述符 fd 以及与之相关的内核资源。</li>
</ul>
<p>​        可以使用这些操作完成一个简单的cp程序</p>
<p><img src="image-20230803170335161.png" alt="image-20230803170335161"></p>
<p><img src="image-20230803170341322.png" alt="image-20230803170341322"></p>
<h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p>​        open()调用既能打开一个业已存在的文件，也能创建并打开一个新文件。</p>
<pre class="line-numbers language-none"><code class="language-none">extern int open (const char *__file, int __oflag, ...) __nonnull ((1));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        要打开的文件由参数 pathname 来标识。<strong>如果 pathname 是一符号链接，会对其进行解引用。如果调用成功，open()将返回一文件描述符，用于在后续函数调用中指代该文件。</strong>若发生错误，则返回−1，并将 errno 置为相应的错误标志。参数 flags 为位掩码，用于指定文件的访问模式</p>
<pre class="line-numbers language-none"><code class="language-none">早期的 UNIX 实现中使用数字 0、1、2，而非表 4-2 中所列的常量名称。大多数现代UNIX 实现将这些常量定义为上述相应数字（以期与早期系统保持兼容）。由此可见，O_RDWR 并不等同于 O_RDONLY | O_WRONLY，后者（或组合）属于逻辑错误。(请务必注意！！！)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当调用 open()创建新文件时，位掩码参数 mode 指定了文件的访问权限。（SUSv3 规定，mode的数据类型 mode_t 属于整数类型。）</p>
<p>​        如果 open()并未指定 O_CREAT 标志，则可以省略 mode 参数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>访问模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code></td>
<td>只读方式打开文件</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td>只写方式打开文件</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td>以读写方式打开文件</td>
</tr>
</tbody>
</table>
</div>
<p><img src="image-20230803170532396.png" alt="image-20230803170532396"></p>
<p>​        如果调用 open()成功，必须保证其返回值为进程未用文件描述符中数值最小者。可以利用该特性以特定文件描述符打开某一文件。例如，如下代码序列就会确保使用标准输入（文件描述符 0）打开一文件。</p>
<p><img src="image-20230803170606375.png" alt="image-20230803170606375"></p>
<p>​        由于文件描述符 0 未用，所以 open()调用势必使用此描述符打开文件。5.5 节中所论及的dup2()和 fcntl()也可实现类似功能，但对于文件描述符的控制更加灵活。</p>
<h3 id="open-调用中的-flags-参数"><a href="#open-调用中的-flags-参数" class="headerlink" title="open()调用中的 flags 参数"></a>open()调用中的 flags 参数</h3><p>对于<code>flags</code>:</p>
<ul>
<li>文件访问模式标志：先前描述的 O_RDONLY、O_WRONLY 和 O_RDWR 标志均在此列，调用 open()时，上述三者在 flags 参数中不能同时使用，只能指定其中一种。调用fcntl()的 F_GETFL 操作能够检索文件的访问模式（见 5.3 节）。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参  数</th>
<th>说  明</th>
<th>参  数</th>
<th>说  明</th>
</tr>
</thead>
<tbody>
<tr>
<td>O_RDONLY</td>
<td>以只读方式打开文件</td>
<td>O_RDWR</td>
<td>以可读写方式打开文件</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>以只写方式打开文件</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>文件创建标志：这些标志在表 4-3 中位于第二部分，其控制范围不拘于 open()调用行为的方方面面，还涉及后续 I/O 操作的各个选项。这些标志不能检索，也无法修改。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参  数</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_CLOEXEC</code></td>
<td>设置close-on-exec标志</td>
</tr>
<tr>
<td><code>O_CREAT</code></td>
<td>若路径中的文件不存在则自动建立该文件</td>
</tr>
<tr>
<td><code>O_DIRECT</code></td>
<td>无缓冲的输入输出</td>
</tr>
<tr>
<td><code>O_DIRECTORY</code></td>
<td>如果pathname不是目录则会失败</td>
</tr>
<tr>
<td><code>O_EXCL</code></td>
<td>如果与O_CREAT同时设置，此指令会去检查文件是否存在，文件若不存在则建立该文件，否则将导致打开文件错误。此外，若O_CREAT与O_EXCL同时设置，并且将要打开的文件为符号连接，则将导致打开文件失败</td>
</tr>
<tr>
<td><code>O_LARGEFILE</code></td>
<td>在32位系统上用之打开大文件</td>
</tr>
<tr>
<td><code>O_NOATIME</code></td>
<td>调用read时候不修改文件最近的访问时间</td>
</tr>
<tr>
<td><code>O_NOCTTY</code></td>
<td>不要让pathname（所指向的终端设备）成为控制终端</td>
</tr>
<tr>
<td><code>O_NOFOLLOW</code></td>
<td>对链接符号不予解引用</td>
</tr>
<tr>
<td><code>O_TRUNC</code></td>
<td>若文件存在并且以可写的方式打开时，此标志会将文件长度清为0，而原来存于该文件的资料也会消失</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>已打开文件的状态标志：这些标志是表 4-3 中的剩余部分，使用 fcntl()的 F_GETFL 和F_SETFL 操作可以分别检索和修改此类标志。有时干脆将其称之为<strong>文件状态标志</strong>。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参  数</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_APPEND</code></td>
<td>读写文件从文件尾部开始移动，所写入的数据追加到文件尾</td>
</tr>
<tr>
<td><code>O_ASYNC</code></td>
<td>当IO操作可行时，产生信号通知进程</td>
</tr>
<tr>
<td><code>O_DSYNC</code></td>
<td>提供同步的IO数据完整性</td>
</tr>
<tr>
<td><code>O_NONBLOCK</code></td>
<td>以非阻塞的方式打开</td>
</tr>
<tr>
<td><code>O_SYNC</code></td>
<td>以同步方式写入文件</td>
</tr>
</tbody>
</table>
</div>
<h4 id="O-APPEND"><a href="#O-APPEND" class="headerlink" title="O_APPEND"></a>O_APPEND</h4><p>​        总是在文件尾部追加数据，5.1 节将讨论此标志的意义。</p>
<h4 id="O-ASYNC"><a href="#O-ASYNC" class="headerlink" title="O_ASYNC"></a>O_ASYNC</h4><p>​        当对于 open()调用所返回的文件描述符可以实施 I/O 操作时，系统会产生一个信号通知进程。这一特性，也被称为信号驱动 I/O，仅对特定类型的文件有效，诸如终端、FIFOS 及 socket。（在 SUSv3 中并未规定 O_ASYNC 标志，但大多数 UNIX 实现都支持此标志或者老版本中与其等效的 FASYNC 标志。）在 Linux 中，调用 open()时指定 O_ASYNC 标志没有任何实质效果。要启用信号驱动 I/O 特性，必须调用 fcntl()的 F_SETFL 操作来设置 O_ASYNC 标志（见 5.3 节）。（其他一些 UNIX 系统的实现有类似行为。）关于 O_ASYNC 标志的更多内容请参考 63.3 节。</p>
<h4 id="O-CLOEXEC（自-Linux-2-6-23-版本开始支持）"><a href="#O-CLOEXEC（自-Linux-2-6-23-版本开始支持）" class="headerlink" title="O_CLOEXEC（自 Linux 2.6.23 版本开始支持）"></a>O_CLOEXEC（自 Linux 2.6.23 版本开始支持）</h4><p>​        为新（创建）的文件描述符启用 close-on-flag 标志（FD_CLOEXEC）。27.4 节将描述 FD_ CLOEXEC 标志。使用 O_CLOEXEC 标志（打开文件），可以免去程序执行 fcntl()的 F_GETFD和 F_SETFD 操作来设置 close-on-exec 标志的额外工作。在多线程程序中执行 fcntl() 的 F_GETFD和 F_SETFD 操作有可能导致竞争状态，而使用 O_CLOEXEC 标志则能够避免这一点。可能引发竞争的场景是：线程某甲打开一文件描述符，尝试为该描述符标记 close-on-exec 标志，于此同时，线程某乙执行 fork()调用，然后调用 exec()执行任意一个程序。（假设在某甲打开文件描述符和调用fcntl()设置 close-on-exec 标志之间，某乙成功地执行了 fork()和 exec()操作。）此类竞争可能会在无意间将打开的文件描述符泄露给不安全的程序。（更多关于竞争状态的内容请参考 5.1 节。）</p>
<h4 id="O-CREAT"><a href="#O-CREAT" class="headerlink" title="O_CREAT"></a>O_CREAT</h4><p>如果文件不存在，将创建一个新的空文件。即使文件以只读方式打开，此标志依然有效。如果在 open()调用中指定 O_CREAT 标志，那么还需要提供 mode 参数，否则，会将新文件的权限设置为栈中的某个随机值。</p>
<h4 id="O-DIRECT"><a href="#O-DIRECT" class="headerlink" title="O_DIRECT"></a>O_DIRECT</h4><p>​        无系统缓冲的文件 I/O 操作。该特性将在 13.6 节中详述。为使 O_DIRECT 标志的常量定义在<fcntl.h>中有效，必须定义_GNU_SOURCE 功能测试宏。</p>
<h4 id="O-DIRECTORY"><a href="#O-DIRECTORY" class="headerlink" title="O_DIRECTORY"></a>O_DIRECTORY</h4><p>​        如果 pathname 参数并非目录，将返回错误（错误号 errno 为 ENOTDIR）。这一标志是专为实现 opendir()函数（18.8 节）而设计的扩展标志。为使 O_DIRECTORY 标志的常量定义在<fcntl.h>中有效，必须定义_GNU_SOURCE 功能测试宏. _</p>
<h4 id="O-DSYNC（自-Linux-2-6-33-版本开始支持）"><a href="#O-DSYNC（自-Linux-2-6-33-版本开始支持）" class="headerlink" title="O_DSYNC（自 Linux 2.6.33 版本开始支持）"></a>O_DSYNC（自 Linux 2.6.33 版本开始支持）</h4><p>​        根据同步 I/O 数据完整性的完成要求1来执行文件写操作。参见 13.3 节中关于内核 I/O 缓冲的讨论。</p>
<h4 id="O-EXCL"><a href="#O-EXCL" class="headerlink" title="O_EXCL"></a>O_EXCL</h4><p>​        此标志与 O_CREAT 标志结合使用表明如果文件已经存在，则不会打开文件，且 open()调用失败，并返回错误，错误号 errno 为 EEXIST。换言之，此标志确保了调用者（open( )的调用进程）就是创建文件的进程。检查文件存在与否和创建文件这两步属于同一原子操作。5.1 节将讨论原子操作的概念。如果在 flags 参数中同时指定了 O_CREAT 和 O_EXCL 标志，且 pathname参数是符号链接，则 open()函数调用失败（错误号 errno 为 EEXIST）。SUSv3 之所以如此规定，是要求有特权的应用程序在已知目录下创建文件，从而消除了如下安全隐患，使用符号链接打开文件会导致在另一位置创建文件（例如，系统目录）。</p>
<h4 id="O-LARGEFILE"><a href="#O-LARGEFILE" class="headerlink" title="O_LARGEFILE"></a>O_LARGEFILE</h4><p>​        支持以大文件方式打开文件。在 32 位操作系统中使用此标志，以支持大文件操作。尽管在 SUSv3 中没有规定这一标志，但其他一些 UNIX 实现都支持这一特性。此标志在诸如 Alpha、IA-64 之类的 64 位 Linux 实现中是无效的。更多的内容将在 5.10 节中讨论。</p>
<h4 id="O-NOATIME（自-Linux-2-6-8-版本开始）"><a href="#O-NOATIME（自-Linux-2-6-8-版本开始）" class="headerlink" title="O_NOATIME（自 Linux 2.6.8 版本开始）"></a>O_NOATIME（自 Linux 2.6.8 版本开始）</h4><p>​        在读文件时，不更新文件的最近访问时间（15.1 节中所描述的 st_atime 属性）。要使用该标志，要么调用进程的有效用户 ID 必须与文件的拥有者相匹配，要么进程需要拥有特权（CAP_FOWNER）。否则，open()调用失败，并返回错误，错误号 errno 为 EPERM。（事实上，如 9.5 节所述，对于非特权进程，当以 O_NOATIME 标志打开文件时，与文件用户 ID 必须匹配的是进程的文件系统用户 ID，而非进程的有效用户 ID。）此标志是 Linux 特有的非标准扩展。要从<fcntl.h>中启用此标志，必须定义_GNU_SOURCE 功能测试宏。O_NOATIME 标志的设计旨在为索引和备份程序服务。该标志的使用能够显著减少磁盘的活动量，省却了既要读取文件内容，又要更新文件 i-node 结构中最近访问时间的繁琐，进而节省了磁头在磁盘上的反复寻道时间（14.4 节）。mount()函数中 MS_ NOATIME 标志（14.8.1 节）和 FS_NOATIME_ FL 标志（15.5 节）与 O_NOATIME 标志功能相似。</p>
<h4 id="O-NOCTTY"><a href="#O-NOCTTY" class="headerlink" title="O_NOCTTY"></a>O_NOCTTY</h4><p>​        如果正在打开的文件属于终端设备，O_NOCTTY 标志防止其成为控制终端。34.4 节将讨论控制终端。如果正在打开的文件不是终端设备，则此标志无效。</p>
<h4 id="O-NOFOLLOW"><a href="#O-NOFOLLOW" class="headerlink" title="O_NOFOLLOW"></a>O_NOFOLLOW</h4><p>​        通常，如果 pathname 参数是符号链接，open()函数将对 pathname 参数进行解引用。一旦在 open()函数中指定了 O_NOFOLLOW 标志，且 pathname 参数属于符号链接，则 open()函数将返回失败（错误号 errno 为 ELOOP）。此标志在特权程序中极为有用，能够确保 open()函数不对符号链接进行解引用。为使 O_NOFOLLOW 标志在<fcntl.h>中有效，必须定义_GNU_SOURCE功能测试宏。_</p>
<h4 id="O-NONBLOCK"><a href="#O-NONBLOCK" class="headerlink" title="O_NONBLOCK"></a>O_NONBLOCK</h4><p>以非阻塞方式打开文件，参照 5.9 节。</p>
<h4 id="O-SYNC"><a href="#O-SYNC" class="headerlink" title="O_SYNC"></a>O_SYNC</h4><p>以同步 I/O 方式打开文件，参见 13.3 节针对内核 I/O 缓冲的讨论。</p>
<h4 id="O-TRUNC"><a href="#O-TRUNC" class="headerlink" title="O_TRUNC"></a>O_TRUNC</h4><p>​        如果文件已经存在且为普通文件，那么将清空文件内容，将其长度置 0。在 Linux 下使用此标志，无论以读、写方式打开文件，都可清空文件内容（在这两种情况下，都必须拥有对文件的写权限）。SUSv3 对 O_RDONLY 与 O_TRUNC 标志的组合未作规定，但多数其他 UNIX实现与 Linux 的处理方式相同。</p>
<h3 id="open可能抛出的异常"><a href="#open可能抛出的异常" class="headerlink" title="open可能抛出的异常"></a>open可能抛出的异常</h3><p>​        若打开文件时发生错误，open()将返回−1，错误号 errno 标识错误原因。以下是一些可能发生的错误（除了在上节参数描述中已经提及的错误之外）。</p>
<h4 id="EACCES"><a href="#EACCES" class="headerlink" title="EACCES"></a>EACCES</h4><p>​        文件权限不允许调用进程以 flags 参数指定的方式打开文件。无法访问文件，其可能的原因有目录权限的限制、文件不存在并且也无法创建该文件。</p>
<h4 id="EISDIR"><a href="#EISDIR" class="headerlink" title="EISDIR"></a>EISDIR</h4><p>​        所指定的文件属于目录，而调用者企图打开该文件进行写操作。不允许这种用法。（另一方面，在某些场合中，打开目录进行读操作是必要的。18.11 节将举例说明。）</p>
<h4 id="EMFILE"><a href="#EMFILE" class="headerlink" title="EMFILE"></a>EMFILE</h4><p>​        进程已打开的文件描述符数量达到了进程资源限制所设定的上限（在 36.3 节将描述RLIMIT_NOFILE 参数）。ENFILE 文件打开数量已经达到系统允许的上限。</p>
<h4 id="ENOENT"><a href="#ENOENT" class="headerlink" title="ENOENT"></a>ENOENT</h4><p>​        要么文件不存在且未指定 O_CREAT 标志，要么指定了 O_CREAT 标志，但 pathname 参数所指定路径的目录之一不存在，或者 pathname 参数为符号链接，而该链接指向的文件不存在（空链接）。</p>
<h4 id="EROFS"><a href="#EROFS" class="headerlink" title="EROFS"></a>EROFS</h4><p>​        所指定的文件隶属于只读文件系统，而调用者企图以写方式打开文件。</p>
<h4 id="ETXTBSY"><a href="#ETXTBSY" class="headerlink" title="ETXTBSY"></a>ETXTBSY</h4><p>​        所指定的文件为可执行文件（程序），且正在运行。系统不允许修改正在运行的程序（比如以写方式打开文件）。（必须首先终止程序运行，然后方可修改可执行文件。）后续在描述其他系统调用或库函数时，一般不会再以上述方式展现可能发生的一系列错误。（每个系统调用或库函数的错误列表可从相关操作手册中查询获得。）采用上述方式原因有二，一是因为 open()是本书详细描述的首个系统调用，而上述列表表明任一原因都有可能导致系统调用或库函数的调用失败。二是 open()调用失败的具体原因列表本身就颇为值得玩味，它展示了影响文件访问的若干因素，以及访问文件时系统所执行的一系列检查。（上述错误列表并不完整，更多 open()调用失败的错误原因请查看 open(2)的操作手册。）</p>
<h2 id="read读文件"><a href="#read读文件" class="headerlink" title="read读文件"></a>read读文件</h2><p>​        read()系统调用从文件描述符 fd 所指代的打开文件中读取数据。</p>
<pre class="line-numbers language-none"><code class="language-none">extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __wur;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        count 参数指定最多能读取的字节数。（size_t 数据类型属于无符号整数类型。）buffer 参数提供用来存放输入数据的内存缓冲区地址。缓冲区至少应有 count 个字节。</p>
<p>​        <strong>如果 read()调用成功，将返回实际读取的字节数，如果遇到文件结束（EOF）则返回 0，如果出现错误则返回-1。</strong>ssize_t 数据类型属于有符号的整数类型，用来存放（读取的）字节数或-1（表示错误）。</p>
<p>​        一次 read()调用所读取的字节数可以小于请求的字节数。对于普通文件而言，这有可能是因为当前读取位置靠近文件尾部。（不难理解，一个只有10b的文件读它个20b，那么实际上就会读取10b）</p>
<p>​        当 read()应用于其他文件类型时，比如管道、FIFO、socket 或者终端，在不同环境下也会出现 read()调用读取的字节数小于请求字节数的情况。例如，默认情况下从终端读取字符，一遇到换行符（\n），read()调用就会结束。</p>
<p>​        值得注意的是：有必要在read的东西加上一个\0以示终止，因为 read()调用没有在 字符串尾部添加一个表示终止的空字符。为什么不加呢？read()无从区分这些数据，故而也无法遵从 C 语言对字符串处理的约定，在字符串尾部追加标识字符串结束的空字符。如果输入缓冲区的结尾处需要一个表示终止的空字符，必须显式追加。</p>
<h2 id="write写文件"><a href="#write写文件" class="headerlink" title="write写文件"></a>write写文件</h2><pre class="line-numbers language-none"><code class="language-none">extern ssize_t write (int __fd, const void *__buf, size_t __n) __wur;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        write()系统调用将数据写入一个已打开的文件中。write()调用的参数含义与 read()调用相类似。buffer 参数为要写入文件中数据的内存地址，count参数为欲从 buffer 写入文件的数据字节数，fd 参数为一文件描述符，指代数据要写入的文件。</p>
<p>​        如果 write()调用成功，将返回实际写入文件的字节数，该返回值可能小于 count 参数值。这被称为“部分写”。对磁盘文件来说，造成“部分写”的原因可能是由于磁盘已满，或是因为进程资源对文件大小的限制。（相关的限制为 RLIMIT_FSIZE，将在 36.3 节描述。）</p>
<p>​        对磁盘文件执行 I/O 操作时，write()调用成功并不能保证数据已经写入磁盘。因为为了减少磁盘活动量和加快 write()系统调用，内核会缓存磁盘的 I/O 操作</p>
<h2 id="close-关闭文件"><a href="#close-关闭文件" class="headerlink" title="close() 关闭文件"></a>close() 关闭文件</h2><p>​        close()系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。</p>
<pre class="line-numbers language-none"><code class="language-none">extern int close (int __fd);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        当一进程终止时，将自动关闭其已打开的所有文件描述符。</p>
<p>​        显式关闭不再需要的文件描述符往往是良好的编程习惯，会使代码在后续修改时更具可读性，也更可靠。进而言之，文件描述符属于有限资源，因此文件描述符关闭失败可能会导致一个进程将文件描述符资源消耗殆尽。在编写需要长期运行并处理大量文件的程序时，比如 shell 或者网络服务器软件，需要特别加以关注。<strong>像其他所有系统调用一样，应对 close()的调用进行错误检查</strong></p>
<pre class="line-numbers language-none"><code class="language-none">if(close(fd) &#x3D;&#x3D; -1)&#123;
	exit(-1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        上述代码能够捕获的错误有：<strong>企图关闭一个未打开的文件描述符，或者两次关闭同一文件描述符，也能捕获特定文件系统在关闭操作中诊断出的错误条件</strong>。针对特定文件系统的错误，NFS（网络文件系统）就是一例。如果 NFS 出现提交失败，这意味着数据没有抵达远程磁盘，随之将这一错误作为 close()调用失败的原因传递给应用系统。</p>
<h2 id="lseek-改变文件偏移量"><a href="#lseek-改变文件偏移量" class="headerlink" title="lseek()改变文件偏移量"></a>lseek()改变文件偏移量</h2><p>​        对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指<strong>执行下一个 read()或 write()操作的文件起始位置</strong>，会以相对于文件头部起始点的文件当前位置来表示。<strong>文件第一个字节的偏移量为 0。</strong></p>
<p>​        文件打开时，会将文件偏移量设置为指向文件开始，以后每次 read()或 write()调用将自动对其进行调整，以指向已读或已写数据后的下一字节。因此，连续的 read()和 write()调用将按顺序递进，对文件进行操作。</p>
<p>​        针对文件描述符 fd 参数所指代的已打开文件，lseek()系统调用依照 offset 和 whence 参数值调整该文件的偏移量。</p>
<pre class="line-numbers language-none"><code class="language-none">extern __off_t lseek (int __fd, __off_t __offset, int __whence) __THROW;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        offset 参数指定了一个以字节为单位的数值。（SUSv3 规定 off_t 数据类型为有符号整型数。）whence 参数则表明应参照哪个基点来解释 offset 参数，应为下列其中之一：</p>
<ul>
<li>SEEK_SET   将文件偏移量设置为从文件头部起始点开始的 offset 个字节。</li>
<li>SEEK_CUR 相对于当前文件偏移量，将文件偏移量调整 offset 个字节1。</li>
<li>SEEK_END 将文件偏移量设置为起始于文件尾部的 offset 个字节。也就是说，offset 参数应该从文件最后一个字节之后的下一个字节算起。</li>
</ul>
<p><img src="image-20230803172531005.png" alt="image-20230803172531005"></p>
<p>​        lseek()并不适用于所有类型的文件。不允许将 lseek()应用于管道、FIFO、socket 或者终端。一旦如此，调用将会失败，并将 errno 置为 ESPIPE。</p>
<p>​        另一方面，只要合情合理，也可以将 lseek()应用于设备。例如，在磁盘或者磁带上查找一处具体位置。lseek()调用名中的 l 源于这样一个事实：offset 参数和调用返回值的类型起初都是 long型。早期的 UNIX 系统还提供了 seek()系统调用，当时这两个值的类型为 int 型。</p>
<h3 id="文件空洞"><a href="#文件空洞" class="headerlink" title="文件空洞"></a>文件空洞</h3><p>​        对于我们想要执行写操作——我们打算在文件偏移量已经大于文件长度的情况下去写东西会如何呢？</p>
<p>​        答案是——不会报错！相反，会将中间的部分填充0后再准备写想写的东西。从文件结尾后到新写入数据间的这段空间被称为文件空洞。从编程角度看，文件空洞中是存在字节的，读取空洞将返回以 0（空字节）填充的缓冲区。</p>
<p>​        然而，文件空洞不占用任何磁盘空间。直到后续某个时点，在文件空洞中写入了数据，文件系统才会为之分配磁盘块。文件空洞的主要优势在于，与为实际需要的空字节分配磁盘块相比，稀疏填充的文件会占用较少的磁盘空间。核心转储文件（core dump）（见 22.1 节）是包含空洞文件的常见例子。</p>
<h2 id="4-9-总结"><a href="#4-9-总结" class="headerlink" title="4.9 总结"></a>4.9 总结</h2><p>​        为了对普通文件执行 I/O 操作，首先必须调用 open()以获得一个文件描述符。随之使用read()和 write()执行文件的 I/O 操作，然后应使用 close()释放文件描述符及相关资源。这些系统调用可对所有类型的文件执行 I/O 操作。所有类型的文件和设备驱动都实现了相同的 I/O 接口，这保证了 I/O 操作的通用性，同时也意味着在无需针对特定文件类型编写代码的情况下，程序通常就能操作所有类型的文件。对于已打开的每个文件，内核都维护有一个文件偏移量，这决定了下一次读或写操作的起始位置。读和写操作会隐式修改文件偏移量。使用 lseek()函数可以显式地将文件偏移量置为文件中或文件结尾后的任一位置。在文件原结尾处之后的某一位置写入数据将导致文件空洞。从文件空洞处读取文件将返回全 0 字节。对于未纳入标准 I/O 模型的所有设备和文件操作而言，ioctl()系统调用是个“百宝箱”。</p>
<h1 id="扩展：传统的-System-Call-I-O"><a href="#扩展：传统的-System-Call-I-O" class="headerlink" title="扩展：传统的 System Call I/O"></a>扩展：传统的 System Call I/O</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/435406445">Linux系统中I/O操作的数据读写流程介绍 - 知乎 (zhihu.com)</a></p>
<p>​        在 Linux 系统中，<strong>传统的访问方式是通过 write() 和 read() 两个系统调用实现的，通过 read() 函数读取文件到到缓存区中，然后通过 write() 方法把缓存中的数据输出到网络端口</strong>。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">read(file_fd, tmp_buf, len);
write(socket_fd, tmp_buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        下图分别对应传统 I/O 操作的数据读写流程，整个过程涉及 2 次 CPU 拷贝、2 次 DMA 拷贝，总共 4 次拷贝，以及 4 次上下文切换。</p>
<ul>
<li><strong>CPU 拷贝</strong>：由 CPU 直接处理数据的传送，数据拷贝时会一直占用 CPU 的资源。</li>
<li><strong>DMA 拷贝</strong>：由 CPU 向DMA磁盘控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，从而减轻了 CPU 资源的占有率。</li>
<li><strong>上下文切换</strong>：当用户程序向内核发起系统调用时，CPU 将用户进程从用户态切换到内核态；当系统调用返回时，CPU 将用户进程从内核态切换回用户态。</li>
</ul>
<h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>​        当应用程序执行 read 系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据。</p>
<p>​        如果数据不存在，则先将数据从磁盘加载数据到内核空间的读缓存（Read Buffer）中，再从读缓存拷贝到用户进程的页内存中。</p>
<p><img src="v2-c4ffd5334a977af27f18b3b6eac6f65c_1440w.webp" alt="img"></p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">read(file_fd, tmp_buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        基于传统的 I/O 读取方式，read 系统调用会触发 2 次上下文切换，1 次 DMA 拷贝和 1 次 CPU 拷贝。</p>
<p><strong>发起数据读取的流程如下：</strong></p>
<ol>
<li>用户进程通过 read() 函数向 Kernel 发起 System Call，上下文从 user space 切换为 kernel space。</li>
<li>CPU 利用 DMA 控制器将数据从主存或硬盘拷贝到 kernel space 的读缓冲区（Read Buffer）。</li>
<li>CPU 将读缓冲区（Read Buffer）中的数据拷贝到 user space 的用户缓冲区（User Buffer）。</li>
<li>上下文从 kernel space 切换回用户态（User Space），read 调用执行返回。</li>
</ol>
<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>​        当应用程序准备好数据，执行 write 系统调用发送网络数据时，先将数据从用户空间的页缓存拷贝到内核空间的网络缓冲区（Socket Buffer）中，然后再将写缓存中的数据拷贝到网卡设备完成数据发送。</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">write(socket_fd, tmp_buf, len);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        基于传统的 I/O 写入方式，write() 系统调用会触发 2 次上下文切换，1 次 CPU 拷贝和 1 次 DMA 拷贝。</p>
<p>​        <strong>用户程序发送网络数据的流程如下：</strong></p>
<ol>
<li>用户进程通过 write() 函数向 kernel 发起 System Call，上下文从 user space 切换为 kernel space。</li>
<li>CPU 将用户缓冲区（User Buffer）中的数据拷贝到 kernel space 的网络缓冲区（Socket Buffer）。</li>
<li>CPU 利用 DMA 控制器将数据从网络缓冲区（Socket Buffer）拷贝到 NIC 进行数据传输。</li>
<li>上下文从 kernel space 切换回 user space，write 系统调用执行返回。</li>
</ol>
<h2 id="网络-I-O"><a href="#网络-I-O" class="headerlink" title="网络 I/O"></a>网络 I/O</h2><p><img src="v2-a0bbc8704096e91fd1ab2546d5dedfde_1440w.webp" alt="img"></p>
<h2 id="磁盘-I-O"><a href="#磁盘-I-O" class="headerlink" title="磁盘 I/O"></a>磁盘 I/O</h2><p><img src="v2-6a02810aa6d653bae2d27784d1f79995_1440w.webp" alt="img"></p>
<h2 id="高性能优化的-I-O"><a href="#高性能优化的-I-O" class="headerlink" title="高性能优化的 I/O"></a>高性能优化的 I/O</h2><ol>
<li><strong>零拷贝技术。</strong></li>
<li><strong>多路复用技术。</strong></li>
<li><strong>页缓存（PageCache）技术。</strong></li>
</ol>
<p>其中，<strong>页缓存（PageCache）</strong>是操作系统对文件的缓存，用来减少对磁盘的 I/O 操作，以页为单位的，内容就是磁盘上的物理块，页缓存能帮助程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于 OS 使用 PageCache 机制对读写访问操作进行了性能优化。</p>
<p><strong>页缓存读取策略</strong>：当进程发起一个读操作 （比如，进程发起一个 read() 系统调用），它首先会检查需要的数据是否在页缓存中：</p>
<ul>
<li><strong>如果在</strong>，则放弃访问磁盘，而直接从页缓存中读取。</li>
<li><strong>如果不在</strong>，则内核调度块 I/O 操作从磁盘去读取数据，并读入紧随其后的少数几个页面（不少于一个页面，通常是三个页面），然后将数据放入页缓存中。</li>
</ul>
<p><img src="v2-222d29b87f50973806ed9c1a7633819f_1440w.webp" alt="img"></p>
<p><strong>页缓存写策略</strong>：当进程发起 write 系统调用写数据到文件中，先写到页缓存，然后方法返回。此时数据还没有真正的保存到文件中去，Linux 仅仅将页缓存中的这一页数据标记为 “脏”，并且被加入到脏页链表中。</p>
<p>然后，由 flusher 回写线程周期性将脏页链表中的页写到磁盘，让磁盘中的数据和内存中保持一致，最后清理“脏”标识。</p>
<p><strong>在以下三种情况下，脏页会被写回磁盘：</strong></p>
<ol>
<li>空闲内存低于一个特定阈值。</li>
<li>脏页在内存中驻留超过一个特定的阈值时。</li>
<li>当用户进程调用 sync() 和 fsync() 系统调用时。</li>
</ol>
<h2 id="存储设备的-I-O-栈"><a href="#存储设备的-I-O-栈" class="headerlink" title="存储设备的 I/O 栈"></a>存储设备的 I/O 栈</h2><p><img src="v2-c5c7c058af6239bbb2f86fe9da0f33f9_1440w.webp" alt="img"></p>
<p><strong>由图可见，从系统调用的接口再往下，Linux 下的 IO 栈致大致有三个层次：</strong></p>
<ol>
<li><strong>文件系统层</strong>，以 write 为例，内核拷贝了 write 参数指定的用户态数据到文件系统 Cache 中，并适时向下层同步。</li>
<li><strong>块层</strong>，管理块设备的 IO 队列，对 IO 请求进行合并、排序（还记得操作系统课程学习过的 IO 调度算法吗？）。</li>
<li><strong>设备层</strong>，通过 DMA 与内存直接交互，完成数据和具体设备之间的交互。</li>
</ol>
<p>结合这个图，想想 Linux 系统编程里用到的 <strong>Buffered IO</strong>、<strong>mmap</strong>、<strong>Direct IO</strong>，这些机制怎么和<strong>Linux I/O栈</strong>联系起来呢？上面的图有点复杂，我画一幅简图，把这些机制所在的位置添加进去：</p>
<p><img src="v2-50b7e6e5b531ab5fc8c294bc6cfa125a_1440w.webp" alt="img"></p>
<h2 id="Linux-IO系统"><a href="#Linux-IO系统" class="headerlink" title="Linux IO系统"></a><strong>Linux IO系统</strong></h2><p>​        这下一目了然了吧？<strong>传统的 Buffered IO</strong> 使用 read 读取文件的过程什么样的？假设要去读一个冷文件（Cache 中不存在），open 打开文件内核后建立了一系列的数据结构，接下来调用 read，到达文件系统这一层，发现 <strong>Page Cache</strong> 中不存在该位置的磁盘映射，然后创建相应的 Page Cache 并和相关的扇区关联。然后请求继续到达块设备层，在 IO 队列里排队，接受一系列的调度后到达设备驱动层，此时一般使用 <strong>DMA</strong> 方式读取相应的磁盘扇区到 Cache 中，然后 read 拷贝数据到用户提供的<strong>用户态 buffer</strong> 中去（read 的参数指出的）。</p>
<p>​        <strong>整个过程有几次拷贝？</strong>从磁盘到 Page Cache 算第一次的话，从 Page Cache 到用户态 buffer 就是第二次了。而 mmap 做了什么？mmap 直接把 Page Cache 映射到了用户态的地址空间里了，所以 mmap 的方式读文件是没有第二次拷贝过程的。</p>
<p>​        <strong>那 Direct IO 做了什么？</strong>这个机制更狠，直接让用户态和块 IO 层对接，直接放弃 Page Cache，从磁盘直接和用户态拷贝数据。好处是什么？写操作直接映射进程的buffer到磁盘扇区，以 DMA 的方式传输数据，减少了原本需要到 Page Cache 层的一次拷贝，提升了写的效率。对于读而言，第一次肯定也是快于传统的方式的，但是之后的读就不如传统方式了（当然也可以在用户态自己做 Cache，有些商用数据库就是这么做的）。</p>
<p>除了传统的 Buffered IO 可以比较自由的用偏移+长度的方式读写文件之外，<strong>mmap</strong> 和 Direct IO 均有数据按页对齐的要求，Direct IO 还限制读写必须是底层存储设备块大小的整数倍（甚至 Linux 2.4 还要求是文件系统逻辑块的整数倍）。所以接口越来越底层，换来表面上的效率提升的背后，需要在应用程序这一层做更多的事情。所以想用好这些高级特性，除了深刻理解其背后的机制之外，也要在系统设计上下一番功夫。</p>
<h2 id="I-O-Buffering"><a href="#I-O-Buffering" class="headerlink" title="I/O Buffering"></a>I/O Buffering</h2><p><img src="v2-5ac443941b2d427d34d958db72480d9e_1440w.webp" alt="img"></p>
<p>​        如图，当程序调用各类文件操作函数后，用户数据（User Data）到达磁盘（Disk）的流程如图所示。</p>
<p>​        图中描述了 Linux 下文件操作函数的层级关系和内存缓存层的存在位置。中间的黑色实线是用户态和内核态的分界线。</p>
<p><strong>从上往下分析这张图：</strong></p>
<p>​        <strong>1.</strong> 首先是 C 语言 stdio 库定义的相关文件操作函数，这些都是用户态实现的跨平台封装函数。stdio 中实现的文件操作函数有自己的 stdio buffer，这是在用户态实现的缓存。此处使用缓存的原因很简单 — 系统调用总是昂贵的。如果用户代码以较小的 size 不断的读或写文件的话，stdio 库将多次的读或者写操作通过 buffer 进行聚合是可以提高程序运行效率的。stdio 库同时也支持 fflush 函数来主动的刷新 buffer，主动的调用底层的系统调用立即更新 buffer 里的数据。特别地，setbuf 函数可以对 stdio 库的用户态 buffer 进行设置，甚至取消 buffer 的使用。</p>
<p>​        <strong>2.</strong> <strong>系统调用的 read/write 和真实的磁盘读写之间也存在一层 buffer</strong>，这里用术语 Kernel buffer cache 来指代这一层缓存。在 Linux 下，文件的缓存习惯性的称之为 Page Cache，而更低一级的设备的缓存称之为 Buffer Cache。这两个概念很容易混淆，这里简单的介绍下概念上的区别：Page Cache 用于缓存文件的内容，和文件系统比较相关。文件的内容需要映射到实际的物理磁盘，这种映射关系由文件系统来完成；Buffer Cache 用于缓存存储设备块（比如磁盘扇区）的数据，而不关心是否有文件系统的存在（文件系统的元数据缓存在 Buffer Cache 中）。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/">http://charliechen114514.github.io/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C-Linux/">C/C++. Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/19/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA%E4%B8%8E%E4%B8%89%E7%A7%8D%E5%8D%8F%E8%AE%AE/" title="Unix网络编程——导论与三种协议"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unix网络编程——导论与三种协议</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/17/Unix-network-programming-Guidance/" title="Unix网络编程 - 1"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unix网络编程 - 1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/15/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA/" title="Linux漫游——导论"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-15</div><div class="title">Linux漫游——导论</div></div></a></div><div><a href="/2023/08/16/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="Linux漫游——系统调用"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-16</div><div class="title">Linux漫游——系统调用</div></div></a></div><div><a href="/2023/08/17/Unix-network-programming-Guidance/" title="Unix网络编程 - 1"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-17</div><div class="title">Unix网络编程 - 1</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E6%BC%AB%E6%B8%B8-%E6%96%87%E4%BB%B6-I-O%EF%BC%9A%E9%80%9A%E7%94%A8%E7%9A%84-I-O-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">Linux漫游- 文件 I&#x2F;O：通用的 I&#x2F;O 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E4%B8%BB%E6%B5%81%E7%9A%84IO%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">四个主流的IO操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#open"><span class="toc-number">1.3.</span> <span class="toc-text">open</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#open-%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84-flags-%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">open()调用中的 flags 参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#O-APPEND"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">O_APPEND</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-ASYNC"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">O_ASYNC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-CLOEXEC%EF%BC%88%E8%87%AA-Linux-2-6-23-%E7%89%88%E6%9C%AC%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81%EF%BC%89"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">O_CLOEXEC（自 Linux 2.6.23 版本开始支持）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-CREAT"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">O_CREAT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-DIRECT"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">O_DIRECT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-DIRECTORY"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">O_DIRECTORY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-DSYNC%EF%BC%88%E8%87%AA-Linux-2-6-33-%E7%89%88%E6%9C%AC%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81%EF%BC%89"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">O_DSYNC（自 Linux 2.6.33 版本开始支持）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-EXCL"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">O_EXCL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-LARGEFILE"><span class="toc-number">1.3.1.9.</span> <span class="toc-text">O_LARGEFILE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-NOATIME%EF%BC%88%E8%87%AA-Linux-2-6-8-%E7%89%88%E6%9C%AC%E5%BC%80%E5%A7%8B%EF%BC%89"><span class="toc-number">1.3.1.10.</span> <span class="toc-text">O_NOATIME（自 Linux 2.6.8 版本开始）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-NOCTTY"><span class="toc-number">1.3.1.11.</span> <span class="toc-text">O_NOCTTY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-NOFOLLOW"><span class="toc-number">1.3.1.12.</span> <span class="toc-text">O_NOFOLLOW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-NONBLOCK"><span class="toc-number">1.3.1.13.</span> <span class="toc-text">O_NONBLOCK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-SYNC"><span class="toc-number">1.3.1.14.</span> <span class="toc-text">O_SYNC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#O-TRUNC"><span class="toc-number">1.3.1.15.</span> <span class="toc-text">O_TRUNC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#open%E5%8F%AF%E8%83%BD%E6%8A%9B%E5%87%BA%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">1.3.2.</span> <span class="toc-text">open可能抛出的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EACCES"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">EACCES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EISDIR"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">EISDIR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EMFILE"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">EMFILE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ENOENT"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">ENOENT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EROFS"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">EROFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ETXTBSY"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">ETXTBSY</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">read读文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">write写文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#close-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">close() 关闭文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lseek-%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">1.7.</span> <span class="toc-text">lseek()改变文件偏移量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%A9%BA%E6%B4%9E"><span class="toc-number">1.7.1.</span> <span class="toc-text">文件空洞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">4.9 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E4%BC%A0%E7%BB%9F%E7%9A%84-System-Call-I-O"><span class="toc-number">2.</span> <span class="toc-text">扩展：传统的 System Call I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">读操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">写操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-I-O"><span class="toc-number">2.3.</span> <span class="toc-text">网络 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98-I-O"><span class="toc-number">2.4.</span> <span class="toc-text">磁盘 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84-I-O"><span class="toc-number">2.5.</span> <span class="toc-text">高性能优化的 I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E7%9A%84-I-O-%E6%A0%88"><span class="toc-number">2.6.</span> <span class="toc-text">存储设备的 I&#x2F;O 栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-IO%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.7.</span> <span class="toc-text">Linux IO系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-Buffering"><span class="toc-number">2.8.</span> <span class="toc-text">I&#x2F;O Buffering</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA%E4%B8%8E%E4%B8%89%E7%A7%8D%E5%8D%8F%E8%AE%AE/" title="Unix网络编程——导论与三种协议"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unix网络编程——导论与三种协议"/></a><div class="content"><a class="title" href="/2023/08/19/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA%E4%B8%8E%E4%B8%89%E7%A7%8D%E5%8D%8F%E8%AE%AE/" title="Unix网络编程——导论与三种协议">Unix网络编程——导论与三种协议</a><time datetime="2023-08-19T09:47:32.000Z" title="发表于 2023-08-19 17:47:32">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/" title="Linux漫游——文件IO操作"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux漫游——文件IO操作"/></a><div class="content"><a class="title" href="/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/" title="Linux漫游——文件IO操作">Linux漫游——文件IO操作</a><time datetime="2023-08-19T03:07:37.000Z" title="发表于 2023-08-19 11:07:37">2023-08-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/17/Unix-network-programming-Guidance/" title="Unix网络编程 - 1"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unix网络编程 - 1"/></a><div class="content"><a class="title" href="/2023/08/17/Unix-network-programming-Guidance/" title="Unix网络编程 - 1">Unix网络编程 - 1</a><time datetime="2023-08-17T10:15:15.000Z" title="发表于 2023-08-17 18:15:15">2023-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/16/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="Linux漫游——系统调用"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux漫游——系统调用"/></a><div class="content"><a class="title" href="/2023/08/16/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="Linux漫游——系统调用">Linux漫游——系统调用</a><time datetime="2023-08-16T13:27:19.000Z" title="发表于 2023-08-16 21:27:19">2023-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA/" title="Linux漫游——导论"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux漫游——导论"/></a><div class="content"><a class="title" href="/2023/08/15/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA/" title="Linux漫游——导论">Linux漫游——导论</a><time datetime="2023-08-15T00:32:15.000Z" title="发表于 2023-08-15 08:32:15">2023-08-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>