<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Effective Modern C++ 1: auto And template | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Effective Modern C++理解模板类别推导​        一个良好风格程序，是可以让客户程序员对其原理一无所知但是却用的相当的satisfied的！ ​        符合上述陈述的，就是模板类别推导机制。这里有一小段伪代码可以view一下： template&lt;typename T&gt; void f(ParamType param); &#x2F;&#x2F; Param">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Modern C++ 1: auto And template">
<meta property="og:url" content="http://charliechen114514.github.io/2023/08/22/Effective-Modern-C-1-auto-And-template/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="Effective Modern C++理解模板类别推导​        一个良好风格程序，是可以让客户程序员对其原理一无所知但是却用的相当的satisfied的！ ​        符合上述陈述的，就是模板类别推导机制。这里有一小段伪代码可以view一下： template&lt;typename T&gt; void f(ParamType param); &#x2F;&#x2F; Param">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-08-22T02:58:43.000Z">
<meta property="article:modified_time" content="2023-08-22T03:02:00.627Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/08/22/Effective-Modern-C-1-auto-And-template/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Effective Modern C++ 1: auto And template',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-22 11:02:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Effective Modern C++ 1: auto And template</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-22T02:58:43.000Z" title="发表于 2023-08-22 10:58:43">2023-08-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-22T03:02:00.627Z" title="更新于 2023-08-22 11:02:00">2023-08-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Effective Modern C++ 1: auto And template"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Effective-Modern-C"><a href="#Effective-Modern-C" class="headerlink" title="Effective Modern C++"></a><code>Effective Modern C++</code></h1><h2 id="理解模板类别推导"><a href="#理解模板类别推导" class="headerlink" title="理解模板类别推导"></a>理解模板类别推导</h2><p>​        一个良好风格程序，是可以让客户程序员对其原理一无所知但是却用的相当的satisfied的！</p>
<p>​        符合上述陈述的，就是模板类别推导机制。这里有一小段伪代码可以view一下：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
void f(ParamType param); &#x2F;&#x2F; ParamType is a compound of T<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        一次调用：</p>
<pre class="line-numbers language-none"><code class="language-none">f(expr);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        在编译期间，我们的编译器通过expr推导两个型别：一个是T，另一个是<code>ParamType</code>,这个<code>ParamType</code>，往往会有一些饰词：举个例子：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
void f(const T&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        调用如下：</p>
<pre class="line-numbers language-none"><code class="language-none">int x &#x3D; 0;
f(x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        不会违背我们常识的——我们马上拿到了T是int,而<em><code>ParamType</code></em>是<code>const T&amp;</code></p>
<p>​        结合我们的开发经验，可以知道<em><code>ParamType</code></em>有三种：</p>
<ul>
<li><code>ParamType</code>具有指针或者是引用型别，但不是一个万能引用</li>
<li><code>ParamType</code>是一个万能引用</li>
<li><code>ParamType</code>啥也不是</li>
</ul>
<h3 id="Case-1-ParamType具有指针或者是引用型别，但不是一个万能引用"><a href="#Case-1-ParamType具有指针或者是引用型别，但不是一个万能引用" class="headerlink" title="Case 1:ParamType具有指针或者是引用型别，但不是一个万能引用"></a><code>Case 1</code>:<code>ParamType</code>具有指针或者是引用型别，但不是一个万能引用</h3><p>​        这是最简单的！运作的步骤就是如下：</p>
<ol>
<li>若expr具有引用型别，先忽略引用</li>
<li>而后，对expr的型别和<code>ParamType</code>的型别进行模式匹配后，来决定T的型别</li>
</ol>
<p>举个例子</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
void f(T&amp; param);

int x &#x3D; 27;			&#x2F;&#x2F; x is int
const int cx &#x3D; x;	&#x2F;&#x2F; cx is const int
const int&amp; rx &#x3D; x;	&#x2F;&#x2F; rx is consy int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        于是</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">f(x);			&#x2F;&#x2F; T is int, param is int&amp;
f(cx);			&#x2F;&#x2F; T is const int, param is const int&amp;
f(rx);			&#x2F;&#x2F; T is const int, param is const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        这个时候，请注意——const关键字在类型模板推到中还是被带上了const。这就说明了模板推导是安全的。</p>
<p>​        当然，那如果是</p>
<pre class="line-numbers language-none"><code class="language-none">void f(const T&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        于是，我们没有必要繁琐的多次添加const，也就是说：</p>
<pre class="line-numbers language-none"><code class="language-none">f(x);			&#x2F;&#x2F; T is int, param is int&amp;
f(cx);			&#x2F;&#x2F; T is int, param is const int&amp;
f(rx);			&#x2F;&#x2F; T is int, param is const int&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        没有必要再让T带上const修饰符了——这里的参数总会具有恒定修饰符。</p>
<p>​        当然，对于指针</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">void f(T* param);
int x &#x3D; 27;
const int cx &#x3D; x;
const int* px &#x3D; &amp;x;

f(&amp;x);	&#x2F;&#x2F; T is int, param is int*
f(px);	&#x2F;&#x2F; T is const int param is const int*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="case-2-param是一个万能引用"><a href="#case-2-param是一个万能引用" class="headerlink" title="case 2: param是一个万能引用"></a><code>case 2: param</code>是一个万能引用</h2><p>​        先简单谈谈什么是万能引用</p>
<p>C++11除了带来了右值引用以外，还引入了一种称为“万能引用”的语法；通过“万能引用”，对某型别的引用T&amp;&amp;，既可以表达右值引用，也可以表达左值引用。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>该语法有两种使用场景，最常见的一种是作为函数模板的形参：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;typename T>
void f(T&amp;&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中param就是一个万能引用。<br>第二个场景则是auto声明：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">auto&amp;&amp; var2 = var1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这两种情况都涉及到了型别的推导，也就是说，如果你虽然遇到了T&amp;&amp;的形式，但是不涉及型别推导，那么它只是一个右值引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">void f(Widget&amp;&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同时，想要成为万能引用，变量声明的形式也必须正确无误，必须正好是形如“T&amp;&amp;”才行。比如下面这些情况就不是万能引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;typename T>
void f1(std::vector&lt;T>&amp;&amp; param); // param是一个右值引用

template&lt;typename T>
void f2(const T&amp;&amp; param);      //param也是一个右值引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你向f1和f2传左值，会都是会直接报错的。<br>除此之外，像下面这种情况也不是万能引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;class T, class Allocator=allocator&lt;T>>
class vector&#123;
public:
  void push_back(T&amp;&amp; x);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>push_back的形参x的型别T是受vector影响的，假设给定T为Widget，那么就会被实例化为如下代码：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;class Widget, class Allocator=allocator&lt;T>>
class vector&#123;
public:
  void push_back(Widget&amp;&amp; x);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而作为对比，vector类中的emplace_back函数则是一个实实在在的万能引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">template&lt;class T, class Allocator=allocator&lt;T>>
class vector&#123;
public:
  template&lt;class...Args>
  void emplace_back(Args&amp;&amp;.. args);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>args的型别Args完全独立于vector的型别形参T，Args必须在每次调用emplace_back时被推导，因此args是万能引用。</p>
<h2 id="为什么是“万能引用”？"><a href="#为什么是“万能引用”？" class="headerlink" title="为什么是“万能引用”？"></a>为什么是“万能引用”？</h2><p>你一定非常好奇，为什么这种形态被称作“万能引用”。原因正像前文所说的，通过“万能引用”，对某型别的引用T&amp;&amp;，既可以表达右值引用，也可以表达左值引用。<br>比如说，传入一个右值引用，一般都要给传入的参数加一个std::move操作确保变量的可移动性：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">class Widget
&#123;
public:
  Widget(Widget&amp;&amp; rhs):name(std::move(rhs.name))&#123;&#125;
private:
  std::string name;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而万能引用则有所不同，它一般是通过std::forward来进行转换：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">class Widget
&#123;
public:
  template&lt;typename T>
  void setName(T&amp;&amp; newName)
  &#123;name = std::forward&lt;T>(newName);&#125;
private:
  std::string name;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这种情况下，若newName是一个左值引用，则forward函数不会对它进行操作，它的返回值仍然是一个左值引用；若newName是一个右值，则会进行std::move的转换。用户使用时无需区分，这也正是它“万能”之处。<br>举个例子：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Widget w;
std::string c = "123";
w.setName(w);            //传入是一个左值，forward返回左值引用
w.setName("123");        //传入是一个右值，forward返回右值引用
w.setName(std::move(w)); //传入是一个右值，forward返回右值引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>​        你一定会很奇怪，为什么万能引用的形式明明是T&amp;&amp;，却既可以代表左值又可以代表右值。这就要涉及到C++的引用折叠语法了。<br>​        首先，C++不支持“引用的引用”这种概念，这样的代码在C++中是非法的：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">int x;
auto&amp; &amp; rx = x;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        但是，假设我们向前面的万能引用函数f传入一个左值引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Widget w = w;
f(w);  //T的推导型别为Widget&amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        那么实例化的结果如下：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">void f(Widget&amp; &amp;&amp; param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        之所以这样的代码能通过，是因为在特殊的情况下（比如模板实例化），C++应用了引用折叠的语法。<br>​        有左值和右值两种引用，所以就有四种可能的组合：左值-左值、左值-右值、右值-左值、右值-右值，如果引用的引用出现在允许的语境，改双重引用会被折叠成单个引用：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">如果任一引用为左值引用，则结果为左值引用。否则（即两个都为右值引用），结果为右值引用。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        因此上述例子中，最终将param推导为左值引用。<br>​        此外，auto的型别推导也会应用引用折叠的场景，例如：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Widget w;
auto &amp;&amp;w1 =w;  //w1是个左值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>话说到这里，我们就可以更深入地理解万能引用，其实它就是满足了下面两个条件的语境中的右值引用：</p>
<ul>
<li>1.型别推导的过程会区别左值和右值。T型别的左值推导结果为T&amp;，而T型别的右值推导结果为T。</li>
<li>2.会发生引用折叠。</li>
</ul>
<p>好了，再给出大纲：</p>
<ul>
<li>如果expr 时一个左值，那么 T 和 paramType都会被推导为左值引用，这个结果仔细思考很有趣：在模板型别推到中，T被认为是引用的唯一情形。其次，尽管在声明的时候使用的是右值引用语法，它的型别推导是左值引用！</li>
<li>expr是右值，那就是常规的，没有什么区别了。</li>
</ul>
<h3 id="case-3-param既不是指针又不是引用"><a href="#case-3-param既不是指针又不是引用" class="headerlink" title="case 3: param既不是指针又不是引用"></a><code>case 3: param</code>既不是指针又不是引用</h3><p>​        那就是剩下值传递了</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
void f(T param);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这意味：传入啥都会是副本，于是我们的param就是一个副本。也就是说：</p>
<pre class="line-numbers language-none"><code class="language-none">int x &#x3D; 27;
const int cx &#x3D; x;
const int&amp; rx &#x3D; x;

f(x);  &#x2F;&#x2F; T 和 param 都是int
f(cx); &#x2F;&#x2F; T 和 param 都是int
f(rx); &#x2F;&#x2F; T 和 param 都是int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        不过，有一个很有趣的情况</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">template&lt;typename T&gt;
void f(T param);

const char* const ptr &#x3D; &quot;Fun wth pointers&quot;;
f(ptr); &#x2F;&#x2F; const char* const的实参<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这个时候，传景区的param类型就会被推到为const char*，原因很简单，我们必须拷贝这个字符串，这就意味着不可能对原本的字符串进行更改（仍然保留了这一原则！），仍然遵循着自身的const或者volitaile属性会被忽略的问题。</p>
<h3 id="数组实参"><a href="#数组实参" class="headerlink" title="数组实参"></a>数组实参</h3><p>​        我们下面考虑的是数组实参的问题</p>
<pre class="line-numbers language-none"><code class="language-none">const char name[] &#x3D; &quot;J,P,Briggs&quot;;
const char* ptrToName &#x3D; name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        这里的ptrToName就是通过name来初始化的。后者的类型是const char[13]，前者是const char*。我们说：这里就发生了数组的退化。</p>
<p>​        现在，当我们把之传递给模板又如何呢？</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;
void f(T param);
f(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        我们知道，这样的传递相当的合法：</p>
<pre class="line-numbers language-none"><code class="language-none">void myFunc(int param[]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        同样的，我们可以按照指针的方式加以处理——等价的！</p>
<pre class="line-numbers language-none"><code class="language-none">void myFunc(int* param);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        所以，对于值传递——param就会变成<code>const char*</code></p>
<p>​        那么，有没有办法传递一个真正的数组呢？答案是传递引用</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;
void f(T&amp; param);
f(name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        T在此时此刻就会变成<code>const char [13]</code>，也就是说，param这个时候是:<code>const char (&amp;) [13]</code></p>
<p>​        嗯，试一下：</p>
<p><img src="image-20230822101943592.png" alt="image-20230822101943592"></p>
<p>​        没有任何意外，答案是5.</p>
<h2 id="理解auto型别推导"><a href="#理解auto型别推导" class="headerlink" title="理解auto型别推导"></a>理解auto型别推导</h2><p>​        有人调侃，未来的C++将会是</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include auto
auto main()&#123;
    auto;
    return auto;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这确实形象的表达了auto的功能——但是没有如此的夸张。他会让你想起来模板类型推导——没有反转，原理完全一致，我甚至不打算在这里重复一遍了。但是，唯独有一个区别…</p>
<p>​        C++11中，引入了一个叫做统一初始化列表的东西，它的语法是这样的</p>
<pre class="line-numbers language-none"><code class="language-none">int x &#x3D; &#123;27&#125;;
int y&#123;27&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        都被允许了！</p>
<pre class="line-numbers language-none"><code class="language-none">auto x1 &#x3D; 27;
auto x2(27); &#x2F;&#x2F; x1 and x2 is 27

auto x3 &#x3D; &#123;27&#125;; &#x2F;&#x2F; initialize_list&lt;int&gt;
auto x4&#123;27&#125;; &#x2F;&#x2F; 存疑，貌似有更改，不再是initialize_list&lt;int&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;

#define SHOWTYPE(X) std::cout &lt;&lt; #X &lt;&lt; &quot; is &quot; &lt;&lt; typeid(X).name() &lt;&lt; std::endl;
void show1()
&#123;
    auto x1 &#x3D; 27;
    SHOWTYPE(x1);
    auto x2(27);

    auto x3 &#x3D; &#123;27&#125;;
    SHOWTYPE(x3);
    auto x4&#123;27&#125;;
    SHOWTYPE(x4);
&#125;

template&lt;typename T&gt;
void f(T param)
&#123;
    std::cout &lt;&lt; &quot; In F&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;T is &quot; &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;param is &quot; &lt;&lt; typeid(param).name() &lt;&lt; std::endl;
&#125;

template&lt;typename T&gt;
void g(std::initializer_list&lt;T&gt; listParam)&#123;
    std::cout &lt;&lt; &quot; In G&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;T is &quot; &lt;&lt; typeid(T).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;param is &quot; &lt;&lt; typeid(listParam).name() &lt;&lt; std::endl;
&#125;


int main()
&#123;
    auto x &#x3D; &#123;1,2,3&#125;;

    &#x2F;&#x2F; f(&#123;1,2,3&#125;); &#x2F;&#x2F; can not pass compiling
    f(x);
    g(&#123;1,2,3&#125;);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        尝试一下使用上面的代码编译一下！最终我们得出结论：auto可以识别initialize_list这个类型（推导时假定），但是模板类型推导不会。</p>
<p>​        C++14中，我们无法使用auto返回initialize_list这个类型：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">auto ErrorReturn()&#123;
	return &#123;1,2,3&#125;; &#x2F;&#x2F; Failed!
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>作者：Codemaxi<br>链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7090673873183571975">https://juejin.cn/post/7090673873183571975</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们都知道，现代的编程语言，不管是动态语言（JavaScript、Python 等），还是静态语言（Go、Rust 等），大都支持自动类型推导（type deduction）。自动类型推导，通俗地讲就是定义一个变量的时候不需要明确指定类型，而是让编译器根据上下文进行推导。 对于C++语言，在 C++11 之前，就只有模板（template）代码就支持编译器自动类型推导。C++11 很重要的一个特性就是加强了编译器自动类型推导的能力，使之不限于模板 —— 与此相关的关键字有两个 <code>auto</code> 和 <code>decltype</code> 。通过这两个关键字不仅能方便地获取复杂的类型，而且还能简化书写，提高编码效率。但是有利也有弊，增加简洁可能就会需要增加学习度，如果不能深入理解类型推断背后的规则与机理，很可能就会出现用法错误。基于我们上一篇文章已经介绍了模板类型推导。本节我们先讲解 auto 关键字，下节再讲解 decltype 关键字。</p>
<h2 id="auto用法"><a href="#auto用法" class="headerlink" title="auto用法"></a>auto用法</h2><p>通常auto的用法有下列两种：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码auto declaratorinitializer;  &#x2F;&#x2F; 普通变量声明定义
auto f &#x3D; [](auto param1, auto param2) &#123;&#125;;  &#x2F;&#x2F; lambda表达式参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>我们来看看 auto 关键字在 C++ 中的使用。 最简单的用法，定义变量的时候不指定类型，通过初始化的值让编译器自动推导。在C++11标准的语法中，auto被定义为自动推断变量的类型。不过C++11的auto关键字时有一个限定条件，那就是必须给申明的变量赋予一个初始值，否则编译器在编译阶段将会报错。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码<span class="token keyword">auto</span> a<span class="token punctuation">;</span>  <span class="token comment">// 编译error，initializer required</span>
<span class="token keyword">auto</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// b 是 int 类型</span>
<span class="token keyword">auto</span> c <span class="token operator">=</span> <span class="token number">0ull</span><span class="token punctuation">;</span>   <span class="token comment">// c 是 unsigned long long 类型  </span>
<span class="token keyword">auto</span> d <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>  <span class="token comment">// d 是 const char* 类型</span>
<span class="token keyword">auto</span> e <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// e 是 std::string 类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="容器类型和迭代器"><a href="#容器类型和迭代器" class="headerlink" title="容器类型和迭代器"></a>容器类型和迭代器</h3><p>auto 和容器类型、迭代器一起配合使用，可以简化代码，代码也更简洁、清晰。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">auto</span> it_begin <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// std::vector&lt;int>::iterator</span>
<span class="token keyword">auto</span> it_end <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// std::vector&lt;int>::iterator</span>
<span class="token keyword">auto</span> sz <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// std::vector&lt;int>::size_type</span>

std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span>list<span class="token operator">&lt;</span>string<span class="token operator">>></span> m<span class="token punctuation">;</span>
<span class="token keyword">auto</span> i <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// std::map&lt;int,list&lt;string>>::iterator</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="引用和-cv-限定符"><a href="#引用和-cv-限定符" class="headerlink" title="引用和 cv 限定符"></a>引用和 cv 限定符</h3><p>特别要注意，使用 <strong><code>auto</code></strong> 会删除引用、 <strong><code>const</code></strong> 限定符和 <strong><code>volatile</code></strong> 限定符。如果定义的对象<strong>不是指针或者引用</strong>，则const属性会被<strong>丢弃</strong>。 请看下面示例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> countRef <span class="token operator">=</span> count<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> myAuto <span class="token operator">=</span> countRef<span class="token punctuation">;</span>

    countRef <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>

    myAuto <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的程序中，myAuto 是一个int，而不是引用int，因此，如果引用限定符尚未被auto删除，则输出11 11，而不是11 12。如果我们希望推导出的auto类型保留<strong>上层const</strong>或引用，我们需要明确指出。例如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码const int i &#x3D; 2;
const auto cvAuto &#x3D; i;  &#x2F;&#x2F; save const
auto&amp; ri &#x3D; i;  &#x2F;&#x2F; save reference<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><p>如果定义的对象<strong>是指针或者引用</strong>，则const属性被<strong>保留</strong>。 <strong>auto关键字与指针</strong>：设置类型为auto的指针，<strong>初始值的const属性仍然保留</strong>。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;
 
int main() &#123;
    int i&#x3D;2;
    const int ci&#x3D;i;
    auto a&#x3D;&amp;i;  &#x2F;&#x2F; a是整型指针(整数的地址就是指向整数的指针)；
    auto b&#x3D;&amp;ci; &#x2F;&#x2F; b是指向整型常量的指针(对const对象取地址是一种底层const)；
    std::cout &lt;&lt; typeid(a).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; Pi
    std::cout &lt;&lt; typeid(b).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; PKi

    &#x2F;&#x2F; 用auto声明指针类型时，用auto和auto *没有任何区别;
    auto *ppi&#x3D;&amp;i;
    auto pi&#x3D;&amp;i;  &#x2F;&#x2F; 两种方式没有差别；
    std::cout &lt;&lt; typeid(ppi).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; Pi
    std::cout &lt;&lt; typeid(pi).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; Pi
    &#x2F;&#x2F;用auto声明引用类型时则必须加&amp;;
    auto &amp;rri&#x3D;i; &#x2F;&#x2F; rri为引用；
    auto ri&#x3D;i;  &#x2F;&#x2F; ri为int；
    std::cout &lt;&lt; typeid(rri).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i
    std::cout &lt;&lt; typeid(ri).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>auto关键字与引用</strong>：在使用auto关键字，使用引用其实是使用引用的对象。特别是当引用被用作初始值时，真正参与初始化的其实是<strong>引用的对象的值</strong>，此时编译器以引用对象的类型作为auto的类型。另外设置类型为auto的引用，<strong>初始值的const属性仍然保留</strong>。例如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;
 
int main() &#123;
    int x &#x3D; 0, &amp;rx &#x3D; x; &#x2F;&#x2F; rx是引用
    auto a1 &#x3D; rx;  &#x2F;&#x2F;使用引用其实是使用引用的对象，
                &#x2F;&#x2F;此时auto以引用对象的类型作为auto的类型，
                &#x2F;&#x2F;所以auto这里被推断为 int;
    auto &amp;a2 &#x3D; rx; &#x2F;&#x2F;此时auto被推断为int类型，a2本身就是int &amp;类型;
    const auto &amp;a3 &#x3D; rx; &#x2F;&#x2F;auto被推断为int类型，a3对象本身是const int &amp;类型;
                   &#x2F;&#x2F;不能通过a3去修改rx引用的对象值;
    std::cout &lt;&lt; typeid(a1).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i
    std::cout &lt;&lt; typeid(a2).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i
    std::cout &lt;&lt; typeid(a3).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i

    int i&#x3D;2; 
	   const int ci&#x3D;i;
    auto &amp;a&#x3D;ci;  &#x2F;&#x2F; 此时auto被推断为const int类型，a本身是const int &amp;类型;
    &#x2F;&#x2F; auto &amp;b&#x3D;42; &#x2F;&#x2F;错误，不能为非const引用绑定字面值；
    const auto &amp;c&#x3D;43; &#x2F;&#x2F;正确，可以为const引用绑定字面值；
    std::cout &lt;&lt; typeid(a).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i
    std::cout &lt;&lt; typeid(c).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="数组和函数"><a href="#数组和函数" class="headerlink" title="数组和函数"></a>数组和函数</h3><p>在一些情况下，数组的操作实际上是<strong>指针的操作</strong>。意味着适用数组作为一个auto变量的初始值时，推断得到的类型是<strong>指针</strong>而非数组。例如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;

int add(int a,int b)&#123; return a+b; &#125;  &#x2F;&#x2F; 函数声明；

int main() &#123;
    int ia[]&#x3D;&#123;1,2,3,4,5&#125;;
    auto ia2(ia); &#x2F;&#x2F; 此时ia2是整型指针，指向ia的第一个元素，
              &#x2F;&#x2F; 相当于auto ia2(&amp;ia[0])；
    std::cout &lt;&lt; typeid(ia2).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; Pi

    decltype(ia) ia3&#x3D;&#123;0,1,2,3,4&#125;; &#x2F;&#x2F; 此时ia3是一个数组，下一篇我们介绍decltype；
    std::cout &lt;&lt; typeid(ia3).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; A5_i

    const char arr[] &#x3D; &quot;I Love China&quot;;
    auto r1 &#x3D; arr; &#x2F;&#x2F; 如果将数组名赋值给auto变量，那么auto推断的结果是指针类型，
               &#x2F;&#x2F; 如果有const属性，则保留，auto推断的结果是const char *；
    auto &amp;r2 &#x3D; arr; &#x2F;&#x2F; 如果将数组名赋值给auto &amp;变量，
               &#x2F;&#x2F; auto &amp;变量的类型是一个数组引用类型，即为const char (&amp;)[14]； 
    std::cout &lt;&lt; typeid(r1).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; PKc
    std::cout &lt;&lt; typeid(r2).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; A13_c


    auto r3 &#x3D; add; &#x2F;&#x2F; r3为函数指针：int(*)(int, int)；
    auto &amp;r4 &#x3D; add; &#x2F;&#x2F; r4为函数引用：int(&amp;)(int, int)；
    std::cout &lt;&lt; typeid(r3).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; PFiiiE
    std::cout &lt;&lt; typeid(r4).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; FiiiE
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>下面的代码示例演示如何使用大括号初始化 <strong><code>auto</code></strong> 变量。 请注意 B 和 C 与 A 与 E 之间的差异。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;

int main()&#123;
    &#x2F;&#x2F; auto初始化表达式可以采用多种形式：
    auto a(1); &#x2F;&#x2F; 直接初始化或构造函数样式的语法，int
    auto b&#123; 2 &#125;;  &#x2F;&#x2F; 通用初始化语法，int
    auto c &#x3D; 3; &#x2F;&#x2F; 赋值语法，int
    auto d &#x3D; &#123; 4 &#125;; &#x2F;&#x2F; 通用赋值语法，是一个列表：std::initializer_list&lt;int&gt;
    std::cout &lt;&lt; typeid(a).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i
    std::cout &lt;&lt; typeid(b).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i
    std::cout &lt;&lt; typeid(c).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; i
    std::cout &lt;&lt; typeid(d).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; St16initializer_listIiE

    auto A &#x3D; &#123; 1, 2 &#125;; &#x2F;&#x2F; std::initializer_list&lt;int&gt;
    auto B &#x3D; &#123; 3 &#125;; &#x2F;&#x2F; std::initializer_list&lt;int&gt;
    auto C&#123; 4 &#125;; &#x2F;&#x2F; int
    std::cout &lt;&lt; typeid(A).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; St16initializer_listIiE
    std::cout &lt;&lt; typeid(B).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; St16initializer_listIiE
    std::cout &lt;&lt; typeid(C).name() &lt;&lt; &#39;\n&#39;;  &#x2F;&#x2F; St16initializer_listIiE

    &#x2F;&#x2F; error: cannot deduce type for &#39;auto&#39; from initializer list&#39;
    auto D &#x3D; &#123; 5, 6.3 &#125;; &#x2F;&#x2F; 不允许两种不同类型
    &#x2F;&#x2F; error in a direct-list-initialization context the type for &#39;auto&#39;
    &#x2F;&#x2F; can only be deduced from a single initializer expression
    auto E&#123; 8, 9 &#125;; &#x2F;&#x2F; 必须要用&#x3D;号
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关键字 auto 是声明具有复杂类型的变量的简单方法。 例如，可用于 auto 声明初始化表达式涉及模板、指向函数的指针或指向成员的指针的变量。 还可以用于 auto 向 lambda 表达式声明和初始化变量。 您不能自行声明变量的类型，因为仅编译器知道 lambda 表达式的类型。 这和<code>auto</code>的一种特殊类型推导有关系。当使用一对花括号来初始化一个<code>auto</code>类型的变量的时候，推导的类型是<code>std::intializer_list</code>。如果这种类型无法被推导（比如在花括号中的变量拥有不同的类型），代码会编译错误。</p>
<h3 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h3><p>以下代码片段声明变量 <code>iter</code> 的类型以及 <code>elem</code> 何时 <strong><code>for</code></strong> 启动范围 <strong><code>for</code></strong> 循环。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码#include <span class="token operator">&lt;</span>vector<span class="token operator">></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">vtDoubleData</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> vtDoubleData<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> vtDoubleData<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>iter<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>

    <span class="token comment">// prefer range-for loops with the following information in mind</span>
    <span class="token comment">// (this applies to any range-for with auto, not just vector, deque, array...)</span>
    <span class="token comment">// COPIES elements, not much better than the previous examples</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> elem <span class="token operator">:</span> vtDoubleData<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>

    <span class="token comment">// observes and/or modifies elements IN-PLACE</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> elem <span class="token operator">:</span> vtDoubleData<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>

    <span class="token comment">// observes elements IN-PLACE</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> elem <span class="token operator">:</span> vtDoubleData<span class="token punctuation">)</span> 
    <span class="token punctuation">&#123;</span> <span class="token comment">/* ... */</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下代码片段使用 new 运算符和指针声明来声明指针：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码#include <span class="token operator">&lt;</span>iostream<span class="token operator">></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">12.34</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> <span class="token operator">*</span>y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> <span class="token operator">*</span><span class="token operator">*</span>z <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">auto</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// d</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// Pd</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// PPd</span>
    <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> v1 <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> v2 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> x <span class="token operator">=</span> v1 <span class="token operator">></span> v2 <span class="token operator">?</span> v1 <span class="token operator">:</span> v2<span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// i</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="auto推导规则"><a href="#auto推导规则" class="headerlink" title="auto推导规则"></a>auto推导规则</h2><p>首先，结论是auto使用的是模板实参推断（Template Argument Deduction）的机制，也就是我们上一篇文章介绍的。auto被一个虚构的模板类型参数T替代，然后进行推断，即相当于把变量设为一个函数参数，将其传递给模板并推断为实参，auto相当于利用了其中进行的实参推断，承担了模板参数T的作用。比如：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码template&lt;typename Container&gt;
void useContainer(const Container&amp; container) &#123;
    auto pos &#x3D; container.begin();  &#x2F;&#x2F; 1
    while (pos !&#x3D; container.end()) &#123;
        auto&amp; element &#x3D; *pos++;  &#x2F;&#x2F; 2
        &#x2F;&#x2F; ... 对元素进行操作
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面第一个auto的初始化相当于下面这个模板传参时的情形，T就是为auto推断的类型：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码<span class="token comment">// 模板声明定义</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">void</span> <span class="token function">deducePos</span><span class="token punctuation">(</span>T pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// auto pos = container.begin()中auto的推导等价于下列语句推导</span>
<span class="token function">deducePos</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而auto类型变量不会是引用类型（int&amp;， float&amp;等），所以要用<code>auto&amp;</code>，第二个auto推断对应于下面这个模板传参时的情形，同样T就是为auto推断的类型:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码template&lt;typename T&gt;
void deduceElement(T&amp; element);

deduceElement(*pos++);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们上一篇文章把模板类型推导划分成三部分，基于在通用的函数模板的<code>ParamType</code>的特性和<code>param</code>的类型声明。在一个用<code>auto</code>声明的变量上，类型声明代替了<code>ParamType</code>的作用，所以也有三种情况：</p>
<ul>
<li>情况1：类型声明是一个指针或者是一个引用，但不是一个通用的引用</li>
<li>情况2：类型声明是一个通用引用</li>
<li>情况3：类型声明既不是一个指针也不是一个引用</li>
</ul>
<p>上面我们已经看了情况1和情况3的例子，如下类似：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码<span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>        <span class="token comment">// 情况3（x既不是指针也不是引用）</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>   <span class="token comment">// 情况3（cx二者都不是）</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> rx <span class="token operator">=</span> x<span class="token punctuation">;</span>  <span class="token comment">// 情况1（rx是一个非通用的引用）</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">*</span> rx <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>  <span class="token comment">// 情况1（rx是一个非通用的指针）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>情况2正如你期待的那样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp复制代码<span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span> 
<span class="token keyword">const</span> <span class="token keyword">auto</span> cx <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref1 <span class="token operator">=</span> x<span class="token punctuation">;</span>   <span class="token comment">// x是int并且是左值，所以uref1的类型是int&amp;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref2 <span class="token operator">=</span> cx<span class="token punctuation">;</span>  <span class="token comment">//cx是int并且是左值，所以uref2的类型是const int&amp;</span>
<span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> uref3 <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span>  <span class="token comment">// 27是int并且是右值，所以uref3的类型是int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然我们上一篇文章还介绍了数组以及函数这两种情形，这两种情形对于auto这里也是适用的，上面我们已经把这两种情形的用法介绍了，这里就不详细介绍它的推导了。</p>
<p>但是，唯一例外的是对初始化列表的推断，auto会将其视为<code>std::initializer_list</code>，而模板则不能对其推断</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;

template&lt;typename T&gt;
void deduceX(T x) &#123;&#125;

int main()&#123;
    auto x &#x3D; &#123; 1, 2 &#125;;  &#x2F;&#x2F; 不允许对auto用initializer_list直接初始化，必须用&#x3D;
    &#x2F;&#x2F; auto x1 &#123; 1, 2 &#125;; &#x2F;&#x2F; 错误
    &#x2F;&#x2F; 保留了单元素列表的直接初始化，但不会将其视为initializer_list，x2是int   
    auto x2 &#123; 1 &#125;;
    std::cout &lt;&lt; typeid(x).name();  &#x2F;&#x2F; class std::initializer_list&lt;int&gt;
    std::cout &lt;&lt; typeid(x2).name();  &#x2F;&#x2F; C++14中为int

    deduceX(&#123; 1, 2 &#125;); &#x2F;&#x2F; 错误：不能推断T
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是，如果你明确模板的<code>param</code>的类型是一个不知道<code>T</code>类型的<code>std::initializer_list&lt;T&gt;</code>：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码#include &lt;iostream&gt;

template&lt;typename T&gt;
void deduceX(std::initializer_list&lt;T&gt; initList) &#123;&#125;

int main()&#123;
    &#x2F;&#x2F; void deduceX&lt;int&gt;(std::initializer_list&lt;int&gt;)
    deduceX(&#123; 1, 2 &#125;); &#x2F;&#x2F; 正确：T是int
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以<code>auto</code>和模板类型推导的本质区别就是<code>auto</code>假设花括号初始化代表的是std::initializer_list，但是模板类型推导却不是。</p>
<p>你们可能对为什么<code>auto</code>类型推导有一个对花括号初始化有一个特殊的规则而模板的类型推导却没有感兴趣。可惜我也没找到答案。这可能就是规则吧，这就意味着你必须记住如果使用<code>auto</code>声明一个变量并且使用花括号来初始化它，类型推导的就是<code>std::initializer_list</code>。在C++11编程里面的一个经典的错误就是误被声明成<code>std::initializer_list</code>，而其实你是想声明另外的一种类型。这个陷阱使得一些开发者仅仅在必要的时候才会在初始化数值周围加上花括号。</p>
<p>C++14还允许auto作为返回类型，但此时auto仍然使用的是模板实参推断的机制，因此返回类型为auto的函数如果返回一个初始化列表，则会出错：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++
复制代码auto newInitList() &#123; return &#123; 1,2 &#125;; &#125; &#x2F;&#x2F; 错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在C++14的lambda里面，当<code>auto</code>用在参数类型声明的时候也是如此：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">c++复制代码std::vector&lt;int&gt; v;
auto resetV &#x3D; [&amp;v](const auto&amp; newValue) &#123; v &#x3D; newValue; &#125; &#x2F;&#x2F; C++14

resetV(&#123; 1, 2, 3 &#125;);   &#x2F;&#x2F; 编译错误，不能推导出&#123; 1, 2, 3 &#125;的类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="什么时候用-auto"><a href="#什么时候用-auto" class="headerlink" title="什么时候用 auto"></a>什么时候用 auto</h2><p>适用的场景：</p>
<ul>
<li>一些类型长度书写很长的，可以用 auto 来简化。例如：</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp
复制代码<span class="token keyword">for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token double-colon punctuation">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果使用auto可以直接写为 :</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp
复制代码<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>当函数返回的值不确定时，可以用auto作为返回值类型，更加方便。编译器会根据返回值的类型推断 auto 的类型，这种语法是在 C++14 才出现的。例如：</li>
</ul>
<pre class="line-numbers language-arduino" data-language="arduino"><code class="language-arduino">arduino
复制代码auto <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>不适用的场景：</p>
<ul>
<li>函数形参不能是auto类型，比如:</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cpp
复制代码<span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">auto</span> a<span class="token punctuation">,</span> <span class="token keyword">auto</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token comment">//是不允许的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>类的非static成员变量不可以是auto类型。类的static成员变量可以是auto类型的，但需要用const修饰，而且该变量需要类内初始化。例如：</li>
</ul>
<pre class="line-numbers language-arduino" data-language="arduino"><code class="language-arduino">arduino复制代码class <span class="token punctuation">&#123;</span>
	auto x <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// error</span>
	auto static const i<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>auto 不能直接用来声明数组。</li>
<li>实例化模板时不能使用auto作为模板参数。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在C++11新标准中引进了auto类型说明符，使用它能够让编译器代替我们去分析<strong>表达式所属的类型</strong>。auto 自动类型推断发生在<strong>编译期</strong>，所以使用 auto 关键字不会降低程序的运行效率。</p>
<p>但是要注意，虽然auto 是一个很强大的工具，但任何工具都有它的两面性，不加选择地随意使用 auto，会带来代码可读性和维护性的严重下降。因此，在使用 auto 的时候，一定要权衡好它带来的“价值”和相应的“损失”。 总的来说, 我认为模板参数推导 (template argument deduction) 和 <code>auto</code> 其实是一回事, 是基于 C++ 类型系统的类型推导 (type inference) 的两个表现形式。</p>
<p>另外，decltype也是 C++11 新增的一个关键字，它和 auto 的功能一样，都是用来在编译时期进行自动类型推导。decltype比auto更确切地推断名称或表达式的类型（即原始的declared type），实现原理和auto类似，只是特殊情况不太一样，具体我们下一篇文章介绍。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/08/22/Effective-Modern-C-1-auto-And-template/">http://charliechen114514.github.io/2023/08/22/Effective-Modern-C-1-auto-And-template/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/23/TCP-IP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941%EF%BC%8C2%EF%BC%8C3/" title="TCP/IP 网络编程笔记——1，2，3"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TCP/IP 网络编程笔记——1，2，3</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/20/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BF%AE%E5%85%BB%E2%80%94%E2%80%94%E5%89%8D%E5%AF%BC/" title="嵌入式C修养——前导"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">嵌入式C修养——前导</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/06/Algorithm-RecursionSpecial/" title="Algorithm_RecursionSpecial"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_RecursionSpecial</div></div></a></div><div><a href="/2023/06/06/Algorithm-in-C-1/" title="Algorithm_in_C(1)"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">Algorithm_in_C(1)</div></div></a></div><div><a href="/2023/06/06/CPP-ExtensiveReadingNotes-1-EssentialCPP/" title="CPP_ExtensiveReadingNotes-1-EssentialCPP"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">CPP_ExtensiveReadingNotes-1-EssentialCPP</div></div></a></div><div><a href="/2023/02/09/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89string-h%E7%B3%BB%E5%88%97/" title="C语言常用函数（1）string.h系列"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-09</div><div class="title">C语言常用函数（1）string.h系列</div></div></a></div><div><a href="/2023/06/06/CPP-ExtensiveReadingNotes-2-MoreEffectiveCPP/" title="CPP_ExtensiveReadingNotes-2-MoreEffectiveCPP"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-06</div><div class="title">CPP_ExtensiveReadingNotes-2-MoreEffectiveCPP</div></div></a></div><div><a href="/2023/09/05/Deep-Qt-Learn-1/" title="Deep Qt Learn-1"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-05</div><div class="title">Deep Qt Learn-1</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Effective-Modern-C"><span class="toc-number">1.</span> <span class="toc-text">Effective Modern C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%88%AB%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.1.</span> <span class="toc-text">理解模板类别推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-1-ParamType%E5%85%B7%E6%9C%89%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E6%98%AF%E5%BC%95%E7%94%A8%E5%9E%8B%E5%88%AB%EF%BC%8C%E4%BD%86%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">Case 1:ParamType具有指针或者是引用型别，但不是一个万能引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#case-2-param%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">case 2: param是一个万能引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E2%80%9D%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">为什么是“万能引用”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0"><span class="toc-number">1.5.</span> <span class="toc-text">引用折叠</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#case-3-param%E6%97%A2%E4%B8%8D%E6%98%AF%E6%8C%87%E9%92%88%E5%8F%88%E4%B8%8D%E6%98%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.5.1.</span> <span class="toc-text">case 3: param既不是指针又不是引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E5%8F%82"><span class="toc-number">1.5.2.</span> <span class="toc-text">数组实参</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3auto%E5%9E%8B%E5%88%AB%E6%8E%A8%E5%AF%BC"><span class="toc-number">1.6.</span> <span class="toc-text">理解auto型别推导</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">2.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">auto用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">容器类型和迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C-cv-%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">2.2.3.</span> <span class="toc-text">引用和 cv 限定符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.4.</span> <span class="toc-text">指针和引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.5.</span> <span class="toc-text">数组和函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.6.</span> <span class="toc-text">复合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.7.</span> <span class="toc-text">更多用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="toc-number">2.3.</span> <span class="toc-text">auto推导规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-auto"><span class="toc-number">2.4.</span> <span class="toc-text">什么时候用 auto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/24/GDB%E5%BF%AB%E6%8D%B7%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/" title="GDB快捷使用小记"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GDB快捷使用小记"/></a><div class="content"><a class="title" href="/2023/12/24/GDB%E5%BF%AB%E6%8D%B7%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/" title="GDB快捷使用小记">GDB快捷使用小记</a><time datetime="2023-12-24T10:08:35.000Z" title="发表于 2023-12-24 18:08:35">2023-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/18/%E4%BD%BF%E7%94%A8std-forward%E4%BC%A0%E9%80%92ofstream/" title="使用std::forward传递ofstream"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用std::forward传递ofstream"/></a><div class="content"><a class="title" href="/2023/12/18/%E4%BD%BF%E7%94%A8std-forward%E4%BC%A0%E9%80%92ofstream/" title="使用std::forward传递ofstream">使用std::forward传递ofstream</a><time datetime="2023-12-18T15:05:33.000Z" title="发表于 2023-12-18 23:05:33">2023-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/18/Visual-Studio%E7%BC%96%E8%AF%91%E9%9D%99%EF%BC%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%8C%87%E5%8D%97%E5%A4%87%E5%BF%98/" title="Visual Studio编译静，动态链接库指南备忘"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Visual Studio编译静，动态链接库指南备忘"/></a><div class="content"><a class="title" href="/2023/12/18/Visual-Studio%E7%BC%96%E8%AF%91%E9%9D%99%EF%BC%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E6%8C%87%E5%8D%97%E5%A4%87%E5%BF%98/" title="Visual Studio编译静，动态链接库指南备忘">Visual Studio编译静，动态链接库指南备忘</a><time datetime="2023-12-18T13:21:13.000Z" title="发表于 2023-12-18 21:21:13">2023-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/14/ImgProcessor%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95-1/" title="ImgProcessor开发记录(1)"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ImgProcessor开发记录(1)"/></a><div class="content"><a class="title" href="/2023/12/14/ImgProcessor%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95-1/" title="ImgProcessor开发记录(1)">ImgProcessor开发记录(1)</a><time datetime="2023-12-14T11:44:05.000Z" title="发表于 2023-12-14 19:44:05">2023-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/03/C-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%93%8D%E4%BD%9C%E6%89%93%E5%8D%B0tuple/" title="C++使用模板操作打印tuple"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++使用模板操作打印tuple"/></a><div class="content"><a class="title" href="/2023/12/03/C-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E6%93%8D%E4%BD%9C%E6%89%93%E5%8D%B0tuple/" title="C++使用模板操作打印tuple">C++使用模板操作打印tuple</a><time datetime="2023-12-03T11:56:05.000Z" title="发表于 2023-12-03 19:56:05">2023-12-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>