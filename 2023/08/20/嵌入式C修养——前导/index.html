<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>嵌入式C修养——前导 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="嵌入式C语言与ARM架构体系前导​        在开始我们嵌入式C语言学习的路程之前,先简单的回顾一下一些工具的简单使用. ​        在嵌入式下,我们经常会使用一些简单的工具,比如说vim, git等等. vim​        vim是我们的一个常用工具,一些操作系统是默认有vim的. 但是我们常见的ubuntu是没有vim 而是只有vi的 ​        啥是vi呢,就是visua">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式C修养——前导">
<meta property="og:url" content="http://charliechen114514.github.io/2023/08/20/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BF%AE%E5%85%BB%E2%80%94%E2%80%94%E5%89%8D%E5%AF%BC/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="嵌入式C语言与ARM架构体系前导​        在开始我们嵌入式C语言学习的路程之前,先简单的回顾一下一些工具的简单使用. ​        在嵌入式下,我们经常会使用一些简单的工具,比如说vim, git等等. vim​        vim是我们的一个常用工具,一些操作系统是默认有vim的. 但是我们常见的ubuntu是没有vim 而是只有vi的 ​        啥是vi呢,就是visua">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-08-20T15:08:58.000Z">
<meta property="article:modified_time" content="2024-01-15T05:58:17.355Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/08/20/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BF%AE%E5%85%BB%E2%80%94%E2%80%94%E5%89%8D%E5%AF%BC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '嵌入式C修养——前导',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-15 13:58:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">嵌入式C修养——前导</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-20T15:08:58.000Z" title="发表于 2023-08-20 23:08:58">2023-08-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-15T05:58:17.355Z" title="更新于 2024-01-15 13:58:17">2024-01-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="嵌入式C修养——前导"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="嵌入式C语言与ARM架构体系"><a href="#嵌入式C语言与ARM架构体系" class="headerlink" title="嵌入式C语言与ARM架构体系"></a>嵌入式C语言与ARM架构体系</h1><h2 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h2><p>​        在开始我们嵌入式C语言学习的路程之前,先简单的回顾一下一些工具的简单使用.</p>
<p>​        在嵌入式下,我们经常会使用一些简单的工具,比如说vim, git等等.</p>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>​        vim是我们的一个常用工具,一些操作系统是默认有vim的. 但是我们常见的ubuntu是没有vim 而是只有vi的</p>
<p>​        啥是vi呢,就是<code>visual interface</code>的一个缩写.我们以前的文本编辑器都是使用行编辑器ex的命令, 后面,我们有了vi来增强他,但是还是会有不少的缺陷.于是我们现在又有了VI improved,就是增强版本.</p>
<p>​        使用如下的命令可以安装vim</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># apt-get install vim</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">vim</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        在其他的Unix系统下,可能使用的包管理器不太一样,这个时候,我们就可以使用对应的包管理来下载vim</p>
<p>​        想查看自己有没有正常的安装,可以使用命令</p>
<pre class="line-numbers language-none"><code class="language-none">vim -v <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        查看版本信息即可</p>
<p>​        这是我的Ubuntu输出的信息</p>
<p><img src="image-20230820145727457.png" alt="image-20230820145727457"></p>
<h3 id="Linux-vi-vim"><a href="#Linux-vi-vim" class="headerlink" title="Linux vi/vim"></a>Linux vi/vim</h3><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p>
<p>但是目前我们使用比较多的是 vim 编辑器。</p>
<p>vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p>
<p>相关文章：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/all-vim-cheatsheat.html">史上最全Vim快捷键键位图 — 入门到进阶</a></p>
<hr>
<h4 id="什么是-vim？"><a href="#什么是-vim？" class="headerlink" title="什么是 vim？"></a>什么是 vim？</h4><p>Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>连 vim 的官方网站 (<a target="_blank" rel="noopener" href="https://www.vim.org/">https://www.vim.org/</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<h4 id="vim-键盘图"><a href="#vim-键盘图" class="headerlink" title="vim 键盘图"></a>vim 键盘图</h4><p><img src="vi-vim-cheat-sheet-sch.gif" alt="img"></p>
<hr>
<h4 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h4><p>基本上 vi/vim 共分为三种模式，<strong>命令模式（Command Mode）、输入模式（Insert Mode）和命令行模式（Command-Line Mode）</strong>。</p>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p><strong>用户刚刚启动 vi/vim，便进入了命令模式。</strong></p>
<p>此状态下敲击键盘动作会被 Vim 识别为命令，而非输入字符，比如我们此时按下 <strong>i</strong>，并不会输入一个字符，<strong>i</strong> 被当作了一个命令。</p>
<p>以下是普通模式常用的几个命令：</p>
<ul>
<li><strong>i</strong> — 切换到输入模式，在光标当前位置开始输入文本。</li>
<li><strong>x</strong> — 删除当前光标所在处的字符。</li>
<li><strong>:</strong> — 切换到底线命令模式，以在最底一行输入命令。</li>
<li><strong>a</strong> — 进入插入模式，在光标下一个位置开始输入文本。</li>
<li><strong>o</strong>：在当前行的下方插入一个新行，并进入插入模式。</li>
<li><strong>O</strong> — 在当前行的上方插入一个新行，并进入插入模式。</li>
<li><strong>dd</strong> — 删除当前行。</li>
<li><strong>yy</strong> — 复制当前行。</li>
<li><strong>p</strong> — 粘贴剪贴板内容到光标下方。</li>
<li><strong>P</strong> — 粘贴剪贴板内容到光标上方。</li>
<li><strong>u</strong> — 撤销上一次操作。</li>
<li><strong>Ctrl + r</strong> — 重做上一次撤销的操作。</li>
<li><strong>:w</strong> — 保存文件。</li>
<li><strong>:q</strong> — 退出 Vim 编辑器。</li>
<li><strong>:q!</strong> — 强制退出Vim 编辑器，不保存修改。</li>
</ul>
<p>若想要编辑文本，只需要启动 Vim，进入了命令模式，按下 <strong>i</strong> 切换到输入模式即可。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠<strong>底线命令行模式</strong>输入更多命令。</p>
<h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>在命令模式下按下 <strong>i</strong> 就进入了输入模式，使用 <strong>Esc</strong> 键可以返回到普通模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及Shift组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li>
<li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li>
<li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<h4 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h4><p>在命令模式下按下 <strong>:</strong>（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li><code>:w</code>：保存文件。</li>
<li><code>:q</code>：退出 Vim 编辑器。</li>
<li><code>:wq</code>：保存文件并退出 Vim 编辑器。</li>
<li><code>:q!</code>：强制退出Vim编辑器，不保存修改。</li>
</ul>
<p>按 <strong>ESC</strong> 键可随时退出底线命令模式。</p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<p><img src="vim-vi-workmodel.png" alt="img"></p>
<hr>
<h4 id="vi-vim-使用实例"><a href="#vi-vim-使用实例" class="headerlink" title="vi/vim 使用实例"></a>vi/vim 使用实例</h4><h5 id="使用-vi-vim-进入一般模式"><a href="#使用-vi-vim-进入一般模式" class="headerlink" title="使用 vi/vim 进入一般模式"></a>使用 vi/vim 进入一般模式</h5><p>如果你想要使用 vi 来建立一个名为 runoob.txt 的文件时，你可以这样做：</p>
<pre class="line-numbers language-none"><code class="language-none">$ vim runoob.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！</p>
<p><img src="078207F0-B204-4464-AAEF-982F45EDDAE9.jpg" alt="img"></p>
<h5 id="按下-i-进入输入模式-也称为编辑模式-，开始编辑文字"><a href="#按下-i-进入输入模式-也称为编辑模式-，开始编辑文字" class="headerlink" title="按下 i 进入输入模式(也称为编辑模式)，开始编辑文字"></a>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</h5><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p>
<p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p>
<p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>
<p><img src="1C928383-471E-4AF1-A61E-9E2CCBD5A913.jpg" alt="img"></p>
<h4 id="按下-ESC-按钮回到一般模式"><a href="#按下-ESC-按钮回到一般模式" class="headerlink" title="按下 ESC 按钮回到一般模式"></a>按下 ESC 按钮回到一般模式</h4><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p>
<h4 id="在一般模式中按下-wq-储存后离开-vi"><a href="#在一般模式中按下-wq-储存后离开-vi" class="headerlink" title="在一般模式中按下 :wq 储存后离开 vi"></a>在一般模式中按下 <strong>:wq</strong> 储存后离开 vi</h4><p>OK，我们要存档了，存盘并离开的指令很简单，输入 <strong>:wq</strong> 即可保存离开！</p>
<p><img src="B2FB5146-327C-4019-AC96-DD7A8EE7460C.jpg" alt="img"></p>
<p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p>
<hr>
<h4 id="vi-vim-按键说明"><a href="#vi-vim-按键说明" class="headerlink" title="vi/vim 按键说明"></a>vi/vim 按键说明</h4><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<h5 id="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td style="text-align:left">j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td style="text-align:left">k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td style="text-align:left">l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td style="text-align:left">如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td style="text-align:left">n<space></td>
<td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td>
</tr>
<tr>
<td style="text-align:left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td style="text-align:left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td style="text-align:left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td style="text-align:left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td style="text-align:left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td style="text-align:left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td style="text-align:left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td style="text-align:left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！ (常用)</td>
</tr>
<tr>
<td style="text-align:left">n<Enter></td>
<td>n 为数字。光标向下移动 n 行(常用)</td>
</tr>
<tr>
<td style="text-align:left">搜索替换</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">/word</td>
<td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td>
</tr>
<tr>
<td style="text-align:left">?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td style="text-align:left">N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
<tr>
<td style="text-align:left">使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">:n1,n2s/word1/word2/g</td>
<td>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)</td>
</tr>
<tr>
<td style="text-align:left"><strong>:1,$s/word1/word2/g</strong> 或 <strong>:%s/word1/word2/g</strong></td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td>
</tr>
<tr>
<td style="text-align:left"><strong>:1,$s/word1/word2/gc</strong> 或 <strong>:%s/word1/word2/gc</strong></td>
<td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td>
</tr>
<tr>
<td style="text-align:left">删除、复制与贴上</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td style="text-align:left">nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td style="text-align:left">dd</td>
<td>剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。</td>
</tr>
<tr>
<td style="text-align:left">ndd</td>
<td>n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p/P 可以粘贴。</td>
</tr>
<tr>
<td style="text-align:left">d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td style="text-align:left">dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td style="text-align:left">d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td style="text-align:left">d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td style="text-align:left">yy</td>
<td>复制游标所在的那一行(常用)</td>
</tr>
<tr>
<td style="text-align:left">nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td style="text-align:left">y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td style="text-align:left">yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td style="text-align:left">y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td style="text-align:left">y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td style="text-align:left">p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td>
</tr>
<tr>
<td style="text-align:left">J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td style="text-align:left">c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td style="text-align:left">u</td>
<td>复原前一个动作。(常用)</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl]+r</td>
<td>重做上一个动作。(常用)</td>
</tr>
<tr>
<td style="text-align:left">这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td>
</tr>
</tbody>
</table>
</div>
<h5 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">i, I</td>
<td>进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td>
</tr>
<tr>
<td style="text-align:left">a, A</td>
<td>进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td style="text-align:left">o, O</td>
<td>进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为在目前光标所在的下一行处输入新的一行； O 为在目前光标所在的上一行处输入新的一行！(常用)</td>
</tr>
<tr>
<td style="text-align:left">r, R</td>
<td>进入取代模式(Replace mode)： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td style="text-align:left">上面这些按键中，在 vi 画面的左下角处会出现『—INSERT—』或『—REPLACE—』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">[Esc]</td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody>
</table>
</div>
<h5 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">指令行的储存、离开等指令</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:w</td>
<td>将编辑的数据写入硬盘档案中(常用)</td>
</tr>
<tr>
<td style="text-align:left">:w!</td>
<td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td>
</tr>
<tr>
<td style="text-align:left">:q</td>
<td>离开 vi (常用)</td>
</tr>
<tr>
<td style="text-align:left">:q!</td>
<td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td>
</tr>
<tr>
<td style="text-align:left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">:wq</td>
<td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td>
</tr>
<tr>
<td style="text-align:left">ZZ</td>
<td>这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出)</td>
</tr>
<tr>
<td style="text-align:left">ZQ</td>
<td>不保存，强制退出。效果等同于 <strong>:q!</strong>。</td>
</tr>
<tr>
<td style="text-align:left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td style="text-align:left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td style="text-align:left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td style="text-align:left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td style="text-align:left">vim 环境的变更</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">:set nu</td>
<td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td>
</tr>
<tr>
<td style="text-align:left">:set nonu</td>
<td>与 set nu 相反，为取消行号！</td>
</tr>
</tbody>
</table>
</div>
<p>特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。</p>
<p>举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。</p>
<h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>​        当你学习到这里的时候,你肯定已经对IDE编译C系语言程序已经是相当的熟悉了,那么下面,我们来简单看看使用GCC编译器编译程序的流程</p>
<p>​        这里是嵌入式C语言学习,意味着我们可能需要交叉编译器</p>
<pre class="line-numbers language-none"><code class="language-none">sudo apt-get install gcc
sudo apt-get install gcc-arm-linux-gnuabi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="image-20230820201431959.png" alt="image-20230820201431959"></p>
<p><img src="image-20230820201549563.png" alt="image-20230820201549563"></p>
<p>​        老样子，查看版本的方式检查我们的安装</p>
<p>​        使用GCC来编译我们的程序，很简单的：</p>
<p>​        好习惯，对于一个单独的测试我们开一个文件夹</p>
<pre class="line-numbers language-none"><code class="language-none">mkdir test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        回车ls一下，你会发现多出了一个test文件夹</p>
<pre class="line-numbers language-none"><code class="language-none">cd test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        上面的这个指令就是切换到test目录下， 下面尝试vim一个.c文件</p>
<pre class="line-numbers language-none"><code class="language-none">vim gcc-try.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        你会看到一个船新的空白的页面。记住，这个时候，显得将模式切换到插入模式：也就是摁I键。</p>
<p>​        你会发现左下角就会有一个INSERT的单词代表现在你可以输入东西了。掏出你的老回忆</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;
&#x2F;* a default test gcc program *&#x2F;

int main()
&#123;

	printf(&quot;Hello, gcc-linux!&quot;); &#x2F;&#x2F; I decide nou to insert a slash here
	return 0;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        你知道的，首先摁ESC键退出，然后<code>:wq</code>一顿操作退出并且保存</p>
<p><img src="image-20230820202610949.png" alt="image-20230820202610949"></p>
<p>​        这是我当时写的，可能有带你不太一样，但是——都是学过C的，这个原理懂的。</p>
<p>​        下面，我们就需要调用GCC连编译他。 GCC一步到位的指令是</p>
<pre class="line-numbers language-none"><code class="language-none">gcc -o $&#123;TARGET&#125; $&#123;SOURCE&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        试一下</p>
<pre class="line-numbers language-none"><code class="language-none">gcc -o gcc-try gcc-try.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果你没什么语法错误，这一步将会相当的平和和迅速。</p>
<p>​        ls一下：</p>
<p><img src="image-20230820202838867.png" alt="image-20230820202838867"></p>
<p>​        你瞧，多出来了一个gcc-try，就是我们指定的那样。对于可执行文件，我们所作的就是：</p>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;gcc-try<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        呐！</p>
<p><img src="image-20230820203022896.png" alt="image-20230820203022896"></p>
<p>​        gcc当然还有其他的活！</p>
<h3 id="扩展GCC：常用命令"><a href="#扩展GCC：常用命令" class="headerlink" title="扩展GCC：常用命令"></a>扩展GCC：常用命令</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/606058690">Linux GCC常用命令 - 知乎 (zhihu.com)</a></p>
<h4 id="1简介"><a href="#1简介" class="headerlink" title="1简介"></a><strong>1简介</strong></h4><p>GCC 的意思也只是 GNU C Compiler 而已。经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语言、C++ 语言、Java 语言、Objective C 语言、Pascal 语言、COBOL语言，以及支持函数式编程和逻辑编程的 Mercury 语言，等等。而 GCC 也不再单只是 GNU C 语言编译器的意思了，而是变成了 GNU Compiler Collection 也即是 GNU 编译器家族的意思了。另一方面，说到 GCC 对于操作系统平台及硬件平台支持，概括起来就是一句话：无所不在。</p>
<h4 id="2简单编译"><a href="#2简单编译" class="headerlink" title="2简单编译"></a><strong>2简单编译</strong></h4><p>示例程序如下：<br>//test.c<br>#include <stdio.h><br>int main(void)<br>{<br>printf(“Hello World!\n”);<br>return 0;<br>}</p>
<p>这个程序，一步到位的编译指令是:</p>
<p>gcc test.c -o test</p>
<p>实质上，上述编译过程是分为四个阶段进行的，即预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。</p>
<p><strong>2.1预处理</strong></p>
<p>gcc -E test.c -o test.i 或 gcc -E test.c</p>
<p>可以输出test.i文件中存放着test.c经预处理之后的代码。打开test.i文件，看一看，就明白了。后面那条指令，是直接在命令行窗口中输出预处理后的代码.</p>
<p>gcc的-E选项，可以让编译器在预处理后停止，并输出预处理结果。在本例中，预处理结果就是将stdio.h 文件中的内容插入到test.c中了。</p>
<p><strong>2.2编译为汇编代码(Compilation)</strong></p>
<p>预处理之后，可直接对生成的test.i文件编译，生成汇编代码：</p>
<p>gcc -S test.i -o test.s</p>
<p>gcc的-S选项，表示在程序编译期间，在生成汇编代码后，停止，-o输出汇编代码文件。</p>
<h5 id="2-3汇编-Assembly"><a href="#2-3汇编-Assembly" class="headerlink" title="2.3汇编(Assembly)"></a><strong>2.3汇编(Assembly)</strong></h5><p>对于上一小节中生成的汇编代码文件test.s，gas汇编器负责将其编译为目标文件，如下：</p>
<p>gcc -c test.s -o test.o</p>
<h5 id="2-4连接-Linking"><a href="#2-4连接-Linking" class="headerlink" title="2.4连接(Linking)"></a><strong>2.4连接(Linking)</strong></h5><p>gcc连接器是gas提供的，负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p>
<p>对于上一小节中生成的test.o，将其与Ｃ标准输入输出库进行连接，最终生成程序test</p>
<p>gcc test.o -o test</p>
<p>在命令行窗口中，执行./test, 让它说HelloWorld吧！</p>
<h4 id="3多个程序文件的编译"><a href="#3多个程序文件的编译" class="headerlink" title="3多个程序文件的编译"></a><strong>3多个程序文件的编译</strong></h4><p>通常整个程序是由多个源文件组成的，相应地也就形成了多个编译单元，使用GCC能够很好地管理这些编译单元。假设有一个由test1.c和 test2.c两个源文件组成的程序，为了对它们进行编译，并最终生成可执行程序test，可以使用下面这条命令：</p>
<p>gcc test1.c test2.c -o test</p>
<p>如果同时处理的文件不止一个，GCC仍然会按照预处理、编译和链接的过程依次进行。如果深究起来，上面这条命令大致相当于依次执行如下三条命令：</p>
<p>gcc -c test1.c -o test1.o<br>gcc -c test2.c -o test2.o<br>gcc test1.o test2.o -o test</p>
<h4 id="4检错"><a href="#4检错" class="headerlink" title="4检错"></a><strong>4检错</strong></h4><p>gcc -pedantic illcode.c -o illcode</p>
<p>-pedantic编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，-pedantic选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。</p>
<p>除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多的警告信息。</p>
<p>gcc -Wall illcode.c -o illcode</p>
<p>GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：</p>
<p>gcc -Werror test.c -o test</p>
<h4 id="5库文件连接"><a href="#5库文件连接" class="headerlink" title="5库文件连接"></a><strong>5库文件连接</strong></h4><p>开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。。虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的办法来查找所需要的头文件和库文件。</p>
<p>例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件libmysqlclient.so</p>
<p>其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/mysql/lib</p>
<h5 id="5-1编译成可执行文件"><a href="#5-1编译成可执行文件" class="headerlink" title="5.1编译成可执行文件"></a><strong>5.1编译成可执行文件</strong></h5><p>首先我们要进行编译test.c为目标文件，这个时候需要执行</p>
<p>gcc –c –I /usr/dev/mysql/include test.c –o test.o</p>
<h5 id="5-2链接"><a href="#5-2链接" class="headerlink" title="5.2链接"></a><strong>5.2链接</strong></h5><p>最后我们把所有目标文件链接成可执行文件:</p>
<p>gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test</p>
<p>Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。</p>
<h5 id="5-3强制链接时使用静态链接库"><a href="#5-3强制链接时使用静态链接库" class="headerlink" title="5.3强制链接时使用静态链接库"></a><strong>5.3强制链接时使用静态链接库</strong></h5><p>默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。</p>
<p>在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:</p>
<p>gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test</p>
<p>静态库链接时搜索路径顺序：</p>
<p>\1. ld会去找GCC命令中的参数-L<br>\2. 再找gcc的环境变量LIBRARY_PATH<br>\3. 再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</p>
<p>动态链接时、执行时搜索路径顺序:</p>
<p>\1. 编译目标代码时指定的动态库搜索路径<br>\2. 环境变量LD_LIBRARY_PATH指定的动态库搜索路径<br>\3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径<br>\4. 默认的动态库搜索路径/lib<br>\5. 默认的动态库搜索路径/usr/lib</p>
<p>有关环境变量：<br>LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径<br>LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径</p>
<h2 id="扩展结束"><a href="#扩展结束" class="headerlink" title="扩展结束"></a>扩展结束</h2><p>​        我们来尝试一个：</p>
<pre class="line-numbers language-none"><code class="language-none">gcc -E -C gcc-try.c &gt; gcc-try.i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        回忆下（或者找我的博客，这里用到了文件重定向符的知识）</p>
<p>​        我们这行指令的意思，就是保留注释的，将<code>gcc-try.c</code>进行预处理产生的结果输出到gcc-try.i文件里去。这恰恰验证了一个事情：就是#include就是将被包含文件的代码粘贴到目标源文件上去</p>
<h2 id="手撸MakeFile"><a href="#手撸MakeFile" class="headerlink" title="手撸MakeFile"></a>手撸MakeFile</h2><p>​        我们尝试一下MakeFile.体验下感觉。</p>
<p>​        我们知道，我们往往回去编译一些大的工程：比如说Linux内核这种，不幸的是，他有大约30000个源文件，还有数不清的链接关系，那怎么编译呢。</p>
<p>​        所以，我们请出战神makefile!</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>​        先来整个最简单最简单的：整数相加工程</p>
<pre class="line-numbers language-none"><code class="language-none">vim add.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#ifndef _ADD_H_
#define _ADD_H_

int add(int num1, int num2);

#endid<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">vim add.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;add.h&quot;

int add(int num1, int num2)
&#123;
	
	return num1  + num2;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">vim main.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &quot;add.h&quot;

int main()
&#123;
    int a &#x3D; 1;
    int b &#x3D; 2;
	printf(&quot;We test the function add: %d + %d &#x3D; %d&quot;,a, b, add(a, b));
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        好，到这里，我们可以开始整活了，手撸一个Makefile</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> all clean
<span class="token target symbol">all</span><span class="token punctuation">:</span> hello
<span class="token target symbol">hello</span><span class="token punctuation">:</span> main.o add.o
	gcc -o hello main.o add.o
<span class="token target symbol">main.o</span><span class="token punctuation">:</span> main.c
	gcc -c main.c
<span class="token target symbol">add.o</span><span class="token punctuation">:</span> add.c
	gcc -c add.c
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	rm -f main.o add.o hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        makefile是由一个个规则而来的，最通用的格式如下</p>
<pre class="line-numbers language-none"><code class="language-none">target: rely
	command<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        我们一般说目标是我们要生成的可执行文件或者是各个源文件所对应的目标文件</p>
<p>​        命令可以很多样：可以是编译命令，可以是链接命令，还可以是shell命令。</p>
<p>​        上面的.PHONY则是声明了一个伪目标（不是一个真正的存在的文件），可以看作是一个目标，一般选择第一个目标作为默认的目标</p>
<p>​        我们把Makefile放到跟源码目录同级的地方，然后，你知道的：</p>
<pre class="line-numbers language-none"><code class="language-none">make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        MakeFile, 启动！</p>
<p><img src="image-20230820211236073.png" alt="image-20230820211236073"></p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>​        啥是Git，简单来讲，托管代码的，我们的工程开发中常常可能会需要代码更改和管理。这玩意就是方便我们的管理而产生的。安装git 很简单</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        然后，我们需要声明一下，我们是谁：</p>
<pre class="line-numbers language-none"><code class="language-none">git config --global user_email 114514@xb.com
git config --global user_name Tiansuohaoer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        —global: 配置 ~/.gitconfig文件，对当前用户下所有的仓库都有效</p>
<p>​        —system: 配置 /etc/gitconfig文件，对所有系统下的用户都生效</p>
<p>​        不配置则是只对当前的仓库生效</p>
<h2 id="常用的Git命令"><a href="#常用的Git命令" class="headerlink" title="常用的Git命令"></a>常用的Git命令</h2><pre class="line-numbers language-none"><code class="language-none">git init: 创建一个本地仓库
git add [FILES]: 添加文件到保护区
git commit : 提交更改到本地仓库
git log: 查看历史
git show commit_id: 根据提交ID查看提交的详细信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        当然，我们从头讲起</p>
<p>​        简单的讲，我们的仓库代码分为三个部分：工作区，暂存区和版本库。现在，我们干活:</p>
<pre class="line-numbers language-none"><code class="language-none">mkdir gitProject
cd .&#x2F;gitProject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        我这边有个Git联系仓库，我们先把远程仓库克隆下来</p>
<pre class="line-numbers language-none"><code class="language-none">git clone https:&#x2F;&#x2F;github.com&#x2F;Charliechen114514&#x2F;git-study-lol.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们先看看看这个仓库里有什么</p>
<p><img src="image-20230820214600945.png" alt="image-20230820214600945"></p>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>​        啥？git clone 的速度太感人了？简单：我们之所以访问github慢，是因为我们的特色的DNS污染，导致我们的访问速度感人，那么，我们只需要修改一下hosts，就可以解决问题。</p>
<p>​        首先可以查找一下github域名解析的结果有哪些（自行找网站查）</p>
<pre class="line-numbers language-none"><code class="language-none">140.82.114.3    github.com
185.199.108.153    assets-cdn.github.com
199.232.69.194    github.global.ssl.fastly.net<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        至少这几个目前管用，听说github时常换解析。可能需要经常更新。</p>
<p>​        然后，记得重启一下network-manager（我的是NetWork-manager管理我的Ubuntu操作系统的网络，所以我重启这个，查看自己的网络管理器，修改就好）</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;etc&#x2F;NetworkManager restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        完事。</p>
<pre class="line-numbers language-none"><code class="language-none">ping github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230820215241368.png" alt="image-20230820215241368"></p>
<p>​        应该不算太卡。</p>
<p>​        好，现在，我们以这个作为基底，整一个本地仓库：</p>
<pre class="line-numbers language-none"><code class="language-none">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    <img src="image-20230820221557705.png" alt="image-20230820221557705"></p>
<pre class="line-numbers language-none"><code class="language-none">ls -a # 查看所有文件（.&#x2F;git是一个隐藏文件夹，所以需要这样搞）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230820221712941.png" alt="image-20230820221712941"></p>
<p>​        现在，我们加上一个文件，比如说——我们测试一下g++是不是正常的，我们把文件整理一下</p>
<pre class="line-numbers language-none"><code class="language-none">mkdir Vector
mv .&#x2F;*.hpp .&#x2F;Vector
mv .&#x2F;*.cpp .&#x2F;Vector
mkdir GppTest
cd GppTest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样就会有上面的效果了（当然现在clone  下来的就已经分类好了）</p>
<pre class="line-numbers language-none"><code class="language-none">vim gppTest.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;iosstream&gt;

int main()&#123;
	std::cout &lt;&lt; &quot;This is a g++ &amp;&amp; git test&quot; &lt;&lt; std::endl;
&#125;
&#x2F;&#x2F; ESC ,:wq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">g++ -o GPPTEST GppTest.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">.&#x2F;GPPTEST<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="image-20230820222153359.png" alt="image-20230820222153359"></p>
<p>​        不难的，不是吗。</p>
<p>​        下面，我们添加所有的文件到暂存区去</p>
<pre class="line-numbers language-none"><code class="language-none">git add .
git status # 查看状态如何<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="image-20230820222428463.png" alt="image-20230820222428463"></p>
<p>​        然后，提交到git本地仓库去</p>
<pre class="line-numbers language-none"><code class="language-none">git commit -m &quot;MSG&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​    <img src="image-20230820222543504.png" alt="image-20230820222543504"></p>
<p>​        下面，我们指定一下本次提交的远程仓库</p>
<p><img src="image-20230820222728347.png" alt="image-20230820222728347"></p>
<p>​        欢乐push</p>
<pre class="line-numbers language-none"><code class="language-none">git push -u gitProject master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        完事。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/135183491">Git 使用教程：最详细、最傻瓜、最浅显、真正手把手教！（万字长文） - 知乎 (zhihu.com)</a></p>
<h2 id="一：Git是什么？"><a href="#一：Git是什么？" class="headerlink" title="一：Git是什么？"></a><strong>一：Git是什么？</strong></h2><p>Git是目前世界上最先进的分布式版本控制系统。</p>
<p>工作原理 / 流程：</p>
<p><img src="v2-4f61dac0b425ebe34efc88d11a68f27b_1440w-1692537350247-379.webp" alt="img"></p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h2 id="二：SVN与Git的最主要的区别？"><a href="#二：SVN与Git的最主要的区别？" class="headerlink" title="二：SVN与Git的最主要的区别？"></a><strong>二：SVN与Git的最主要的区别？</strong></h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p>
<p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<h2 id="三、在windows上如何安装Git？"><a href="#三、在windows上如何安装Git？" class="headerlink" title="三、在windows上如何安装Git？"></a><strong>三、在windows上如何安装Git？</strong></h2><p>msysgit是 windows版的Git,如下：</p>
<p><img src="v2-70a91b73789275b2b2f454c722670c3b_1440w-1692537350247-381.webp" alt="img"></p>
<p>需要从网上下载一个，然后进行默认安装即可。安装完成后，在开始菜单里面找到 “Git —&gt; Git Bash”会弹出一个类似的命令窗口的东西，就说明Git安装成功。如下：</p>
<p><img src="v2-daaedb3f59e70a1faf4dbc4446fb4bb2_1440w-1692537350247-384.webp" alt="img"></p>
<p>安装完成后，还需要最后一步设置，在命令行输入如下：</p>
<p><img src="v2-bdd873dd845c3f073849155c0963073c_1440w-1692537350247-386.webp" alt="img"></p>
<p>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p>
<p>注意：git config —global 参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p>
<h2 id="四：如何操作？"><a href="#四：如何操作？" class="headerlink" title="四：如何操作？"></a><strong>四：如何操作？</strong></h2><h2 id="一：创建版本库。"><a href="#一：创建版本库。" class="headerlink" title="一：创建版本库。"></a><strong>一：创建版本库。</strong></h2><p>什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。</p>
<p>所以创建一个版本库也非常简单，如下我是D盘 –&gt; www下 目录下新建一个testgit版本库。</p>
<p><img src="v2-ff7970ec6ba1fe08f2aa85d5c492d4e8_1440w-1692537350247-388.webp" alt="img"></p>
<p>pwd 命令是用于显示当前的目录。</p>
<p>通过命令 git init 把这个目录变成git可以管理的仓库，如下：</p>
<p><img src="v2-11477dcb7b5a41ed736723bce7591ce7_1440w-1692537350248-390.webp" alt="img"></p>
<p>这时候你当前testgit目录下会多了一个.git的目录，这个目录是Git来跟踪管理版本的，没事千万不要手动乱改这个目录里面的文件，否则，会把git仓库给破坏了。如下：</p>
<p><img src="v2-de09c7374f69dff1eb382c90fb5453ea_1440w-1692537350248-392.webp" alt="img"></p>
<p>下面先看下demo如下演示：</p>
<p>我在版本库testgit目录下新建一个记事本文件 readme.txt 内容如下：11111111</p>
<p>第一步：使用命令 git add readme.txt添加到暂存区里面去。如下：</p>
<p><img src="v2-45c5f787266917a66b019ed2e527b54e_1440w-1692537350248-394.webp" alt="img"></p>
<p>如果和上面一样，没有任何提示，说明已经添加成功了。</p>
<p>第二步：用命令 git commit告诉Git，把文件提交到仓库。</p>
<p><img src="v2-3e7db42a3a3084b913b09d501eba4162_1440w-1692537350248-396.webp" alt="img"></p>
<p>现在我们已经提交了一个readme.txt文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：</p>
<p><img src="v2-babc2bfc4a8cab014316dd9686cb77e8_1440w-1692537350248-398.webp" alt="img"></p>
<p>说明没有任何文件未提交，但是我现在继续来改下readme.txt内容，比如我在下面添加一行2222222222内容，继续使用git status来查看下结果，如下：</p>
<p><img src="v2-6c63e31ec6931349c70b15280719ac91_1440w-1692537350248-400.webp" alt="img"></p>
<p>上面的命令告诉我们 readme.txt文件已被修改，但是未被提交的修改。</p>
<p>把文件添加到版本库中。</p>
<p>首先要明确下，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件，网页，所有程序的代码等，Git也不列外，版本控制系统可以告诉你每次的改动，但是图片，视频这些二进制文件，虽能也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是知道图片从1kb变成2kb，但是到底改了啥，版本控制也不知道。</p>
<p>接下来我想看下readme.txt文件到底改了什么内容，如何查看呢？可以使用如下命令：</p>
<p>git diff readme.txt 如下：</p>
<p><img src="v2-de35f9aa38e4fafa28d9530b40ff4938_1440w-1692537350248-402.webp" alt="img"></p>
<p>如上可以看到，readme.txt文件内容从一行11111111改成 二行 添加了一行22222222内容。</p>
<p>知道了对readme.txt文件做了什么修改后，我们可以放心的提交到仓库了，提交修改和提交文件是一样的2步(第一步是git add 第二步是：git commit)。</p>
<p>如下：</p>
<p><img src="v2-f1b908bcd6ad00b24865de6ebbcb25fd_1440w-1692537350248-404.webp" alt="img"></p>
<h2 id="二：版本回退："><a href="#二：版本回退：" class="headerlink" title="二：版本回退："></a><strong>二：版本回退：</strong></h2><p>如上，我们已经学会了修改文件，现在我继续对readme.txt文件进行修改，再增加一行内容为33333333333333</p>
<p>现在我已经对readme.txt文件做了三次修改了，那么我现在想查看下历史记录，如何查呢？我们现在可以使用命令 git log 演示如下所示：</p>
<p><img src="v2-cb45508f26591db4d3bf466b1c8038c9_1440w-1692537350248-406.webp" alt="img"></p>
<p>git log命令显示从最近到最远的显示日志，我们可以看到最近三次提交，最近的一次是,增加内容为333333.上一次是添加内容222222，第一次默认是 111111.如果嫌上面显示的信息太多的话，我们可以使用命令 git log –pretty=oneline 演示如下：</p>
<p><img src="v2-d93f3959e90828a564d937ea14531aae_1440w-1692537350248-408.webp" alt="img"></p>
<p>现在我想使用版本回退操作，我想把当前的版本回退到上一个版本，要使用什么命令呢？可以使用如下2种命令，第一种是：git reset —hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset —hard HEAD~100 即可。未回退之前的readme.txt内容如下：</p>
<p><img src="v2-9e4a6141c2b535b611370b630617aedf_1440w-1692537350248-410.webp" alt="img"></p>
<p>如果想回退到上一个版本的命令如下操作：</p>
<p><img src="v2-7068989f6728f00654f7527cb6577956_1440w-1692537350248-412.webp" alt="img"></p>
<p>再来查看下 readme.txt内容如下：通过命令cat readme.txt查看</p>
<p><img src="v2-38e4dc805a5e86793a968c515081c16a_1440w.jpeg" alt="img"></p>
<p>可以看到，内容已经回退到上一个版本了。我们可以继续使用git log 来查看下历史记录信息，如下：</p>
<p><img src="v2-24f6d3f8e7a36ea0b3b935deb087c4de_1440w-1692537350248-415.webp" alt="img"></p>
<p>我们看到 增加333333 内容我们没有看到了，但是现在我想回退到最新的版本，如：有333333的内容要如何恢复呢？我们可以通过版本号回退，使用命令方法如下：</p>
<p>git reset —hard 版本号 ，但是现在的问题假如我已经关掉过一次命令行或者333内容的版本号我并不知道呢？要如何知道增加3333内容的版本号呢？可以通过如下命令即可获取到版本号：git reflog 演示如下：</p>
<p><img src="v2-215458338ded9193d0865a0937102fba_1440w-1692537350248-417.webp" alt="img"></p>
<p>通过上面的显示我们可以知道，增加内容3333的版本号是 6fcfc89.我们现在可以命令</p>
<p>git reset —hard 6fcfc89来恢复了。演示如下：</p>
<p><img src="v2-5416a5b7fce0cbf525b89c79a2c79857_1440w-1692537350248-419.webp" alt="img"></p>
<p>可以看到 目前已经是最新的版本了。</p>
<h2 id="三：理解工作区与暂存区的区别？"><a href="#三：理解工作区与暂存区的区别？" class="headerlink" title="三：理解工作区与暂存区的区别？"></a><strong>三：理解工作区与暂存区的区别？</strong></h2><ul>
<li>工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</li>
<li>版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</li>
</ul>
<p>我们前面说过使用Git提交文件到版本库有两步：</p>
<ol>
<li>是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。</li>
<li>使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。</li>
</ol>
<p>我们继续使用demo来演示下：</p>
<p>我们在readme.txt再添加一行内容为4444444，接着在目录下新建一个文件为test.txt 内容为test，我们先用命令 git status来查看下状态，如下：</p>
<p><img src="v2-ed23c551370326d29f13e0f662e903df_1440w-1692537350248-421.webp" alt="img"></p>
<p>现在我们先使用git add 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：</p>
<p><img src="v2-a7e91944849ebc009fd25d7fe95a1e42_1440w-1692537350248-423.webp" alt="img"></p>
<p>接着我们可以使用git commit一次性提交到分支上，如下：</p>
<p><img src="v2-13d5b4db326d192d97ff4a52480a914f_1440w-1692537350248-425.webp" alt="img"></p>
<h2 id="四：Git撤销修改和删除文件操作"><a href="#四：Git撤销修改和删除文件操作" class="headerlink" title="四：Git撤销修改和删除文件操作"></a><strong>四：Git撤销修改和删除文件操作</strong></h2><h2 id="一：撤销修改："><a href="#一：撤销修改：" class="headerlink" title="一：撤销修改："></a><strong>一：撤销修改：</strong></h2><p>比如我现在在readme.txt文件里面增加一行 内容为555555555555，我们先通过命令查看如下：</p>
<p><img src="v2-e1a53a233580c18437ddc14a2a87d7ac_1440w-1692537350248-427.webp" alt="img"></p>
<p>在我未提交之前，我发现添加5555555555555内容有误，所以我得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p>
<ol>
<li>如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。</li>
<li>我可以按以前的方法直接恢复到上一个版本。使用 git reset —hard HEAD^</li>
</ol>
<p>但是现在我不想使用上面的2种方法，我想直接想使用撤销命令该如何操作呢？首先在做撤销之前，我们可以先用 git status 查看下当前的状态。如下所示：</p>
<p><img src="v2-e3c10eb402b7974609d8e2dcc74b6214_1440w-1692537350248-429.webp" alt="img"></p>
<p>可以发现，Git会告诉你，git checkout — file 可以丢弃工作区的修改，如下命令：</p>
<p>git checkout — readme.txt,如下所示：</p>
<p><img src="v2-b364f12ef91cc1ebb9a1ddac11e379c5_1440w-1692537350248-431.webp" alt="img"></p>
<p>命令 git checkout —readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销，这里有2种情况，如下：</p>
<ol>
<li>readme.txt自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。</li>
<li>另外一种是readme.txt已经放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态</li>
</ol>
<p>对于第二种情况，我想我们继续做demo来看下，假如现在我对readme.txt添加一行 内容为6666666666666，我git add 增加到暂存区后，接着添加内容7777777，我想通过撤销命令让其回到暂存区后的状态。如下所示：</p>
<p><img src="v2-662af880828c52e92e355c5fbaa97d00_1440w-1692537350248-433.webp" alt="img"></p>
<p>注意：命令git checkout — readme.txt 中的 — 很重要，如果没有 — 的话，那么命令变成创建分支了。</p>
<h2 id="二：删除文件"><a href="#二：删除文件" class="headerlink" title="二：删除文件"></a><strong>二：删除文件</strong></h2><p>假如我现在版本库testgit目录添加一个文件b.txt,然后提交。如下：</p>
<p><img src="v2-5b4a1389f02045d431fd10dfabe5e366_1440w-1692537350248-435.webp" alt="img"></p>
<p>如上：一般情况下，可以直接在文件目录中把文件删了，或者使用如上rm命令：rm b.txt ，如果我想彻底从版本库中删掉了此文件的话，可以再执行commit命令 提交掉，现在目录是这样的，</p>
<p><img src="v2-d27fcfaf70c28e90d138e26badd2d6e6_1440w-1692537350248-437.webp" alt="img"></p>
<p>只要没有commit之前，如果我想在版本库中恢复此文件如何操作呢？</p>
<p>可以使用如下命令 git checkout — b.txt，如下所示：</p>
<p><img src="v2-b959d2af16e2779b07869353b78ecc84_1440w.jpeg" alt="img"></p>
<p>再来看看我们testgit目录，添加了3个文件了。如下所示：</p>
<p><img src="v2-014dc55563b04b2453bcd84841072fd7_1440w-1692537350248-440.webp" alt="img"></p>
<h2 id="五：远程仓库"><a href="#五：远程仓库" class="headerlink" title="五：远程仓库"></a><strong>五：远程仓库</strong></h2><p>在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：</p>
<p>第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：</p>
<p>ssh-keygen -t rsa –C “youremail@example.com”, 由于我本地此前运行过一次，所以本地有，如下所示：</p>
<p><img src="v2-b2bd43e875e921a2d62ed6f89025919e_1440w.jpeg" alt="img"></p>
<p>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>第二步：登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。</p>
<p><img src="v2-6dc17124a790b2bd358dc5245da8af43_1440w-1692537350249-443.webp" alt="img"></p>
<p>点击 Add Key，你就应该可以看到已经添加的key。</p>
<p><img src="v2-e8724f6557b8efdf2dc402d76d443962_1440w-1692537350249-445.webp" alt="img"></p>
<h2 id="如何添加远程库？"><a href="#如何添加远程库？" class="headerlink" title="如何添加远程库？"></a><strong>如何添加远程库？</strong></h2><p>现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。</p>
<p>首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。如下：</p>
<p><img src="v2-cf6df573d9098b8a47c87589d0705429_1440w-1692537350249-447.webp" alt="img"></p>
<p>在Repository name填入testgit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p><img src="v2-f0da99e1a8cb0f6eed619a84e72fe047_1440w-1692537350249-449.webp" alt="img"></p>
<p>目前，在GitHub上的这个testgit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的testgit仓库下运行命令：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">git remote add origin https://github.com/tugenhua0707/testgit.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>所有的如下：</p>
<p><img src="v2-8f745d6400ea37c25058ce4a1383e7ac_1440w-1692537350249-451.webp" alt="img"></p>
<p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。</p>
<p>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：</p>
<p><img src="v2-9c100c2fe1fe45f7175f8fa2f400882e_1440w-1692537350249-453.webp" alt="img"></p>
<p>从现在起，只要本地作了提交，就可以通过如下命令：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。</p>
<h2 id="如何从远程库克隆？"><a href="#如何从远程库克隆？" class="headerlink" title="如何从远程库克隆？"></a><strong>如何从远程库克隆？</strong></h2><p>上面我们了解了先有本地库，后有远程库时候，如何关联远程库。</p>
<p>现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？</p>
<p>首先，登录github，创建一个新的仓库，名字叫testgit2.如下：</p>
<p><img src="v2-7dd99200b98a20178b4f89fe9ca66dfa_1440w-1692537350249-455.webp" alt="img"></p>
<p>如下，我们看到：</p>
<p><img src="v2-73b7641802c7801295d8b8f346165af1_1440w-1692537350249-457.webp" alt="img"></p>
<p>现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：</p>
<p><img src="v2-eed3b1479f3a70a7edf79c88d6cb3df7_1440w-1692537350249-459.webp" alt="img"></p>
<p>接着在我本地目录下 生成testgit2目录了，如下所示：</p>
<p><img src="v2-215ce5fa4304f72aab370ed949a96605_1440w-1692537350249-461.webp" alt="img"></p>
<h2 id="六：创建与合并分支"><a href="#六：创建与合并分支" class="headerlink" title="六：创建与合并分支"></a><strong>六：创建与合并分支</strong></h2><p>在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>首先，我们来创建dev分支，然后切换到dev分支上。如下操作：</p>
<p><img src="v2-c8b668d0bac8600a6db8a187c5ef02d9_1440w-1692537350249-463.webp" alt="img"></p>
<p>git checkout命令加上 –b参数表示创建并切换，相当于如下2条命令</p>
<ol>
<li>git branch dev</li>
<li>git checkout dev</li>
</ol>
<p>git branch查看分支，会列出所有的分支，当前分支前面会添加一个星号。然后我们在dev分支上继续做demo，比如我们现在在readme.txt再增加一行 7777777777777</p>
<p>首先我们先来查看下readme.txt内容，接着添加内容77777777，如下：</p>
<p><img src="v2-409a7acb8ddc28687c6406b475ab954c_1440w-1692537350249-465.webp" alt="img"></p>
<p>现在dev分支工作已完成，现在我们切换到主分支master上，继续查看readme.txt内容如下：</p>
<p><img src="v2-50074e45f108bb246a76deb9be2dc4f7_1440w-1692537350249-467.webp" alt="img"></p>
<p>现在我们可以把dev分支上的内容合并到分支master上了，可以在master分支上，使用如下命令 git merge dev 如下所示：</p>
<p><img src="v2-df606def3d16dd7eee4728cd2a8c283b_1440w-1692537350249-469.webp" alt="img"></p>
<p>git merge命令用于合并指定分支到当前分支上，合并后，再查看readme.txt内容，可以看到，和dev分支最新提交的是完全一样的。</p>
<p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p>
<p>合并完成后，我们可以接着删除dev分支了，操作如下：</p>
<p><img src="v2-c7b799a096de8ae1d7c5fb6a7787ff83_1440w-1692537350249-471.webp" alt="img"></p>
<p>总结创建与合并分支命令如下：</p>
<ul>
<li>查看分支：git branch</li>
<li>创建分支：git branch name</li>
<li>切换分支：git checkout name</li>
<li>创建+切换分支：git checkout –b name</li>
<li>合并某分支到当前分支：git merge name</li>
<li>删除分支：git branch –d name</li>
</ul>
<h2 id="如何解决冲突？"><a href="#如何解决冲突？" class="headerlink" title="如何解决冲突？"></a><strong>如何解决冲突？</strong></h2><p>下面我们还是一步一步来，先新建一个新分支，比如名字叫fenzhi1，在readme.txt添加一行内容8888888，然后提交，如下所示：</p>
<p><img src="v2-70a250bbf159121aa7503189c3011baa_1440w-1692537350249-473.webp" alt="img"></p>
<p>同样，我们现在切换到master分支上来，也在最后一行添加内容，内容为99999999，如下所示：</p>
<p><img src="v2-055ccea0ead91a43fbdf7573e4013956_1440w-1692537350249-475.webp" alt="img"></p>
<p>现在我们需要在master分支上来合并fenzhi1，如下操作：</p>
<p><img src="v2-d02f5cdc0ba9bc644018ab7b4834e846_1440w-1692537350249-477.webp" alt="img"></p>
<p>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;<HEAD是指主分支修改的内容，>&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</p>
<p><img src="v2-51b771544ccf5cf5480f6d32f4e082c4_1440w-1692537350249-479.webp" alt="img"></p>
<p>如果我想查看分支合并的情况的话，需要使用命令 git log.命令行演示如下：</p>
<p><img src="v2-ccfdbe225d3882080b50be2284930e5e_1440w-1692537350249-481.webp" alt="img"></p>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a><strong>分支管理策略</strong></h2><p>通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。首先我们来做demo演示下：</p>
<ol>
<li>创建一个dev分支。</li>
<li>修改readme.txt内容。</li>
<li>添加到暂存区。</li>
<li>切换回主分支(master)。</li>
<li>合并dev分支，使用命令 git merge –no-ff -m “注释” dev</li>
<li>查看历史记录</li>
</ol>
<p>截图如下：</p>
<p><img src="v2-0dfa2b3201d650e5db28a9249d564aed_1440w-1692537350249-483.webp" alt="img"></p>
<p>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>
<h2 id="七：bug分支"><a href="#七：bug分支" class="headerlink" title="七：bug分支"></a><strong>七：bug分支</strong></h2><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>
<p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</p>
<p><img src="v2-50c2c93d3ab1d7f727521490abc00d82_1440w-1692537350249-485.webp" alt="img"></p>
<p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下：</p>
<p><img src="v2-6ff78e92b4936260bb81b1fc477d9aaa_1440w-1692537350249-487.webp" alt="img"></p>
<p>所以现在我可以通过创建issue-404分支来修复bug了。</p>
<p>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：</p>
<p><img src="v2-491170135f7ecc5d2e318fd50fa6d98c_1440w-1692537350249-489.webp" alt="img"></p>
<p>修复完成后，切换到master分支上，并完成合并，最后删除issue-404分支。演示如下：</p>
<p><img src="v2-e6d740741e4451d1ba843feb563a59b6_1440w-1692537350249-491.webp" alt="img"></p>
<p>现在，我们回到dev分支上干活了。</p>
<p><img src="v2-ba96abb9e8fe98a3945991e7ad9c0263_1440w-1692537350249-493.webp" alt="img"></p>
<p>工作区是干净的，那么我们工作现场去哪里呢？我们可以使用命令 git stash list来查看下。如下：</p>
<p><img src="v2-219d116d0028692cba1c325eb8f85717_1440w-1692537350249-495.webp" alt="img"></p>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p>
<ol>
<li>git stash apply恢复，恢复后，stash内容并不删除，你需要使用命令git stash drop来删除。</li>
<li>另一种方式是使用git stash pop,恢复的同时把stash内容也删除了。</li>
</ol>
<p>演示如下</p>
<p><img src="v2-97f33bfff48c8ed0ee11afa191b9bf28_1440w-1692537350249-497.webp" alt="img"></p>
<h2 id="八：多人协作"><a href="#八：多人协作" class="headerlink" title="八：多人协作"></a><strong>八：多人协作</strong></h2><p>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</p>
<ul>
<li>要查看远程库的信息 使用 git remote</li>
<li>要查看远程库的详细信息 使用 git remote –v</li>
</ul>
<p>如下演示：</p>
<p><img src="v2-055c51e840ec528db51036e63409948b_1440w-1692537350249-499.webp" alt="img"></p>
<h2 id="一：推送分支："><a href="#一：推送分支：" class="headerlink" title="一：推送分支："></a><strong>一：推送分支：</strong></h2><p>推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：使用命令 git push origin master</p>
<p>比如我现在的github上的readme.txt代码如下：</p>
<p><img src="v2-c7c9ef773753c2fb56e29ec40dbe56cc_1440w-1692537350250-501.webp" alt="img"></p>
<p>本地的readme.txt代码如下：</p>
<p><img src="v2-4c7f927c71e8b6bb7bd79f5204b55db6_1440w-1692537350250-503.webp" alt="img"></p>
<p>现在我想把本地更新的readme.txt代码推送到远程库中，使用命令如下：</p>
<p><img src="v2-adb686a9a510b042741db44b7951969a_1440w-1692537350250-505.webp" alt="img"></p>
<p>我们可以看到如上，推送成功，我们可以继续来截图github上的readme.txt内容 如下：</p>
<p><img src="v2-e53b1b0c9f3f579fef1e39c61087161f_1440w-1692537350250-507.webp" alt="img"></p>
<p>可以看到 推送成功了，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令 git push origin dev</p>
<p>那么一般情况下，那些分支要推送呢？</p>
<p>master分支是主分支，因此要时刻与远程同步。</p>
<p>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</p>
<h2 id="二：抓取分支："><a href="#二：抓取分支：" class="headerlink" title="二：抓取分支："></a><strong>二：抓取分支：</strong></h2><p>多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2</p>
<p>但是我首先要把dev分支也要推送到远程去，如下</p>
<p><img src="v2-7e4940ed8054b609b9fe53a4e3e98023_1440w-1692537350250-509.webp" alt="img"></p>
<p>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</p>
<p><img src="v2-7ff68c6f6753b4faaf54599a2e7f81a9_1440w-1692537350250-511.webp" alt="img"></p>
<p>现在目录下生成有如下所示：</p>
<p><img src="v2-a54859d18fcce0a2f87886e09f9a5b2c_1440w-1692537350250-513.webp" alt="img"></p>
<p>现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">git checkout –b dev origin/dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。</p>
<p>如下：</p>
<p><img src="v2-82f32fc35de5f832dc74d2896292f53c_1440w-1692537350250-515.webp" alt="img"></p>
<p>小伙伴们已经向origin/dev分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p>
<p><img src="v2-583d1e8ffd87183c6b7905f20600f296_1440w-1692537350250-517.webp" alt="img"></p>
<p>由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p>
<p><img src="v2-cbf0e628e26b977734d5879e2c5d743c_1440w-1692537350250-519.webp" alt="img"></p>
<p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：</p>
<p><img src="v2-803d356dee751407329cbaa5607dc39c_1440w-1692537350250-521.webp" alt="img"></p>
<p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的 解决冲突完全一样。解决后，提交，再push：</p>
<p>我们可以先来看看readme.txt内容了。</p>
<p><img src="v2-944bbc1fc16551c3ec56a6be0a19feb4_1440w-1692537350250-523.webp" alt="img"></p>
<p>现在手动已经解决完了，我接在需要再提交，再push到远程库里面去。如下所示：</p>
<p><img src="v2-b31f58b5727346b2314b026aee673a62_1440w-1692537350250-525.webp" alt="img"></p>
<p>因此：多人协作工作模式一般是这样的：</p>
<ul>
<li>首先，可以试图用git push origin branch-name推送自己的修改.</li>
<li>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</li>
<li>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/08/20/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BF%AE%E5%85%BB%E2%80%94%E2%80%94%E5%89%8D%E5%AF%BC/">http://charliechen114514.github.io/2023/08/20/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BF%AE%E5%85%BB%E2%80%94%E2%80%94%E5%89%8D%E5%AF%BC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/23/TCP-IP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941%EF%BC%8C2%EF%BC%8C3/" title="TCP/IP 网络编程笔记——1，2，3"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TCP/IP 网络编程笔记——1，2，3</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/19/Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA%E4%B8%8E%E4%B8%89%E7%A7%8D%E5%8D%8F%E8%AE%AE/" title="Unix网络编程——导论与三种协议"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unix网络编程——导论与三种协议</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/04/03/Linux-%E5%86%85%E6%A0%B8-Linux%E7%AE%80%E5%8D%95%E7%AE%80%E5%8F%B2%E4%B8%8E%E6%A6%82%E8%AE%BA/" title="Linux-内核-Linux简单简史与概论"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="title">Linux-内核-Linux简单简史与概论</div></div></a></div><div><a href="/2024/04/03/Linux%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%99%E7%A8%8B%EF%BC%88%E5%BC%95%E8%AE%BA%EF%BC%89/" title="Linux深度学习教程（引论）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-03</div><div class="title">Linux深度学习教程（引论）</div></div></a></div><div><a href="/2024/07/27/Linux%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E4%B8%8ESystemd/" title="Linux进程启动与Systemd"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-27</div><div class="title">Linux进程启动与Systemd</div></div></a></div><div><a href="/2024/07/30/Linux-Debug%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" title="Linux Debug学习之路"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-30</div><div class="title">Linux Debug学习之路</div></div></a></div><div><a href="/2024/01/19/Linux%E6%BC%AB%E6%B8%B8%E5%90%88%E9%9B%86/" title="Linux漫游合集"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-19</div><div class="title">Linux漫游合集</div></div></a></div><div><a href="/2023/08/23/TCP-IP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%941%EF%BC%8C2%EF%BC%8C3/" title="TCP&#x2F;IP 网络编程笔记——1，2，3"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-23</div><div class="title">TCP&#x2F;IP 网络编程笔记——1，2，3</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">上传了一些在CSDN和博客园写的博客(喜),甚至更换了背景图(喜x2)</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8FC%E8%AF%AD%E8%A8%80%E4%B8%8EARM%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB"><span class="toc-number">1.</span> <span class="toc-text">嵌入式C语言与ARM架构体系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%AF%BC"><span class="toc-number">1.1.</span> <span class="toc-text">前导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vim"><span class="toc-number">1.1.1.</span> <span class="toc-text">vim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-vi-vim"><span class="toc-number">1.1.2.</span> <span class="toc-text">Linux vi&#x2F;vim</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-vim%EF%BC%9F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">什么是 vim？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vim-%E9%94%AE%E7%9B%98%E5%9B%BE"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">vim 键盘图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vi-vim-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">vi&#x2F;vim 的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">输入模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E7%BA%BF%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">底线命令模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vi-vim-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">vi&#x2F;vim 使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-vi-vim-%E8%BF%9B%E5%85%A5%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.7.1.</span> <span class="toc-text">使用 vi&#x2F;vim 进入一般模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E4%B8%8B-i-%E8%BF%9B%E5%85%A5%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F-%E4%B9%9F%E7%A7%B0%E4%B8%BA%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F-%EF%BC%8C%E5%BC%80%E5%A7%8B%E7%BC%96%E8%BE%91%E6%96%87%E5%AD%97"><span class="toc-number">1.1.2.7.2.</span> <span class="toc-text">按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%B8%8B-ESC-%E6%8C%89%E9%92%AE%E5%9B%9E%E5%88%B0%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">按下 ESC 按钮回到一般模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F%E4%B8%AD%E6%8C%89%E4%B8%8B-wq-%E5%82%A8%E5%AD%98%E5%90%8E%E7%A6%BB%E5%BC%80-vi"><span class="toc-number">1.1.2.9.</span> <span class="toc-text">在一般模式中按下 :wq 储存后离开 vi</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vi-vim-%E6%8C%89%E9%94%AE%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.2.10.</span> <span class="toc-text">vi&#x2F;vim 按键说明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F%E5%8F%AF%E7%94%A8%E7%9A%84%E5%85%89%E6%A0%87%E7%A7%BB%E5%8A%A8%E3%80%81%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E3%80%81%E6%90%9C%E7%B4%A2%E6%9B%BF%E6%8D%A2%E7%AD%89"><span class="toc-number">1.1.2.10.1.</span> <span class="toc-text">第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%E5%88%B0%E7%BC%96%E8%BE%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%AF%E7%94%A8%E7%9A%84%E6%8C%89%E9%92%AE%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.2.10.2.</span> <span class="toc-text">第二部分：一般模式切换到编辑模式的可用的按钮说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%E5%88%B0%E6%8C%87%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%AF%E7%94%A8%E7%9A%84%E6%8C%89%E9%92%AE%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.2.10.3.</span> <span class="toc-text">第三部分：一般模式切换到指令行模式的可用的按钮说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make"><span class="toc-number">1.1.3.</span> <span class="toc-text">make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95GCC%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.4.</span> <span class="toc-text">扩展GCC：常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E7%AE%80%E5%8D%95%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2简单编译</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3%E6%B1%87%E7%BC%96-Assembly"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">2.3汇编(Assembly)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4%E8%BF%9E%E6%8E%A5-Linking"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">2.4连接(Linking)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E5%A4%9A%E4%B8%AA%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">3多个程序文件的编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E6%A3%80%E9%94%99"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">4检错</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E5%BA%93%E6%96%87%E4%BB%B6%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">5库文件连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1%E7%BC%96%E8%AF%91%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.4.5.1.</span> <span class="toc-text">5.1编译成可执行文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.4.5.2.</span> <span class="toc-text">5.2链接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3%E5%BC%BA%E5%88%B6%E9%93%BE%E6%8E%A5%E6%97%B6%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-number">1.1.4.5.3.</span> <span class="toc-text">5.3强制链接时使用静态链接库</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E7%BB%93%E6%9D%9F"><span class="toc-number">1.2.</span> <span class="toc-text">扩展结束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E6%92%B8MakeFile"><span class="toc-number">1.3.</span> <span class="toc-text">手撸MakeFile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">1.3.1.</span> <span class="toc-text">准备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git"><span class="toc-number">1.4.</span> <span class="toc-text">Git</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84Git%E5%91%BD%E4%BB%A4"><span class="toc-number">1.5.</span> <span class="toc-text">常用的Git命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D"><span class="toc-number">1.5.1.</span> <span class="toc-text">题外话</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">1.6.</span> <span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9AGit%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">一：Git是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9ASVN%E4%B8%8EGit%E7%9A%84%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">二：SVN与Git的最主要的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9C%A8windows%E4%B8%8A%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85Git%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">三、在windows上如何安装Git？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9A%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">四：如何操作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93%E3%80%82"><span class="toc-number">1.11.</span> <span class="toc-text">一：创建版本库。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80%EF%BC%9A"><span class="toc-number">1.12.</span> <span class="toc-text">二：版本回退：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%EF%BC%9A%E7%90%86%E8%A7%A3%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%8E%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">三：理解工作区与暂存区的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%EF%BC%9AGit%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9%E5%92%8C%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.14.</span> <span class="toc-text">四：Git撤销修改和删除文件操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E6%92%A4%E9%94%80%E4%BF%AE%E6%94%B9%EF%BC%9A"><span class="toc-number">1.15.</span> <span class="toc-text">一：撤销修改：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">1.16.</span> <span class="toc-text">二：删除文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%EF%BC%9A%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="toc-number">1.17.</span> <span class="toc-text">五：远程仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E8%BF%9C%E7%A8%8B%E5%BA%93%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">如何添加远程库？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E8%BF%9C%E7%A8%8B%E5%BA%93%E5%85%8B%E9%9A%86%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">如何从远程库克隆？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF"><span class="toc-number">1.20.</span> <span class="toc-text">六：创建与合并分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">如何解决冲突？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">1.22.</span> <span class="toc-text">分支管理策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%EF%BC%9Abug%E5%88%86%E6%94%AF"><span class="toc-number">1.23.</span> <span class="toc-text">七：bug分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%EF%BC%9A%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C"><span class="toc-number">1.24.</span> <span class="toc-text">八：多人协作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%9A%E6%8E%A8%E9%80%81%E5%88%86%E6%94%AF%EF%BC%9A"><span class="toc-number">1.25.</span> <span class="toc-text">一：推送分支：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%9A%E6%8A%93%E5%8F%96%E5%88%86%E6%94%AF%EF%BC%9A"><span class="toc-number">1.26.</span> <span class="toc-text">二：抓取分支：</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF1/" title="树莓派学习之路1"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="树莓派学习之路1"/></a><div class="content"><a class="title" href="/2024/09/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF1/" title="树莓派学习之路1">树莓派学习之路1</a><time datetime="2024-09-26T03:55:47.000Z" title="发表于 2024-09-26 11:55:47">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0F1/" title="设计模式小记F1"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式小记F1"/></a><div class="content"><a class="title" href="/2024/09/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B0%8F%E8%AE%B0F1/" title="设计模式小记F1">设计模式小记F1</a><time datetime="2024-09-26T03:55:35.000Z" title="发表于 2024-09-26 11:55:35">2024-09-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/30/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" title="Linux学习之路"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux学习之路"/></a><div class="content"><a class="title" href="/2024/07/30/Linux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" title="Linux学习之路">Linux学习之路</a><time datetime="2024-07-30T02:02:02.000Z" title="发表于 2024-07-30 10:02:02">2024-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/30/Linux-Debug%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" title="Linux Debug学习之路"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux Debug学习之路"/></a><div class="content"><a class="title" href="/2024/07/30/Linux-Debug%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" title="Linux Debug学习之路">Linux Debug学习之路</a><time datetime="2024-07-30T01:10:54.000Z" title="发表于 2024-07-30 09:10:54">2024-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/29/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E4%B8%8A%E6%9E%84%E5%BB%BARaspberry-Pi%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/" title="如何在Linux上构建Raspberry Pi虚拟环境"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何在Linux上构建Raspberry Pi虚拟环境"/></a><div class="content"><a class="title" href="/2024/07/29/%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E4%B8%8A%E6%9E%84%E5%BB%BARaspberry-Pi%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/" title="如何在Linux上构建Raspberry Pi虚拟环境">如何在Linux上构建Raspberry Pi虚拟环境</a><time datetime="2024-07-29T14:11:04.000Z" title="发表于 2024-07-29 22:11:04">2024-07-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>