<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Unix网络编程 - 1 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Unix网络编程概述​        我们一般认为Web服务器是一个长期运行的程序。一般的讲：我们的（通信）请求总是由客户发起的（想想某种浏览器）。大多数的网络应用都可以被划分成——客户（client）和服务器(server) ​        下图，你可以看到一个简单的模型      ​            一般来讲，一个客户只跟一个服务器通信。但是一个服务器往往可以同时处理多个客户的请求（线">
<meta property="og:type" content="article">
<meta property="og:title" content="Unix网络编程 - 1">
<meta property="og:url" content="http://charliechen114514.github.io/2023/08/17/Unix-network-programming-Guidance/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="Unix网络编程概述​        我们一般认为Web服务器是一个长期运行的程序。一般的讲：我们的（通信）请求总是由客户发起的（想想某种浏览器）。大多数的网络应用都可以被划分成——客户（client）和服务器(server) ​        下图，你可以看到一个简单的模型      ​            一般来讲，一个客户只跟一个服务器通信。但是一个服务器往往可以同时处理多个客户的请求（线">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-08-17T10:15:15.000Z">
<meta property="article:modified_time" content="2024-01-15T05:58:01.052Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/08/17/Unix-network-programming-Guidance/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unix网络编程 - 1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-15 13:58:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unix网络编程 - 1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-17T10:15:15.000Z" title="发表于 2023-08-17 18:15:15">2023-08-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-15T05:58:01.052Z" title="更新于 2024-01-15 13:58:01">2024-01-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unix网络编程 - 1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Unix网络编程"><a href="#Unix网络编程" class="headerlink" title="Unix网络编程"></a>Unix网络编程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        我们一般认为Web服务器是一个长期运行的程序。一般的讲：我们的（通信）请求总是由客户发起的（想想某种浏览器）。大多数的网络应用都可以被划分成——客户（client）和服务器(server)</p>
<p>​        下图，你可以看到一个简单的模型</p>
<p><img src="image-20230817084042597-1692267130131-1.png" alt="image-20230817084042597">    </p>
<p>​            一般来讲，一个客户只跟一个服务器通信。但是一个服务器往往可以同时处理多个客户的请求（线程解决）</p>
<p><img src="image-20230817084516015-1692267130131-2.png" alt="image-20230817084516015"></p>
<p>（可以看到上面的图中一个服务器可以处理多个客户的请求）</p>
<p><img src="image-20230817171652172-1692267130131-3.png" alt="image-20230817171652172"></p>
<p>​        你也可以看到，这是一个客户和服务器通讯的一个基本的协议层次图。</p>
<p>​        客户与服务器之间的信息流在其中一端是向下通过协议栈的，跨越网络后，在另一端是向上通过协议栈的。客户和服务器通常是用户进程，而TCP和IP协议通常是内核中协议栈的一部分。</p>
<p>​        上图中术语IP自20世纪80年代以来一直在使用，其正式名称是IPv4（IP version 4），<strong>IPv4的新版本IPv6是在20世纪90年代中期开发出来的，将来会取代IPv4。</strong></p>
<p>​        客户和服务器无需如上图一样都处于一个局域网（LAN），可通过路由器将两个局域网连接到广域网（WAN）：</p>
<p><img src="image-20230817172011557-1692267130131-4.png" alt="image-20230817172011557"></p>
<p>​        路由器是广域网的架构设备。<strong>当今最大的广域网是因特网，许多公司也构建自己的广域网，这些私用的广域网既可以连接到因特网，也可以不连接。</strong></p>
<h2 id="一个简单的小程序"><a href="#一个简单的小程序" class="headerlink" title="一个简单的小程序"></a>一个简单的小程序</h2><p>​        来看一个返回时间的网络小程序：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;unp.h&gt;

int main(int argc,char** agrv)
&#123;
    int sockfd, n;
    char recvline[MAXLINE + 1];
    struct sockaddr_in servaddr;

    if(argc !&#x3D; 2)
        err_quit(&quot;usage: a.out &lt;IPaddress&gt;&quot;);

    if((sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
        err_sys(&quot;socket error&quot;);

    bzero(&amp;servaddr, sizeof(servaddr));
    servaddr.sin_family &#x3D; AF_INET;
    servaddr.sin_port &#x3D; htons(13); &#x2F;&#x2F; daytime server
    if(inet_pton(AF_INET, agrv[1], &amp;servaddr.sin_addr) &lt;&#x3D; 0)
        err_quit(&quot;inet_pton error for %s&quot;, agrv[1]);

    if(connect(sockfd, (SA*)&amp;servaddr, sizeof(servaddr)) &lt; 0)
        err_sys(&quot;connect error&quot;);

    while((n &#x3D; read(sockfd, recvline, MAXLINE)) &gt; 0)
    &#123;
        recvline[n] &#x3D; 0; &#x2F;&#x2F; null terminate
        if(fputs(recvline, stdout) &#x3D;&#x3D; EOF)
            err_sys(&quot;fputs error&quot;);
    &#125;

    if(n &lt; 0)
        err_sys(&quot;read error&quot;);

    exit(0);
        &#x2F;&#x2F; have no daytime server
        &#x2F;&#x2F; try IPv4  129.6.15.28
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们对它进行编译：</p>
<p><img src="image-20230817172342839-1692267130132-5.png" alt="image-20230817172342839"></p>
<p>​        可以尝试IP：129.6.15.28。这个IP可以链接成功并且返回当地时间的。</p>
<p>​        下面，我们来简单的看看这个程序</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys&#x2F;socket.h&gt;
#include &lt;netinet&#x2F;in.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

#define MAXLINE 512

int main(int argc, char **argv) &#123;
    int sockfd, n;
    char recvline[MAXLINE + 1];
    struct sockaddr_in servaddr;    &#x2F;&#x2F; 此结构位于头文件netinet&#x2F;in.h

    if (argc !&#x3D; 2) &#123;
        printf(&quot;usage: a.out &lt;IPaddress&gt;\n&quot;);
		exit(1);
    &#125;

    &#x2F;&#x2F; 作为一种编码风格，作者在两个左括号间加了一个空格，提示比较运算的左侧同时也是一个赋值运算
    &#x2F;&#x2F; 这种风格借鉴自Minix源代码，下面的while语句也用了相同的格式
    if ( (sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123;    &#x2F;&#x2F; 创建一个网际（AF_INET）字节流（SOCK_STREAM）套接字，即TCP套接字，它返回一个小整数描述符，以后的函数调用（如connect和read函数）就用该描述符来标识这个套接字
        printf(&quot;socket error\n&quot;);
		exit(1);
    &#125;

    bzero(&amp;servaddr, sizeof(servaddr));    &#x2F;&#x2F; bzero函数位于头文件string.h，把指定字节大小的地址区域都置为0字节
    servaddr.sin_family &#x3D; AF_INET;    &#x2F;&#x2F; 置地址族为AF_INET
    servaddr.sin_port &#x3D; htons(13);    &#x2F;&#x2F; daytime server的端口号为13，htons函数将短整型变量从主机字节顺序转变成网络字节顺序（高位字节存在低地址处）
    if (inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;&#x3D; 0) &#123;    &#x2F;&#x2F; inet_pton函数将点分十进制IP地址转换为二进制
                                                                   &#x2F;&#x2F; inet_pton函数是支持IPv6的新函数，以前的代码使用inet_addr函数将ASCII点分十进制串变成正确形式，但inet_addr函数有很多局限，这些局限都在inet_pton函数中被纠正
        printf(&quot;inet_pton error for %s\n&quot;, argv[1]);
		exit(1);
    &#125;
    
    &#x2F;&#x2F; connect函数与它的第二个参数指向的套接字地址结构所指定的服务器建立TCP连接
    &#x2F;&#x2F; 第三个参数是这个套接字地址结构的长度，对于网际套接字地址结构，我们总是使用C语言的sizeof操作符由编译器来计算这个长度
    &#x2F;&#x2F; 第二个参数我们用sockaddr类型指针指向了sockaddr_in类型，因为sockaddr类型是通用套接字地址结构
    &#x2F;&#x2F; 每当一个套接字函数需要一个指向某个套接字地址结构的指针时，这个指针必须强制类型转换成一个指向通用套接字地址结构的指针
    &#x2F;&#x2F; 这是因为套接字函数早于ANSI C标准，20世纪80年代开发这些函数时，ANSI C的void *指针类型还不可用
    &#x2F;&#x2F; 但转换时，struct sockaddr长达15个字符，往往造成源代码超出屏幕右边缘，因此我们可以使用#define将其简化为SA
    if (connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;    &#x2F;&#x2F; sockaddr结构位于头文件sys&#x2F;socket.h
        printf(&quot;connect error\n&quot;);
		perror(&quot;connect&quot;);    &#x2F;&#x2F; perror函数将其参数和errno所对应的错误一起输出到标准错误
		exit(1);
    &#125;

    &#x2F;&#x2F; 此处需要while循环，因为服务器可能会将TCP分节，我们一次只能读取单个分节，需要一直读取，直到read函数返回0（对端关闭连接）或负数（发生错误），此程序中，服务器关闭连接表示记录接收结束
    while ( (n &#x3D; read(sockfd, recvline, MAXLINE)) &gt; 0) &#123;
        recvline[n] &#x3D; 0;    &#x2F;&#x2F; null terminate
        if (fputs(recvline, stdout) &#x3D;&#x3D; EOF) &#123;
		    printf(&quot;fputs error\n&quot;);
		    exit(1);
		&#125;
    &#125;
    if (n &lt; 0) &#123;
        printf(&quot;fputs error\n&quot;);
    &#125;

    exit(0);    &#x2F;&#x2F; 结束程序，内核会关闭所有打开的文件描述符，套接字就此被关闭
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        我们的socket函数创建了一个叫<strong>网际字节流的东西（AF_INET SOCK_STREAM）</strong>。返回的是一个整形描述符，我们就是用它来代替链接进行后续的操作</p>
<p>​        这里有一个技巧：请看</p>
<pre class="line-numbers language-none"><code class="language-none">if ( (sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0) ) &lt; 0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        实际上，这里使用了C语言的一个重要的特性：也就是运算符优先级</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0);
if(sockfd &lt; 0)&#123;
	...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是跟上面的话是等效的。</p>
<p>​         随后，我们指定服务器的IP地址和端口：服务器的IP地址和端口号填入一个网际套接字地址结构（一个名为servaddr的sockaddr_in结构变量）。网际套接字地址结构中IP地址和端口号这两个成员必须使用特定格式，<strong>htons（“主机到网络短整数”）去转换二进制端口号，inet_pton(“呈现形式到数值”)把ASCII命令行参数转换为合适的格式。</strong></p>
<p>​        接着，当我们指定好了服务器的IP地址和端口之后，实际上我们就是知道了服务器的位置，下面就是建立联系。</p>
<p>​        connect函数应用于一个TCP套接字时，将与由它的第二个参数指向的套接字地址结构指定的服务器建立一个TCP连接。该套接字结构的长度也必须作为该函数的第三个参数指定，对于网际套接字地址结构，用sizeof操作符指定。每当一个套接字函数需要一个指向某个套接字地址结构的指针时，<strong>这个指针必须强制类型转换成一个指向通用套接字地址结构的指针。</strong></p>
<pre><code>     建立联系后就是拿到服务器的数据了：**读入并输出服务器的应答**：通常服务器返回包含所有字节的单个分节，但是如果数据量很大，就不能保证一次read调用能返回服务器的整个应答。因此从TCP套接字读取数据时，总是需要把read编写在某个循环中，当read返回0（表明对端关闭连接）或者负值（表明发生错误）时终止循环。
</code></pre><p>​        这就是我们拿到的联系：</p>
<p><img src="image-20230817173715614-1692267130132-6.png" alt="image-20230817173715614"></p>
<p>​        注意到我们这里并没有转化为我们可以读到的格式。</p>
<p>​        为什么我们要：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">while ( (n &#x3D; read(sockfd, recvline, MAXLINE)) &gt; 0) &#123;
       recvline[n] &#x3D; 0;    &#x2F;&#x2F; null terminate
       if (fputs(recvline, stdout) &#x3D;&#x3D; EOF) &#123;
	    printf(&quot;fputs error\n&quot;);
	    exit(1);
	&#125;
   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        呢？答案是，我们没有办法保证我们一次就可以读完所有的数据。如果数据量很大，我们就不能确保一次read调用能返回服务器的整个应答，因此从TCP套接字读取数据时，我们总是需要把read函数编写在某个循环中，当read函数返回0（表明对端关闭连接）或负值（表明发生错误）时终止循环。</p>
<p>​        上例中，服务器关闭连接表征记录的结束，HTTP（Hypertext Transfer Protocol，超文本传送协议）的1.0版本也采用这种技术。也可用其他技术标识记录结束，如SMTP（Simple Mail Transfer Protocol，简单邮件传送协议）使用由ASCII回车符后跟换行符构成的2字节序列标记记录的结束；Sun远程过程调用和域名系统在每个要发送的记录前放置一个二进制计数值，给出这个记录的长度。这里的重要概念是TCP本身不提供记录结束标志，应用需要自己实现记录边界的确定。</p>
<p>​        我们的协议使用的是IPv4，注意到的是他不可以直接搬到IPv6上运行。我们需要做一些修改</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys&#x2F;socket.h&gt;
#include &lt;netinet&#x2F;in.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

#define MAXLINE 512

int main(int argc, char **argv) &#123;
    int sockfd, n;
    char recvline[MAXLINE + 1];
&#x2F;&#x2F;  struct sockaddr_in servaddr;    
    struct sockaddr_in6 servaddr;

    if (argc !&#x3D; 2) &#123;
        printf(&quot;usage: a.out &lt;IPaddress&gt;\n&quot;);
		exit(1);
    &#125;

&#x2F;&#x2F;  if ( (sockfd &#x3D; socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123;
    if ( (sockfd &#x3D; socket(AF_INET6, SOCK_STREAM, 0)) &lt; 0) &#123;   
        printf(&quot;socket error\n&quot;);
		exit(1);
    &#125;

    bzero(&amp;servaddr, sizeof(servaddr));
&#x2F;&#x2F;  servaddr.sin_family &#x3D; AF_INET;
    servaddr.sin6_family &#x3D; AF_INET6;
&#x2F;&#x2F;  servaddr.sin_port &#x3D; htons(13);
    servaddr.sin6_port &#x3D; htons(13);
&#x2F;&#x2F;  if (inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;&#x3D; 0) &#123; 
    if (inet_pton(AF_INET6, argv[1], &amp;servaddr.sin6_addr) &lt;&#x3D; 0) &#123;   
        printf(&quot;inet_pton error for %s\n&quot;, argv[1]);
		exit(1);
    &#125;
    
    if (connect(sockfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0) &#123;   
        printf(&quot;connect error\n&quot;);
		perror(&quot;connect&quot;);    
		exit(1);
    &#125;

    while ( (n &#x3D; read(sockfd, recvline, MAXLINE)) &gt; 0) &#123;
        recvline[n] &#x3D; 0;    
        if (fputs(recvline, stdout) &#x3D;&#x3D; EOF) &#123;
		    printf(&quot;fputs error\n&quot;);
		    exit(1);
		&#125;
    &#125;
    if (n &lt; 0) &#123;
        printf(&quot;fputs error\n&quot;);
    &#125;

    exit(0);    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        当然一个更好的做法是去编写一个与协议无关的程序——这个我们之后再说。</p>
<p>​        以上程序的另一个不足之处是，用户必须以点分十进制数格式给出服务器的IP地址，人们更习惯于用域名来代替数字。</p>
<p>​        以上程序中，当函数调用发生错误时，我们输出一个出错消息并终止程序运行，这是大多情况下的做法，<strong>个别情况下，我们要做的事并非简单地终止程序运行，如需要检查系统调用是否被中断了。</strong>既然大多情况下发生错误时需要终止程序，<strong>我们可以定义包裹函数来缩短程序，每个包裹函数完成实际的函数调用，检查返回值，并在发生错误时终止进程。包裹函数名一般是实际函数名的首字母大写形式，这是约定，</strong>如：</p>
<pre class="line-numbers language-none"><code class="language-none">int Socket(int family, int type, int protocol) &#123;
    int n;

    if ( (n &#x3D; socket(family, type, protocol)) &lt; 0) &#123;
        err_sys(&quot;socket error\n&quot;);
        exit(1);
    &#125;
    return n;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这是一个良好的编程习惯（即handle我们的异常值和处理，同时简化代码，屏蔽掉无关竟要的细节）</p>
<p>​        熟知Unix系统编程的知道：errno值可以用来衡量错误是啥。但是一些函数是开在线程中的，我们需要手动的设置errno值并且返回调用端。</p>
<pre class="line-numbers language-none"><code class="language-none">线程函数在遇到错误是并不设置标准Unix errno变量，而是把errno的值作为函数返回值返回调用者，我们每次调用以pthread_开头的函数时，必须分配一个变量来存放函数返回值，以便在输出错误消息前把errno变量设置为该值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">void Pthread_mutex_lock(pthread_mutex_t *mptr) &#123;
    int n;

    if ( (n &#x3D; pthread_mutex_lock(mptr)) &#x3D;&#x3D; 0) &#123;
        return;
    &#125;
    errno &#x3D; n;
    err_sys(&quot;pthread_mutex_lock error&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="扩展：Unix的errno值"><a href="#扩展：Unix的errno值" class="headerlink" title="扩展：Unix的errno值"></a>扩展：Unix的errno值</h3><p>​        只要一个Unix函数中有错误发生，<strong>全局变量errno就被置为一个指明该错误类型的正值，函数本身则通常返回-1。自定义函数err_sys查看errno变量的值并输出相应的出错消息，如errno值等于ETIMEDOUT时，输出”Connection timed out”。</strong></p>
<p>​        errno的值只在函数发生错误时设置，如果函数没有出错，errno的值就没有定义。errno的所有正数错误值都是常值，并有以E开头的全大写字母名，并通常在<sys/errno.h>头文件中定义。errno值0不表示任何错误。</p>
<h2 id="一个简单的时间获取服务器程序"><a href="#一个简单的时间获取服务器程序" class="headerlink" title="一个简单的时间获取服务器程序"></a>一个简单的时间获取服务器程序</h2><pre class="line-numbers language-none"><code class="language-none">#include &lt;unp.h&gt;
#include &lt;time.h&gt;

int main()
&#123;
    int listenfd, connfd;
    struct sockaddr_in servaddr;
    char buff[MAXLINE];
    time_t ticks;

    listenfd &#x3D; Socket(AF_INET, SOCK_STREAM, 0);

    bzero(&amp;servaddr, sizeof(servaddr)); &#x2F;&#x2F; 初始化

    servaddr.sin_family &#x3D; AF_INET;

    servaddr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);

    servaddr.sin_port &#x3D; htons(13);

    Bind(listenfd, (SA *)&amp;servaddr, sizeof(servaddr));

    Listen(listenfd, LISTENQ);

    for (;;)
    &#123;
        connfd &#x3D; Accept(listenfd, (SA *)NULL, NULL);

        ticks &#x3D; time(NULL);

        snprintf(buff, sizeof(buff), &quot;%.24s\r\n&quot;, ctime(&amp;ticks));

        Write(connfd, buff, strlen(buff));

        Close(connfd);
    &#125;

    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        上述的城西完成了这几个动作：</p>
<p>​        监听套接字：listen函数将套接字转换成一个监听套接字，这样来自客户的外来连接就可在该套接字上由内核接受。LISTENQ指定系统内核允许在这个监听描述符上排队的最大客户连接数。<br>         接受客户连接，发送应答：通常情况，服务器进程在accept调用中被投入睡眠，等待某个客户连接的到达并被内核接受。TCP连接使用三路握手来建立连接，握手完毕accept返回一个已连接描述符，用于与客户通信。<br>         终止连接：服务器通过close关闭与客户的连接。该调用引发正常的TCP连接终止序列：每个方向上发送一个FIN，每个FIN又由各自对端确认</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include &quot;unp.h&quot;
#include &lt;time.h&gt;

int main(int argc, char **argv) &#123;
    int listenfd, connfd;
    struct sockaddr_in servaddr;
    char buff[MAXLINE];
    time_t ticks;

    listenfd &#x3D; Socket(AF_INET, SOCK_STREAM, 0);

    bzero(&amp;servaddr, sizeof(servaddr));
    servaddr.sin_family &#x3D; AF_INET;
    servaddr.sin_addr.s_addr &#x3D; htonl(INADDR_ANY);
    servaddr.sin_port &#x3D; htons(13);    &#x2F;* daytime server *&#x2F;

    Bind(listenfd, (SA *)&amp;servaddr, sizeof(servaddr));

    &#x2F;&#x2F; 调用listen函数将该套接字转换成一个监听套接字，这样来自客户的外来连接就可以在该套接字上由内核接收
    &#x2F;&#x2F; LISTENQ在头文件unp.h中定义，它指定系统内核允许在这个监听描述符上排队的最大客户连接数
    Listen(listenfd, LISTENQ);
    &#x2F;&#x2F; socket、bind、listen这3个调用步骤是任何TCP服务器准备监听描述符的正常步骤

    for (; ; ) &#123;
        &#x2F;&#x2F; 通常，服务器进程在accept调用中被投入睡眠，等待某个客户连接的到达并被内核接受
       &#x2F;&#x2F; TCP使用三路握手来建立连接，握手完毕时accept函数返回，其返回值是一个称为已连接描述符的新描述符，该描述符用于同新近连接的那个客户通信
        &#x2F;&#x2F; accept函数为每个连接到本服务器的客户返回一个新描述符
        connfd &#x3D; Accept(listenfd, (SA *)NULL, NULL);

       &#x2F;&#x2F; time函数返回自Unix纪元（即19700101000000）以来的秒数
		ticks &#x3D; time(NULL);
		&#x2F;&#x2F; 相比于sprintf函数，snprintf函数要求其第二个参数指定目的缓冲区大小，因此可确保该缓冲区不溢出
		&#x2F;&#x2F; snprintf函数在ISO C99版本中才加入到ANSI C标准中，但几乎所有厂商都把它作为标准C函数库的一部分提供，出于可靠性考虑，可将其改为sprintf函数
		&#x2F;&#x2F; 但许多网络入侵是由黑客通过发送数据，导致服务器对sprintf调用使其缓冲区溢出而发生的
		&#x2F;&#x2F; 需要小心的函数还有gets、strcat、strcpy，通常应分别改为fgets、strncat、strncpy函数，更好的替代函数是strlcat和strlcpy，它们确保结果是正确终止的字符串
		snprintf(buff, sizeof(buff), &quot;%.24s\r\n&quot;, ctime(&amp;ticks));    &#x2F;&#x2F; %.24s表示最多打印24个字符，ctime函数返回一个25个字节的串，如&quot;Wed Jun 30 21:49:08 1993\n&quot;
		                                                             &#x2F;&#x2F; %24s表示最少打印24个字符
		Write(connfd, buff, strlen(buff));
	
	    &#x2F;&#x2F; 通过close调用关闭与客户的连接，该调用引发正常的TCP连接终止序列：每个方向上发送一个FIN，每个FIN又由各自的对端确认
		Close(connfd);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p>​        国际标准化组织（International Organization for Standardization，ISO）的开放系统互连（Open Systems Interconnection，OSI）模型，这是一个七层模型（图中还给出了它与网际协议族的近似映射）：</p>
<p><img src="8d760d7c2f744c9bad396817afc0035f-1692267130132-7.png" alt="在这里插入图片描述"></p>
<p>​        我们认为OSI模型的底下两层是随系统提供的设备驱动程序和网络硬件，通常，除需知道数据链路层的某些特性外（如1500字节的以太网MTU大小），我们不关心这两层情况。</p>
<p>​        上图网际协议族中，传输层的TCP和UDP中间留有空隙，表明网络应用可能绕过传输层直接使用IPv4或IPv6，这是所谓的原始套接字。我们甚至可以绕过IP层直接读写数据链路层的帧。</p>
<p>​        OSI模型的顶上三层在网际协议中被合并为一层，称为应用层，这是Web客户（浏览器）、Telnet客户、Web服务器、FTP服务器和其他我们使用的网络应用所在的层。对于网际协议，OSI模型的顶上三层协议几乎没有区别。</p>
<p>​        本书讲述的套接字编程接口是从OSI的顶上三层（即网际协议的应用层）进入传输层的接口。为什么套接字提供的是从OSI模型的顶上三层进入传输层的接口？这样设计有两个理由：一是顶上三层处理具体网络应用（如FTP、Telnet、HTTP）的所有细节，却对通信细节了解很少；底下四层对具体网络应用了解不多，却处理所有通信细节（发送数据、等待确认、给无序到达的数据排序、计算并验证校验和等）。二是顶上三层通常构成所谓用户进程，底下四层通常作为操作系统内核的一部分提供，Unix与其他现代操作系统都提供分隔用户进程与内核的机制。由以上可见，OSI模型的第4层和第5层之间的接口是构建API的自然位置。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>​        如果发现配置完成了但是再VScode下还是会爆出undefined reference的问题，可以直接采用自己编译的方式，也就是在命令行中</p>
<pre class="line-numbers language-none"><code class="language-none">gcc -o result file.c &#x2F;usr&#x2F;lib&#x2F;libunp.a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        的方式。当然，自己找到file.c和libunp.a的位置！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/08/17/Unix-network-programming-Guidance/">http://charliechen114514.github.io/2023/08/17/Unix-network-programming-Guidance/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/" title="Linux漫游——文件IO操作"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux漫游——文件IO操作</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/16/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="Linux漫游——系统调用"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux漫游——系统调用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/30/Linux%E6%BC%AB%E6%B8%B8-%E6%9B%B4%E6%B7%B1%E5%B1%82%E6%AC%A1%E7%9A%84%E6%96%87%E4%BB%B6IO/" title="Linux漫游 更深层次的文件IO"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">Linux漫游 更深层次的文件IO</div></div></a></div><div><a href="/2023/08/15/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E5%AF%BC%E8%AE%BA/" title="Linux漫游——导论"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-15</div><div class="title">Linux漫游——导论</div></div></a></div><div><a href="/2023/08/19/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/" title="Linux漫游——文件IO操作"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-19</div><div class="title">Linux漫游——文件IO操作</div></div></a></div><div><a href="/2023/08/16/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="Linux漫游——系统调用"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-16</div><div class="title">Linux漫游——系统调用</div></div></a></div><div><a href="/2023/08/30/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E4%B8%8E%E7%B3%BB%E7%BB%9F%E9%99%90%E5%88%B6/" title="Linux漫游——时间与系统限制"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">Linux漫游——时间与系统限制</div></div></a></div><div><a href="/2023/08/30/Linux%E6%BC%AB%E6%B8%B8%E2%80%94%E2%80%94%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%87%AD%E8%AF%81/" title="Linux漫游——用户与组，进程凭证"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">Linux漫游——用户与组，进程凭证</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">合并了大部分博客，并且优化了目录和标签！部分老博客删除，数据结构部分将会用Algorithm_in_C为大纲重写，可以期待一下（）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Unix网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">一个简单的小程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9AUnix%E7%9A%84errno%E5%80%BC"><span class="toc-number">1.2.1.</span> <span class="toc-text">扩展：Unix的errno值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">一个简单的时间获取服务器程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI"><span class="toc-number">1.4.</span> <span class="toc-text">OSI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D"><span class="toc-number">1.5.</span> <span class="toc-text">题外话</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/16/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-3/" title="重新学习Linux系统编程-3"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="重新学习Linux系统编程-3"/></a><div class="content"><a class="title" href="/2024/01/16/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-3/" title="重新学习Linux系统编程-3">重新学习Linux系统编程-3</a><time datetime="2024-01-16T05:17:44.000Z" title="发表于 2024-01-16 13:17:44">2024-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%A6%82%E8%AE%BA/" title="计算机网络笔记概论"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络笔记概论"/></a><div class="content"><a class="title" href="/2024/01/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%A6%82%E8%AE%BA/" title="计算机网络笔记概论">计算机网络笔记概论</a><time datetime="2024-01-16T05:17:18.000Z" title="发表于 2024-01-16 13:17:18">2024-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/15/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-2/" title="重新学习Linux系统编程-2"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="重新学习Linux系统编程-2"/></a><div class="content"><a class="title" href="/2024/01/15/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-2/" title="重新学习Linux系统编程-2">重新学习Linux系统编程-2</a><time datetime="2024-01-15T05:50:39.000Z" title="发表于 2024-01-15 13:50:39">2024-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/15/Missing-Class-In-CS-I-Vim-Bash/" title="Missing Class In CS I_Vim_Bash"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Missing Class In CS I_Vim_Bash"/></a><div class="content"><a class="title" href="/2024/01/15/Missing-Class-In-CS-I-Vim-Bash/" title="Missing Class In CS I_Vim_Bash">Missing Class In CS I_Vim_Bash</a><time datetime="2024-01-15T05:48:18.000Z" title="发表于 2024-01-15 13:48:18">2024-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/15/xv6%E9%80%9F%E9%80%9A/" title="xv6速通"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="xv6速通"/></a><div class="content"><a class="title" href="/2024/01/15/xv6%E9%80%9F%E9%80%9A/" title="xv6速通">xv6速通</a><time datetime="2024-01-15T05:45:36.000Z" title="发表于 2024-01-15 13:45:36">2024-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>