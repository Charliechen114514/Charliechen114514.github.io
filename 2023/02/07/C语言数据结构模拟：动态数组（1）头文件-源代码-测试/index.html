<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>C语言数据结构模拟：动态数组（1）头文件+源代码+测试 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="动态数组（1）源代码阅读+注释开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））​        请注意：使用和调用环境为C语言环境，不！要！用！在！CPP文件里！函数指针返回逻辑不一样lol ​        下载源文件和MD文件（有代码高亮）可以去我的GitHub上下载！ 头文件一览：#define _CRT_SECURE_NO_WARNINGS">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言数据结构模拟：动态数组（1）头文件+源代码+测试">
<meta property="og:url" content="http://charliechen114514.github.io/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="动态数组（1）源代码阅读+注释开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））​        请注意：使用和调用环境为C语言环境，不！要！用！在！CPP文件里！函数指针返回逻辑不一样lol ​        下载源文件和MD文件（有代码高亮）可以去我的GitHub上下载！ 头文件一览：#define _CRT_SECURE_NO_WARNINGS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-02-07T06:52:56.000Z">
<meta property="article:modified_time" content="2023-02-15T08:17:09.301Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="MyTinyLibProject">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言数据结构模拟：动态数组（1）头文件+源代码+测试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-15 16:17:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言数据结构模拟：动态数组（1）头文件+源代码+测试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-07T06:52:56.000Z" title="发表于 2023-02-07 14:52:56">2023-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-15T08:17:09.301Z" title="更新于 2023-02-15 16:17:09">2023-02-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言数据结构模拟：动态数组（1）头文件+源代码+测试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="动态数组（1）源代码阅读-注释"><a href="#动态数组（1）源代码阅读-注释" class="headerlink" title="动态数组（1）源代码阅读+注释"></a>动态数组（1）源代码阅读+注释</h1><h4 id="开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））"><a href="#开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））" class="headerlink" title="开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））"></a>开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））</h4><p>​        请注意：使用和调用环境为C语言环境，不！要！用！在！CPP文件里！函数指针返回逻辑不一样lol</p>
<p>​        下载源文件和MD文件（有代码高亮）可以去我的GitHub上下载！</p>
<h5 id="头文件一览："><a href="#头文件一览：" class="headerlink" title="头文件一览："></a>头文件一览：</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1
#define	OPENUPPOSARR 1
#define OPENUPDEFAULTSIZE 1
#define	QUICKMALLOC 1
&#x2F;&#x2F;(General Version)
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
&#x2F;&#x2F;Error Code Meaning
&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0
&#x2F;&#x2F;When Error in mallocing Space the program return 1
&#x2F;&#x2F;when inputing a NULL we returns -1
&#x2F;&#x2F;when inputing a invalid input we returns -2
&#x2F;&#x2F;Locations UnFind we returns -3 
&#x2F;&#x2F;
typedef enum _DynamicFunctionStatues_ &#123;
	DynamicArray_Normal &#x3D; 0,
	DynamicArray_ERROR_IN_MALLOCING_SPACE &#x3D; 1,
	DynamicArray_NULL_INPUT &#x3D; -1,
	DynamicArray_Invalid_Input &#x3D; -2,
	DynamicArray_UnFind &#x3D; -3,
	DynamicArray_Invalid_Free &#x3D; -4
&#125;DynamicArrayFunctionStatues;
&#x2F;&#x2F;Mybool defined
&#x2F;&#x2F;
typedef enum _bool_ &#123;
	True &#x3D; 1,
	False &#x3D; 0
&#125;Bool;
#define SHOW_ERROR_DynamicArray_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)
#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)
#define SHOW_ERROR_DynamicArray_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)
#define SHOW_ERROR_DynamicArray_UnFind printf(&quot;\nPositions unfind!\n&quot;)
#define SHOW_ERROR_DynamicArray_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)
&#x2F;&#x2F;this type of int is specifically used in Returning Find Or Unfind.
&#x2F;&#x2F;Recommmend to be used as a nickname:)
&#x2F;&#x2F;Can use Find or Unfind to return the result
&#x2F;&#x2F;
typedef enum _DynamicArray_isFind_ &#123;
	Find &#x3D; 1,
	Unfind &#x3D; 0
&#125;DynamicArray_isFind;

&#x2F;&#x2F;A switch that used in better Print in Dynamic Array!
&#x2F;&#x2F;Often use OPEN to beautify the control table
&#x2F;&#x2F;
typedef enum _BetterPrintSwitch_for_dyarr_ &#123;
	Dyarr_OPEN &#x3D; 1,
	Dyarr_CLOSE &#x3D; 0
&#125;BetterPrintSwitch_for_dyarr;

&#x2F;&#x2F;Main Definitions about DynamicArray
&#x2F;&#x2F;When Programing , not recommend to Change the data directly! 
&#x2F;&#x2F;
typedef struct _DynamicArray_ &#123;
	void* DataPiece;
	size_t current_size;
	size_t total_usable_size;
	size_t Single_Data_size;
&#125;DynamicArray;

&#x2F;&#x2F;--------------------------------Default_size_Type--------------------------------------------
&#x2F;&#x2F;These abstractions are used to reduce the input
&#x2F;&#x2F;used as Dyarr_Default_TYPE(type_number) to replace the code:sizeof(Typename)*type_number
#if OPENUPDEFAULTSIZE

&#x2F;&#x2F;Single Type size
&#x2F;&#x2F;
#define Dyarr_SIGINT sizeof(int)
#define Dyarr_SIGCHAR sizeof(char)
#define Dyarr_SIGFLOAT sizeof(float)
#define Dyarr_SIGDOUBLE sizeof(double)
#define Dyarr_SIG(dataType) sizeof(dataType)

&#x2F;&#x2F;Mutiply type size
&#x2F;&#x2F;
#define Dyarr_INT_SIZE(X) sizeof(int)*X
#define Dyarr_CHAR_SIZE(X) sizeof(char)*X
#define Dyarr_FLOAT_SIZE(X) sizeof(float)*X
#define Dyarr_DOUBLE_SIZE(X) sizeof(double)*X
#define Dyarr_TYPE_SIZE(dataType,X) sizeof(dataType)*X

#endif


&#x2F;&#x2F;-------------------------------------------QuickMalloc----------------------------------------

&#x2F;&#x2F;As the name goes lol
&#x2F;&#x2F;
#if QUICKMALLOC 

#define Dyarr_DEFAULT_MALLOC 5
#define MALLOCDYARR(datatype,data_num) (datatype*)malloc(sizeof(datatype)*data_num)

#endif


&#x2F;&#x2F;----------------------------------------STD_FUNC_AND_INT_TYPE----------------------------------

&#x2F;&#x2F; Return type of compared functions
&#x2F;&#x2F;
typedef unsigned int Is_Used_Compared_Int;

&#x2F;&#x2F; the pointer type of Print !
&#x2F;&#x2F; When Printing , type :
&#x2F;&#x2F; MyPrint user_print_function_name(datatype* e1, datatype* e2)
&#x2F;&#x2F; &#123;
&#x2F;&#x2F;	print in your way for your data!
&#x2F;&#x2F; &#125;
&#x2F;&#x2F;
typedef void(*MyPrint)(void*);

&#x2F;&#x2F; the pointer type of Making change for the data that has been locates in the Dynamic Array!
&#x2F;&#x2F; When want to make some change, type like this:
&#x2F;&#x2F; Do_Specific_Change user_dochange_function_name(datatype* e1, datatype* e2)
&#x2F;&#x2F;&#123;
&#x2F;&#x2F;	do some change here for your data!
&#x2F;&#x2F;&#125;
&#x2F;&#x2F;
typedef void* (*Do_Specific_Change)(void*);

&#x2F;&#x2F; the pointer type of using when comparing for your data
&#x2F;&#x2F; When want to make a comparisons, type like this:
&#x2F;&#x2F; CompareFunc user_comp_function_name(datatype* e1, datatype* e2)
&#x2F;&#x2F;&#123;
&#x2F;&#x2F;	return &#x2F;&#x2F;the wishing compare!&#x2F;&#x2F;
&#x2F;&#x2F;&#125;
&#x2F;&#x2F;
typedef Is_Used_Compared_Int(*CompareFunc)(void*, void*);

&#x2F;&#x2F; the pointer type of using when checking iflocated for your data
&#x2F;&#x2F; When want to make a comparisons, type like this:
&#x2F;&#x2F; LocateFunc user_loc_function_name(datatype* e1, datatype* e2)
&#x2F;&#x2F;&#123;
&#x2F;&#x2F;	return data1&#x3D;&#x3D;data2(define by yourself! if complicated, just return Find or unfind to show whether is found)
&#x2F;&#x2F;&#125;
&#x2F;&#x2F;
typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);


&#x2F;&#x2F;-----------------------Position_Stored_Dynamic_Array_For_Dyarr---------------------------------
#if OPENUPPOSARR
&#x2F;&#x2F;Main data structure!
&#x2F;&#x2F;Used in returning multitude locations
&#x2F;&#x2F;
typedef struct _Dyarrposarr_ &#123;
	int* posSpace;
	size_t pos_size;
&#125;Position_Stored_Dynamic_ArrayFordyarr;

&#x2F;&#x2F;Want a better Print to beutify your control table? try this one
&#x2F;&#x2F;
typedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;
	PSDA_dyarr_OPEN &#x3D; 1,
	PSDA_dyarr_CLOSE &#x3D; 0
&#125;BetterPrintSwitch_for_pos_dyarr;

&#x2F;&#x2F;can use this type when indicating the type
&#x2F;&#x2F;
typedef unsigned int BetterPrintfor_PosDyarr;

&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func
&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:
&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();
&#x2F;&#x2F;
Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr();
&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos
&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE
&#x2F;&#x2F;
DynamicArrayFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr* posarr,
	BetterPrintfor_PosDyarr					Whether_Better_Print
);
&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to push back a position into the Position_Stored_Dynamic_ArrayFordyarr
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_back_a_locations_in_PSDA_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr* posarr,
	int			pos_acquired
);
&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to return the number of locations
&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE
&#x2F;&#x2F;
size_t Get_pos_size_From_PSDA_for_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr* posarr,
	BetterPrintfor_PosDyarr							Whether_Shown_Print
);
&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;Erase a dynamic Array when donot using it!
&#x2F;&#x2F;
DynamicArrayFunctionStatues DesTroy_A_PSDA_for_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr* pointer_to_wishedfreeposarr
);
&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;return a pos that is targeted!
&#x2F;&#x2F;
void* getPosbyPosinPSDA(
	Position_Stored_Dynamic_ArrayFordyarr* getter,
	size_t												pos
);
#endif

&#x2F;&#x2F;----------------------------------DynamicArray----------------------------------------------------------------------
&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;A Properway to init a default and empty Dynamic Array
&#x2F;&#x2F;Use like this: DynamicArray* Dyarr &#x3D; Init_A_DynamicArray(expected_number, datasize)
&#x2F;&#x2F;
DynamicArray* Init_A_DynamicArray(
	size_t					expected_number,
	size_t					datasize
);
&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Copied up a Dyarr!
&#x2F;&#x2F;Use like this: DynamicArray* copied_one &#x3D; Init_A_DynamicArray_by_CopyADyarr(be_copied)
&#x2F;&#x2F;
DynamicArray* Init_A_DynamicArray_by_CopyADyarr(
	DynamicArray* dyarr_copied
);
&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;An update! used to transform a static array to DynamicArray
&#x2F;&#x2F;use like this:  
&#x2F;&#x2F;DynamicArray* update_arr &#x3D; Updata_A_Static_Array_To_Dynamic_Array(
&#x2F;&#x2F;static arr,
&#x2F;&#x2F;sizeof(data),
&#x2F;&#x2F;how_many_data_are_there_in_the_static_array)
&#x2F;&#x2F;
DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(
	void* data,
	size_t						datasize,
	size_t						datanum
);
&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Push back a data into the Dynamic Array
&#x2F;&#x2F;Use like this: Push_Back_Into_A_Dynamic_Array(dyarr,data)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(
	DynamicArray*										dyarr,
	void*												data,
	size_t												datasize
);
&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Push back a lot of data that has a organization that has all the same data
&#x2F;&#x2F;Use like this: 
&#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(dyarr,data,the_time_data_repeated,sizeof(data))
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(
	DynamicArray* dyarr,
	void* data,
	size_t						n_repeat,
	size_t						datasize
);
&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Push back a lot of data that has a organization that has a organiztion with static array
&#x2F;&#x2F;Use like this: 
&#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(
&#x2F;&#x2F;dyarr,
&#x2F;&#x2F;data,
&#x2F;&#x2F;how_many_data_are_there_in_static_array,
&#x2F;&#x2F;sizeof(data))
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(
	DynamicArray* dyarr,
	void* data_array,
	size_t						array_num,
	size_t						pos,
	size_t						data_inarray_size
);
&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Reshape the dynamic array
&#x2F;&#x2F;NOT ROCOMMEND TO USE UNLESS YOU ARE CONCIOUS OF WHAT YOU ARE DOING
&#x2F;&#x2F;
DynamicArrayFunctionStatues Resize_The_Dynamic_Array(
	DynamicArray* dyarr,
	size_t						wished_new_space_size
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Insert back a data 
&#x2F;&#x2F; use like this: 
&#x2F;&#x2F; Insert_Into_A_Dynamic_Array(
&#x2F;&#x2F; dyarr, 
&#x2F;&#x2F; data, 
&#x2F;&#x2F; where_to_insert,
&#x2F;&#x2F;
DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(
	DynamicArray* dyarr,
	void* data,
	size_t						pos
);

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data
&#x2F;&#x2F;Use like this: 																		
&#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(
	DynamicArray* dyarr,
	void* data,
	size_t												n_repeat,
	size_t												datasize,
	size_t												pos
);
&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Insert back some data that organized in static array
&#x2F;&#x2F;use like this: Insert_Into_A_Dynamic_Array(
&#x2F;&#x2F; dyarr, 
&#x2F;&#x2F; where_to_insert, 
&#x2F;&#x2F; data, 
&#x2F;&#x2F; how_many_data_are_there_in_static_array,
&#x2F;&#x2F; sizeof(data)
&#x2F;&#x2F;)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(
	DynamicArray* dyarr,
	size_t						pos,
	void* data_array,
	size_t						array_num,
	size_t						data_inarray_size
);
&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Append another dynamic Array
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; AppendByMergeDynamicArray(dyarr_be_appended, exp_append_array)
&#x2F;&#x2F;
DynamicArrayFunctionStatues AppendByMergeDynamicArray(
	DynamicArray* dyarr_be_appended,
	DynamicArray* exp_append_array
);
&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Gain a copy of targeted array from the dynamic array
&#x2F;&#x2F;use like this
&#x2F;&#x2F; type* datawanna &#x3D; Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(dyarr, datawanna, sizeof(datawanna))
&#x2F;&#x2F;
void* Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(
	DynamicArray* dyarr,
	size_t						pos,
	void* container,
	size_t						container_size
);

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase the final element!
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(
	DynamicArray* dyarr
);

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase the final element!
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(
	DynamicArray* dyarr
);

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase all elements!
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Clear_A_Dynamic_Array(dyarr)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Clear_A_Dynamic_Array(
	DynamicArray* dyarr
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase all elements! and unable to be used again!
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Destroy_A_Dynamic_Array(dyarr)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(
	DynamicArray* dyarr
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually Print All data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(
	DynamicArray* dyarr,
	MyPrint						user_print,
	BetterPrintSwitch_for_dyarr whether_better_print
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually Print a specific data
&#x2F;&#x2F; use like this
&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(
	DynamicArray* dyarr,
	MyPrint						user_print,
	size_t						pos
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually make some change in all data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(
	DynamicArray* dyarr,
	Do_Specific_Change			user_change
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually make some change in a specific data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(
	DynamicArray* dyarr,
	Do_Specific_Change			user_change,
	size_t						pos
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase a specific data by pos
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(
	DynamicArray* dyarr,
	size_t						pos
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase some specific data by pos
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(
	DynamicArray* dyarr,
	size_t						Beginpos,
	size_t						Endpos
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase a specific data by pos
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues reverse_Data_In_DynamicArray(
	DynamicArray* dyarr
);
&#x2F;&#x2F;
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; this is used in judging whether the dynamic array is empty
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; isEmpty_InDynamicArray(dyarr)
&#x2F;&#x2F;
Bool isEmpty_InDynamicArray(
	DynamicArray* dyarr
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; this is used in swap data
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)
&#x2F;&#x2F;
DynamicArrayFunctionStatues swapData_in_DynamicArray(
	DynamicArray* dyarr,
	size_t						pos1,
	size_t						pos2
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; sadly that is bubblesort :(
&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)
&#x2F;&#x2F;
DynamicArrayFunctionStatues sort_In_Dynamic_Array(
	DynamicArray* dyarr,
	CompareFunc					compfunc
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; check if located in the dynamic array
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; isLocateinDyarr(dyarr, data, comparision_funcuntional_pointer)
&#x2F;&#x2F;
DynamicArrayFunctionStatues isLocateinDyarr(
	DynamicArray* dyarr,
	void* data,
	LocateFunc					user_func
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; return the position of data that is targeted 
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; returnAElembyPos_inDyarr(dyarr, data, comparision_funcuntional_pointer)
&#x2F;&#x2F;
DynamicArrayFunctionStatues returnAElembyPos_inDyarr(
	DynamicArray* dyarr,
	void* data,
	LocateFunc					user_func
);
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Using the function when Posarr is enable to use!
&#x2F;&#x2F; return a bunch of position of data that is targeted 
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Position_Stored_Dynamic_ArrayFordyarr* pos &#x3D;r eturnAElembyPos_inDyarr(dyarr, posArr,data, comparision_funcuntional_pointer)
&#x2F;&#x2F;
#if OPENUPPOSARR
Position_Stored_Dynamic_ArrayFordyarr* returnABunchofData_inDyarr(
	DynamicArray* dyarr,
	Position_Stored_Dynamic_ArrayFordyarr* posArr,
	void* data,
	LocateFunc					user_func
);
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>2.源文件：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1
#define	OPENUPPOSARR 1
#define OPENUPDEFAULTSIZE 1
#define	QUICKMALLOC 1
&#x2F;&#x2F;(General Version)
&#x2F;&#x2F;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
&#x2F;&#x2F;Error Code Meaning
&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0
&#x2F;&#x2F;When Error in mallocing Space the program return 1
&#x2F;&#x2F;when inputing a NULL we returns -1
&#x2F;&#x2F;when inputing a invalid input we returns -2
&#x2F;&#x2F;Locations UnFind we returns -3 
&#x2F;&#x2F;
typedef enum _DynamicFunctionStatues_ &#123;
	DynamicArray_Normal &#x3D; 0,
	DynamicArray_ERROR_IN_MALLOCING_SPACE&#x3D;1,
	DynamicArray_NULL_INPUT&#x3D;-1,
	DynamicArray_Invalid_Input&#x3D;-2,
	DynamicArray_UnFind&#x3D;-3,
	DynamicArray_Invalid_Free&#x3D;-4
&#125;DynamicArrayFunctionStatues;
&#x2F;&#x2F;Mybool defined
&#x2F;&#x2F;
typedef enum _bool_ &#123;
	True &#x3D; 1,
	False &#x3D; 0
&#125;Bool;
#define SHOW_ERROR_DynamicArray_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)
#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)
#define SHOW_ERROR_DynamicArray_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)
#define SHOW_ERROR_DynamicArray_UnFind printf(&quot;\nPositions unfind!\n&quot;)
#define SHOW_ERROR_DynamicArray_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)
&#x2F;&#x2F;this type of int is specifically used in Returning Find Or Unfind.
&#x2F;&#x2F;Recommmend to be used as a nickname:)
&#x2F;&#x2F;Can use Find or Unfind to return the result
&#x2F;&#x2F;
typedef enum _DynamicArray_isFind_ &#123;
	Find&#x3D;1,
	Unfind&#x3D;-1
&#125;DynamicArray_isFind;

&#x2F;&#x2F;A switch that used in better Print in Dynamic Array!
&#x2F;&#x2F;Often use OPEN to beautify the control table
&#x2F;&#x2F;
typedef enum _BetterPrintSwitch_for_dyarr_ &#123;
	Dyarr_OPEN &#x3D; 1,
	Dyarr_CLOSE &#x3D; 0
&#125;BetterPrintSwitch_for_dyarr;

&#x2F;&#x2F;Main Definitions about DynamicArray
&#x2F;&#x2F;When Programing , not recommend to Change the data directly! 
&#x2F;&#x2F;
typedef struct _DynamicArray_ &#123;
	void* DataPiece;
	size_t current_size;
	size_t total_usable_size;
	size_t Single_Data_size;
&#125;DynamicArray;

&#x2F;&#x2F;--------------------------------Default_size_Type--------------------------------------------
&#x2F;&#x2F;These abstractions are used to reduce the input
&#x2F;&#x2F;used as Dyarr_Default_TYPE(type_number) to replace the code:sizeof(Typename)*type_number
#if OPENUPDEFAULTSIZE

&#x2F;&#x2F;Single Type size
&#x2F;&#x2F;
#define Dyarr_SIGINT sizeof(int)
#define Dyarr_SIGCHAR sizeof(char)
#define Dyarr_SIGFLOAT sizeof(float)
#define Dyarr_SIGDOUBLE sizeof(double)
#define Dyarr_SIG(dataType) sizeof(dataType)

&#x2F;&#x2F;Mutiply type size
&#x2F;&#x2F;
#define Dyarr_INT_SIZE(X) sizeof(int)*X
#define Dyarr_CHAR_SIZE(X) sizeof(char)*X
#define Dyarr_FLOAT_SIZE(X) sizeof(float)*X
#define Dyarr_DOUBLE_SIZE(X) sizeof(double)*X
#define Dyarr_TYPE_SIZE(dataType,X) sizeof(dataType)*X

#endif


&#x2F;&#x2F;-------------------------------------------QuickMalloc----------------------------------------

&#x2F;&#x2F;As the name goes lol
&#x2F;&#x2F;
#if QUICKMALLOC 

#define Dyarr_DEFAULT_MALLOC 5
#define MALLOCDYARR(datatype,data_num) (datatype*)malloc(sizeof(datatype)*data_num)

#endif


&#x2F;&#x2F;----------------------------------------STD_FUNC_AND_INT_TYPE----------------------------------

&#x2F;&#x2F; Return type of compared functions
&#x2F;&#x2F;
typedef unsigned int Is_Used_Compared_Int;

&#x2F;&#x2F; the pointer type of Print !
&#x2F;&#x2F; When Printing , type :
&#x2F;&#x2F; MyPrint user_print_function_name(datatype* e1, datatype* e2)
&#x2F;&#x2F; &#123;
&#x2F;&#x2F;	print in your way for your data!
&#x2F;&#x2F; &#125;
&#x2F;&#x2F;
typedef void(*MyPrint)(void*);

&#x2F;&#x2F; the pointer type of Making change for the data that has been locates in the Dynamic Array!
&#x2F;&#x2F; When want to make some change, type like this:
&#x2F;&#x2F; Do_Specific_Change user_dochange_function_name(datatype* e1, datatype* e2)
&#x2F;&#x2F;&#123;
&#x2F;&#x2F;	do some change here for your data!
&#x2F;&#x2F;&#125;
&#x2F;&#x2F;
typedef void*(*Do_Specific_Change)(void*);

&#x2F;&#x2F; the pointer type of using when comparing for your data
&#x2F;&#x2F; When want to make a comparisons, type like this:
&#x2F;&#x2F; CompareFunc user_comp_function_name(datatype* e1, datatype* e2)
&#x2F;&#x2F;&#123;
&#x2F;&#x2F;	return &#x2F;&#x2F;the wishing compare!&#x2F;&#x2F;
&#x2F;&#x2F;&#125;
&#x2F;&#x2F;
typedef Is_Used_Compared_Int(*CompareFunc)(void*,void*);

&#x2F;&#x2F; the pointer type of using when checking iflocated for your data
&#x2F;&#x2F; When want to make a comparisons, type like this:
&#x2F;&#x2F; LocateFunc user_loc_function_name(datatype* e1, datatype* e2)
&#x2F;&#x2F;&#123;
&#x2F;&#x2F;	return data1&#x3D;&#x3D;data2(define by yourself! if complicated, just return Find or unfind to show whether is found)
&#x2F;&#x2F;&#125;
&#x2F;&#x2F;
typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);


&#x2F;&#x2F;-----------------------Position_Stored_Dynamic_Array_For_Dyarr---------------------------------
#if OPENUPPOSARR
&#x2F;&#x2F;Main data structure!
&#x2F;&#x2F;Used in returning multitude locations
&#x2F;&#x2F;
typedef struct _Dyarrposarr_ &#123;
	int* posSpace;
	size_t pos_size;
&#125;Position_Stored_Dynamic_ArrayFordyarr;

&#x2F;&#x2F;Want a better Print to beutify your control table? try this one
&#x2F;&#x2F;
typedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;
	PSDA_dyarr_OPEN &#x3D; 1,
	PSDA_dyarr_CLOSE &#x3D; 0
&#125;BetterPrintSwitch_for_pos_dyarr;

&#x2F;&#x2F;can use this type when indicating the type
&#x2F;&#x2F;
typedef unsigned int BetterPrintfor_PosDyarr;

&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func
&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:
&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();
&#x2F;&#x2F;
Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr()
&#123;
	Position_Stored_Dynamic_ArrayFordyarr* pro_usable_space &#x3D; MALLOCDYARR(Position_Stored_Dynamic_ArrayFordyarr, 1);
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
  	pro_usable_space-&gt;posSpace &#x3D; NULL;
	pro_usable_space-&gt;pos_size &#x3D; 0;
	return pro_usable_space;
&#125;
&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos
&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE
&#x2F;&#x2F;
DynamicArrayFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*				posarr,
	BetterPrintfor_PosDyarr								Whether_Better_Print
)
&#123;
	if (!posarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)
		printf(&quot;\nPositions are shown! :\n&quot;);
	for (int i &#x3D; 0; i &lt; posarr-&gt;pos_size; i++)
		printf(&quot;%u &quot;, posarr-&gt;posSpace[i]);
	if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)
		printf(&quot;\nFinish Printing!\n&quot;);
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to push back a position into the Position_Stored_Dynamic_ArrayFordyarr
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_back_a_locations_in_PSDA_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*				posarr, 
	int													pos_acquired
)
&#123;
	int* pro_usable_space &#x3D; (int*)realloc(posarr-&gt;posSpace, sizeof(int) * (posarr-&gt;pos_size + 1));
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	posarr-&gt;posSpace &#x3D; pro_usable_space;
	posarr-&gt;posSpace[posarr-&gt;pos_size] &#x3D; pos_acquired;
	posarr-&gt;pos_size++;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to return the number of locations
&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE
&#x2F;&#x2F;
size_t Get_pos_size_From_PSDA_for_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*				posarr,
	BetterPrintfor_PosDyarr								Whether_Shown_Print 
)
&#123;
	if (!posarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (Whether_Shown_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)
		printf(&quot;\nCurrent targeted data&#39;s total num is:%u!\n&quot;,posarr-&gt;pos_size);
	return posarr-&gt;pos_size;
&#125;

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;Erase a dynamic Array when donot using it!
&#x2F;&#x2F;
DynamicArrayFunctionStatues DesTroy_A_PSDA_for_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*				pointer_to_wishedfreeposarr
)
&#123;
	if (!pointer_to_wishedfreeposarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_Invalid_Free);
	&#125;
	free(pointer_to_wishedfreeposarr-&gt;posSpace);
	free(pointer_to_wishedfreeposarr);
	pointer_to_wishedfreeposarr &#x3D; NULL;
	return DynamicArray_Normal;
&#125;
&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;return a pos that is targeted!
&#x2F;&#x2F;
void* getPosbyPosinPSDA(
	Position_Stored_Dynamic_ArrayFordyarr*				getter,
	size_t												pos
) 
&#123;
	if (!getter) &#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_Invalid_Free);
	&#125;
	if (pos &gt; getter-&gt;pos_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	for (int i &#x3D; 0; i &lt; pos; i++)
		return (char*)getter-&gt;posSpace + i * sizeof(size_t);
&#125;
#endif

&#x2F;&#x2F;----------------------------------DynamicArray----------------------------------------------------------------------
&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;A Properway to init a default and empty Dynamic Array
&#x2F;&#x2F;Use like this: DynamicArray* Dyarr &#x3D; Init_A_DynamicArray(expected_number, datasize)
&#x2F;&#x2F;
DynamicArray* Init_A_DynamicArray(
	size_t												expected_number,
	size_t												datasize
)
&#123;
	DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);
	if(!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	pro_usable_space-&gt;DataPiece &#x3D; NULL;
	pro_usable_space-&gt;Single_Data_size &#x3D; datasize;
	if (expected_number &gt;&#x3D; Dyarr_DEFAULT_MALLOC)
		pro_usable_space-&gt;total_usable_size &#x3D; expected_number;
	else
		pro_usable_space-&gt;total_usable_size &#x3D; Dyarr_DEFAULT_MALLOC;
	pro_usable_space-&gt;current_size &#x3D; 0;
	return pro_usable_space;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Copied up a Dyarr!
&#x2F;&#x2F;Use like this: DynamicArray* copied_one &#x3D; Init_A_DynamicArray_by_CopyADyarr(be_copied)
&#x2F;&#x2F;
DynamicArray* Init_A_DynamicArray_by_CopyADyarr(
	DynamicArray*										dyarr_copied
)
&#123;
	if (!dyarr_copied)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	void* pro_usable_data &#x3D; MALLOCDYARR(char, (dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size));
	if(!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;
	memcpy(pro_usable_space-&gt;DataPiece, dyarr_copied-&gt;DataPiece, dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size);
	pro_usable_space-&gt;current_size &#x3D; dyarr_copied-&gt;current_size;
	pro_usable_space-&gt;Single_Data_size &#x3D; dyarr_copied-&gt;Single_Data_size;
	pro_usable_space-&gt;total_usable_size &#x3D; dyarr_copied-&gt;total_usable_size;
	return pro_usable_space;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;An update! used to transform a static array to DynamicArray
&#x2F;&#x2F;use like this:  
&#x2F;&#x2F;DynamicArray* update_arr &#x3D; Updata_A_Static_Array_To_Dynamic_Array(
&#x2F;&#x2F;static arr,
&#x2F;&#x2F;sizeof(data),
&#x2F;&#x2F;how_many_data_are_there_in_the_static_array)
&#x2F;&#x2F;
DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(
	void*												data, 
	size_t												datasize,
	size_t												datanum
)
&#123;
	if (!data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);
	if(!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	void* pro_usable_data &#x3D; malloc(datasize * datanum*1.5);
	if(!pro_usable_data)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memcpy(pro_usable_data, data, datasize * datanum);
	pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;
	pro_usable_space-&gt;current_size &#x3D; datanum;
	pro_usable_space-&gt;Single_Data_size &#x3D; datasize;
	pro_usable_space-&gt;total_usable_size &#x3D; 1.5 * datanum;
	return pro_usable_space;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Push back a data into the Dynamic Array
&#x2F;&#x2F;Use like this: Push_Back_Into_A_Dynamic_Array(dyarr,data)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(
	DynamicArray*										dyarr, 
	void*												data,
	size_t												datasize
)
&#123;
	if (!dyarr &amp;&amp; !data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (datasize !&#x3D; dyarr-&gt;Single_Data_size) 
	&#123;
		printf(&quot;%d &quot;, sizeof(data));
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 1.3 * (dyarr-&gt;total_usable_size));
	void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1)*dyarr-&gt;Single_Data_size);
	if (!Afteradd_piece)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memcpy((char*)Afteradd_piece + dyarr-&gt;current_size * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);
	dyarr-&gt;DataPiece &#x3D; Afteradd_piece;
	dyarr-&gt;current_size++;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Push back a lot of data that has a organization that has all the same data
&#x2F;&#x2F;Use like this: 
&#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(dyarr,data,the_time_data_repeated,sizeof(data))
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr,
	void*												data,
	size_t												n_repeat,
	size_t												datasize
)
&#123;
	if (!dyarr &amp;&amp; !data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (datasize !&#x3D; dyarr-&gt;Single_Data_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);
	int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;
	if (datarate &gt; 0)
		Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);
	void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);
	if (!newspace)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	for (int i &#x3D; 0; i &lt; n_repeat; i++)
		memcpy(
			(char*)newspace + (dyarr-&gt;current_size+i) * dyarr-&gt;Single_Data_size,
			data,
			dyarr-&gt;Single_Data_size
		);
	dyarr-&gt;DataPiece &#x3D; newspace;
	dyarr-&gt;current_size +&#x3D; n_repeat;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Push back a lot of data that has a organization that has a organiztion with static array
&#x2F;&#x2F;Use like this: 
&#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(
&#x2F;&#x2F;dyarr,
&#x2F;&#x2F;data,
&#x2F;&#x2F;how_many_data_are_there_in_static_array,
&#x2F;&#x2F;sizeof(data))
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr, 
	void*												data_array, 
	size_t												array_num, 
	size_t												pos,
	size_t												data_inarray_size
)
&#123;
	if (!dyarr &amp;&amp; !data_array)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (data_inarray_size !&#x3D; dyarr-&gt;Single_Data_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;
	if (DataRate &gt; 0)
		Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);
	void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);
	if(!newspace)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	dyarr-&gt;DataPiece &#x3D; newspace;
	for (int i &#x3D; 0; i &lt; array_num; i++)
		memcpy(
			(char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,
			(char*)data_array + i * (dyarr-&gt;Single_Data_size),
			dyarr-&gt;Single_Data_size
		);
	dyarr-&gt;current_size +&#x3D; array_num;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Reshape the dynamic array
&#x2F;&#x2F;NOT ROCOMMEND TO USE UNLESS YOU ARE CONCIOUS OF WHAT YOU ARE DOING
&#x2F;&#x2F;
DynamicArrayFunctionStatues Resize_The_Dynamic_Array(
	DynamicArray*										dyarr,
	size_t												wished_new_space_size
)
&#123;
	if(!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, wished_new_space_size * (dyarr-&gt;Single_Data_size));
	if (!newspace)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	dyarr-&gt;DataPiece &#x3D; newspace;
	dyarr-&gt;total_usable_size &#x3D; wished_new_space_size;
	if (dyarr-&gt;current_size &gt; dyarr-&gt;total_usable_size)
		dyarr-&gt;current_size &#x3D; dyarr-&gt;total_usable_size;&#x2F;&#x2F;Used when still unable to contain data
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Insert back a data 
&#x2F;&#x2F; use like this: 
&#x2F;&#x2F; Insert_Into_A_Dynamic_Array(
&#x2F;&#x2F; dyarr, 
&#x2F;&#x2F; data, 
&#x2F;&#x2F; where_to_insert,
&#x2F;&#x2F;
DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(
	DynamicArray*										dyarr, 
	void*												data, 
	size_t												pos
)
&#123;
	if (!dyarr &amp;&amp; !data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 2 * (dyarr-&gt;total_usable_size));
	void* Afteradd_piece&#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1) * dyarr-&gt;Single_Data_size);
	if (!Afteradd_piece)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memcpy(
		(char*)dyarr-&gt;DataPiece + (pos + 1) * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos+1)
	);
	memmove(
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size, 
		data, 
		dyarr-&gt;Single_Data_size
	);
	dyarr-&gt;current_size++;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data
&#x2F;&#x2F;Use like this: 																		
&#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr,
	void*												data,
	size_t												n_repeat,
	size_t												datasize,
	size_t												pos
)
&#123;
	if (!dyarr &amp;&amp; !data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (datasize !&#x3D; dyarr-&gt;Single_Data_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);
	int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;
	if (datarate &gt; 0)
		Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);
	void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);
	if (!newspace)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memmove(
		(char*)dyarr-&gt;DataPiece + (pos + n_repeat) * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size * n_repeat
	);
	for (int i &#x3D; 0; i &lt; n_repeat; i++)
		memcpy(
			(char*)newspace + (pos + i) * dyarr-&gt;Single_Data_size,
			data,
			dyarr-&gt;Single_Data_size
		);
	dyarr-&gt;DataPiece &#x3D; newspace;
	dyarr-&gt;current_size +&#x3D; n_repeat;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Insert back some data that organized in static array
&#x2F;&#x2F;use like this: Insert_Into_A_Dynamic_Array(
&#x2F;&#x2F; dyarr, 
&#x2F;&#x2F; where_to_insert, 
&#x2F;&#x2F; data, 
&#x2F;&#x2F; how_many_data_are_there_in_static_array,
&#x2F;&#x2F; sizeof(data)
&#x2F;&#x2F;)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr,
	size_t												pos,
	void*												data_array, 
	size_t												array_num,
	size_t												data_inarray_size
)
&#123;
	if (!dyarr &amp;&amp; !data_array)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (!dyarr-&gt;current_size)
	&#123;
		Push_Back_Some_data_Into_A_Dynamic_Array(
			dyarr, 
			data_array, 
			array_num, 
			pos,
			data_inarray_size
		);
		return DynamicArray_Normal;
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);
	int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;
	if (DataRate &gt; 0)
		Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);
	void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);
	if (!Afteradd_piece)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memmove(
		(char*)dyarr-&gt;DataPiece + (pos + array_num) * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size*array_num
	);
	for (int i &#x3D; 0; i &lt; array_num; i++)
		memcpy(
			(char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,
			(char*)data_array + i * (dyarr-&gt;Single_Data_size),
			dyarr-&gt;Single_Data_size
		);
	dyarr-&gt;current_size +&#x3D; array_num;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Append another dynamic Array
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; AppendByMergeDynamicArray(dyarr_be_appended, exp_append_array)
&#x2F;&#x2F;
DynamicArrayFunctionStatues AppendByMergeDynamicArray(
	DynamicArray*											dyarr_be_appended,
	DynamicArray*											exp_append_array
)
&#123;
	if (!dyarr_be_appended &amp;&amp; !exp_append_array)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	int datarate &#x3D; exp_append_array-&gt;current_size &#x2F; dyarr_be_appended-&gt;total_usable_size;
	if (dyarr_be_appended-&gt;current_size &#x3D;&#x3D; dyarr_be_appended-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr_be_appended, 2 * dyarr_be_appended-&gt;total_usable_size);
	if (datarate &gt; 0)
		Resize_The_Dynamic_Array(dyarr_be_appended, (datarate + 1) * dyarr_be_appended-&gt;total_usable_size);
	void* AfterAppend &#x3D; realloc(
		dyarr_be_appended-&gt;DataPiece,
		(dyarr_be_appended-&gt;current_size + exp_append_array-&gt;current_size) * dyarr_be_appended-&gt;Single_Data_size
	);
	if (!AfterAppend)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	dyarr_be_appended-&gt;DataPiece &#x3D; AfterAppend;
	memcpy(
		(char*)dyarr_be_appended-&gt;DataPiece + dyarr_be_appended-&gt;current_size * dyarr_be_appended-&gt;Single_Data_size,
		(char*)exp_append_array-&gt;DataPiece,
		exp_append_array-&gt;current_size * exp_append_array-&gt;Single_Data_size
	);
	dyarr_be_appended-&gt;current_size +&#x3D; exp_append_array-&gt;current_size;
	
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Gain a copy of targeted array from the dynamic array
&#x2F;&#x2F;use like this
&#x2F;&#x2F; type* datawanna &#x3D; Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(dyarr, datawanna, sizeof(datawanna))
&#x2F;&#x2F;
void* Copy_A_Specific_DataFrom_A_Dynamic_Array_bypos(
	DynamicArray*											dyarr, 
	size_t													pos,
	void*													container,
	size_t													container_size
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;Single_Data_size&gt; container_size)
	&#123;
		printf(&quot;Specifically unable to contain your data! Try Larger one!\nNull pointer is returned!&quot;);
		return NULL;
	&#125;
	if (dyarr-&gt;Single_Data_size &lt; container_size)
	&#123;
		printf(
			&quot;Warning:Be Cautious the size doesn&#39;t fit!Please change your pointer step from %u to %u\nElse Error will be occurred&quot;, 
			container_size, 
			dyarr-&gt;Single_Data_size
		);
		exit(DynamicArray_Invalid_Input);
	&#125;
	memcpy(
		container, 
		(char*)dyarr-&gt;DataPiece + pos * (dyarr-&gt;Single_Data_size), 
		container_size
	);
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase the final element!
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(
	DynamicArray*											dyarr
)
&#123;
	if(!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	dyarr-&gt;current_size--;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase all elements!
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Clear_A_Dynamic_Array(dyarr)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Clear_A_Dynamic_Array(
	DynamicArray*											dyarr
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	dyarr-&gt;current_size &#x3D; 0;
	if (!dyarr-&gt;DataPiece)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Free;
		printf(&quot;VOID DATA SHOULDN&#39;T BE FREE!&quot;);
		exit(DynamicArray_Invalid_Free);
	&#125;
	void* pro_usable_space&#x3D; realloc(dyarr-&gt;DataPiece, dyarr-&gt;Single_Data_size);
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	dyarr-&gt;DataPiece&#x3D;pro_usable_space;
	dyarr-&gt;total_usable_size &#x3D; 1;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase all elements! and unable to be used again!
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Destroy_A_Dynamic_Array(dyarr)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(
	DynamicArray*												dyarr
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Free;
		exit(DynamicArray_Invalid_Free);
	&#125;
	free(dyarr-&gt;DataPiece);
	free(dyarr);
	return DynamicArray_Normal;
&#125;


&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually Print All data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(
	DynamicArray*												dyarr,
	MyPrint														user_print,
	BetterPrintSwitch_for_dyarr									whether_better_print
)
&#123;
	if (!dyarr &amp;&amp; !user_print)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if(whether_better_print&#x3D;&#x3D;Dyarr_OPEN)
	&#123;
		printf(&quot;\nStart Printing\n&quot;);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
	&#123;
		(*user_print)((char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size));
	&#125;
	if (whether_better_print &#x3D;&#x3D; Dyarr_OPEN)
	&#123;
		printf(&quot;\nFinish Printing\n&quot;);
	&#125;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually Print a specific data
&#x2F;&#x2F; use like this
&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(
	DynamicArray*												dyarr, 
	MyPrint														user_print, 
	size_t														pos
) 
&#123;
	if (!dyarr &amp;&amp; !user_print)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	printf(&quot;\nSpecific Data is Shown:\n&quot;);
	user_print((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));
	printf(&quot;\nSpecific Data Finished Showing!\n&quot;);
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually make some change in all data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(
	DynamicArray*												dyarr, 
	Do_Specific_Change											user_change
) 
&#123;
	if (!dyarr &amp;&amp; !user_change)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
		user_change((char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size));
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually make some change in a specific data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(
	DynamicArray*												dyarr, 
	Do_Specific_Change											user_change, 
	size_t														pos
)
&#123;
	if (!dyarr &amp;&amp; !user_change)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	user_change((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase a specific data by pos
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(
	DynamicArray*												dyarr, 
	size_t														pos
)
&#123;
	if(!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	memcpy(
		(char*)dyarr-&gt;DataPiece+pos*dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece+(pos+1)*dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos-1)
		);
	dyarr-&gt;current_size--;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase some specific data by pos
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(
	DynamicArray*												dyarr, 
	size_t														Beginpos, 
	size_t														Endpos
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (Beginpos &lt; 0 || Beginpos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (Endpos &lt; 0 || Endpos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	memcpy(
		(char*)dyarr-&gt;DataPiece + Beginpos * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + (Endpos + 1) * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - Endpos + 1)
	);
	dyarr-&gt;current_size -&#x3D; Endpos - Beginpos + 1;
	if (dyarr-&gt;current_size &lt;&#x3D; dyarr-&gt;total_usable_size &#x2F; 4 &amp;&amp; dyarr-&gt;total_usable_size &gt; 5)
	&#123;
		Resize_The_Dynamic_Array(dyarr, dyarr-&gt;total_usable_size &#x2F; 2);
		dyarr-&gt;total_usable_size &#x2F;&#x3D; 2;
	&#125;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase a specific data by pos
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues reverse_Data_In_DynamicArray(
	DynamicArray*												dyarr
) 
&#123;
	if(!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size &#x2F; 2; i++)
	&#123;
		memcpy(
			swapbit, 
			(char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size, 
			dyarr-&gt;Single_Data_size
		);&#x2F;&#x2F;原型：int temp&#x3D;*a,*a&#x3D;*b,*b&#x3D;temp
		memmove(
			(char*)dyarr-&gt;DataPiece + i*dyarr-&gt;Single_Data_size,
			(char*)dyarr-&gt;DataPiece + (dyarr-&gt;current_size - i-1) * dyarr-&gt;Single_Data_size,
			dyarr-&gt;Single_Data_size
		);
		memcpy(
			(char*)dyarr-&gt;DataPiece + (dyarr-&gt;current_size - i - 1) * dyarr-&gt;Single_Data_size, 
			swapbit, 
			dyarr-&gt;Single_Data_size
		);
	&#125;
	free(swapbit);
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; this is used in judging whether the dynamic array is empty
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; isEmpty_InDynamicArray(dyarr)
&#x2F;&#x2F;
Bool isEmpty_InDynamicArray(
	DynamicArray*												dyarr
) 
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!dyarr-&gt;current_size)
		return True;
	return False;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; this is used in swap data
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)
&#x2F;&#x2F;
DynamicArrayFunctionStatues swapData_in_DynamicArray(
	DynamicArray*												dyarr, 
	size_t														pos1, 
	size_t														pos2
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);
	if(!swapbit)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memcpy(
		swapbit,
		(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size
	);
	memmove(
		(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size
	);
	memcpy(
		(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,
		swapbit,
		dyarr-&gt;Single_Data_size
	);
	free(swapbit);
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; sadly that is bubblesort :(
&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)
&#x2F;&#x2F;
DynamicArrayFunctionStatues sort_In_Dynamic_Array(
	DynamicArray*												dyarr,
	CompareFunc													compfunc
) 
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!compfunc)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size-1; i++)
	&#123;
		for (int j &#x3D; 0; j &lt; dyarr-&gt;current_size - i-1; j++)
		&#123;
			if (
				compfunc(
							(char*)dyarr-&gt;DataPiece + j * dyarr-&gt;Single_Data_size,
							(char*)dyarr-&gt;DataPiece + (j + 1) * dyarr-&gt;Single_Data_size
						)
				)
				swapData_in_DynamicArray(dyarr, j, j + 1);
		&#125;
	&#125;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; check if located in the dynamic array
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; isLocateinDyarr(dyarr, data, comparision_funcuntional_pointer)
&#x2F;&#x2F;
DynamicArrayFunctionStatues isLocateinDyarr(
	DynamicArray*												dyarr,
	void*														data,
	LocateFunc													user_func
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!user_func)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
	&#123;
		if (user_func((char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size, data))
		&#123;
			return Find;
		&#125;
	&#125;
	return Unfind;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; return the position of data that is targeted 
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; returnAElembyPos_inDyarr(dyarr, data, comparision_funcuntional_pointer)
&#x2F;&#x2F;
DynamicArrayFunctionStatues returnAElembyPos_inDyarr(
	DynamicArray*												dyarr, 
	void*														data, 
	LocateFunc													user_func
) 
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!user_func)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
	&#123;
		if (user_func((char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size, data))
		&#123;
			return i;
		&#125;
	&#125;
	return Unfind;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Using the function when Posarr is enable to use!
&#x2F;&#x2F; return a bunch of position of data that is targeted 
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Position_Stored_Dynamic_ArrayFordyarr* pos &#x3D;r eturnAElembyPos_inDyarr(dyarr, posArr,data, comparision_funcuntional_pointer)
&#x2F;&#x2F;
#if OPENUPPOSARR
Position_Stored_Dynamic_ArrayFordyarr* returnABunchofData_inDyarr(
	DynamicArray*									dyarr, 
	Position_Stored_Dynamic_ArrayFordyarr*			posArr, 
	void*											data, 
	LocateFunc										user_func
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!user_func)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
	&#123;
		int possible_count &#x3D; 0;
		for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
		&#123;
			if ((*user_func)(data, (char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size))
			&#123;
				int* pro_usable_stored_space &#x3D; (int*)realloc(posArr-&gt;posSpace, sizeof(int) * (possible_count + 1));
				if (!pro_usable_stored_space)
				&#123;
					SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
					exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
				&#125;
				posArr-&gt;posSpace &#x3D; pro_usable_stored_space;
				posArr-&gt;posSpace[possible_count] &#x3D; i;
				possible_count++;
				posArr-&gt;pos_size &#x3D; possible_count;
			&#125;
		&#125;
		if (posArr-&gt;pos_size)
			return posArr;
		return Unfind;
	&#125;
&#125;
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试文档：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1
#include&quot;standard_dynamic_array.h&quot;
MyPrint print(int* e1) &#123;
	printf(&quot;%d &quot;, *e1);
&#125;
Do_Specific_Change dochange(int* e1) &#123;
	*e1 &#x3D; *e1 + 1;
&#125;
LocateFunc loc(int* e1, int* e2) &#123;
	if (*e1 &#x3D;&#x3D; *e2) &#123;
		return Find;
	&#125;
	return Unfind;
&#125;
int main()
&#123;
	int data1 &#x3D; 10;
	printf(&quot;%d &quot;, sizeof(data1));
    
	&#x2F;&#x2F;test Initing
	DynamicArray* testDyarr1 &#x3D; Init_A_DynamicArray(10, Dyarr_SIGINT);
    
	&#x2F;&#x2F;test a Sigdata pushed:
	Push_Back_Into_A_Dynamic_Array(testDyarr1, &amp;data1,sizeof(int));
	Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);
    
	&#x2F;&#x2F;test pushing the same data
	Push_back_Same_data_Into_A_Dynamic_Array(testDyarr1, &amp;data1, 10, Dyarr_SIGINT);
	Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);
    
	&#x2F;&#x2F;Test Clearing
	Clear_A_Dynamic_Array(testDyarr1);
	Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);
    
	&#x2F;&#x2F;test update
	int data2[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;
	DynamicArray* test2&#x3D;Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);
	Print_ALL_Data_In_A_Dynamic_Array(test2, print, Dyarr_OPEN);
    
	&#x2F;&#x2F;test copy:
	DynamicArray* copyone &#x3D; Init_A_DynamicArray_by_CopyADyarr(test2);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
    
	&#x2F;&#x2F;test insert	
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Insert_Into_A_Dynamic_Array(copyone, &amp;data1, 1);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
    
	&#x2F;&#x2F;test insert bunch
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Insert_Some_Data_Into_A_Dynamic_Array(copyone, 1, data2, 10, Dyarr_SIGINT);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
    
	&#x2F;&#x2F;test Erasing sigone
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Delete_A_Specific_Data_From_the_DynamicArray(copyone, 1);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
    
	&#x2F;&#x2F;test Erasing bunch one
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Delete_Some_Specific_Data_From_the_DynamicArray(copyone,1,10);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
    
	&#x2F;&#x2F;test Do change
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Do_Specific_Change_To_Specific_Data(copyone,dochange,1);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Do_Specific_Change_To_All_Data(copyone, dochange);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
    
	&#x2F;&#x2F;test location:
	DynamicArray* test3 &#x3D; Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);
	if (isLocateinDyarr(test3, &amp;data2[2], loc)) &#123;
		printf(&quot;\nI have found it!\n&quot;);
	&#125;
	int where &#x3D; returnAElembyPos_inDyarr(test3, &amp;data2[2], loc);
	printf(&quot;\nIn dyarr the %d place\n&quot;, where);
    
	&#x2F;&#x2F;test Position Stored Dynamic Array and returnBunch
	Clear_A_Dynamic_Array(test3);
	Push_back_Same_data_Into_A_Dynamic_Array(test3, &amp;data2[2], 10, Dyarr_SIGINT);
	Position_Stored_Dynamic_ArrayFordyarr* p1 &#x3D; Init_A_Postion_Stored_Dynamic_ArrayFordyarr();
	returnABunchofData_inDyarr(test3, p1, &amp;data2[2], loc);
	Print_ALL_Data_In_A_Dynamic_Array(test3, print, Dyarr_OPEN);
	Show_All_Locations_In_PSDAfor_dyarr(p1, PSDA_dyarr_OPEN);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/">http://charliechen114514.github.io/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/MyTinyLibProject/">MyTinyLibProject</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84API%E8%AF%A6%E8%A7%A3/" title="C语言数据结构模拟（1）：动态数组API详解"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C语言数据结构模拟（1）：动态数组API详解</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/06/Opencv-in-Pycharm-%EF%BC%883%EF%BC%89/" title="Opencv-in-Pycharm （3）"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Opencv-in-Pycharm （3）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84API%E8%AF%A6%E8%A7%A3/" title="C语言数据结构模拟（1）：动态数组API详解"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">C语言数据结构模拟（1）：动态数组API详解</div></div></a></div><div><a href="/2023/02/12/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/" title="C语言数据结构模拟：动态数组的实现思路"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">C语言数据结构模拟：动态数组的实现思路</div></div></a></div><div><a href="/2023/02/11/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/" title="C语言数据结构模拟（2）：经典单链表头文件-源代码-测试"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-11</div><div class="title">C语言数据结构模拟（2）：经典单链表头文件-源代码-测试</div></div></a></div><div><a href="/2023/02/15/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8API%E8%AF%A6%E8%A7%A3/" title="C语言数据结构 （2） 单链表API详解"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="title">C语言数据结构 （2） 单链表API详解</div></div></a></div><div><a href="/2023/01/28/C%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/" title="C简单教程（1）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-28</div><div class="title">C简单教程（1）</div></div></a></div><div><a href="/2023/01/30/%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/" title="算法（1）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-30</div><div class="title">算法（1）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">大更新！这下上了简单的数据结构的C实现，如果只对思路感兴趣看思路即可，如果想查看API实现就取看详解</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB-%E6%B3%A8%E9%87%8A"><span class="toc-number">1.</span> <span class="toc-text">动态数组（1）源代码阅读+注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E4%B8%AA%E5%A4%A7%E5%9D%91%E5%85%88%EF%BC%9A%E5%90%8E%E7%BB%AD%E4%BC%9A%E8%A1%A5%E4%B8%8A%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84API%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%87%E7%AB%A0%E5%92%8C%E8%AF%A6%E8%A7%A3%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%85%88%E7%9C%8B%E7%9C%8B%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%88%E5%B9%B2%E4%BA%86%E5%BE%88%E4%B9%85%EF%BC%88%E5%A4%A7%E5%93%AD%EF%BC%89%EF%BC%89"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">开个大坑先：后续会补上关于动态数组的API实现的文章和详解，可以先看看源代码（干了很久（大哭））</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%80%E8%A7%88%EF%BC%9A"><span class="toc-number">1.0.0.1.1.</span> <span class="toc-text">头文件一览：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/27/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4/" title="Windows-API-程序设计(4)"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows-API-程序设计(4)"/></a><div class="content"><a class="title" href="/2023/05/27/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4/" title="Windows-API-程序设计(4)">Windows-API-程序设计(4)</a><time datetime="2023-05-27T03:03:44.000Z" title="发表于 2023-05-27 11:03:44">2023-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/27/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3/" title="Windows-API-程序设计(3)"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows-API-程序设计(3)"/></a><div class="content"><a class="title" href="/2023/05/27/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3/" title="Windows-API-程序设计(3)">Windows-API-程序设计(3)</a><time datetime="2023-05-27T03:03:40.000Z" title="发表于 2023-05-27 11:03:40">2023-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/26/QT-new-9-10-11/" title="QT new 9-10-11"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QT new 9-10-11"/></a><div class="content"><a class="title" href="/2023/05/26/QT-new-9-10-11/" title="QT new 9-10-11">QT new 9-10-11</a><time datetime="2023-05-26T12:28:03.000Z" title="发表于 2023-05-26 20:28:03">2023-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/26/QT-new-7-8/" title="QT new 7-8"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QT new 7-8"/></a><div class="content"><a class="title" href="/2023/05/26/QT-new-7-8/" title="QT new 7-8">QT new 7-8</a><time datetime="2023-05-26T12:27:54.000Z" title="发表于 2023-05-26 20:27:54">2023-05-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/19/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89/" title="Windows-API-程序设计（2）"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Windows-API-程序设计（2）"/></a><div class="content"><a class="title" href="/2023/05/19/Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89/" title="Windows-API-程序设计（2）">Windows-API-程序设计（2）</a><time datetime="2023-05-19T07:18:04.000Z" title="发表于 2023-05-19 15:18:04">2023-05-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>