<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>C语言数据结构模拟（1）：动态数组API详解 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="动态数组——API思路详解​        写在前面：这里是动态数组API简介：版本是v1.0.0!这篇API博客我写了4个小时，匆匆忙忙。但却是我第一个过一万字的博客！ ​        我第一次手搓大型的小项目，也是我第一次单个程序突破1000行！这个前言就算小小的纪念一下这个成就吧！ ​        鄙人编程年龄仅仅就7个月，还是一枚小白，这个项目里面肯定还有许多不足！如果你对它感兴趣！可">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言数据结构模拟（1）：动态数组API详解">
<meta property="og:url" content="http://charliechen114514.github.io/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84API%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="动态数组——API思路详解​        写在前面：这里是动态数组API简介：版本是v1.0.0!这篇API博客我写了4个小时，匆匆忙忙。但却是我第一个过一万字的博客！ ​        我第一次手搓大型的小项目，也是我第一次单个程序突破1000行！这个前言就算小小的纪念一下这个成就吧！ ​        鄙人编程年龄仅仅就7个月，还是一枚小白，这个项目里面肯定还有许多不足！如果你对它感兴趣！可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-02-07T14:09:31.000Z">
<meta property="article:modified_time" content="2023-02-09T07:17:28.373Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="MyTinyLibProject">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84API%E8%AF%A6%E8%A7%A3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言数据结构模拟（1）：动态数组API详解',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-09 15:17:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言数据结构模拟（1）：动态数组API详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-07T14:09:31.000Z" title="发表于 2023-02-07 22:09:31">2023-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-09T07:17:28.373Z" title="更新于 2023-02-09 15:17:28">2023-02-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言数据结构模拟（1）：动态数组API详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="动态数组——API思路详解"><a href="#动态数组——API思路详解" class="headerlink" title="动态数组——API思路详解"></a>动态数组——API思路详解</h1><p>​        写在前面：这里是动态数组API简介：版本是v1.0.0!这篇API博客我写了4个小时，匆匆忙忙。但却是我第一个过一万字的博客！</p>
<p>​        我第一次手搓大型的小项目，也是我第一次单个程序突破1000行！这个前言就算小小的纪念一下这个成就吧！</p>
<p>​        鄙人编程年龄仅仅就7个月，还是一枚小白，这个项目里面肯定还有许多不足！如果你对它感兴趣！可以到我的GitHub上下载，测试！如果发现了Bug，麻烦及时反馈给我！（如果还有解决方案我会直接磕头叫声Daddy（逃））</p>
<p>​                                                                                                                                                                                        —-2023/2.7/21：47</p>
<h3 id="动态数组入门"><a href="#动态数组入门" class="headerlink" title="动态数组入门"></a>动态数组入门</h3><p>​        首先，作为入门级别的数据结构，我们毫无疑问的：这个数据结构必须满足增删查改！其中，增加就必须要有一个一个增加的，还有直接加入一大群的，删除也是如此。此外，这个数组可以查询是否有目标元素存在，这就需要我们也写一些相关的函数来支持我们的操作！就是这些，我们还可以为了使我们的打印更加清晰，（有点难过的是：C语言必须多增加一个参数来存放它，使得看起来相当的拥挤），可以自定义打印方式。事实上，这就是我们C++里面的vector容器（我就是想要复刻API哈哈哈）</p>
<p>​        我们的数据结构首先已经被框死：他是一个数组，存储的是相同类型的元素：要不全是整形，要不全是字符，要不全是指针，要么就是同一个类型的结构体！于是，我们不妨这样设想：他必须还是数组，那就说明内存的物理结构还是连续的，但是又要不停的扩展或者伸缩！那就把我们的数组（严肃的讲是静态数组）做一些改动，使之可以自由扩展不就好了嘛？这就需要我们使用头文件,来引入malloc函数群就好了</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt;&#x2F;&#x2F;IO流交互
#include&lt;stdlib.h&gt;&#x2F;&#x2F;标准库：里面有我们想要的函数
#include&lt;string.h&gt;&#x2F;&#x2F;memory函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>基于上面的思路，我们很快就搓出来一个这个玩意：</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">int main()
&#123;
	void* data &#x3D; NULL;
    int current_size&#x3D;0;
    &#x2F;&#x2F;...Do something and the size need to increase
    
    data&#x3D;realloc(data,current_size+1);
    current_size++;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        不错，这就是我们动态数组的雏形了！不过，这样散架着太捞了，后续也不好维护与处理。那很简单了：结构体用起来嘛！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _DynamicArray_ &#123;&#x2F;&#x2F;_HHH_是为了后续智能提示不会产生冲突
	void* DataPiece; &#x2F;&#x2F;连续内存块
	size_t current_size; &#x2F;&#x2F;当前的大小如何！不过，使用size_t其实更是说明我们的程序变量是非负的而已！
&#125;DynamicArray;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        好像也不太好，我们后续要知道，访问起来是void*！这个特殊的指针不能帮我们锁定目标，是一个未确定类型的指针，所以。。。我们不妨加上一个常量，在数据首次入动态数组的时候直接将这样的值初始化！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _DynamicArray_ &#123;&#x2F;&#x2F;_HHH_是为了后续智能提示不会产生冲突
	void* DataPiece; &#x2F;&#x2F;连续内存块
	size_t current_size; &#x2F;&#x2F;当前的大小如何！不过，使用size_t其实更是说明我们的程序变量是非负的而已！
	size_t total_usable_size;&#x2F;&#x2F;用来调整数组的大小，同时又允许我们在一定范围内自由插入
	size_t Single_Data_size;&#x2F;&#x2F;相当于类型名了，这个数据在我们后面十分的重要
&#125;DynamicArray;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样，我想我们的动态数组就具有了极强的通用性：可以像一般的数组那样存储任何数据！</p>
<h3 id="工厂函数与基本调整函数系列"><a href="#工厂函数与基本调整函数系列" class="headerlink" title="工厂函数与基本调整函数系列"></a>工厂函数与基本调整函数系列</h3><p>​        什么是工厂函数？就是产生对象并且返回它供我们程序员使用的函数，比如说，C语言的malloc函数就是一个代表性的工厂函数。他返回一个任意大小的堆空间：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">(void*)malloc(bit_malloc)&#x2F;&#x2F;开辟多少字节自己制定，是一个操作性很强的函数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        我们的函数就必须使用它来开辟我们的内存：但是，直接让用户制定是麻烦的，极易出错的，所以：</p>
<h4 id="默认工厂函数"><a href="#默认工厂函数" class="headerlink" title="默认工厂函数"></a>默认工厂函数</h4><p>​        我们首先需要一个可以产生一个这样的结构体并且还要返回它的函数，为了初始化这样的结构体，我们需要知道我们要开辟多少个元素，元素多大，否则我们不会开辟。函数的原型可以轻而易举的给出：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* Init_A_DynamicArray(
	size_t					expected_number, 
	size_t					datasize
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        首先，作为动态数组，灵活性是重要的，用户（也就是咱们），往往压根就不知道我们会有多少个数据入列。于是，我们可能需要自己指定一个默认的大小，一旦我们的数据超过了指标，我们就马上调用一个自己手动写的函数，如你所见，就是这个功能的封装：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;...Do something and the size need to increase
    
    data&#x3D;realloc(data,current_size+1);&#x2F;&#x2F; Adjustment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>来立马调用起来防止指针越界！我们稍后在调整函数里会再次阐述！回到初始化函数Init_A_DynamicArray上来！我们首先初始化一个结构体：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* pro_usable_space &#x3D; (DynamicArray*)malloc(sizeof(DynamicArray))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        如果屏幕前的你有一定编程经验，马上就会意识到如果仅是止步如此会大错特错！因为我们的malloc函数一旦开辟失败就会返回一个NULL指针，如果我们不对它进行空判断就会闹出程序崩溃的笑话，这里我们看到，一般的教程是直接这么写的：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if(!pro_usable_space)&#123;
  	return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        如果只是随意教教，这样写可以；工程开发中如此书写很不负责任！首先，我们的程序不可以直接return！后续我们的操作一旦再次拿起甚至时使用返回出去的NULL指针，马上又会闹起报错的笑话！既然如此，我们做一点报错友善处理！·</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if(pro_usable_space &#x3D;&#x3D; NULL)&#123;
  	printf(&quot;Sorry! Failed to malloc a new space! Program exits!&quot;);
    exit(-1);    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​         这样好些了！我们后续开发还会反复用到，何不直接使用宏定义直接节省反复车轮子的工作呢？还是相信智能提示的好！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;Sorry! Failed to malloc a new space! Program exits!&quot;) &#x2F;&#x2F;宏定义的重要作用之一：代替代码块

#define DynamicArray_ERROR_IN_MALLOCING_SPACE 1 &#x2F;&#x2F;编写异常程序可以这样写，使之错误码和错误信息完全对应起来

&#x2F;&#x2F;  Do Something 
...
    
 if(pro_usable_space &#x3D;&#x3D; NULL)
 &#123;
  	SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
	exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);  
 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​         随后顺手初始化，回到刚刚的问题，我们需要给数据结构一个默认的大小，我们不妨设置成5！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define Dyarr_DEFAULT_MALLOC 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pro_usable_space-&gt;DataPiece &#x3D; NULL;&#x2F;&#x2F;赋予空指针，防止成为野指针修改其他内存块
pro_usable_space-&gt;Single_Data_size &#x3D; datasize;&#x2F;&#x2F;初始化单位元素大小
if (expected_number &gt;&#x3D; Dyarr_DEFAULT_MALLOC)&#x2F;&#x2F;大于默认的就用户指定的那个大小
	pro_usable_space-&gt;total_usable_size &#x3D; expected_number;
else
	pro_usable_space-&gt;total_usable_size &#x3D; Dyarr_DEFAULT_MALLOC;&#x2F;&#x2F;顺手处理异常的数字大小
pro_usable_space-&gt;current_size &#x3D; 0;&#x2F;&#x2F;当下就没有元素在，赋0！
return pro_usable_space;&#x2F;&#x2F;返回产生的堆区开辟的结构体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        有的时候我们可能需要直接拿起一个静态数组直接转化，很简单，我们可以这样写：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()
&#123;
	int arr[10]&#x3D;&#123;1,2,3,4,5,6,7,8,9,10&#125;;
    for(int i &#x3D; 0; i &lt; 10; i++)&#123;
        &#x2F;&#x2F;插入
    &#125;
    &#x2F;&#x2F;...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        但这样我们需要反复调用函数，导致程序性能很差，我们为什么不直接提供一个接口，一边创造结构体一边入列呢？</p>
<h4 id="升级工厂函数"><a href="#升级工厂函数" class="headerlink" title="升级工厂函数"></a>升级工厂函数</h4><p>​        很简单明了，我们的函数的原型是很容易想到的：你这个数组：是什么？（Single_Data_size），有多少个元素？（current_size），在哪里（Datapiece）的问题！我们产生的结构体还是要返回给用户使用的！</p>
<p>​        所以，我们的参数需要：数组地址（在哪里），数组元素大小（是什么），数组元素个数（有几个）</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(
void*												data, 
size_t												datasize,
size_t												datanum
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        注意，这个时候要多想！data会不会是空？我们是要看看的！类似的，我们再次构造一个错误码模块：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!data)
&#123;
	SHOW_ERROR_DynamicArray_NULL_INPUT;
	exit(DynamicArray_NULL_INPUT);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        之后的流程相比就很简单了：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">	DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);
	if(!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
&#x2F;&#x2F;。。。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        Ok，到这里，我们要开始准备初始化了，不同于标准的，默认的工厂函数，我们这里直接就是有数据的！因此，需要直接开始拷贝！</p>
<p>​        <strong>注意：不建议直接把data的地址交给DataPiece直接托管！！！！！！！！！！！！之后的我们的操作可能会使数据抹除，但是DataPiece还记得，贸然的直接托管会导致非法访问内存！</strong></p>
<p>​        所以：我们单独为数据准备一块空间：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void* pro_usable_data &#x3D; malloc(datasize * datanum*1.5);&#x2F;&#x2F;预留一些空间
if(!pro_usable_data)
&#123;
	SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
	exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
&#125;	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        养成随手判断空的好习惯（乐）。</p>
<p>​        然后，拿出我们的memcpy，这是因为我们的数据可能啥都是，指定一个类型会使得我们的动态数组丧失通用性！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">memcpy(
    pro_usable_data,     &#x2F;&#x2F;dst : 我们的预留空间
    data, 		        &#x2F;&#x2F;rsc : 我们的来源：静态数组
    datasize * datanum	&#x2F;&#x2F;多大？很是显然！个数乘上大小
      );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        然后初始化</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">pro_usable_space-&gt;DataPiece         &#x3D; pro_usable_data; &#x2F;&#x2F;将拷贝的空间交给dataPiece托管
pro_usable_space-&gt;current_size      &#x3D; datanum;
pro_usable_space-&gt;Single_Data_size  &#x3D; datasize;
pro_usable_space-&gt;total_usable_size &#x3D; 1.5 * datanum;&#x2F;&#x2F;开辟多大就给多大
return pro_usable_space;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="复制工厂函数"><a href="#复制工厂函数" class="headerlink" title="复制工厂函数"></a>复制工厂函数</h4><p>​            我们可以模仿C++ STL里面的复制构造：协同上面的升级函数一样，这里不过多的废话！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArray* Init_A_DynamicArray_by_CopyADyarr(
	DynamicArray*										dyarr_copied
)
&#123;
	&#x2F;&#x2F;检查来源是否合法
    if (!dyarr_copied)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
        
     &#x2F;&#x2F;准备空间并检查
	DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
    
	void* pro_usable_data &#x3D; MALLOCDYARR(
        char, &#x2F;&#x2F;一个字节单位
        (dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size)&#x2F;&#x2F;多大？还是一样嘛！
    );
	if(!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
    &#x2F;&#x2F;拷贝数据
	pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;
	memcpy(
        pro_usable_space-&gt;DataPiece, &#x2F;&#x2F;dst : 我们的预留空间
        dyarr_copied-&gt;DataPiece, &#x2F;&#x2F; rsc: 来源：显然是被拷贝的dataPiece
        dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size
    );
    &#x2F;&#x2F;初始化与托管数据
	pro_usable_space-&gt;current_size &#x3D; dyarr_copied-&gt;current_size;
	pro_usable_space-&gt;Single_Data_size &#x3D; dyarr_copied-&gt;Single_Data_size;
	pro_usable_space-&gt;total_usable_size &#x3D; dyarr_copied-&gt;total_usable_size;
	return pro_usable_space;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在，我们的三个基本工厂函数已经做好：可以一览了</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;1 默认的工厂函数
DynamicArray* Init_A_DynamicArray(
	size_t												expected_number,
	size_t												datasize
)
&#123;
	DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);
	if(!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	pro_usable_space-&gt;DataPiece &#x3D; NULL;
	pro_usable_space-&gt;Single_Data_size &#x3D; datasize;
	if (expected_number &gt;&#x3D; Dyarr_DEFAULT_MALLOC)
		pro_usable_space-&gt;total_usable_size &#x3D; expected_number;
	else
		pro_usable_space-&gt;total_usable_size &#x3D; Dyarr_DEFAULT_MALLOC;
	pro_usable_space-&gt;current_size &#x3D; 0;
	return pro_usable_space;
&#125;

&#x2F;&#x2F;2.拷贝工厂函数
DynamicArray* Init_A_DynamicArray_by_CopyADyarr(
	DynamicArray*										dyarr_copied
)
&#123;
	if (!dyarr_copied)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	void* pro_usable_data &#x3D; MALLOCDYARR(char, (dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size));
	if(!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;
	memcpy(pro_usable_space-&gt;DataPiece, dyarr_copied-&gt;DataPiece, dyarr_copied-&gt;Single_Data_size * dyarr_copied-&gt;current_size);
	pro_usable_space-&gt;current_size &#x3D; dyarr_copied-&gt;current_size;
	pro_usable_space-&gt;Single_Data_size &#x3D; dyarr_copied-&gt;Single_Data_size;
	pro_usable_space-&gt;total_usable_size &#x3D; dyarr_copied-&gt;total_usable_size;
	return pro_usable_space;
&#125;

&#x2F;&#x2F;3.升级工厂函数
DynamicArray* Updata_A_Static_Array_To_Dynamic_Array(
	void*												data, 
	size_t												datasize,
	size_t												datanum
)
&#123;
	if (!data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	DynamicArray* pro_usable_space &#x3D; MALLOCDYARR(DynamicArray, 1);
	if(!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	void* pro_usable_data &#x3D; malloc(datasize * datanum*1.5);
	if(!pro_usable_data)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memcpy(pro_usable_data, data, datasize * datanum);
	pro_usable_space-&gt;DataPiece &#x3D; pro_usable_data;
	pro_usable_space-&gt;current_size &#x3D; datanum;
	pro_usable_space-&gt;Single_Data_size &#x3D; datasize;
	pro_usable_space-&gt;total_usable_size &#x3D; 1.5 * datanum;
	return pro_usable_space;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        现在我们已经有了基本的工厂函数，已经有了一个可以可以操作的对象了！不过，我们还提到，动态数组必须有必要的调整函数，防止大量的插入导致空间不足或者是删除导致大量的空间浪费！</p>
<h4 id="基本调整函数"><a href="#基本调整函数" class="headerlink" title="基本调整函数"></a>基本调整函数</h4><p>​        调整大小，我们首先要拿到希望调整的动态数组，以及我们想要调成多大！函数的原型，显然易见：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void Resize_The_Dynamic_Array(
	DynamicArray*									dyarr,
	size_t											wished_new_space_size
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        为了使程序更加健壮，我们还是返回一个NORMAL的FLAG值表示程序逻辑正常，从而更好的调整程序，这里，我先把enum列举列齐：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Error Code Meaning
&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0
&#x2F;&#x2F;When Error in mallocing Space the program return 1
&#x2F;&#x2F;when inputing a NULL we returns -1
&#x2F;&#x2F;when inputing a invalid input we returns -2
&#x2F;&#x2F;Locations UnFind we returns -3 
&#x2F;&#x2F;
	typedef enum _DynamicFunctionStatues_ &#123;
		DynamicArray_Normal &#x3D; 0,&#x2F;&#x2F;正常返回
		DynamicArray_ERROR_IN_MALLOCING_SPACE&#x3D;1,&#x2F;&#x2F;错误1：开辟空间失败
		DynamicArray_NULL_INPUT&#x3D;-1,&#x2F;&#x2F;错误-1：传入空值
		DynamicArray_Invalid_Input&#x3D;-2,&#x2F;&#x2F;错误-2： 传入不合法的值
		DynamicArray_UnFind&#x3D;-3, &#x2F;&#x2F;错误值-3 没有找到（后面没有使用，这里就算遗留了）
		DynamicArray_Invalid_Free&#x3D;-4&#x2F;&#x2F;错误值-4 不合法的释放，后面删减的时候会用到
	&#125;DynamicArrayFunctionStatues;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        以及错误提示宏：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define SHOW_ERROR_DynamicArray_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)

#define SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)

#define SHOW_ERROR_DynamicArray_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)

#define SHOW_ERROR_DynamicArray_UnFind printf(&quot;\nPositions unfind!\n&quot;)

#define SHOW_ERROR_DynamicArray_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        其他所有的空返回函数全部就会升级成状态标识函数：只需要我们返回的是：DynamicArrayFunctionStatues枚举下的值（有点伤心，如果是C++11以上，我们可以使用Enum 作用域这个概念了）就好了。函数就改成了：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Resize_The_Dynamic_Array(
	DynamicArray*									dyarr,
	size_t											wished_new_space_size
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这样，我们的框架又可以搭建起来了：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Resize_The_Dynamic_Array(
	DynamicArray*									dyarr,
	size_t											wished_new_space_size
)
&#123;
    &#x2F;&#x2F;经典检查
	if(!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
    ...&#x2F;&#x2F;Do something 
    return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对于调整函数，我们实际上就是在调整数组的堆空间，这下马上就知道函数的核心是什么了！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void* newspace &#x3D; realloc(dataPiece, new_size)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        不错，就是realloc函数！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;调整
void* newspace &#x3D; realloc(
	dyarr-&gt;DataPiece, 
	wished_new_space_size * (dyarr-&gt;Single_Data_size)
);
&#x2F;&#x2F;检查空间是否合法
if (newspace &#x3D;&#x3D; NULL)
&#123;
	SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
	exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​         然后就是托管，和调整结构体参数：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">dyarr-&gt;DataPiece &#x3D; newspace;&#x2F;&#x2F;空间托管
dyarr-&gt;total_usable_size &#x3D; wished_new_space_size;&#x2F;&#x2F;调整usable space<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>​        别跑，还先别返回正常状态，我们想一个问题，万一，我们的函数当前数据大于了可用空间怎么办？既然是就想要这么多，我们何不妨：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (dyarr-&gt;current_size &gt; dyarr-&gt;total_usable_size)
&#123;
    dyarr-&gt;current_size &#x3D; dyarr-&gt;total_usable_size;&#x2F;&#x2F;调整至正好满溢的状态，后面的数据直接截断归还给操作系统
&#125;&#x2F;&#x2F;Used when still unable to contain data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        活干完了，返回正常状态！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="总体一览工厂函数与基本调整函数："><a href="#总体一览工厂函数与基本调整函数：" class="headerlink" title="总体一览工厂函数与基本调整函数："></a>总体一览工厂函数与基本调整函数：</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Resize_The_Dynamic_Array(
	DynamicArray*									dyarr,
	size_t											wished_new_space_size
)
&#123;
	if(!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, wished_new_space_size * (dyarr-&gt;Single_Data_size));
	if (!newspace)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	dyarr-&gt;DataPiece &#x3D; newspace;
	dyarr-&gt;total_usable_size &#x3D; wished_new_space_size;
	if (dyarr-&gt;current_size &gt; dyarr-&gt;total_usable_size)
		dyarr-&gt;current_size &#x3D; dyarr-&gt;total_usable_size;&#x2F;&#x2F;Used when still unable to contain data
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="增（加）函数一览"><a href="#增（加）函数一览" class="headerlink" title="增（加）函数一览"></a>增（加）函数一览</h3><p>​        终于，我们可以进行增删查改了！先来看增函数！</p>
<p>​        增加：一个数据？一堆数据？是往后面加，还是插入式的加？这就引出了四个基本函数：我们先来最简单的追加一个数据！</p>
<h4 id="追加单个"><a href="#追加单个" class="headerlink" title="追加单个"></a>追加单个</h4><p>​        我们仔细问问自己，追加的数据，有多大？玩意要满溢了，要不要调整？OK！我们一个一个按照程序的进行考虑！首先思考函数的原型：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(
	DynamicArray*										dyarr,
	void*												data,
	size_t												datasize
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        很容易想到吧！我们往哪里插入，插入什么！就是我们的参数列表吧！</p>
<p>​        好，检查来了：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!dyarr &amp;&amp; !data)
&#123;
	SHOW_ERROR_DynamicArray_NULL_INPUT;
	exit(DynamicArray_NULL_INPUT);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        完事了？肯定没有！我们试想一下，用户可能在不知情的情况下，传入一个完全不是本类型的数据进来：怎么办？</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (sizeof(data) !&#x3D; dyarr-&gt;Single_Data_size) 
&#123;
	SHOW_ERROR_DynamicArray_Invalid_Input;
	exit(DynamicArray_Invalid_Input);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        挺好，我们进一步想啊，数据进来了：万一溢出来，怎么办？</p>
<p>​        别怕，我们不是已经有了调整函数了嘛！调整一下就好了！（不过这里没有用，开销不必要）</p>
<p>​        现在，数据准备入列！我们准备一块空间：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void* Afteradd_piece &#x3D; realloc(
    dyarr-&gt;DataPiece, 
    (dyarr-&gt;current_size + 1)*dyarr-&gt;Single_Data_size
);
if (!Afteradd_piece)
&#123;
	SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
	exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        入列咯！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;拷贝
memcpy(
       &#x2F;&#x2F;注意：我们插入到尾部：那就是第I-1的后面，
	(char*)Afteradd_piece + dyarr-&gt;current_size * dyarr-&gt;Single_Data_size, 
	&#x2F;&#x2F;拷贝Data
        data, 
       &#x2F;&#x2F;拷贝Single_Data_size大小，或者sizeof(data)，这个随意！
	dyarr-&gt;Single_Data_size
);
&#x2F;&#x2F;刷新结构体值
dyarr-&gt;DataPiece &#x3D; Afteradd_piece;
dyarr-&gt;current_size++;
&#x2F;&#x2F;任务完成，返回状态Flag
return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="尾插多个数据函数1：尾插相同数据"><a href="#尾插多个数据函数1：尾插相同数据" class="headerlink" title="尾插多个数据函数1：尾插相同数据"></a>尾插多个数据函数1：尾插相同数据</h4><p>​        那插入一堆值，也是如此了！我们在尾插的时候，可以开发出来两个函数：一个是尾插一堆一样的值！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr,
	void*												data,
	size_t												n_repeat,
	size_t												datasize
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        一个是尾插一个数组，有点像Update升级函数了：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr, 
	void*												data_array, 
	size_t												array_num, 
	size_t												pos,
	size_t												data_inarray_size
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        一个个来！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;检查
	if (!dyarr &amp;&amp; !data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (datasize !&#x3D; dyarr-&gt;Single_Data_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
    &#123;
        &#x2F;&#x2F;先预备好空间，因为大量数据准备入场
        Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下面是扩展多大空间的问题：我们扩展是按照比例扩展的，那就需要计算比例：再传入调整函数！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;
if (datarate &gt; 0)
&#123;
    Resize_The_Dynamic_Array(
        dyarr, 
        (datarate + 1) * dyarr-&gt;total_usable_size
    );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        预留，托管和拷贝：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void* newspace &#x3D; realloc(
    dyarr-&gt;DataPiece, 
    (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size
);
if (!newspace)
&#123;
	SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
	exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
&#125;
for (int i &#x3D; 0; i &lt; n_repeat; i++)
&#123;
    &#x2F;&#x2F;逐个拷贝
    memcpy(
        &#x2F;&#x2F;插入到后面的第I+cur_size个位置上，第一个插入结束就要插入到后面一个
		(char*)newspace + (dyarr-&gt;current_size+i) * dyarr-&gt;Single_Data_size,
		data,
		dyarr-&gt;Single_Data_size
	);
&#125;
dyarr-&gt;DataPiece &#x3D; newspace;
dyarr-&gt;current_size +&#x3D; n_repeat;
return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="尾插一个数组函数"><a href="#尾插一个数组函数" class="headerlink" title="尾插一个数组函数"></a>尾插一个数组函数</h4><p>​        而同类型的数组拷贝推入逻辑上是一样的：但是我们不得不遍历目标数组，再逐个插入</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr, 
	void*												data_array, 
	size_t												array_num, 
	size_t												pos,
	size_t												data_inarray_size
)
&#123;
	if (!dyarr &amp;&amp; !data_array)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (data_inarray_size !&#x3D; dyarr-&gt;Single_Data_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;
	if (DataRate &gt; 0)
	&#123;
        Resize_The_Dynamic_Array(
            dyarr, 
            (DataRate + 1) * dyarr-&gt;total_usable_size
        );
    &#125;
	void* newspace &#x3D; realloc(
        dyarr-&gt;DataPiece, 
        (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size
    );
	if(!newspace)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	dyarr-&gt;DataPiece &#x3D; newspace;
	for (int i &#x3D; 0; i &lt; array_num; i++)
		memcpy(
        &#x2F;&#x2F;插入到后面的第I+cur_size个位置上，第一个插入结束就要插入到后面一个
			(char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,
        &#x2F;&#x2F;这个是数组的，写成&amp;data_array[i]也是无伤大雅的
			(char*)data_array + i * (dyarr-&gt;Single_Data_size),
        &#x2F;&#x2F;拷贝的大小
			dyarr-&gt;Single_Data_size
		);
    &#x2F;&#x2F;调整大小
	dyarr-&gt;current_size +&#x3D; array_num;
	return DynamicArray_Normal;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        下面就是有点难度的插入增函数了：我们这样想，我们需要把一个元素插入到目标动态数组的pos位置上。那：使用memmove把想要插入的位置后面的所有数据挪动一个元素大小的位置，那么，目标位置就空出来了一个位置虚以待坐了！前面的工作不再多说了：</p>
<h4 id="插入一个元素函数"><a href="#插入一个元素函数" class="headerlink" title="插入一个元素函数"></a>插入一个元素函数</h4><p>​        函数的原型：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(
	DynamicArray*										dyarr, 
	void*												data, 
	size_t												pos
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        检查：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#123;
	if (!dyarr &amp;&amp; !data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 2 * (dyarr-&gt;total_usable_size));
	void* Afteradd_piece&#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1) * dyarr-&gt;Single_Data_size);
	if (!Afteradd_piece)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	&#x2F;&#x2F;。。。
    return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        OK，我们开始让后面的数据挪动他们的屁股！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">memcpy(
    &#x2F;&#x2F;拷贝到pos+1位置处
		(char*)dyarr-&gt;DataPiece + (pos + 1) * dyarr-&gt;Single_Data_size,
    &#x2F;&#x2F;从pos往后的数据
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,
    &#x2F;&#x2F;大小计算是个数学问题：不过就是那种从i到j有几个数字的问题：j-i+1个！
		dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - pos + 1)
	);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        然后把数据请进来：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">memmove(
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size, 
		data, 
		dyarr-&gt;Single_Data_size
);
dyarr-&gt;current_size++;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​         然后嘞：宣布我们干完活了！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="插入若干数据函数1：插入数组"><a href="#插入若干数据函数1：插入数组" class="headerlink" title="插入若干数据函数1：插入数组"></a>插入若干数据函数1：插入数组</h4><p>​        于是，插入一堆数据，还是一个原理的！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr,
	size_t												pos,
	void*												data_array, 
	size_t												array_num,
	size_t												data_inarray_size
)
&#123;
	if (!dyarr &amp;&amp; !data_array)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (!dyarr-&gt;current_size)
	&#123;
		Push_Back_Some_data_Into_A_Dynamic_Array(
			dyarr, 
			data_array, 
			array_num, 
			pos,
			data_inarray_size
		);
		return DynamicArray_Normal;
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);
	int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;
	if (DataRate &gt; 0)
		Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);
	void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);
	if (!Afteradd_piece)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memmove(
        &#x2F;&#x2F;预留array_num个位置
		(char*)dyarr-&gt;DataPiece + (pos + array_num) * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size*array_num
	);
	for (int i &#x3D; 0; i &lt; array_num; i++)
		memcpy(
        	&#x2F;&#x2F;从目标位往后拷贝
			(char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,
        &#x2F;&#x2F;这个是数组的，写成&amp;data_array[i]也是无伤大雅的
			(char*)data_array + i * (dyarr-&gt;Single_Data_size),
			dyarr-&gt;Single_Data_size
		);
	dyarr-&gt;current_size +&#x3D; array_num;
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="插入若干数据：相同数据"><a href="#插入若干数据：相同数据" class="headerlink" title="插入若干数据：相同数据"></a>插入若干数据：相同数据</h4><p>​        还是一样，直接上代码：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data
&#x2F;&#x2F;Use like this: 														
&#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr,
	void*												data,
	size_t												n_repeat,
	size_t												datasize,
	size_t												pos
)
&#123;
	if (!dyarr &amp;&amp; !data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (datasize !&#x3D; dyarr-&gt;Single_Data_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);
	int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;
	if (datarate &gt; 0)
		Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);
	void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);
	if (!newspace)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memmove(
		(char*)dyarr-&gt;DataPiece + (pos + n_repeat) * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size * n_repeat
	);
	for (int i &#x3D; 0; i &lt; n_repeat; i++)
		memcpy(
			(char*)newspace + (pos + i) * dyarr-&gt;Single_Data_size,
			data,
			dyarr-&gt;Single_Data_size
		);
	dyarr-&gt;DataPiece &#x3D; newspace;
	dyarr-&gt;current_size +&#x3D; n_repeat;
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="拼接动态数组"><a href="#拼接动态数组" class="headerlink" title="拼接动态数组"></a>拼接动态数组</h4><p>​        欸嘿！我们可不可以拼接一下两个动态数组呢？可以啊！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues AppendByMergeDynamicArray(
	DynamicArray*										dyarr_be_appended,
	DynamicArray*										exp_append_array
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这下很容易了：我们的dataPiece直接延后exp_append_array-&gt;current_size个，再拷贝就完事咯！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues AppendByMergeDynamicArray(
	DynamicArray*										dyarr_be_appended,
	DynamicArray*										exp_append_array
)
&#123;
	if (!dyarr_be_appended &amp;&amp; !exp_append_array)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	&#x2F;&#x2F;跟插入大量数据是一个道理的！
	int datarate &#x3D; exp_append_array-&gt;current_size &#x2F; dyarr_be_appended-&gt;total_usable_size;
	if (
        dyarr_be_appended-&gt;current_size 
        &#x3D;&#x3D; 
        dyarr_be_appended-&gt;total_usable_size
    )
	&#123;
        Resize_The_Dynamic_Array(
            dyarr_be_appended, 
            2 * dyarr_be_appended-&gt;total_usable_size
        );
    &#125;
	if (datarate &gt; 0)
		Resize_The_Dynamic_Array(dyarr_be_appended, (datarate + 1) * dyarr_be_appended-&gt;total_usable_size);
	void* AfterAppend &#x3D; realloc(
		dyarr_be_appended-&gt;DataPiece,
        &#x2F;&#x2F;这一大长串就是两个动态数组一共的大小！
        (dyarr_be_appended-&gt;current_size + exp_append_array-&gt;current_size) * dyarr_be_appended-&gt;Single_Data_size
	);
	if (!AfterAppend)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	dyarr_be_appended-&gt;DataPiece &#x3D; AfterAppend;
	memcpy(
		&#x2F;&#x2F;目标地：被追加的数组的尾部
        (char*)dyarr_be_appended-&gt;DataPiece + 
        dyarr_be_appended-&gt;current_size * dyarr_be_appended-&gt;Single_Data_size,
        &#x2F;&#x2F;源头：被拷贝的数组
		(char*)exp_append_array-&gt;DataPiece,
        &#x2F;&#x2F;大小：被拷贝数组的大小
		exp_append_array-&gt;current_size * exp_append_array-&gt;Single_Data_size
	);
    &#x2F;&#x2F;调整大小
	dyarr_be_appended-&gt;current_size +&#x3D; exp_append_array-&gt;current_size;
	
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="一览增（加）函数"><a href="#一览增（加）函数" class="headerlink" title="一览增（加）函数"></a>一览增（加）函数</h4><p>OK，我们再一览我们的成果就好了：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Push back a data into the Dynamic Array
&#x2F;&#x2F;Use like this: Push_Back_Into_A_Dynamic_Array(dyarr,data)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_Back_Into_A_Dynamic_Array(
	DynamicArray*										dyarr, 
	void*												data,
	size_t												datasize
)
&#123;
	if (!dyarr &amp;&amp; !data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (datasize !&#x3D; dyarr-&gt;Single_Data_size) 
	&#123;
		printf(&quot;%d &quot;, sizeof(data));
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 1.3 * (dyarr-&gt;total_usable_size));
	void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1)*dyarr-&gt;Single_Data_size);
	if (!Afteradd_piece)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memcpy((char*)Afteradd_piece + dyarr-&gt;current_size * dyarr-&gt;Single_Data_size, data, dyarr-&gt;Single_Data_size);
	dyarr-&gt;DataPiece &#x3D; Afteradd_piece;
	dyarr-&gt;current_size++;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Push back a lot of data that has a organization that has all the same data
&#x2F;&#x2F;Use like this: 
&#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(dyarr,data,the_time_data_repeated,sizeof(data))
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_back_Same_data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr,
	void*												data,
	size_t												n_repeat,
	size_t												datasize
)
&#123;
	if (!dyarr &amp;&amp; !data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (datasize !&#x3D; dyarr-&gt;Single_Data_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);
	int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;
	if (datarate &gt; 0)
		Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);
	void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);
	if (!newspace)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	for (int i &#x3D; 0; i &lt; n_repeat; i++)
		memcpy(
			(char*)newspace + (dyarr-&gt;current_size+i) * dyarr-&gt;Single_Data_size,
			data,
			dyarr-&gt;Single_Data_size
		);
	dyarr-&gt;DataPiece &#x3D; newspace;
	dyarr-&gt;current_size +&#x3D; n_repeat;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Push back a lot of data that has a organization that has a organiztion with static array
&#x2F;&#x2F;Use like this: 
&#x2F;&#x2F;Push_back_Same_data_Into_A_Dynamic_Array(
&#x2F;&#x2F;dyarr,
&#x2F;&#x2F;data,
&#x2F;&#x2F;how_many_data_are_there_in_static_array,
&#x2F;&#x2F;sizeof(data))
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_Back_Some_data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr, 
	void*												data_array, 
	size_t												array_num, 
	size_t												pos,
	size_t												data_inarray_size
)
&#123;
	if (!dyarr &amp;&amp; !data_array)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (data_inarray_size !&#x3D; dyarr-&gt;Single_Data_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;
	if (DataRate &gt; 0)
		Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);
	void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);
	if(!newspace)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	dyarr-&gt;DataPiece &#x3D; newspace;
	for (int i &#x3D; 0; i &lt; array_num; i++)
		memcpy(
			(char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,
			(char*)data_array + i * (dyarr-&gt;Single_Data_size),
			dyarr-&gt;Single_Data_size
		);
	dyarr-&gt;current_size +&#x3D; array_num;
	return DynamicArray_Normal;
&#125;
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Insert back a data 
&#x2F;&#x2F; use like this: 
&#x2F;&#x2F; Insert_Into_A_Dynamic_Array(
&#x2F;&#x2F; dyarr, 
&#x2F;&#x2F; data, 
&#x2F;&#x2F; where_to_insert,
&#x2F;&#x2F;
DynamicArrayFunctionStatues Insert_Into_A_Dynamic_Array(
	DynamicArray*										dyarr, 
	void*												data, 
	size_t												pos
)
&#123;
	if (!dyarr &amp;&amp; !data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 2 * (dyarr-&gt;total_usable_size));
	void* Afteradd_piece&#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + 1) * dyarr-&gt;Single_Data_size);
	if (!Afteradd_piece)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memcpy(
		(char*)dyarr-&gt;DataPiece + (pos + 1) * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos+1)
	);
	memmove(
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size, 
		data, 
		dyarr-&gt;Single_Data_size
	);
	dyarr-&gt;current_size++;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Insert back a lot of data that has a organization that has all the same data
&#x2F;&#x2F;Use like this: 																		
&#x2F;&#x2F;insert_back_Same_data_Into_A_Dynamic_Array(dyarr,n_repeat,datasize,pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues insert_back_Same_data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr,
	void*												data,
	size_t												n_repeat,
	size_t												datasize,
	size_t												pos
)
&#123;
	if (!dyarr &amp;&amp; !data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (datasize !&#x3D; dyarr-&gt;Single_Data_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);
	int datarate &#x3D; datasize &#x2F; dyarr-&gt;total_usable_size;
	if (datarate &gt; 0)
		Resize_The_Dynamic_Array(dyarr, (datarate + 1) * dyarr-&gt;total_usable_size);
	void* newspace &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + n_repeat) * dyarr-&gt;Single_Data_size);
	if (!newspace)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memmove(
		(char*)dyarr-&gt;DataPiece + (pos + n_repeat) * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size * n_repeat
	);
	for (int i &#x3D; 0; i &lt; n_repeat; i++)
		memcpy(
			(char*)newspace + (pos + i) * dyarr-&gt;Single_Data_size,
			data,
			dyarr-&gt;Single_Data_size
		);
	dyarr-&gt;DataPiece &#x3D; newspace;
	dyarr-&gt;current_size +&#x3D; n_repeat;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Insert back some data that organized in static array
&#x2F;&#x2F;use like this: Insert_Into_A_Dynamic_Array(
&#x2F;&#x2F; dyarr, 
&#x2F;&#x2F; where_to_insert, 
&#x2F;&#x2F; data, 
&#x2F;&#x2F; how_many_data_are_there_in_static_array,
&#x2F;&#x2F; sizeof(data)
&#x2F;&#x2F;)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Insert_Some_Data_Into_A_Dynamic_Array(
	DynamicArray*										dyarr,
	size_t												pos,
	void*												data_array, 
	size_t												array_num,
	size_t												data_inarray_size
)
&#123;
	if (!dyarr &amp;&amp; !data_array)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (!dyarr-&gt;current_size)
	&#123;
		Push_Back_Some_data_Into_A_Dynamic_Array(
			dyarr, 
			data_array, 
			array_num, 
			pos,
			data_inarray_size
		);
		return DynamicArray_Normal;
	&#125;
	if (dyarr-&gt;current_size &#x3D;&#x3D; dyarr-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr, 2 * dyarr-&gt;total_usable_size);
	int DataRate &#x3D; array_num &#x2F; dyarr-&gt;total_usable_size;
	if (DataRate &gt; 0)
		Resize_The_Dynamic_Array(dyarr, (DataRate + 1) * dyarr-&gt;total_usable_size);
	void* Afteradd_piece &#x3D; realloc(dyarr-&gt;DataPiece, (dyarr-&gt;current_size + array_num) * dyarr-&gt;Single_Data_size);
	if (!Afteradd_piece)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memmove(
		(char*)dyarr-&gt;DataPiece + (pos + array_num) * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + pos * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size*array_num
	);
	for (int i &#x3D; 0; i &lt; array_num; i++)
		memcpy(
			(char*)dyarr-&gt;DataPiece + (pos + i) * dyarr-&gt;Single_Data_size,
			(char*)data_array + i * (dyarr-&gt;Single_Data_size),
			dyarr-&gt;Single_Data_size
		);
	dyarr-&gt;current_size +&#x3D; array_num;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F;About Dynamic Array
&#x2F;&#x2F;Append another dynamic Array
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; AppendByMergeDynamicArray(dyarr_be_appended, exp_append_array)
&#x2F;&#x2F;
DynamicArrayFunctionStatues AppendByMergeDynamicArray(
	DynamicArray*											dyarr_be_appended,
	DynamicArray*											exp_append_array
)
&#123;
	if (!dyarr_be_appended &amp;&amp; !exp_append_array)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	int datarate &#x3D; exp_append_array-&gt;current_size &#x2F; dyarr_be_appended-&gt;total_usable_size;
	if (dyarr_be_appended-&gt;current_size &#x3D;&#x3D; dyarr_be_appended-&gt;total_usable_size)
		Resize_The_Dynamic_Array(dyarr_be_appended, 2 * dyarr_be_appended-&gt;total_usable_size);
	if (datarate &gt; 0)
		Resize_The_Dynamic_Array(dyarr_be_appended, (datarate + 1) * dyarr_be_appended-&gt;total_usable_size);
	void* AfterAppend &#x3D; realloc(
		dyarr_be_appended-&gt;DataPiece,
		(dyarr_be_appended-&gt;current_size + exp_append_array-&gt;current_size) * dyarr_be_appended-&gt;Single_Data_size
	);
	if (!AfterAppend)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	dyarr_be_appended-&gt;DataPiece &#x3D; AfterAppend;
	memcpy(
		(char*)dyarr_be_appended-&gt;DataPiece + dyarr_be_appended-&gt;current_size * dyarr_be_appended-&gt;Single_Data_size,
		(char*)exp_append_array-&gt;DataPiece,
		exp_append_array-&gt;current_size * exp_append_array-&gt;Single_Data_size
	);
	dyarr_be_appended-&gt;current_size +&#x3D; exp_append_array-&gt;current_size;
	
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="删减函数"><a href="#删减函数" class="headerlink" title="删减函数"></a>删减函数</h3><p>​        就像人生需要做减法一样，我们也要给我们的数据结构提供删减操作！</p>
<h4 id="尾删除函数（删减一个）"><a href="#尾删除函数（删减一个）" class="headerlink" title="尾删除函数（删减一个）"></a>尾删除函数（删减一个）</h4><p>​        不删减多个，不水代码！</p>
<p>​        很简单，我们只需要size—就好了！之后再次增加的时候会直接覆盖，同时，若是删减过多可以在后续直接调用Resize函数！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase the final element!
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(
	DynamicArray*											dyarr
)
&#123;
	if(!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	dyarr-&gt;current_size--;
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="直接清除函数（直接清空）"><a href="#直接清除函数（直接清空）" class="headerlink" title="直接清除函数（直接清空）"></a>直接清除函数（直接清空）</h4><p>​        一个思路，但是，这次由于是清空，我们直接free掉数据！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Clear_A_Dynamic_Array(
	DynamicArray*											dyarr
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	dyarr-&gt;current_size &#x3D; 0;
	if (!dyarr-&gt;DataPiece)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Free;
		printf(&quot;VOID DATA SHOULDN&#39;T BE FREE!&quot;);
		exit(DynamicArray_Invalid_Free);
	&#125;
    &#x2F;&#x2F;预留一个位置，便于后期操作！
	void* pro_usable_space&#x3D; realloc(dyarr-&gt;DataPiece, dyarr-&gt;Single_Data_size);
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	dyarr-&gt;DataPiece&#x3D;pro_usable_space;
	dyarr-&gt;total_usable_size &#x3D; 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="删除一个数据（指定一个位置）"><a href="#删除一个数据（指定一个位置）" class="headerlink" title="删除一个数据（指定一个位置）"></a>删除一个数据（指定一个位置）</h4><p>​        我们怎么删除数组里的一个数据呢？只需要回顾到Insert函数的操作，我们反过来，让pos后面的数据往前移动一个！不久把数据盖上了嘛！随后size—就是我们想要的结果！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase a specific data by pos
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(
	DynamicArray*												dyarr, 
	size_t														pos
)
&#123;
    &#x2F;&#x2F;检查
	if(!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
    &#x2F;&#x2F;直接拷贝覆盖跑路！
	memcpy(
		(char*)dyarr-&gt;DataPiece+pos*dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece+(pos+1)*dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos-1)
		);
    &#x2F;&#x2F;size--，防止访问到奇怪的数据！
	dyarr-&gt;current_size--;
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="删除一些数据"><a href="#删除一些数据" class="headerlink" title="删除一些数据"></a>删除一些数据</h4><p>​        这个难度稍大一点：关键在于，如果我们删除了大量的数据，我们需要调用Resize函数来释放多余的空间，这样可以优化内存占用！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase some specific data by pos
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(
	DynamicArray*												dyarr, 
	size_t														Beginpos, 
	size_t														Endpos
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (Beginpos &lt; 0 || Beginpos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (Endpos &lt; 0 || Endpos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	memcpy(
		(char*)dyarr-&gt;DataPiece + Beginpos * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + (Endpos + 1) * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - Endpos + 1)
	);
	dyarr-&gt;current_size -&#x3D; Endpos - Beginpos + 1;
    &#x2F;&#x2F;开始调整大小！
	if (dyarr-&gt;current_size &lt;&#x3D; dyarr-&gt;total_usable_size &#x2F; 4 &amp;&amp; dyarr-&gt;total_usable_size &gt; 5)
	&#123;
		Resize_The_Dynamic_Array(dyarr, dyarr-&gt;total_usable_size &#x2F; 2);
		dyarr-&gt;total_usable_size &#x2F;&#x3D; 2;
	&#125;
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="直接删掉整个动态数组的函数："><a href="#直接删掉整个动态数组的函数：" class="headerlink" title="直接删掉整个动态数组的函数："></a>直接删掉整个动态数组的函数：</h4><p>​        注意：我们先释放数据，再释放本身！不然会造成内存泄漏！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(
	DynamicArray*												dyarr
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Free;
		exit(DynamicArray_Invalid_Free);
	&#125;
	free(dyarr-&gt;DataPiece);
	free(dyarr);
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="一览删除函数："><a href="#一览删除函数：" class="headerlink" title="一览删除函数："></a>一览删除函数：</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase the final element!
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Pop_Out_From_A_Dynamic_Array(dyarr)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Pop_Out_From_A_Dynamic_Array(
	DynamicArray*											dyarr
)
&#123;
	if(!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	dyarr-&gt;current_size--;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase all elements!
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Clear_A_Dynamic_Array(dyarr)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Clear_A_Dynamic_Array(
	DynamicArray*											dyarr
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	dyarr-&gt;current_size &#x3D; 0;
	if (!dyarr-&gt;DataPiece)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Free;
		printf(&quot;VOID DATA SHOULDN&#39;T BE FREE!&quot;);
		exit(DynamicArray_Invalid_Free);
	&#125;
	void* pro_usable_space&#x3D; realloc(dyarr-&gt;DataPiece, dyarr-&gt;Single_Data_size);
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	dyarr-&gt;DataPiece&#x3D;pro_usable_space;
	dyarr-&gt;total_usable_size &#x3D; 1;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase all elements! and unable to be used again!
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; Destroy_A_Dynamic_Array(dyarr)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Destroy_A_Dynamic_Array(
	DynamicArray*												dyarr
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Free;
		exit(DynamicArray_Invalid_Free);
	&#125;
	free(dyarr-&gt;DataPiece);
	free(dyarr);
	return DynamicArray_Normal;
&#125;
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase a specific data by pos
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr,  pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Delete_A_Specific_Data_From_the_DynamicArray(
	DynamicArray*												dyarr, 
	size_t														pos
)
&#123;
	if(!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	memcpy(
		(char*)dyarr-&gt;DataPiece+pos*dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece+(pos+1)*dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size*(dyarr-&gt;current_size-pos-1)
		);
	dyarr-&gt;current_size--;
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually erase some specific data by pos
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Delete_A_Specific_Data_From_the_DynamicArray(dyarr, beginpos, endpos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Delete_Some_Specific_Data_From_the_DynamicArray(
	DynamicArray*												dyarr, 
	size_t														Beginpos, 
	size_t														Endpos
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (Beginpos &lt; 0 || Beginpos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (Endpos &lt; 0 || Endpos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	memcpy(
		(char*)dyarr-&gt;DataPiece + Beginpos * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + (Endpos + 1) * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size * (dyarr-&gt;current_size - Endpos + 1)
	);
	dyarr-&gt;current_size -&#x3D; Endpos - Beginpos + 1;
	if (dyarr-&gt;current_size &lt;&#x3D; dyarr-&gt;total_usable_size &#x2F; 4 &amp;&amp; dyarr-&gt;total_usable_size &gt; 5)
	&#123;
		Resize_The_Dynamic_Array(dyarr, dyarr-&gt;total_usable_size &#x2F; 2);
		dyarr-&gt;total_usable_size &#x2F;&#x3D; 2;
	&#125;
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="打印内容与处理其内数据函数系列"><a href="#打印内容与处理其内数据函数系列" class="headerlink" title="打印内容与处理其内数据函数系列"></a>打印内容与处理其内数据函数系列</h3><h4 id="打印操作"><a href="#打印操作" class="headerlink" title="打印操作"></a>打印操作</h4><p>​        打印数据是我们常用的与数据交互的操作，我们正是需要这个东西来看看我们的数据如何：注意到，我们打印的可能不是整数，可能不是字符，而是任何东西！那么，我们所作的，只是提供一个函数接口！至于怎么打印，让用户自己看着办！为了方便打字，为了防止用户花式整出来奇形八怪的Print接口，我们统一 一个！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void(* MyPrint )(void*)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这个是函数指针别名的经典写法，如果你不熟悉，可以从这里看：比若说，我要指定一个类型，给他起个别名便于我们后续写程序提醒与应用（工程上常常这么做！提醒自己这个是干嘛的的）</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef int MyInt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这就是说：MyInt是我自己起的一个类型，但是本质上就是Int！它可以跟int 起到完全一致的效果！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int main()
&#123;
    int a &#x3D; 1;
    MyInt b &#x3D; 1;&#x2F;&#x2F; Legal!
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        而这个：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void(* MyPrint )(void*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        就是一个函数指针（说白了，就是一个接受一个任意数据啥都不返回的函数！）的别名，这样写，你可能会更有感觉：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void(*)(void*) MyPrint ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        于是，我们的打印函数就有了点可行的想法了！</p>
<h4 id="打印一个数据（指定位置）"><a href="#打印一个数据（指定位置）" class="headerlink" title="打印一个数据（指定位置）"></a>打印一个数据（指定位置）</h4><p>​        这个函数可以和后面的返回位置的查找函数搭配使用！我们的这个函数打印动态数组里的一个元素！函数肯定的：需要一个动态数组！需要位置！需要打印方式！原型直接出来了：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(
	DynamicArray*											dyarr, 
	MyPrint	&#x2F;*就是函数指针，说白了就是打印方式传进来*&#x2F;				user_print, 
	size_t													pos
) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        还是检查：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#123;
	if (!dyarr &amp;&amp; !user_print)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
    ...
        
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        为了让打印好看点，我们加入表示语句：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">printf(&quot;\nSpecific Data is Shown:\n&quot;);
...&#x2F;&#x2F;here we print
printf(&quot;\nSpecific Data Finished Showing!\n&quot;);
return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        对于函数的调用，我们使用（）调用！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">user_print(
    (char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size)
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>​        为什么这样写？注意，我们必须转化void* 为具体的指针来对指针进行加减操作！否则不合法！，而操作程度最小的指针就是char指针！于是，我们使用：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">(char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>定位到我们想要打印到的位置！之后解引用的方式（决定访问步长，这是指针的一个应用本质）是由用户决定的！</p>
<p>​        看看成品：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually Print a specific data
&#x2F;&#x2F; use like this
&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(
	DynamicArray*												dyarr, 
	MyPrint														user_print, 
	size_t														pos
) 
&#123;
	if (!dyarr &amp;&amp; !user_print)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	printf(&quot;\nSpecific Data is Shown:\n&quot;);
	user_print((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));
	printf(&quot;\nSpecific Data Finished Showing!\n&quot;);
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="打印所有数据"><a href="#打印所有数据" class="headerlink" title="打印所有数据"></a>打印所有数据</h4><p>​        我说停！先别开工！我们引入一个enum，让用户传入一个参数来决定要不要更好的打印我们的数据！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;A switch that used in better Print in Dynamic Array!
&#x2F;&#x2F;Often use OPEN to beautify the control table
&#x2F;&#x2F;
typedef enum _BetterPrintSwitch_for_dyarr_ &#123;
	Dyarr_OPEN &#x3D; 1,
	Dyarr_CLOSE &#x3D; 0
&#125;BetterPrintSwitch_for_dyarr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        之后？就是遍历咯！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually Print All data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(
	DynamicArray*												dyarr,
	MyPrint													user_print,
	BetterPrintSwitch_for_dyarr							whether_better_print
)
&#123;
	if (!dyarr &amp;&amp; !user_print)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
    &#x2F;&#x2F;要不要更好的打印？
	if(whether_better_print&#x3D;&#x3D;Dyarr_OPEN)
	&#123;
		printf(&quot;\nStart Printing\n&quot;);
	&#125;
    &#x2F;&#x2F;遍历！
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
	&#123;
        &#x2F;&#x2F;函数名跟数组名一样！本质上还是指针，所以，无所谓解不解引用
		(*user_print)(
            &#x2F;&#x2F;打印第I个
            (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)
        );
	&#125;
	if (whether_better_print &#x3D;&#x3D; Dyarr_OPEN)
	&#123;
		printf(&quot;\nFinish Printing\n&quot;);
	&#125;
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="处理数据（单个多个）"><a href="#处理数据（单个多个）" class="headerlink" title="处理数据（单个多个）"></a>处理数据（单个多个）</h4><p>​        仿照Print思路，这一次，我们使用Do_Specific_Change函数指针！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef void*(*Do_Specific_Change)(void*);&#x2F;&#x2F;返回void也行，主要考虑扩展接口的问题，后续可能自己定义函数要继续操作<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这次不在多说！一样的：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually make some change in all data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(
	DynamicArray*												dyarr, 
	Do_Specific_Change											user_change
) 
&#123;
	if (!dyarr &amp;&amp; !user_change)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
		user_change(
        &#x2F;&#x2F;处理第I个数据
        (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)
    );
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually make some change in a specific data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(
	DynamicArray*												dyarr, 
	Do_Specific_Change										user_change, 
	size_t														pos
)
&#123;
	if (!dyarr &amp;&amp; !user_change)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	user_change((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="打印内容与处理其内数据函数系列一览"><a href="#打印内容与处理其内数据函数系列一览" class="headerlink" title="打印内容与处理其内数据函数系列一览"></a>打印内容与处理其内数据函数系列一览</h4><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually Print a specific data
&#x2F;&#x2F; use like this
&#x2F;&#x2F;Print_Specific_Data_In_A_Dynamic_Array(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Print_Specific_Data_In_A_Dynamic_Array(
	DynamicArray*												dyarr, 
	MyPrint														user_print, 
	size_t														pos
) 
&#123;
	if (!dyarr &amp;&amp; !user_print)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	printf(&quot;\nSpecific Data is Shown:\n&quot;);
	user_print((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));
	printf(&quot;\nSpecific Data Finished Showing!\n&quot;);
	return DynamicArray_Normal;
&#125;
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually Print All data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Print_ALL_Data_In_A_Dynamic_Array(dyarr,user_print_funtional_pointer, Dyarr_OPEN or Dyarr_ClOSE)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Print_ALL_Data_In_A_Dynamic_Array(
	DynamicArray*												dyarr,
	MyPrint													user_print,
	BetterPrintSwitch_for_dyarr							whether_better_print
)
&#123;
	if (!dyarr &amp;&amp; !user_print)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
    &#x2F;&#x2F;要不要更好的打印？
	if(whether_better_print&#x3D;&#x3D;Dyarr_OPEN)
	&#123;
		printf(&quot;\nStart Printing\n&quot;);
	&#125;
    &#x2F;&#x2F;遍历！
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
	&#123;
        &#x2F;&#x2F;函数名跟数组名一样！本质上还是指针，所以，无所谓解不解引用
		(*user_print)(
            &#x2F;&#x2F;打印第I个
            (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)
        );
	&#125;
	if (whether_better_print &#x3D;&#x3D; Dyarr_OPEN)
	&#123;
		printf(&quot;\nFinish Printing\n&quot;);
	&#125;
	return DynamicArray_Normal;
&#125;
&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually make some change in all data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Do_Specific_Change_To_All_Data(
	DynamicArray*												dyarr, 
	Do_Specific_Change											user_change
) 
&#123;
	if (!dyarr &amp;&amp; !user_change)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
		user_change(
        &#x2F;&#x2F;处理第I个数据
        (char*)(dyarr-&gt;DataPiece) + i * (dyarr-&gt;Single_Data_size)
    );
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; Actually make some change in a specific data
&#x2F;&#x2F; use like this
&#x2F;&#x2F; Do_Specific_Change_To_All_Data(dyarr, user_print, pos)
&#x2F;&#x2F;
DynamicArrayFunctionStatues Do_Specific_Change_To_Specific_Data(
	DynamicArray*												dyarr, 
	Do_Specific_Change										user_change, 
	size_t														pos
)
&#123;
	if (!dyarr &amp;&amp; !user_change)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos &lt; 0 || pos&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	user_change((char*)(dyarr-&gt;DataPiece) + pos * (dyarr-&gt;Single_Data_size));
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="查询状况与数据函数一览"><a href="#查询状况与数据函数一览" class="headerlink" title="查询状况与数据函数一览"></a>查询状况与数据函数一览</h3><h4 id="查询动态数组是否为空函数"><a href="#查询动态数组是否为空函数" class="headerlink" title="查询动态数组是否为空函数"></a>查询动态数组是否为空函数</h4><p>​        呃，最简单了哈哈：不过注意，在C89的时候还没有布尔类型！我们需要自己手搓一个：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Mybool defined
&#x2F;&#x2F;
typedef enum _bool_ &#123;
	True &#x3D; 1,
	False &#x3D; 0
&#125;Bool;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        用起来咯！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; this is used in judging whether the dynamic array is empty
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; isEmpty_InDynamicArray(dyarr)
&#x2F;&#x2F;
Bool isEmpty_InDynamicArray(
	DynamicArray*						dyarr
) 
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (dyarr-&gt;current_size&#x3D;&#x3D;0)
		return True;
	return False;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="查询特定元素是否存在"><a href="#查询特定元素是否存在" class="headerlink" title="查询特定元素是否存在"></a>查询特定元素是否存在</h4><p>​        咳咳，难度来了：对于任意的数据，我们怎么知道他们符不符合要求：相等呢？嘛！这个简单，用户决定嘛！</p>
<p>​        还是一样，我们统一一个函数指针：其返回值类型是专门用来标记是否存在的：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef unsigned int Is_Used_Compared_Int;&#x2F;&#x2F;返回类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>​        这下函数原型好说了！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues isLocateinDyarr(
	DynamicArray*	 					dyarr,
	void*								data,
	LocateFunc						user_func
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        老老老样子，判判判判断！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!user_func)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>遍历一下咯！不过为了提高程序可阅读性质：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;this type of int is specifically used in Returning Find Or Unfind.
&#x2F;&#x2F;Recommmend to be used as a nickname:)
&#x2F;&#x2F;Can use Find or Unfind to return the result
&#x2F;&#x2F;
typedef enum _DynamicArray_isFind_ &#123;
	Find	&#x3D; 1,
	Unfind	&#x3D; -1
&#125;DynamicArray_isFind;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
&#123;
	if (
	user_func(
        &#x2F;&#x2F;check the Ith one
        (char*)dyarr-&gt;DataPiece +
        i * dyarr-&gt;Single_Data_size, 
        data
    )&#x2F;&#x2F;if found return Find
	)
	&#123;
		return Find;
	&#125;
&#125;
	return Unfind;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="返回第一次遇到的位置"><a href="#返回第一次遇到的位置" class="headerlink" title="返回第一次遇到的位置"></a>返回第一次遇到的位置</h4><p>​        跟上面很类似捏：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues returnAElembyPos_inDyarr(
	DynamicArray*												dyarr, 
	void*														data, 
	LocateFunc													user_func
) 
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!user_func)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
	&#123;
		if ( &#x2F;&#x2F;check the Ith one
            user_func
            (
            	(char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size,
            	data
            )
        )
		&#123;&#x2F;&#x2F; if found return i(the position)
			return i;
		&#125;
	&#125;
	return Unfind;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="存储位置的动态数组及其API"><a href="#存储位置的动态数组及其API" class="headerlink" title="存储位置的动态数组及其API"></a>存储位置的动态数组及其API</h4><p>​        这个是为了下面做铺垫！原理一致，只展现API！</p>
<h6 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h6><pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct _Dyarrposarr_ &#123;
	int* posSpace;
	size_t pos_size;
&#125;Position_Stored_Dynamic_ArrayFordyarr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h6 id="更好的打印开关枚举定义："><a href="#更好的打印开关枚举定义：" class="headerlink" title="更好的打印开关枚举定义："></a>更好的打印开关枚举定义：</h6><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;Want a better Print to beutify your control table? try this one
&#x2F;&#x2F;
typedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;
	PSDA_dyarr_OPEN &#x3D; 1,
	PSDA_dyarr_CLOSE &#x3D; 0
&#125;BetterPrintSwitch_for_pos_dyarr;
&#x2F;&#x2F;can use this type when indicating the type
&#x2F;&#x2F;
typedef unsigned int BetterPrintfor_PosDyarr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="API-1：创造一个存储位置的动态数组"><a href="#API-1：创造一个存储位置的动态数组" class="headerlink" title="API 1：创造一个存储位置的动态数组"></a>API 1：创造一个存储位置的动态数组</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func
&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:
&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();
&#x2F;&#x2F;
Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr()
&#123;
	Position_Stored_Dynamic_ArrayFordyarr* pro_usable_space 
        &#x3D; 
        MALLOCDYARR(Position_Stored_Dynamic_ArrayFordyarr, 1);
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
  	pro_usable_space-&gt;posSpace &#x3D; NULL;
	pro_usable_space-&gt;pos_size &#x3D; 0;
	return pro_usable_space;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="API-2：打印所有的位置："><a href="#API-2：打印所有的位置：" class="headerlink" title="API 2：打印所有的位置："></a>API 2：打印所有的位置：</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos
&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE
&#x2F;&#x2F;
DynamicArrayFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*				posarr,
	BetterPrintfor_PosDyarr							   Whether_Better_Print
)
&#123;
	if (!posarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)
		printf(&quot;\nPositions are shown! :\n&quot;);
	for (int i &#x3D; 0; i &lt; posarr-&gt;pos_size; i++)
		printf(&quot;%u &quot;, posarr-&gt;posSpace[i]);
	if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)
		printf(&quot;\nFinish Printing!\n&quot;);
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="API-3：推入一个位置"><a href="#API-3：推入一个位置" class="headerlink" title="API 3：推入一个位置"></a>API 3：推入一个位置</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to push back a position into the Position_Stored_Dynamic_ArrayFordyarr
&#x2F;&#x2F;
DynamicArrayFunctionStatues Push_back_a_locations_in_PSDA_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*				posarr, 
	int													pos_acquired
)
&#123;
	int* pro_usable_space &#x3D; (int*)realloc(posarr-&gt;posSpace, sizeof(int) * (posarr-&gt;pos_size + 1));
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	posarr-&gt;posSpace &#x3D; pro_usable_space;
	posarr-&gt;posSpace[posarr-&gt;pos_size] &#x3D; pos_acquired;
	posarr-&gt;pos_size++;
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="API4：统计个数"><a href="#API4：统计个数" class="headerlink" title="API4：统计个数"></a>API4：统计个数</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to return the number of locations
&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE
&#x2F;&#x2F;
size_t Get_pos_size_From_PSDA_for_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*				posarr,
	BetterPrintfor_PosDyarr								Whether_Shown_Print 
)
&#123;
	if (!posarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (Whether_Shown_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)
		printf(&quot;\nCurrent targeted data&#39;s total num is:%u!\n&quot;,posarr-&gt;pos_size);
	return posarr-&gt;pos_size;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="API-5：销毁一个存储位置的动态数组"><a href="#API-5：销毁一个存储位置的动态数组" class="headerlink" title="API 5：销毁一个存储位置的动态数组"></a>API 5：销毁一个存储位置的动态数组</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;Erase a dynamic Array when donot using it!
&#x2F;&#x2F;
DynamicArrayFunctionStatues DesTroy_A_PSDA_for_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*				pointer_to_wishedfreeposarr
)
&#123;
	if (!pointer_to_wishedfreeposarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_Invalid_Free);
	&#125;
	free(pointer_to_wishedfreeposarr-&gt;posSpace);
	free(pointer_to_wishedfreeposarr);
	pointer_to_wishedfreeposarr &#x3D; NULL;
	return DynamicArray_Normal;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="API-6：返回指定位置的标记位置"><a href="#API-6：返回指定位置的标记位置" class="headerlink" title="API 6：返回指定位置的标记位置"></a>API 6：返回指定位置的标记位置</h5><pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;return a pos that is targeted!
&#x2F;&#x2F;
DynamicArrayFunctionStatues getPosbyPosinPSDA(
	Position_Stored_Dynamic_ArrayFordyarr*					getter,
	size_t												 pos
) 
&#123;
	if (!getter) &#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_Invalid_Free);
	&#125;
	if (pos &gt; getter-&gt;pos_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	for (int i &#x3D; 0; i &lt; pos; i++)
		return (char*)getter-&gt;posSpace + i * sizeof(size_t);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        这些API很简单，我不阐述原理了！</p>
<h4 id="返回多个位置函数"><a href="#返回多个位置函数" class="headerlink" title="返回多个位置函数"></a>返回多个位置函数</h4><p>​        返回一个简单，返回多个怎么办？存储位置的动态数组嘛！不过，这个是只记载位置的：那就好说了！</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">Position_Stored_Dynamic_ArrayFordyarr* returnABunchofData_inDyarr(
	DynamicArray*									dyarr, 
	Position_Stored_Dynamic_ArrayFordyarr*			posArr, 
	void*											data, 
	LocateFunc										user_func
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!user_func)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!data)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
	&#123;
		for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size; i++)
		&#123;
			if (
                (*user_func)(
                    data, 
                    (char*)dyarr-&gt;DataPiece + i * dyarr-&gt;Single_Data_size)
            )
			&#123;
                &#x2F;&#x2F;类似于return i，这次往PSDA里return！
				Push_back_a_locations_in_PSDA_dyarr(posArr，i)
			&#125;
		&#125;
		if (posArr-&gt;pos_size!&#x3D;0)
			return posArr;
		return Unfind;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="交换于排序函数系列"><a href="#交换于排序函数系列" class="headerlink" title="交换于排序函数系列"></a>交换于排序函数系列</h3><p>​        我们的排序只涉及冒泡排序！</p>
<h4 id="交换函数"><a href="#交换函数" class="headerlink" title="交换函数"></a>交换函数</h4><p>​        回忆一下基本的交换方法：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void swapInt(int* e1, int*e2)&#123;
    int temp &#x3D; *e1 ;
    *e1 &#x3D; *e2;
    *e2 &#x3D; temp;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        基于此：我们还是一样的仿照设计出函数原型：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">DynamicArrayFunctionStatues swapData_in_DynamicArray(
	DynamicArray*												dyarr, 
	size_t														pos1, 
	size_t														pos2
)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>检查：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">if (!dyarr)
&#123;
	SHOW_ERROR_DynamicArray_NULL_INPUT;
	exit(DynamicArray_NULL_INPUT);
&#125;
if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)
&#123;
	SHOW_ERROR_DynamicArray_Invalid_Input;
	exit(DynamicArray_Invalid_Input);
&#125;
if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)
&#123;
	SHOW_ERROR_DynamicArray_Invalid_Input;
	exit(DynamicArray_Invalid_Input);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这一次，我们的交换使用memcpy（memmove都可以）(为了演示我交叉使用了)</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F;准备空间
char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);
if(!swapbit)
&#123;
	SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
	exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
&#125;
&#x2F;&#x2F; int temp &#x3D; *e1 ;
memcpy(
	swapbit,
	(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,
	dyarr-&gt;Single_Data_size
);
&#x2F;&#x2F;*e1 &#x3D; *e2;
memmove(
	(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,
	(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,
	dyarr-&gt;Single_Data_size
);
&#x2F;&#x2F; *e2 &#x3D; temp;
memcpy(
	(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,
	swapbit,
	dyarr-&gt;Single_Data_size
);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>​        别忘了释放空间：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">free(swapbit);
return DynamicArray_Normal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>整合看看：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; this is used in swap data
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)
&#x2F;&#x2F;
DynamicArrayFunctionStatues swapData_in_DynamicArray(
	DynamicArray*												dyarr, 
	size_t														pos1, 
	size_t														pos2
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);
	if(!swapbit)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memcpy(
		swapbit,
		(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size
	);
	memmove(
		(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size
	);
	memcpy(
		(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,
		swapbit,
		dyarr-&gt;Single_Data_size
	);
	free(swapbit);
	return DynamicArray_Normal;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="冒泡排序交换函数："><a href="#冒泡排序交换函数：" class="headerlink" title="冒泡排序交换函数："></a>冒泡排序交换函数：</h4><p>​        仿照经典冒泡排序。。。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">void bubbleSort(int* arr, int arr_size)
&#123;
    
	if(arr&#x3D;&#x3D;NULL)&#123;
        return;
    &#125;   
    
    if(arr_size&lt;&#x3D;1)&#123;
        return;
    &#125;
    
    for(int i&#x3D;0; i&lt;arr_size-1; i++)
    &#123;
        for(int j &#x3D; 0;j&lt;arr_size-i-1; j++)
        &#123;
            if(arr[j]&gt; arr[j+1])
            &#123;
                swap(arr[j],arr[j+1]);&#x2F;&#x2F;swap不实现了，上面就有
            &#125;
        &#125;
    &#125;
    
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; sadly that is bubblesort :(
&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)
&#x2F;&#x2F;
DynamicArrayFunctionStatues sort_In_Dynamic_Array(
	DynamicArray*												dyarr,
	CompareFunc													compfunc
) 
&#123;
    &#x2F;&#x2F;检查
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!compfunc)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size-1; i++)
	&#123;
		for (int j &#x3D; 0; j &lt; dyarr-&gt;current_size - i-1; j++)
		&#123;
			if (&#x2F;&#x2F;if(arr[j]&gt; arr[j+1])
				compfunc
                		(
				(char*)dyarr-&gt;DataPiece + j * dyarr-&gt;Single_Data_size,
				(char*)dyarr-&gt;DataPiece + (j + 1) * dyarr-&gt;Single_Data_size
						)
				)
                &#x2F;&#x2F;swap(arr[j],arr[j+1])
				swapData_in_DynamicArray(dyarr, j, j + 1);
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="交换于排序函数系列一览"><a href="#交换于排序函数系列一览" class="headerlink" title="交换于排序函数系列一览"></a>交换于排序函数系列一览</h4><p>OK，集合一下</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; this is used in swap data
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; swapData_in_DynamicArray(dyarr,pos1,pos2)
&#x2F;&#x2F;
DynamicArrayFunctionStatues swapData_in_DynamicArray(
	DynamicArray*												dyarr, 
	size_t														pos1, 
	size_t														pos2
)
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (pos1&lt;0 || pos1&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	if (pos2&lt;0 || pos2&gt;dyarr-&gt;current_size)
	&#123;
		SHOW_ERROR_DynamicArray_Invalid_Input;
		exit(DynamicArray_Invalid_Input);
	&#125;
	char* swapbit &#x3D; (char*)malloc(dyarr-&gt;Single_Data_size);
	if(!swapbit)
	&#123;
		SHOW_ERROR_DynamicArray_ERROR_IN_MALLOCING_SPACE;
		exit(DynamicArray_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memcpy(
		swapbit,
		(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size
	);
	memmove(
		(char*)dyarr-&gt;DataPiece + pos1 * dyarr-&gt;Single_Data_size,
		(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,
		dyarr-&gt;Single_Data_size
	);
	memcpy(
		(char*)dyarr-&gt;DataPiece + pos2 * dyarr-&gt;Single_Data_size,
		swapbit,
		dyarr-&gt;Single_Data_size
	);
	free(swapbit);
	return DynamicArray_Normal;
&#125;

&#x2F;&#x2F; About Dynamic Array
&#x2F;&#x2F; sadly that is bubblesort :(
&#x2F;&#x2F; I haven&#39;t make it in quicksort as it was toooooooooooooooooooooo tiring lol
&#x2F;&#x2F; use like this:
&#x2F;&#x2F; sort_In_Dynamic_Array(dyarr,comparision_funcuntional_pointer)
&#x2F;&#x2F;
DynamicArrayFunctionStatues sort_In_Dynamic_Array(
	DynamicArray*												dyarr,
	CompareFunc													compfunc
) 
&#123;
	if (!dyarr)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	if (!compfunc)
	&#123;
		SHOW_ERROR_DynamicArray_NULL_INPUT;
		exit(DynamicArray_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; dyarr-&gt;current_size-1; i++)
	&#123;
		for (int j &#x3D; 0; j &lt; dyarr-&gt;current_size - i-1; j++)
		&#123;
			if (
				compfunc(
					(char*)dyarr-&gt;DataPiece + j * dyarr-&gt;Single_Data_size,
					(char*)dyarr-&gt;DataPiece + (j + 1) * dyarr-&gt;Single_Data_size
						)
				)
				swapData_in_DynamicArray(dyarr, j, j + 1);
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="测试一下子咯！"><a href="#测试一下子咯！" class="headerlink" title="测试一下子咯！"></a>测试一下子咯！</h3><p>测试代码：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1
#include&quot;standard_dynamic_array.h&quot;
MyPrint print(int* e1) &#123;
	printf(&quot;%d &quot;, *e1);
&#125;
Do_Specific_Change dochange(int* e1) &#123;
	*e1 &#x3D; *e1 + 1;
&#125;
LocateFunc loc(int* e1, int* e2) &#123;
	if (*e1 &#x3D;&#x3D; *e2) &#123;
		return Find;
	&#125;
	return Unfind;
&#125;
int main()
&#123;
	int data1 &#x3D; 10;
	
    &#x2F;&#x2F;test Initing
	DynamicArray* testDyarr1 &#x3D; Init_A_DynamicArray(10, Dyarr_SIGINT);
	
    &#x2F;&#x2F;test a Sigdata pushed:
	Push_Back_Into_A_Dynamic_Array(testDyarr1, &amp;data1);
	Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);
	
    &#x2F;&#x2F;test pushing the same data
	Push_back_Same_data_Into_A_Dynamic_Array(testDyarr1, &amp;data1, 10, Dyarr_SIGINT);
	Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);
	
    &#x2F;&#x2F;Test Clearing
	Clear_A_Dynamic_Array(testDyarr1);
	Print_ALL_Data_In_A_Dynamic_Array(testDyarr1, print, Dyarr_OPEN);
	
    &#x2F;&#x2F;test update
	int data2[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;
	DynamicArray* test2&#x3D;Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);
	Print_ALL_Data_In_A_Dynamic_Array(test2, print, Dyarr_OPEN);
	
    &#x2F;&#x2F;test copy:
	DynamicArray* copyone &#x3D; Init_A_DynamicArray_by_CopyADyarr(test2);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	
    &#x2F;&#x2F;test insert	
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Insert_Into_A_Dynamic_Array(copyone, &amp;data1, 1);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	
    &#x2F;&#x2F;test insert bunch
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Insert_Some_Data_Into_A_Dynamic_Array(copyone, 1, data2, 10, Dyarr_SIGINT);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	
    &#x2F;&#x2F;test Erasing sigone
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Delete_A_Specific_Data_From_the_DynamicArray(copyone, 1);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	
    &#x2F;&#x2F;test Erasing bunch one
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Delete_Some_Specific_Data_From_the_DynamicArray(copyone,1,10);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	
    &#x2F;&#x2F;test Do change
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Do_Specific_Change_To_Specific_Data(copyone,dochange,1);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	printf(&quot;before:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	Do_Specific_Change_To_All_Data(copyone, dochange);
	printf(&quot;after:&quot;);
	Print_ALL_Data_In_A_Dynamic_Array(copyone, print, Dyarr_OPEN);
	
    &#x2F;&#x2F;test location:
	DynamicArray* test3 &#x3D; Updata_A_Static_Array_To_Dynamic_Array(data2, Dyarr_SIGINT, 10);
	if (isLocateinDyarr(test3, &amp;data2[2], loc)) &#123;
		printf(&quot;\nI have found it!\n&quot;);
	&#125;
	int where &#x3D; returnAElembyPos_inDyarr(test3, &amp;data2[2], loc);
	printf(&quot;\nIn dyarr the %d place\n&quot;, where);
	
    &#x2F;&#x2F;test Position Stored Dynamic Array and returnBunch
	Clear_A_Dynamic_Array(test3);
	Push_back_Same_data_Into_A_Dynamic_Array(test3, &amp;data2[2], 10, Dyarr_SIGINT);
	Position_Stored_Dynamic_ArrayFordyarr* p1 &#x3D; Init_A_Postion_Stored_Dynamic_ArrayFordyarr();
	returnABunchofData_inDyarr(test3, p1, &amp;data2[2], loc);
	Print_ALL_Data_In_A_Dynamic_Array(test3, print, Dyarr_OPEN);
	Show_All_Locations_In_PSDAfor_dyarr(p1, PSDA_dyarr_OPEN);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看看效果：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">4
Start Printing
10
Finish Printing

Start Printing
10 10 10 10 10 10 10 10 10 10 10
Finish Printing

Start Printing

Finish Printing

Start Printing
1 2 3 4 5 6 7 8 9 10
Finish Printing

Start Printing
1 2 3 4 5 6 7 8 9 10
Finish Printing
before:
Start Printing
1 2 3 4 5 6 7 8 9 10
Finish Printing
after:
Start Printing
1 10 2 3 4 5 6 7 8 9 10
Finish Printing
before:
Start Printing
1 10 2 3 4 5 6 7 8 9 10
Finish Printing
after:
Start Printing
1 1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10
Finish Printing
before:
Start Printing
1 1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10
Finish Printing
after:
Start Printing
1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10
Finish Printing
before:
Start Printing
1 2 3 4 5 6 7 8 9 10 10 2 3 4 5 6 7 8 9 10
Finish Printing
after:
Start Printing
1 2 3 4 5 6 7 8 9 10
Finish Printing
before:
Start Printing
1 2 3 4 5 6 7 8 9 10
Finish Printing
after:
Start Printing
1 3 3 4 5 6 7 8 9 10
Finish Printing
before:
Start Printing
1 3 3 4 5 6 7 8 9 10
Finish Printing
after:
Start Printing
2 4 4 5 6 7 8 9 10 11
Finish Printing

I have found it!

In dyarr the 2 place

Start Printing
3 3 3 3 3 3 3 3 3 3
Finish Printing

Positions are shown! :
0 1 2 3 4 5 6 7 8 9
Finish Printing!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="image-20230207221151700.png" alt="image-20230207221151700"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84API%E8%AF%A6%E8%A7%A3/">http://charliechen114514.github.io/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84API%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/MyTinyLibProject/">MyTinyLibProject</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/09/C-extension-Learning-%EF%BC%881%EF%BC%89-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/" title="C extension Learning （1） 位运算符，逻辑运算符和简单应用"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C extension Learning （1） 位运算符，逻辑运算符和简单应用</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/" title="C语言数据结构模拟：动态数组（1）头文件+源代码+测试"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C语言数据结构模拟：动态数组（1）头文件+源代码+测试</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/" title="C语言数据结构模拟：动态数组（1）头文件+源代码+测试"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">C语言数据结构模拟：动态数组（1）头文件+源代码+测试</div></div></a></div><div><a href="/2023/02/12/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/" title="C语言数据结构模拟：动态数组的实现思路"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">C语言数据结构模拟：动态数组的实现思路</div></div></a></div><div><a href="/2023/02/11/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/" title="C语言数据结构模拟（2）：经典单链表头文件-源代码-测试"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-11</div><div class="title">C语言数据结构模拟（2）：经典单链表头文件-源代码-测试</div></div></a></div><div><a href="/2023/02/15/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8API%E8%AF%A6%E8%A7%A3/" title="C语言数据结构 （2） 单链表API详解"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="title">C语言数据结构 （2） 单链表API详解</div></div></a></div><div><a href="/2023/01/28/C%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/" title="C简单教程（1）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-28</div><div class="title">C简单教程（1）</div></div></a></div><div><a href="/2023/01/30/%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/" title="算法（1）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-30</div><div class="title">算法（1）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">大更新！这下上了简单的数据结构的C实现，如果只对思路感兴趣看思路即可，如果想查看API实现就取看详解</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94API%E6%80%9D%E8%B7%AF%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">动态数组——API思路详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%85%A5%E9%97%A8"><span class="toc-number">1.0.1.</span> <span class="toc-text">动态数组入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%B0%83%E6%95%B4%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97"><span class="toc-number">1.0.2.</span> <span class="toc-text">工厂函数与基本调整函数系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">默认工厂函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">升级工厂函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">复制工厂函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%B0%83%E6%95%B4%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">基本调整函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E4%B8%80%E8%A7%88%E5%B7%A5%E5%8E%82%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9F%BA%E6%9C%AC%E8%B0%83%E6%95%B4%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">总体一览工厂函数与基本调整函数：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%EF%BC%88%E5%8A%A0%EF%BC%89%E5%87%BD%E6%95%B0%E4%B8%80%E8%A7%88"><span class="toc-number">1.0.3.</span> <span class="toc-text">增（加）函数一览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E5%8D%95%E4%B8%AA"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">追加单个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E6%8F%92%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B01%EF%BC%9A%E5%B0%BE%E6%8F%92%E7%9B%B8%E5%90%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.3.2.</span> <span class="toc-text">尾插多个数据函数1：尾插相同数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E6%8F%92%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.3.3.</span> <span class="toc-text">尾插一个数组函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.3.4.</span> <span class="toc-text">插入一个元素函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%8B%A5%E5%B9%B2%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B01%EF%BC%9A%E6%8F%92%E5%85%A5%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.3.5.</span> <span class="toc-text">插入若干数据函数1：插入数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%8B%A5%E5%B9%B2%E6%95%B0%E6%8D%AE%EF%BC%9A%E7%9B%B8%E5%90%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.3.6.</span> <span class="toc-text">插入若干数据：相同数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%BC%E6%8E%A5%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.3.7.</span> <span class="toc-text">拼接动态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%A7%88%E5%A2%9E%EF%BC%88%E5%8A%A0%EF%BC%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.3.8.</span> <span class="toc-text">一览增（加）函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E5%87%8F%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.4.</span> <span class="toc-text">删减函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0%EF%BC%88%E5%88%A0%E5%87%8F%E4%B8%80%E4%B8%AA%EF%BC%89"><span class="toc-number">1.0.4.1.</span> <span class="toc-text">尾删除函数（删减一个）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%B8%85%E9%99%A4%E5%87%BD%E6%95%B0%EF%BC%88%E7%9B%B4%E6%8E%A5%E6%B8%85%E7%A9%BA%EF%BC%89"><span class="toc-number">1.0.4.2.</span> <span class="toc-text">直接清除函数（直接清空）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%EF%BC%88%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">1.0.4.3.</span> <span class="toc-text">删除一个数据（指定一个位置）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.4.4.</span> <span class="toc-text">删除一些数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%A0%E6%8E%89%E6%95%B4%E4%B8%AA%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.0.4.5.</span> <span class="toc-text">直接删掉整个动态数组的函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%A7%88%E5%88%A0%E9%99%A4%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.0.4.6.</span> <span class="toc-text">一览删除函数：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E5%86%85%E5%AE%B9%E4%B8%8E%E5%A4%84%E7%90%86%E5%85%B6%E5%86%85%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97"><span class="toc-number">1.0.5.</span> <span class="toc-text">打印内容与处理其内数据函数系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">打印操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%EF%BC%88%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">打印一个数据（指定位置）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">打印所有数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%EF%BC%88%E5%8D%95%E4%B8%AA%E5%A4%9A%E4%B8%AA%EF%BC%89"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">处理数据（单个多个）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E5%86%85%E5%AE%B9%E4%B8%8E%E5%A4%84%E7%90%86%E5%85%B6%E5%86%85%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97%E4%B8%80%E8%A7%88"><span class="toc-number">1.0.5.5.</span> <span class="toc-text">打印内容与处理其内数据函数系列一览</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%8A%B6%E5%86%B5%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%87%BD%E6%95%B0%E4%B8%80%E8%A7%88"><span class="toc-number">1.0.6.</span> <span class="toc-text">查询状况与数据函数一览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">查询动态数组是否为空函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%89%B9%E5%AE%9A%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">查询特定元素是否存在</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%81%87%E5%88%B0%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">返回第一次遇到的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%8F%8A%E5%85%B6API"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">存储位置的动态数组及其API</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.0.6.4.0.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%89%93%E5%8D%B0%E5%BC%80%E5%85%B3%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.0.6.4.0.2.</span> <span class="toc-text">更好的打印开关枚举定义：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API-1%EF%BC%9A%E5%88%9B%E9%80%A0%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.6.4.1.</span> <span class="toc-text">API 1：创造一个存储位置的动态数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API-2%EF%BC%9A%E6%89%93%E5%8D%B0%E6%89%80%E6%9C%89%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">1.0.6.4.2.</span> <span class="toc-text">API 2：打印所有的位置：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API-3%EF%BC%9A%E6%8E%A8%E5%85%A5%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.0.6.4.3.</span> <span class="toc-text">API 3：推入一个位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API4%EF%BC%9A%E7%BB%9F%E8%AE%A1%E4%B8%AA%E6%95%B0"><span class="toc-number">1.0.6.4.4.</span> <span class="toc-text">API4：统计个数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API-5%EF%BC%9A%E9%94%80%E6%AF%81%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.6.4.5.</span> <span class="toc-text">API 5：销毁一个存储位置的动态数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#API-6%EF%BC%9A%E8%BF%94%E5%9B%9E%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%A0%87%E8%AE%B0%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.0.6.4.6.</span> <span class="toc-text">API 6：返回指定位置的标记位置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%A4%9A%E4%B8%AA%E4%BD%8D%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.5.</span> <span class="toc-text">返回多个位置函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97"><span class="toc-number">1.0.7.</span> <span class="toc-text">交换于排序函数系列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">交换函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BA%A4%E6%8D%A2%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">冒泡排序交换函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E4%BA%8E%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E7%B3%BB%E5%88%97%E4%B8%80%E8%A7%88"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">交换于排序函数系列一览</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%8B%E5%AD%90%E5%92%AF%EF%BC%81"><span class="toc-number">1.0.8.</span> <span class="toc-text">测试一下子咯！</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/19/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/" title="C数据结构 1"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C数据结构 1"/></a><div class="content"><a class="title" href="/2023/03/19/C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/" title="C数据结构 1">C数据结构 1</a><time datetime="2023-03-19T03:02:44.000Z" title="发表于 2023-03-19 11:02:44">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/05/Opencv-in-Visual-Studio-C/" title="Opencv in Visual Studio C++"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Opencv in Visual Studio C++"/></a><div class="content"><a class="title" href="/2023/03/05/Opencv-in-Visual-Studio-C/" title="Opencv in Visual Studio C++">Opencv in Visual Studio C++</a><time datetime="2023-03-05T08:13:00.000Z" title="发表于 2023-03-05 16:13:00">2023-03-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/04/ROS-%E5%9F%BA%E4%BA%8EVScode%E7%9A%84%E8%8A%82%E7%82%B9%E8%B0%83%E8%AF%95/" title="ROS 基于VScode的节点调试"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ROS 基于VScode的节点调试"/></a><div class="content"><a class="title" href="/2023/03/04/ROS-%E5%9F%BA%E4%BA%8EVScode%E7%9A%84%E8%8A%82%E7%82%B9%E8%B0%83%E8%AF%95/" title="ROS 基于VScode的节点调试">ROS 基于VScode的节点调试</a><time datetime="2023-03-04T15:34:04.000Z" title="发表于 2023-03-04 23:34:04">2023-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/02/ROS-%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E7%BC%96%E7%A8%8B%EF%BC%8C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/" title="ROS 节点的创建，编程，编译与运行"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ROS 节点的创建，编程，编译与运行"/></a><div class="content"><a class="title" href="/2023/03/02/ROS-%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%8C%E7%BC%96%E7%A8%8B%EF%BC%8C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C/" title="ROS 节点的创建，编程，编译与运行">ROS 节点的创建，编程，编译与运行</a><time datetime="2023-03-02T15:05:38.000Z" title="发表于 2023-03-02 23:05:38">2023-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/01/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8-1/" title="51单片机入门 1"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="51单片机入门 1"/></a><div class="content"><a class="title" href="/2023/03/01/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8-1/" title="51单片机入门 1">51单片机入门 1</a><time datetime="2023-03-01T12:38:33.000Z" title="发表于 2023-03-01 20:38:33">2023-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>