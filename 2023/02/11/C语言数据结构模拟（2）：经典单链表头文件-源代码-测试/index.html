<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>C语言数据结构模拟（2）：经典单链表头文件-源代码-测试 | Hello World!</title><meta name="author" content="Charlie Chen"><meta name="copyright" content="Charlie Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="API一览1.头文件： define _CRT_SECURE_NO_WARNINGS 1 #define	OPENUPPOSARR 1 #define OPENUPDEFAULTSIZE 1 #define OPENQUICKMALLOC 1 &#x2F;&#x2F;(General Version) #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言数据结构模拟（2）：经典单链表头文件-源代码-测试">
<meta property="og:url" content="http://charliechen114514.github.io/2023/02/11/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/index.html">
<meta property="og:site_name" content="Hello World!">
<meta property="og:description" content="API一览1.头文件： define _CRT_SECURE_NO_WARNINGS 1 #define	OPENUPPOSARR 1 #define OPENUPDEFAULTSIZE 1 #define OPENQUICKMALLOC 1 &#x2F;&#x2F;(General Version) #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://charliechen114514.github.io/img/passagepage.png">
<meta property="article:published_time" content="2023-02-11T08:46:58.000Z">
<meta property="article:modified_time" content="2023-02-15T07:45:39.669Z">
<meta property="article:author" content="Charlie Chen">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="MyTinyLibProject">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://charliechen114514.github.io/img/passagepage.png"><link rel="shortcut icon" href="/img/webicon.png"><link rel="canonical" href="http://charliechen114514.github.io/2023/02/11/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言数据结构模拟（2）：经典单链表头文件-源代码-测试',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-15 15:45:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/webicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/passagepage.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World!"><span class="site-name">Hello World!</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 大爹们</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言数据结构模拟（2）：经典单链表头文件-源代码-测试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-11T08:46:58.000Z" title="发表于 2023-02-11 16:46:58">2023-02-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-15T07:45:39.669Z" title="更新于 2023-02-15 15:45:39">2023-02-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言数据结构模拟（2）：经典单链表头文件-源代码-测试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="API一览"><a href="#API一览" class="headerlink" title="API一览"></a>API一览</h1><p>1.头文件：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">define _CRT_SECURE_NO_WARNINGS 1
#define	OPENUPPOSARR 1
#define OPENUPDEFAULTSIZE 1
#define OPENQUICKMALLOC 1
&#x2F;&#x2F;(General Version)
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

&#x2F;&#x2F;Error Code Meaning
&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0
&#x2F;&#x2F;When Error in mallocing Space the program return 1
&#x2F;&#x2F;when inputing a NULL we returns -1
&#x2F;&#x2F;when inputing a invalid input we returns -2
&#x2F;&#x2F;Locations UnFind we returns -3 
typedef enum _ClassicLinkListFunctionStatues_ &#123;
	ClassicLinkList_NORMAL &#x3D; 0,
	ClassicLinkList_ERROR_IN_MALLOCING_SPACE &#x3D; 1,
	ClassicLinkList_NULL_INPUT &#x3D; -1,
	ClassicLinkList_Invalid_Input &#x3D; -2,
	ClassicLinkList_UnFind &#x3D; -3,
	ClassicLinkList_Invalid_Free &#x3D; -4,
&#125;ClassicLinkListFunctionStatues;

&#x2F;&#x2F;MyBool Defined here!
&#x2F;&#x2F;
typedef enum _bool_ &#123;
	True &#x3D; 1,
	False &#x3D; 0
&#125;Bool;

&#x2F;&#x2F;This is some abstractions using in reminding you some basic informations and errors!
&#x2F;&#x2F;
#define SHOW_ERROR_ClassicLinkList_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)
#define SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)
#define SHOW_ERROR_ClassicLinkList_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)
#define SHOW_ERROR_ClassicLinkList_UnFind printf(&quot;\nPositions unfind!\n&quot;)
#define SHOW_ERROR_ClassicLinkList_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)
#define SHOW_WARNING_ClassicLinkList_SWAPPED_POS printf(&quot;Warning! the front_pos is bigger then the final pos\n Do you agreed swap them?&quot;)
#define SHOW_WARNING_ClassicLinkList_OVERLAP_POS printf(&quot;Considered as your insertion_input is overlapped!\n set pos as the cur_size?&quot;)
&#x2F;&#x2F;this abstractions is used to define the aquisition of whether the program&#39;s decison is acceptable,
&#x2F;&#x2F;X is the message string!
&#x2F;&#x2F;
#define SHOW_WHETHER_ACCCEPTED(X) printf(X)

&#x2F;&#x2F;If wanted flashed a newline you can use it! 
&#x2F;&#x2F;
#define SLASHN printf(&quot;\n&quot;)

&#x2F;&#x2F;used in MergeclassicLinkList
&#x2F;&#x2F;If accepted copy �� Do write ClassicLinkList_ACCEPTED_COPY
#define ClassicLinkList_ACCEPTED_COPY 1
#define ClassicLinkList_NO_COPY	0
#define Unfind_ClassicLinkList -1

&#x2F;&#x2F;Used in whether the targeted elements is found
&#x2F;&#x2F;If is considered found, just use Find , otherwise unfind!
typedef enum _ClassicLinkList_isFind_ &#123;
	Find &#x3D; 1,
	Unfind &#x3D; 0
&#125;ClassicLinkList_isFind;

&#x2F;&#x2F;Used in whether print data in ClassicLinkList better
&#x2F;&#x2F;Use ClassicLinkList_OPEN if you want a better print
typedef enum _BetterPrintSwitch_for_ClassicLinkList_ &#123;
	ClassicLinkList_OPEN &#x3D; 1,
	ClassicLinkList_CLOSE &#x3D; 0
&#125;BetterPrintSwitch_for_ClassicLinkList;

&#x2F;&#x2F;-------------------------------------------Main_Define------------------------------------------

&#x2F;&#x2F;Basic definitions of datanode, it can be considered as a node in a loop
&#x2F;&#x2F;is consisted of dataPiece and the pointer to the next datanode
&#x2F;&#x2F;UNLESS YOU ARE CONCIOUS ABOUT WHAT YOU ARE DOING! DO NOT CHANGE THE DATA DIRECTLY! 
typedef struct _Classic_DataNode_ &#123;
	void* data;
	struct _Classic_DataNode_* p_next_one;
&#125;Classic_DataNode;

&#x2F;&#x2F;basic definations of datalist , it can be considered as the loop or the main body of the data structure
&#x2F;&#x2F;to better operate the data structure , it is consisted of Head pointer that pointed to the first data in the data struct
&#x2F;&#x2F;as well as the current_size of the data structure
&#x2F;&#x2F;UNLESS YOU ARE CONCIOUS ABOUT WHAT YOU ARE DOING! DO NOT CHANGE THE DATA DIRECTLY! 
typedef struct _Classic_DataList_ &#123;
	Classic_DataNode* Head;
	size_t current_size;
&#125;Classic_DataList;

&#x2F;&#x2F;this type of int is used to mark the returnType of the compare functions
typedef unsigned int Is_Used_Compared_Int;
typedef void(*MyPrint)(void*);
typedef void* (*Do_Specific_Change)(void*);
typedef Is_Used_Compared_Int(*CompareFunc)(void*, void*);
typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);

&#x2F;&#x2F;--------------------Default_size_Type---------------------------------------------
#if OPENUPDEFAULTSIZE


#define Dyarr_SIGINT sizeof(int)
#define Dyarr_SIGCHAR sizeof(char)
#define Dyarr_SIGFLOAT sizeof(float)
#define Dyarr_SIGDOUBLE sizeof(double)
#define Dyarr_SIG(dataType) sizeof(dataType)

#define Dyarr_INT_SIZE(X) sizeof(int)*X
#define Dyarr_CHAR_SIZE(X) sizeof(char)*X
#define Dyarr_FLOAT_SIZE(X) sizeof(float)*X
#define Dyarr_DOUBLE_SIZE(X) sizeof(double)*X
#define Dyarr_TYPE_SIZE(dataType,X) sizeof(dataType)*X

#endif

&#x2F;&#x2F;-------------------------------QuickMalloc----------------------------------------------------
#if OPENQUICKMALLOC

#define MALLOC(type) (type*)malloc(sizeof(type))
#define MALLOCN(type,ElemNum) (type*)malloc(sizeof(type)*ElemNum)

#endif
&#x2F;&#x2F;-----------------------Position_Stored_Dynamic_Array_For_Dyarr---------------------------------
&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func
&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:
&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();
&#x2F;&#x2F;Used in returning multitude locations

#if OPENUPPOSARR

&#x2F;&#x2F;Main data structure!
&#x2F;&#x2F;Used in returning multitude locations

typedef struct _Dyarrposarr_ &#123;
	int* posSpace;
	size_t pos_size;
&#125;Position_Stored_Dynamic_ArrayFordyarr;

&#x2F;&#x2F;Want a better Print to beutify your control table? try this one

typedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;
	PSDA_dyarr_OPEN &#x3D; 1,
	PSDA_dyarr_CLOSE &#x3D; 0
&#125;BetterPrintSwitch_for_pos_dyarr;

&#x2F;&#x2F;can use this type when indicating the type

typedef unsigned int BetterPrintfor_PosDyarr;

&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func
&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:
&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();

Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr();

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos
&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE
&#x2F;&#x2F;
ClassicLinkListFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr* posarr,
	BetterPrintfor_PosDyarr									Whether_Better_Print
);

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F; push back a pos into the dynamic array
&#x2F;&#x2F;
ClassicLinkListFunctionStatues Push_back_a_locations_in_PSDA_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr* posarr,
	int														pos_acquired
);

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to return the number of locations
&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE
size_t Get_pos_size_From_PSDA_for_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr* posarr,
	BetterPrintfor_PosDyarr									Whether_Shown_Print
);

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;return a pos that is targeted!
&#x2F;&#x2F;
void* getPosbyPosinPSDA(
	Position_Stored_Dynamic_ArrayFordyarr* getter,
	size_t												pos
);

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
ClassicLinkListFunctionStatues DesTroy_A_PSDA_for_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr* pointer_to_wishedfreeposarr
);

#endif &#x2F;&#x2F; 	OPENUPPOSARR


&#x2F;&#x2F;-----------------------------About ClassicLinkList-----------------------------------------------------

&#x2F;&#x2F;----------------------------Init-functions-------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; there are three basic type of initialization
&#x2F;&#x2F; 
&#x2F;&#x2F; -----------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 1.includeing the default type (init a NULL head and zero cur_size)
&#x2F;&#x2F; func1: Classic_DataList* Init_A_ClassicLinkList()
&#x2F;&#x2F; 
&#x2F;&#x2F; No input , or input VOID
&#x2F;&#x2F; have output : output a clssicLinklist pointer
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 2.includeing the copy one (init the same type of the be-copied one)
&#x2F;&#x2F; func2: Classic_DataList* Init_A_ClassicLinkList_By_CopyAClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : a required_be_copied list .
&#x2F;&#x2F; output: a new list but have is the same as the be_copied list
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 3.includeing to transform the static array to the linklist one
&#x2F;&#x2F; func3: Classic_DataList* UpdateStaticArray2ClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : a waited_transformed static_array , the element size which is in the static array 
&#x2F;&#x2F; output: a new pointer that points to classicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; 
&#x2F;&#x2F;----------------------------Init-functions-------------------------------------------------------------


&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; This function is used to init a default type of classicLinkList
&#x2F;&#x2F; that the head of dataPiece is NULL and the cur_size is zero.
&#x2F;&#x2F; Use push back to init the dataPiece
&#x2F;&#x2F; use in this Way: 
&#x2F;&#x2F; Classic_DataList* List &#x3D; Init_A_ClassicLinkList();
&#x2F;&#x2F;
Classic_DataList* Init_A_ClassicLinkList();

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to copy an already exited linklist
&#x2F;&#x2F; Classic_DataList* List &#x3D; Init_A_ClassicLinkList_By_CopyAClassicLinkList(Classic_DataList* list) 
&#x2F;&#x2F;
Classic_DataList* Init_A_ClassicLinkList_By_CopyAClassicLinkList(
	Classic_DataList* list
);


&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to updata a static array into a ClassicLinkList
&#x2F;&#x2F; Classic_DataList* List &#x3D; UpdateStaticArray2ClassicLinkList(
&#x2F;&#x2F; void* inputArray, 
&#x2F;&#x2F; size_t dataSize, 
&#x2F;&#x2F; size_t dataNum
&#x2F;&#x2F; )
&#x2F;&#x2F;
Classic_DataList* UpdateStaticArray2ClassicLinkList(
	void* inputArray,
	size_t									dataSize,
	size_t									dataNum
);


&#x2F;&#x2F;----------------------------------------Basic_Add_Functions--------------------------------------------
&#x2F;&#x2F; there are four basic input functions:
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 1. push back an element into the classicLinkList
&#x2F;&#x2F; func1 : ClassicLinkListFunctionStatues Push_Back_Into_A_ClassicLinkList
&#x2F;&#x2F;
&#x2F;&#x2F; input : the inserted list ,the data wanted to be inserted and the inserted datasize
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 2. insert back an element into the classicLinkList by offering a valid pos
&#x2F;&#x2F; func2 : ClassicLinkListFunctionStatues Insert_into_AClassicLinkList(Classic_DataList* list, void* data,size_t dataSize,size_t pos)
&#x2F;&#x2F; 
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the inserted list , the data ,the datasize as well as the position you wanted to insert
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 3. push back a bunch of data into the classicLinkList like the first function
&#x2F;&#x2F; func3 :ClassicLinkListFunctionStatues push_Back_BunchDataintoClassicLinkList(Classic_DataList* list,void* inputArray,size_t sigElemSize,size_t arrayNum)
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the inserted list , the data ,the datasize as well as the position you wanted to insert
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 4. insert back a bunch of data into the classicLinkList like the second function
&#x2F;&#x2F; func4: ClassicLinkListFunctionStatues Insert_A_Bunch_of_data_intoClassicLinkList
&#x2F;&#x2F;
&#x2F;&#x2F; input : the inserted list , the static array ,the datasize in the static array as well as the position you wanted to insert
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore! 
&#x2F;&#x2F; 
&#x2F;&#x2F;----------------------------------------Basic_Add_Functions--------------------------------------------

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; push back some data ,like dynamic array , into the final position
&#x2F;&#x2F;Used like this Push_Back_Into_A_ClassicLinkList(appendedClassicLinkList, data ,sizeof(data))
&#x2F;&#x2F;
ClassicLinkListFunctionStatues Push_Back_Into_A_ClassicLinkList(
	Classic_DataList* list,
	void* data,
	size_t														datasize
);

&#x2F;&#x2F; About ClassicDataList
&#x2F;&#x2F; insert back a data into the datalist
&#x2F;&#x2F; used like this: Insert_into_AClassicLinkList(inserted list, input data,dataSize,insertion_pos)
&#x2F;&#x2F; 
ClassicLinkListFunctionStatues Insert_into_AClassicLinkList(
	Classic_DataList* list,
	void* data,
	size_t													dataSize,
	size_t													pos
);


&#x2F;&#x2F; About ClassicDataList
&#x2F;&#x2F; push back a bunch data into the datalist
&#x2F;&#x2F; used like this : push_Back_BunchDataintoClassicLinkList( inserted_list , the static array ,the elementsize ,the element num)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues push_Back_BunchDataintoClassicLinkList(
	Classic_DataList* list,
	void* inputArray,
	size_t													sigElemSize,
	size_t													arrayNum
);

&#x2F;&#x2F; About ClassicDataList
&#x2F;&#x2F; insert back a bunch of data into the datalist
&#x2F;&#x2F; used like this: Insert_into_AClassicLinkList(inserted list, insertion_pos,input array ,Single dataSize, the amount of elements)
&#x2F;&#x2F; 
ClassicLinkListFunctionStatues Insert_A_Bunch_of_data_intoClassicLinkList(
	Classic_DataList* list,
	size_t											pos,
	void* inputArray,
	size_t											sigElemSize,
	size_t											arrayNum
);


&#x2F;&#x2F;------------------------------------------Deletion_Functions-------------------------------------------
&#x2F;&#x2F; there are two basic type of functions in the sections
&#x2F;&#x2F; 1. Erase a targeted element and erase it from the ClassicDataList
&#x2F;&#x2F; fun1:eraseAElementfromDataList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the list and the erase position
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 2.Erase some target elements from the ClassicDataList
&#x2F;&#x2F; fun2:eraseAbunchData
&#x2F;&#x2F; 
&#x2F;&#x2F; input: the list and the start position as well as the last position, that means offer a paired pos
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F;------------------------------------------Deletion_Functions-------------------------------------------


&#x2F;&#x2F; About ClassicDataList
&#x2F;&#x2F; delete a  data in the datalist by offering a position
&#x2F;&#x2F;used like this: eraseAElementfromDataList(list, erasing_pos)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues eraseAElementfromDataList(
	Classic_DataList* list,
	size_t													pos
);

&#x2F;&#x2F; About ClassicDataList
&#x2F;&#x2F; delete a bunch of data in the datalist
&#x2F;&#x2F; used like this eraseAbunchData( list,  front_pos,  final_pos)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues eraseAbunchData_inDataList(
	Classic_DataList* list,
	size_t														front_pos,
	size_t														final_pos
);


&#x2F;&#x2F;----------------------------------------check_if_element_existed_functions-----------------------------
&#x2F;&#x2F; there are four functions in this sections
&#x2F;&#x2F; 
&#x2F;&#x2F; 1.check if the classiclinklist is empty
&#x2F;&#x2F; fun1: isEmptyClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input :the checked list
&#x2F;&#x2F; output: My defined bool(Sadly the org C doesn&#39;t define that)
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 2. check if the target elements is exsited in the datalist
&#x2F;&#x2F; fun2: checkIsLocateinLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the checked list ,the searched data and the Compared functions
&#x2F;&#x2F; output: the locations that we first found it
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 3. return out the first locations that we found of the target elements
&#x2F;&#x2F; func3:checkIsLocateinLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the checked list ,the searched data and the Compared functions
&#x2F;&#x2F; output: My defined bool(Sadly the org C doesn&#39;t define that)
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; Warning : this functions required the PSDA abstractions is opened so you can use Position_Stored_Dynamic_ArrayFordyarr*
&#x2F;&#x2F; to get the position
&#x2F;&#x2F; 
&#x2F;&#x2F; 4. return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr
&#x2F;&#x2F; fun4:returnAbunchLocationsinLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the checked list , the Position_Stored_Dynamic_ArrayFordyarr*(required init first)
&#x2F;&#x2F; output: the Position_Stored_Dynamic_ArrayFordyarr that stored the positions!
&#x2F;&#x2F;
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------



&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; check if the LinkList is empty
&#x2F;&#x2F;
Bool isEmptyClassicLinkList(Classic_DataList* list);

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; check if the target elements is exsited in the datalist
&#x2F;&#x2F;
Bool checkIsLocateinLinkList(
	Classic_DataList* list,
	void* data,
	LocateFunc														user_func
);

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; return out the first locations that we found of the target elements
&#x2F;&#x2F; can use in this way: size_t pos &#x3D; returnOutDatabyposinLinkList( list, data, user_func)
size_t returnOutDatabyposinLinkList(
	Classic_DataList* list,
	void* data,
	LocateFunc												user_func
);

#if OPENUPPOSARR

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr
&#x2F;&#x2F; can use in this way: Position_Stored_Dynamic_ArrayFordyarr* somePos &#x3D; 
&#x2F;&#x2F; returnAbunchLocationsinLinkList( list,  posArr,  data,  user_func)
&#x2F;&#x2F;
Position_Stored_Dynamic_ArrayFordyarr* returnAbunchLocationsinLinkList(
	Classic_DataList* list,
	Position_Stored_Dynamic_ArrayFordyarr* posArr,
	void* data,
	LocateFunc												user_func
);

#endif 

&#x2F;&#x2F;---------------------------------------Do_Something_to_the_datalist_functions--------------------------
&#x2F;&#x2F; there are seven functions in this sections
&#x2F;&#x2F; 
&#x2F;&#x2F; 1. Classic Print functions
&#x2F;&#x2F; func1: Print_All_Data_LinkList
&#x2F;&#x2F; to print all the data in the user_defined linklist
&#x2F;&#x2F; 
&#x2F;&#x2F; input : list and the user print , and the decision whether enjoyed a better print
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 2. Do some change to the specific data
&#x2F;&#x2F; to make some change directly to an element
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the list ,the targeted positions and the way how you want to operate the data itself
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 3. Do some change to all the data in the classiclinklist
&#x2F;&#x2F; to make some change directly to the whole elements
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the list ,the way how you want to operate the data itself
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 4. Do specific change to an interval pos in the classicLickList
&#x2F;&#x2F; to make some change directly to the interval elements
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the list ,the front_pos and the final_pos
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 5. reverse ClassicLinkList
&#x2F;&#x2F; to reverse up the classic LinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the ready_reversed data
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 6. combine two linkList into one
&#x2F;&#x2F; to combine the two classic linklist into one!
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the two linklist
&#x2F;&#x2F; output: the merged linklist Pointer
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 7. sort the elements in the classicLinkList under the user&#39;s constructions
&#x2F;&#x2F; to sort the ClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the classicLinklist
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------
&#x2F;&#x2F;


&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to print the data
&#x2F;&#x2F; use in this way: Print_All_Data_LinkList( list, user_print,  whether_better_print)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues Print_All_Data_LinkList(
	Classic_DataList* list,
	MyPrint												user_print,
	BetterPrintSwitch_for_ClassicLinkList				whether_better_print
);


&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to make some change to the specific data
&#x2F;&#x2F; use in this way:doChangetoSpecificElementinLinkList( list,  pos , user_func)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues doChangetoSpecificElementinLinkList(
	Classic_DataList* list,
	size_t											pos,
	Do_Specific_Change								user_func
);

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to make some change to the interval data
&#x2F;&#x2F; use in this way:doChangetoTargetIntervalDatainLinkList(list , pos1,pos2, user_func)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues doChangetoTargetIntervalDatainLinkList(
	Classic_DataList* list,
	size_t													front_pos,
	size_t													final_pos,
	Do_Specific_Change										user_func
);

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to make some change to the whole elements in the data
&#x2F;&#x2F; use in this way:doChangetoAllDatainLinkList( list,  user_func)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues doChangetoAllDatainLinkList(
	Classic_DataList* list,
	Do_Specific_Change									user_func
);


&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to reverse up the classiclinklist
&#x2F;&#x2F; use in this way:ReverseLinkList(list)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues ReverseLinkList(Classic_DataList* list);

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to merge two linklist into the one
&#x2F;&#x2F; use in this way:mergeLinkList(list_be_added, list_adder, whether_copied)
&#x2F;&#x2F;
Classic_DataList* mergeLinkList(
	Classic_DataList* list_be_added,
	Classic_DataList* list_adder,
	size_t												whether_copied
);

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; sort the classicLinklist in the bobblesort
&#x2F;&#x2F; use in this way:sortClassicLinkListinBubbleSort(Classic_DataList* list, CompareFunc user_func) 
&#x2F;&#x2F;
ClassicLinkListFunctionStatues sortClassicLinkListinBubbleSort(
	Classic_DataList* list,
	CompareFunc																user_func
);

&#x2F;&#x2F;----------------------------------------------------Basic_Erase----------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 1.Erase A LinkList
&#x2F;&#x2F; used in just clear a linklist
&#x2F;&#x2F; func1: clearAClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : just a classiclinklist
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------

&#x2F;&#x2F;About ClassicLinkList
&#x2F;&#x2F; Erase a classicLinkList
&#x2F;&#x2F; Use in this way clearAClassicLinkList( list)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues clearAClassicLinkList(Classic_DataList* list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>源文件：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1
#define	OPENUPPOSARR 1
#define OPENUPDEFAULTSIZE 1
#define OPENQUICKMALLOC 1
&#x2F;&#x2F;(General Version)
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

&#x2F;&#x2F;Error Code Meaning
&#x2F;&#x2F;Program Normally run till the end return NORMAL as 0
&#x2F;&#x2F;When Error in mallocing Space the program return 1
&#x2F;&#x2F;when inputing a NULL we returns -1
&#x2F;&#x2F;when inputing a invalid input we returns -2
&#x2F;&#x2F;Locations UnFind we returns -3 
typedef enum _ClassicLinkListFunctionStatues_ &#123;
	ClassicLinkList_NORMAL&#x3D;0,
	ClassicLinkList_ERROR_IN_MALLOCING_SPACE &#x3D; 1,
	ClassicLinkList_NULL_INPUT &#x3D; -1,
	ClassicLinkList_Invalid_Input&#x3D;-2,
	ClassicLinkList_UnFind&#x3D;-3,
	ClassicLinkList_Invalid_Free&#x3D;-4,
&#125;ClassicLinkListFunctionStatues;

&#x2F;&#x2F;MyBool Defined here!
&#x2F;&#x2F;
typedef enum _bool_ &#123;
	True &#x3D; 1,
	False &#x3D; 0
&#125;Bool;

&#x2F;&#x2F;This is some abstractions using in reminding you some basic informations and errors!
&#x2F;&#x2F;
#define SHOW_ERROR_ClassicLinkList_NULL_INPUT printf(&quot;\nSorry! Your input NULL!\n&quot;)
#define SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE printf(&quot;\nSorry!Failed to malloc space for your data\n&quot;)
#define SHOW_ERROR_ClassicLinkList_Invalid_Input printf(&quot;\nYour input invalid, reject to run functions\n&quot;)
#define SHOW_ERROR_ClassicLinkList_UnFind printf(&quot;\nPositions unfind!\n&quot;)
#define SHOW_ERROR_ClassicLinkList_Invalid_Free printf(&quot;\nFree the invalid space,reject to run the functions\n&quot;)
#define SHOW_WARNING_ClassicLinkList_SWAPPED_POS printf(&quot;Warning! the front_pos is bigger then the final pos\n Do you agreed swap them?&quot;)
#define SHOW_WARNING_ClassicLinkList_OVERLAP_POS printf(&quot;Considered as your insertion_input is overlapped!\n set pos as the cur_size?&quot;)
&#x2F;&#x2F;this abstractions is used to define the aquisition of whether the program&#39;s decison is acceptable,
&#x2F;&#x2F;X is the message string!
&#x2F;&#x2F;
#define SHOW_WHETHER_ACCCEPTED(X) printf(X)

&#x2F;&#x2F;If wanted flashed a newline you can use it! 
&#x2F;&#x2F;
#define SLASHN printf(&quot;\n&quot;)

&#x2F;&#x2F;used in MergeclassicLinkList
&#x2F;&#x2F;If accepted copy ！ Do write ClassicLinkList_ACCEPTED_COPY
#define ClassicLinkList_ACCEPTED_COPY 1
#define ClassicLinkList_NO_COPY	0
#define Unfind_ClassicLinkList -1

&#x2F;&#x2F;Used in whether the targeted elements is found
&#x2F;&#x2F;If is considered found, just use Find , otherwise unfind!
typedef enum _ClassicLinkList_isFind_ &#123;
	Find &#x3D; 1,
	Unfind &#x3D; 0
&#125;ClassicLinkList_isFind;

&#x2F;&#x2F;Used in whether print data in ClassicLinkList better
&#x2F;&#x2F;Use ClassicLinkList_OPEN if you want a better print
typedef enum _BetterPrintSwitch_for_ClassicLinkList_ &#123;
	ClassicLinkList_OPEN &#x3D; 1,
	ClassicLinkList_CLOSE &#x3D; 0
&#125;BetterPrintSwitch_for_ClassicLinkList;

&#x2F;&#x2F;-------------------------------------------Main_Define------------------------------------------

&#x2F;&#x2F;Basic definitions of datanode, it can be considered as a node in a loop
&#x2F;&#x2F;is consisted of dataPiece and the pointer to the next datanode
&#x2F;&#x2F;UNLESS YOU ARE CONCIOUS ABOUT WHAT YOU ARE DOING! DO NOT CHANGE THE DATA DIRECTLY! 
typedef struct _Classic_DataNode_ &#123;
	void* data;
	struct _Classic_DataNode_* p_next_one;
&#125;Classic_DataNode;

&#x2F;&#x2F;basic definations of datalist , it can be considered as the loop or the main body of the data structure
&#x2F;&#x2F;to better operate the data structure , it is consisted of Head pointer that pointed to the first data in the data struct
&#x2F;&#x2F;as well as the current_size of the data structure
&#x2F;&#x2F;UNLESS YOU ARE CONCIOUS ABOUT WHAT YOU ARE DOING! DO NOT CHANGE THE DATA DIRECTLY! 
typedef struct _Classic_DataList_ &#123;
	Classic_DataNode* Head;
	size_t current_size;
&#125;Classic_DataList;

&#x2F;&#x2F;this type of int is used to mark the returnType of the compare functions
typedef unsigned int Is_Used_Compared_Int;
typedef void(*MyPrint)(void*);
typedef void* (*Do_Specific_Change)(void*);
typedef Is_Used_Compared_Int(*CompareFunc)(void*, void*);
typedef Is_Used_Compared_Int(*LocateFunc)(void*, void*);

&#x2F;&#x2F;--------------------Default_size_Type---------------------------------------------
#if OPENUPDEFAULTSIZE


#define Dyarr_SIGINT sizeof(int)
#define Dyarr_SIGCHAR sizeof(char)
#define Dyarr_SIGFLOAT sizeof(float)
#define Dyarr_SIGDOUBLE sizeof(double)
#define Dyarr_SIG(dataType) sizeof(dataType)

#define Dyarr_INT_SIZE(X) sizeof(int)*X
#define Dyarr_CHAR_SIZE(X) sizeof(char)*X
#define Dyarr_FLOAT_SIZE(X) sizeof(float)*X
#define Dyarr_DOUBLE_SIZE(X) sizeof(double)*X
#define Dyarr_TYPE_SIZE(dataType,X) sizeof(dataType)*X

#endif

&#x2F;&#x2F;-------------------------------QuickMalloc----------------------------------------------------
#if OPENQUICKMALLOC

#define MALLOC(type) (type*)malloc(sizeof(type))
#define MALLOCN(type,ElemNum) (type*)malloc(sizeof(type)*ElemNum)

#endif
&#x2F;&#x2F;-----------------------Position_Stored_Dynamic_Array_For_Dyarr---------------------------------
&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func
&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:
&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();
&#x2F;&#x2F;Used in returning multitude locations

#if OPENUPPOSARR

&#x2F;&#x2F;Main data structure!
&#x2F;&#x2F;Used in returning multitude locations

typedef struct _Dyarrposarr_ &#123;
	int* posSpace;
	size_t pos_size;
&#125;Position_Stored_Dynamic_ArrayFordyarr;

&#x2F;&#x2F;Want a better Print to beutify your control table? try this one

typedef enum _BetterPrintSwitch_for_pos_dyarr_ &#123;
	PSDA_dyarr_OPEN &#x3D; 1,
	PSDA_dyarr_CLOSE &#x3D; 0
&#125;BetterPrintSwitch_for_pos_dyarr;

&#x2F;&#x2F;can use this type when indicating the type

typedef unsigned int BetterPrintfor_PosDyarr;

&#x2F;&#x2F;About Position_Stored_Dynamic_Array_Func
&#x2F;&#x2F;Create A Position_Stored_Dynamic_Array! Can init it in this way:
&#x2F;&#x2F;&gt;&gt;Position_Stored_Dynamic_ArrayFordyarr* Name&#x3D;Init_A_Postion_Stored_Dynamic_ArrayFordyarr();

Position_Stored_Dynamic_ArrayFordyarr* Init_A_Postion_Stored_Dynamic_ArrayFordyarr()
&#123;
	Position_Stored_Dynamic_ArrayFordyarr* pro_usable_space &#x3D; (Position_Stored_Dynamic_ArrayFordyarr*)malloc(sizeof(Position_Stored_Dynamic_ArrayFordyarr));
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	pro_usable_space-&gt;posSpace &#x3D; NULL;
	pro_usable_space-&gt;pos_size &#x3D; 0;
	return pro_usable_space;
&#125;

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to output a series of locations that is stored in the pos
&#x2F;&#x2F;&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE

ClassicLinkListFunctionStatues Show_All_Locations_In_PSDAfor_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*					posarr,
	BetterPrintfor_PosDyarr									Whether_Better_Print
)
&#123;
	if (!posarr)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)
		printf(&quot;\nPositions are shown! :\n&quot;);
	for (int i &#x3D; 0; i &lt; posarr-&gt;pos_size; i++)
		printf(&quot;%u &quot;, posarr-&gt;posSpace[i]);
	if (Whether_Better_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)
		printf(&quot;\nFinish Printing!\n&quot;);
	return ClassicLinkList_NORMAL;
&#125;

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
ClassicLinkListFunctionStatues Push_back_a_locations_in_PSDA_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*					posarr, 
	int														pos_acquired
)
&#123;
	int* pro_usable_space &#x3D; (int*)realloc(posarr-&gt;posSpace, sizeof(int) * (posarr-&gt;pos_size + 1));
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
		exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
	&#125;
	posarr-&gt;posSpace &#x3D; pro_usable_space;
	posarr-&gt;posSpace[posarr-&gt;pos_size] &#x3D; pos_acquired;
	posarr-&gt;pos_size++;
	return ClassicLinkList_NORMAL;
&#125;
&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;this function is aimed to return the number of locations
&#x2F;&#x2F;Use PSDA_dyarr_OPEN to have a better shown ,else use PSDA_dyarr_CLOSE
size_t Get_pos_size_From_PSDA_for_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*					posarr, 
	BetterPrintfor_PosDyarr									Whether_Shown_Print
)
&#123;
	if (!posarr)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (Whether_Shown_Print &#x3D;&#x3D; PSDA_dyarr_OPEN)
		printf(&quot;\nCurrent targeted data&#39;s total num is:%u!\n&quot;, posarr-&gt;pos_size);
	return posarr-&gt;pos_size;
&#125;

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
&#x2F;&#x2F;return a pos that is targeted!
&#x2F;&#x2F;
void* getPosbyPosinPSDA(
	Position_Stored_Dynamic_ArrayFordyarr* getter,
	size_t												pos
)
&#123;
	if (!getter) 
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (pos &gt; getter-&gt;pos_size)
	&#123;
		SHOW_ERROR_ClassicLinkList_Invalid_Input;
		exit(ClassicLinkList_Invalid_Input);
	&#125;
	for (int i &#x3D; 0; i &lt; pos; i++)
		return (char*)getter-&gt;posSpace + i * sizeof(size_t);
&#125;

&#x2F;&#x2F;About Positions_Stored_Dynamic_Array
ClassicLinkListFunctionStatues DesTroy_A_PSDA_for_dyarr(
	Position_Stored_Dynamic_ArrayFordyarr*					pointer_to_wishedfreeposarr
)
&#123;
	if (!pointer_to_wishedfreeposarr)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	free(pointer_to_wishedfreeposarr-&gt;posSpace);
	free(pointer_to_wishedfreeposarr);
	pointer_to_wishedfreeposarr &#x3D; NULL;
	return ClassicLinkList_NORMAL;
&#125;
#endif &#x2F;&#x2F; 	OPENUPPOSARR



&#x2F;&#x2F;-----------------------------About ClassicLinkList-----------------------------------------------------------

&#x2F;&#x2F;----------------------------Init-functions--------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; there are three basic type of initialization
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 1.includeing the default type (init a NULL head and zero cur_size)
&#x2F;&#x2F; func1: Classic_DataList* Init_A_ClassicLinkList()
&#x2F;&#x2F; 
&#x2F;&#x2F; No input , or input VOID
&#x2F;&#x2F; have output : output a clssicLinklist pointer
&#x2F;&#x2F; -------------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 2.includeing the copy one (init the same type of the be-copied one)
&#x2F;&#x2F; func2: Classic_DataList* Init_A_ClassicLinkList_By_CopyAClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : a required_be_copied list .
&#x2F;&#x2F; output: a new list but have is the same as the be_copied list
&#x2F;&#x2F; -------------------------------------------------------------------------------------------------------------
&#x2F;&#x2F; 3.includeing to transform the static array to the linklist one
&#x2F;&#x2F; func3: Classic_DataList* UpdateStaticArray2ClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : a waited_transformed static_array , the element size which is in the static array 
&#x2F;&#x2F; output: a new pointer that points to classicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; 
&#x2F;&#x2F;----------------------------Init-functions--------------------------------------------------------------------


&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; This function is used to init a default type of classicLinkList
&#x2F;&#x2F; that the head of dataPiece is NULL and the cur_size is zero.
&#x2F;&#x2F; Use push back to init the dataPiece
&#x2F;&#x2F; use in this Way: 
&#x2F;&#x2F; Classic_DataList* List &#x3D; Init_A_ClassicLinkList();


Classic_DataList* Init_A_ClassicLinkList()
&#123;
	&#x2F;&#x2F; create empty space
	Classic_DataList* pro_usable_space &#x3D; (Classic_DataList*)malloc(sizeof(Classic_DataList));

	&#x2F;&#x2F; Check whether init succeeded
	if (!pro_usable_space)
	&#123;
		SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
		exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
	&#125;

	&#x2F;&#x2F; Default set 
	pro_usable_space-&gt;Head &#x3D; NULL;
	pro_usable_space-&gt;current_size &#x3D; 0;

	&#x2F;&#x2F; return out the Structure
	return pro_usable_space;
&#125;

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to copy an already exited linklist
&#x2F;&#x2F; Classic_DataList* List &#x3D; Init_A_ClassicLinkList_By_CopyAClassicLinkList(Classic_DataList* list) 
&#x2F;&#x2F;
Classic_DataList* Init_A_ClassicLinkList_By_CopyAClassicLinkList(
	Classic_DataList*										list
) 
&#123;
	&#x2F;&#x2F;check whether the input is legal
	if (list &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	&#x2F;&#x2F;check whether there is neccessity to copy 
	if (list-&gt;current_size &#x3D;&#x3D; 0)
	&#123;
		printf(&quot;No need to copy! it hasn&#39;t been initialize yet!&quot;);
		&#x2F;&#x2F;Used to return NULL , but it is dangerous that two pointers points one things 
		return NULL;
	&#125;

	&#x2F;&#x2F;New a List and new a head and new the data of the head
	Classic_DataList* p_NewList &#x3D; (Classic_DataList*)malloc(sizeof(Classic_DataList));
	Classic_DataNode* newHead &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));
	void* newdata &#x3D; malloc(sizeof(list-&gt;Head-&gt;data));

	&#x2F;&#x2F;check whether we init the node successfully
	if (newHead &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
		exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
	&#125;

	if (newdata &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
		exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
	&#125;

	&#x2F;&#x2F;Do copy the data to the new head and finished initialization
	memcpy(newdata, list-&gt;Head-&gt;data, sizeof(list-&gt;Head-&gt;data));
	newHead-&gt;data &#x3D; newdata;
	newHead-&gt;p_next_one &#x3D; NULL;
	p_NewList-&gt;Head &#x3D; newHead;
	p_NewList-&gt;current_size &#x3D; 1;

	&#x2F;&#x2F;Start copy other nodes
	Classic_DataNode* p_Currency &#x3D; list-&gt;Head-&gt;p_next_one;
	Classic_DataNode* pCurCopy &#x3D; p_NewList-&gt;Head;
	for (int i &#x3D; 0; i &lt; list-&gt;current_size-1; i++) 
	&#123;
		&#x2F;&#x2F;Copy the I-th node
		Classic_DataNode* newDataNode &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));

		&#x2F;&#x2F;check if the initialization is illegal
		if(newDataNode&#x3D;&#x3D;NULL)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;

		&#x2F;&#x2F; prepare to copy data from the current node
		void* newdata &#x3D; malloc(sizeof(p_Currency-&gt;data));

		&#x2F;&#x2F; check if the initialization is illegal
		if (newdata &#x3D;&#x3D; NULL)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;

		&#x2F;&#x2F;copy the detailed node
		memcpy(newdata, p_Currency-&gt;data, sizeof(p_Currency-&gt;data));
		newDataNode-&gt;data &#x3D; newdata;
		newDataNode-&gt;p_next_one &#x3D; NULL;

		&#x2F;&#x2F;Moving the pointer and prepared next copy
		pCurCopy-&gt;p_next_one &#x3D; newDataNode;
		pCurCopy &#x3D; pCurCopy-&gt;p_next_one;
		p_Currency &#x3D; p_Currency-&gt;p_next_one;
	&#125;

	&#x2F;&#x2F;Data copy finished , init the cur_size
	p_NewList-&gt;current_size &#x3D; list-&gt;current_size;
	return p_NewList;
&#125;

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to updata a static array into a ClassicLinkList
&#x2F;&#x2F; Classic_DataList* List &#x3D; UpdateStaticArray2ClassicLinkList(
&#x2F;&#x2F; void* inputArray, 
&#x2F;&#x2F; size_t dataSize, 
&#x2F;&#x2F; size_t dataNum
&#x2F;&#x2F; )
&#x2F;&#x2F;
Classic_DataList* UpdateStaticArray2ClassicLinkList(
	void*									inputArray, 
	size_t									dataSize, 
	size_t									dataNum
)
&#123;
	if (inputArray &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	Classic_DataList* pro_usable_space &#x3D; (Classic_DataList*)malloc(sizeof(Classic_DataList));
	Classic_DataNode* FirstHeaddata &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode*));
	void* datapiece &#x3D; malloc(dataSize);
	if (
		pro_usable_space &#x3D;&#x3D; NULL
		&amp;&amp;
		FirstHeaddata &#x3D;&#x3D; NULL
		&amp;&amp;
		datapiece &#x3D;&#x3D; NULL
		)
	&#123;
		SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
		exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
	&#125;
	memcpy(datapiece, inputArray, dataSize);
	FirstHeaddata-&gt;data &#x3D; datapiece;
	FirstHeaddata-&gt;p_next_one &#x3D; NULL;
	pro_usable_space-&gt;current_size &#x3D; 1;
	pro_usable_space-&gt;Head &#x3D; FirstHeaddata;
	for (int i &#x3D; 1; i &lt; dataNum; i++)
	&#123;
		Classic_DataNode* p_Currency &#x3D; pro_usable_space-&gt;Head;
		while (p_Currency-&gt;p_next_one)
		&#123;
			p_Currency &#x3D; p_Currency-&gt;p_next_one;
		&#125;
		void* datastored &#x3D; malloc(dataSize);
		if (!datastored)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;
		memcpy(datastored, (char*)inputArray + i * dataSize, dataSize);
		Classic_DataNode* datanode &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));
		if (!datanode)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;
		datanode-&gt;data &#x3D; datastored;
		datanode-&gt;p_next_one &#x3D; NULL;
		p_Currency-&gt;p_next_one &#x3D; datanode;
		pro_usable_space-&gt;current_size++;
	&#125;
	return pro_usable_space;
&#125;

&#x2F;&#x2F;----------------------------------------Basic_Add_Functions------------------------
&#x2F;&#x2F; there are four basic input functions:
&#x2F;&#x2F; 
&#x2F;&#x2F; ----------------------------------------------------------------------------------
&#x2F;&#x2F; 1. push back an element into the classicLinkList
&#x2F;&#x2F; func1 : ClassicLinkListFunctionStatues Push_Back_Into_A_ClassicLinkList
&#x2F;&#x2F;
&#x2F;&#x2F; input : the inserted list ,the data wanted to be inserted and the inserted datasize
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ----------------------------------------------------------------------------------
&#x2F;&#x2F; 2. insert back an element into the classicLinkList by offering a valid pos
&#x2F;&#x2F; func2 : ClassicLinkListFunctionStatues Insert_into_AClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the inserted list , the data ,the datasize as well as the position you wanted to insert
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ----------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 3. push back a bunch of data into the classicLinkList like the first function
&#x2F;&#x2F; func3 :ClassicLinkListFunctionStatues push_Back_BunchDataintoClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the inserted list , the data ,the datasize as well as the position you wanted to insert
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ----------------------------------------------------------------------------------
&#x2F;&#x2F; 4. insert back a bunch of data into the classicLinkList like the second function
&#x2F;&#x2F; func4: ClassicLinkListFunctionStatues Insert_A_Bunch_of_data_intoClassicLinkList
&#x2F;&#x2F;
&#x2F;&#x2F; input : the inserted list , the static array ,the datasize in the static array as well as the position you wanted to insert
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore! 
&#x2F;&#x2F; 
&#x2F;&#x2F;----------------------------------------Basic_Add_Functions-------------------------

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; push back some data ,like dynamic array , into the final position
&#x2F;&#x2F;Used like this Push_Back_Into_A_ClassicLinkList(appendedClassicLinkList, data ,sizeof(data))
&#x2F;&#x2F;
ClassicLinkListFunctionStatues Push_Back_Into_A_ClassicLinkList(
	Classic_DataList*											list, 
	void*														data,
	size_t														datasize
)
&#123;
	if (!list)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (!data)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	Classic_DataNode* p_Currency &#x3D; list-&gt;Head;
	if(list-&gt;Head !&#x3D; NULL)
	&#123;
		while (p_Currency-&gt;p_next_one)
		&#123;
			p_Currency &#x3D; p_Currency-&gt;p_next_one;
		&#125;
		void* datastored &#x3D; malloc(datasize);
		if (!datastored)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;
		memcpy(datastored, data, datasize);
		Classic_DataNode* datanode &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));
		if (!datanode)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;
		datanode-&gt;data &#x3D; datastored;
		datanode-&gt;p_next_one &#x3D; NULL;
		p_Currency-&gt;p_next_one &#x3D; datanode;
		list-&gt;current_size++;
	&#125;
	else
	&#123;
		void* datastored &#x3D; malloc(datasize);
		if (!datastored)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;
		memcpy(datastored, data, datasize);
		Classic_DataNode* datanode &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));
		if (!datanode)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;
		datanode-&gt;data &#x3D; datastored;
		datanode-&gt;p_next_one &#x3D; NULL;
		list-&gt;Head &#x3D; datanode;
		list-&gt;current_size++;
	&#125;
	return ClassicLinkList_NORMAL;
&#125;

&#x2F;&#x2F; About ClassicDataList
&#x2F;&#x2F; insert back a data into the datalist
&#x2F;&#x2F; used like this: Insert_into_AClassicLinkList(inserted list, input data,dataSize,insertion_pos)
&#x2F;&#x2F; 
ClassicLinkListFunctionStatues Insert_into_AClassicLinkList(
	Classic_DataList*										list, 
	void*													data,
	size_t													dataSize,
	size_t													pos
)
&#123;
	
	if (list &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (data &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;list-&gt;current_size)
	&#123;
		SHOW_ERROR_ClassicLinkList_Invalid_Input;
		exit(ClassicLinkList_Invalid_Input);
	&#125;
	if (pos &#x3D;&#x3D; 0)
	&#123;
		Classic_DataNode* stored &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));
		if (stored &#x3D;&#x3D; NULL)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;
		void* dataPiece &#x3D; malloc(dataSize);
		memcpy(dataPiece, data, dataSize);
		stored-&gt;data &#x3D; dataPiece;
		stored-&gt;p_next_one &#x3D; list-&gt;Head;
		list-&gt;Head &#x3D; stored;
		list-&gt;current_size++;
		return ClassicLinkList_NORMAL;
	&#125;
	Classic_DataNode* pCurrency &#x3D; list-&gt;Head;
	Classic_DataNode* stored &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));
	if (stored &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
		exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
	&#125;
	void* dataPiece &#x3D; malloc(dataSize);
	memcpy(dataPiece, data, dataSize);
	stored-&gt;data &#x3D; dataPiece;
	for (int i &#x3D; 0; i &lt; pos; i++)
	&#123;
		pCurrency &#x3D; pCurrency-&gt;p_next_one;
	&#125;
	stored-&gt;p_next_one &#x3D; pCurrency-&gt;p_next_one;
	pCurrency-&gt;p_next_one &#x3D; stored;
	list-&gt;current_size++;
	return ClassicLinkList_NORMAL;
&#125;

&#x2F;&#x2F; About ClassicDataList
&#x2F;&#x2F; push back a bunch data into the datalist
&#x2F;&#x2F; used like this : push_Back_BunchDataintoClassicLinkList( inserted_list , the static array ,the elementsize ,the element num)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues push_Back_BunchDataintoClassicLinkList(
	Classic_DataList*										list,
	void*													inputArray, 
	size_t													sigElemSize, 
	size_t													arrayNum
)
&#123;
	if (list &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;

	if(inputArray&#x3D;&#x3D;NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;


	&#x2F;&#x2F;Equally as to updata a Static Array into a ClassicLinkList
	&#x2F;&#x2F;Once just use  UpdateStaticArray2ClassicLinkList(),but i&#39;m afraid of unable to use this functions
	&#x2F;&#x2F;as it is said: &quot;DO NOT motivate another functions , try to finish all work if neccessary&quot;
	if (list-&gt;Head &#x3D;&#x3D; NULL)
	&#123;
		&#x2F;&#x2F;New a List and new a head and new the data of the head
		Classic_DataList* p_NewList &#x3D; (Classic_DataList*)malloc(sizeof(Classic_DataList));
		Classic_DataNode* newHead &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));
		void* newdata &#x3D; malloc(sizeof(list-&gt;Head-&gt;data));

		&#x2F;&#x2F;check whether we init the node successfully
		if (newHead &#x3D;&#x3D; NULL)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;

		if (newdata &#x3D;&#x3D; NULL)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;

		&#x2F;&#x2F;Do copy the data to the new head and finished initialization
		memcpy(newdata, list-&gt;Head-&gt;data, sizeof(list-&gt;Head-&gt;data));
		newHead-&gt;data &#x3D; newdata;
		newHead-&gt;p_next_one &#x3D; NULL;
		p_NewList-&gt;Head &#x3D; newHead;
		p_NewList-&gt;current_size &#x3D; 1;

		&#x2F;&#x2F;Start copy other nodes
		Classic_DataNode* p_Currency &#x3D; list-&gt;Head-&gt;p_next_one;
		Classic_DataNode* pCurCopy &#x3D; p_NewList-&gt;Head;
		for (int i &#x3D; 0; i &lt; list-&gt;current_size - 1; i++)
		&#123;
			&#x2F;&#x2F;Copy the I-th node
			Classic_DataNode* newDataNode &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));

			&#x2F;&#x2F;check if the initialization is illegal
			if (newDataNode &#x3D;&#x3D; NULL)
			&#123;
				SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
				exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
			&#125;

			&#x2F;&#x2F; prepare to copy data from the current node
			void* newdata &#x3D; malloc(sizeof(p_Currency-&gt;data));

			&#x2F;&#x2F; check if the initialization is illegal
			if (newdata &#x3D;&#x3D; NULL)
			&#123;
				SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
				exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
			&#125;

			&#x2F;&#x2F;copy the detailed node
			memcpy(newdata, p_Currency-&gt;data, sizeof(p_Currency-&gt;data));
			newDataNode-&gt;data &#x3D; newdata;
			newDataNode-&gt;p_next_one &#x3D; NULL;

			&#x2F;&#x2F;Moving the pointer and prepared next copy
			pCurCopy-&gt;p_next_one &#x3D; newDataNode;
			pCurCopy &#x3D; pCurCopy-&gt;p_next_one;
			p_Currency &#x3D; p_Currency-&gt;p_next_one;
		&#125;

		&#x2F;&#x2F;Data copy finished , init the cur_size
		p_NewList-&gt;current_size &#x3D; list-&gt;current_size;
		list &#x3D; p_NewList;
		return ClassicLinkList_NORMAL;
	&#125;

	&#x2F;&#x2F;for this section , that means the head isn&#39;t NULL , just copy as usual:
	Classic_DataNode* pCur &#x3D; list-&gt;Head;
	for (int i &#x3D; 0; i &lt; list-&gt;current_size-1; i++) 
	&#123;
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;
	
	for (int i &#x3D; 0; i &lt; arrayNum; i++) 
	&#123;
		Classic_DataNode* pCopyCur &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));
		void* copyData &#x3D; malloc(sizeof(sigElemSize));
		if (pCopyCur &#x3D;&#x3D; NULL &amp;&amp; copyData &#x3D;&#x3D; NULL) 
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;

		memcpy(copyData, (char*)inputArray + i * sigElemSize, sigElemSize);
		pCopyCur-&gt;data &#x3D; copyData;
		pCopyCur-&gt;p_next_one &#x3D; NULL;
		pCur-&gt;p_next_one &#x3D; pCopyCur;
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;

	list-&gt;current_size +&#x3D; arrayNum;
	return ClassicLinkList_NORMAL;
&#125;

&#x2F;&#x2F; About ClassicDataList
&#x2F;&#x2F; insert back a bunch of data into the datalist
&#x2F;&#x2F; used like this: Insert_into_AClassicLinkList(inserted list, insertion_pos,input array ,Single dataSize, the amount of elements)
&#x2F;&#x2F; 
ClassicLinkListFunctionStatues Insert_A_Bunch_of_data_intoClassicLinkList(
	Classic_DataList*								list,
	size_t											pos,
	void*											inputArray,
	size_t											sigElemSize,
	size_t											arrayNum
) 
&#123;
	if (list &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (inputArray &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;

	if (pos &gt; list-&gt;current_size)
	&#123;
		SHOW_WARNING_ClassicLinkList_OVERLAP_POS;
		SHOW_WHETHER_ACCCEPTED(&quot;y&#x2F;n: y for yes , n for n&quot;);
		int choice;
		scanf(&quot;%c&quot;, &amp;choice);
		if (choice &#x3D;&#x3D; &#39;y&#39;)
		&#123;
			pos &#x3D; list-&gt;current_size;
		&#125;
		else
		&#123;
			SHOW_ERROR_ClassicLinkList_Invalid_Input;
			exit(ClassicLinkList_Invalid_Input);
		&#125;
	&#125;

	Classic_DataNode* pCurNow &#x3D; NULL;
	Classic_DataNode* pStart &#x3D; NULL;

	for(int i &#x3D; 0 ; i &lt; arrayNum ; i++)
	&#123;

		Classic_DataNode* pCopyCur &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));
		void* copydata &#x3D; malloc(sigElemSize);

		if (pCopyCur &#x3D;&#x3D; NULL &amp;&amp; copydata &#x3D;&#x3D; NULL)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;

		memcpy(copydata, (char*)inputArray + i * sigElemSize, sigElemSize);
		pCopyCur-&gt;data &#x3D; copydata;
		pCopyCur-&gt;p_next_one &#x3D; NULL;

		if (i &#x3D;&#x3D; 0)
		&#123;
			pCurNow &#x3D; pCopyCur;
			pStart &#x3D; pCopyCur;
			continue;
		&#125;
		pCurNow-&gt;p_next_one &#x3D; pCopyCur;
		pCurNow &#x3D; pCurNow-&gt;p_next_one;
	&#125;
	
	if (pos &#x3D;&#x3D; 0)
	&#123;
		pCurNow-&gt;p_next_one &#x3D; list-&gt;Head;
		list-&gt;Head &#x3D; pStart;
		list-&gt;current_size +&#x3D; arrayNum;
		return ClassicLinkList_NORMAL;
	&#125;

	Classic_DataNode* pCur &#x3D; list-&gt;Head;
	for (int i &#x3D; 0; i &lt; pos; i++) 
	&#123;
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;

	pCurNow-&gt;p_next_one &#x3D; pCur-&gt;p_next_one;
	pCur-&gt;p_next_one &#x3D; pStart;
	list-&gt;current_size +&#x3D; arrayNum;
	return ClassicLinkList_NORMAL;
&#125;

&#x2F;&#x2F;------------------------------------------Deletion_Functions-------------
&#x2F;&#x2F; there are two basic type of functions in the sections
&#x2F;&#x2F; 1. Erase a targeted element and erase it from the ClassicDataList
&#x2F;&#x2F; fun1:eraseAElementfromDataList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the list and the erase position
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; --------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 2.Erase some target elements from the ClassicDataList
&#x2F;&#x2F; fun2:eraseAbunchData
&#x2F;&#x2F; 
&#x2F;&#x2F; input: the list and the start position as well as the last position, that means offer a paired pos
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F;------------------------------------------Deletion_Functions----------------


&#x2F;&#x2F; About ClassicDataList
&#x2F;&#x2F; delete a  data in the datalist by offering a position
&#x2F;&#x2F;used like this: eraseAElementfromDataList(list, erasing_pos)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues eraseAElementfromDataList(
	Classic_DataList*										list,
	size_t													pos
) 
&#123;
	if (list &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;list-&gt;current_size)
	&#123;
		SHOW_ERROR_ClassicLinkList_Invalid_Input;
		exit(ClassicLinkList_Invalid_Input);
	&#125;
	if (pos &#x3D;&#x3D; 0)
	&#123;
		Classic_DataNode* pNewHead &#x3D; list-&gt;Head-&gt;p_next_one;
		Classic_DataNode* pDel &#x3D; list-&gt;Head;
		list-&gt;Head &#x3D; pNewHead;
		free(pDel-&gt;data);
		list-&gt;current_size--;
		return ClassicLinkList_NORMAL;
	&#125;
	Classic_DataNode* pCur &#x3D; list-&gt;Head;
	for (int i &#x3D; 0; i &lt; pos-1; i++)
	&#123;
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;
	Classic_DataNode* pDel &#x3D; pCur-&gt;p_next_one;
	pCur-&gt;p_next_one &#x3D; pDel-&gt;p_next_one;
	free(pDel-&gt;data);
	free(pDel);
	list-&gt;current_size--;
	return ClassicLinkList_NORMAL;
&#125;


&#x2F;&#x2F; About ClassicDataList
&#x2F;&#x2F; delete a bunch of data in the datalist
&#x2F;&#x2F; used like this eraseAbunchData( list,  front_pos,  final_pos)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues eraseAbunchData_inDataList(
	Classic_DataList*											list, 
	size_t														front_pos,
	size_t														final_pos
)
&#123;
	if (list &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (front_pos&lt;0 || front_pos&gt;list-&gt;current_size)
	&#123;
		SHOW_ERROR_ClassicLinkList_Invalid_Input;
		exit(ClassicLinkList_Invalid_Input);
	&#125;
	if (final_pos&lt;0 || final_pos&gt;list-&gt;current_size)
	&#123;
		SHOW_ERROR_ClassicLinkList_Invalid_Input;
		exit(ClassicLinkList_Invalid_Input);
	&#125;
	if (front_pos &gt; final_pos)
	&#123;
		SHOW_WARNING_ClassicLinkList_SWAPPED_POS;
		SHOW_WHETHER_ACCCEPTED(&quot;y&#x2F;n: y for yes , n for n&quot;);
		int choice;
		scanf(&quot;%c&quot;, &amp;choice);
		if (choice &#x3D;&#x3D; &#39;y&#39;) 
		&#123;
			int temp &#x3D; final_pos;
			final_pos &#x3D; front_pos;
			front_pos &#x3D; temp;
		&#125;
		else
		&#123;
			SHOW_ERROR_ClassicLinkList_Invalid_Input;
			exit(ClassicLinkList_Invalid_Input);
		&#125;
	&#125;
	Bool flag &#x3D;False;
	if (front_pos &#x3D;&#x3D; 0) 
	&#123;
		flag &#x3D; True;
		front_pos++;
	&#125;
	Classic_DataNode* pCur &#x3D; list-&gt;Head;
	for (int i &#x3D; 0; i &lt; front_pos-1; i++) 
	&#123;
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;
	int cur_place &#x3D; front_pos-1;
	while (cur_place &lt;&#x3D; final_pos-1) &#123;
		Classic_DataNode* pDel &#x3D; pCur-&gt;p_next_one;
		pCur-&gt;p_next_one &#x3D; pDel-&gt;p_next_one;
		free(pDel);
		cur_place++;
	&#125;
	list-&gt;current_size -&#x3D; final_pos - front_pos +1;
	if (flag &#x3D;&#x3D; True) &#123;
		Classic_DataNode* pNewHead &#x3D; pCur-&gt;p_next_one;
		Classic_DataNode* pDel &#x3D; list-&gt;Head;
		list-&gt;Head &#x3D; pNewHead;
		free(pDel-&gt;data);
		front_pos++;
		list-&gt;current_size--;
	&#125;
	return ClassicLinkList_NORMAL;
&#125;

&#x2F;&#x2F;----------------------------------------check_if_element_existed_functions-----
&#x2F;&#x2F; there are four functions in this sections
&#x2F;&#x2F; 
&#x2F;&#x2F; 1.check if the classiclinklist is empty
&#x2F;&#x2F; fun1: isEmptyClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input :the checked list
&#x2F;&#x2F; output: My defined bool(Sadly the org C doesn&#39;t define that)
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 2. check if the target elements is exsited in the datalist
&#x2F;&#x2F; fun2: checkIsLocateinLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the checked list ,the searched data and the Compared functions
&#x2F;&#x2F; output: the locations that we first found it
&#x2F;&#x2F; 
&#x2F;&#x2F; -------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 3. return out the first locations that we found of the target elements
&#x2F;&#x2F; func3:checkIsLocateinLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the checked list ,the searched data and the Compared functions
&#x2F;&#x2F; output: My defined bool(Sadly the org C doesn&#39;t define that)
&#x2F;&#x2F; 
&#x2F;&#x2F; --------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; Warning : this functions required the PSDA abstractions is opened so you can use Position_Stored_Dynamic_ArrayFordyarr*
&#x2F;&#x2F; to get the position
&#x2F;&#x2F; 
&#x2F;&#x2F; 4. return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr
&#x2F;&#x2F; fun4:returnAbunchLocationsinLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the checked list , the Position_Stored_Dynamic_ArrayFordyarr*(required init first)
&#x2F;&#x2F; output: the Position_Stored_Dynamic_ArrayFordyarr that stored the positions!
&#x2F;&#x2F;
&#x2F;&#x2F; ---------------------------------------------------------------------------------



&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; check if the LinkList is empty
&#x2F;&#x2F;
Bool isEmptyClassicLinkList(Classic_DataList* list)
&#123;
	if (list-&gt;current_size &#x3D;&#x3D; 0)
	&#123;
		return True;
	&#125;
	return False;
&#125;

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; check if the target elements is exsited in the datalist
&#x2F;&#x2F;
Bool checkIsLocateinLinkList(
	Classic_DataList*												list, 
	void*															data,
	LocateFunc														user_func
)
&#123;
	if (list &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (data &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (user_func &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	Classic_DataNode* pCur &#x3D; list-&gt;Head;
	for (int i &#x3D; 0; i &lt; list-&gt;current_size; i++)
	&#123;
		if (user_func(data, pCur-&gt;data)) &#123;
			return True;
		&#125;
	&#125;
	return False;
&#125;

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; return out the first locations that we found of the target elements
&#x2F;&#x2F; can use in this way: size_t pos &#x3D; returnOutDatabyposinLinkList( list, data, user_func)
size_t returnOutDatabyposinLinkList(
	Classic_DataList*										list, 
	void*													data, 
	LocateFunc												user_func
)
&#123;
	Classic_DataNode* pCur &#x3D; list-&gt;Head;
	for (int i &#x3D; 0; i &lt; list-&gt;current_size; i++)
	&#123;
		if (user_func(data, pCur-&gt;data)) &#123;
			return i;
		&#125;
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;
	return Unfind_ClassicLinkList;
&#125;


&#x2F;&#x2F; Make sure the OPENUPPOSARR &#x3D;&#x3D; 1 if wanted to use it

#if OPENUPPOSARR

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; return out a bunch of data that was contained in Position_Stored_Dynamic_ArrayFordyarr
&#x2F;&#x2F; can use in this way: Position_Stored_Dynamic_ArrayFordyarr* somePos &#x3D; 
&#x2F;&#x2F; returnAbunchLocationsinLinkList( list,  posArr,  data,  user_func)
&#x2F;&#x2F;
Position_Stored_Dynamic_ArrayFordyarr* returnAbunchLocationsinLinkList(
	Classic_DataList*										list, 
	Position_Stored_Dynamic_ArrayFordyarr*					posArr, 
	void*													data,
	LocateFunc												user_func
)
&#123;
	if (list &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (data &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (posArr &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	Classic_DataNode* p_Currency &#x3D; list-&gt;Head;
	int possible_count &#x3D; 0;
	for (int i &#x3D; 0; i &lt; list-&gt;current_size; i++)
	&#123;
		if ((*user_func)(data, p_Currency-&gt;data))
		&#123;
			int* pro_usable_stored_space &#x3D; (int*)realloc(posArr-&gt;posSpace, sizeof(int) * (possible_count + 1));
			if (!pro_usable_stored_space)
			&#123;
				SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
				exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
			&#125;
			posArr-&gt;posSpace &#x3D; pro_usable_stored_space;
			posArr-&gt;posSpace[possible_count] &#x3D; i;
			possible_count++;
			posArr-&gt;pos_size &#x3D; possible_count;
		&#125;
		p_Currency &#x3D; p_Currency-&gt;p_next_one;
	&#125;
	if (posArr-&gt;pos_size)
		return posArr;
	return Unfind_ClassicLinkList;
&#125;

#endif 




&#x2F;&#x2F;---------------------------------------Do_Something_to_the_datalist_functions----------
&#x2F;&#x2F; there are seven functions in this sections
&#x2F;&#x2F; 
&#x2F;&#x2F; 1. Classic Print functions
&#x2F;&#x2F; func1: Print_All_Data_LinkList
&#x2F;&#x2F; to print all the data in the user_defined linklist
&#x2F;&#x2F; 
&#x2F;&#x2F; input : list and the user print , and the decision whether enjoyed a better print
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 2. Do some change to the specific data
&#x2F;&#x2F; to make some change directly to an element
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the list ,the targeted positions and the way how you want to operate the data itself
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ------------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 3. Do some change to all the data in the classiclinklist
&#x2F;&#x2F; to make some change directly to the whole elements
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the list ,the way how you want to operate the data itself
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; -----------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 4. Do specific change to an interval pos in the classicLickList
&#x2F;&#x2F; to make some change directly to the interval elements
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the list ,the front_pos and the final_pos
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; -----------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 5. reverse ClassicLinkList
&#x2F;&#x2F; to reverse up the classic LinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the ready_reversed data
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; -----------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 6. combine two linkList into one
&#x2F;&#x2F; to combine the two classic linklist into one!
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the two linklist
&#x2F;&#x2F; output: the merged linklist Pointer
&#x2F;&#x2F; 
&#x2F;&#x2F; -----------------------------------------------------------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 7. sort the elements in the classicLinkList under the user&#39;s constructions
&#x2F;&#x2F; to sort the ClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : the classicLinklist
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; ---------------------------------------------------------------------------------


&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to print the data
&#x2F;&#x2F; use in this way: Print_All_Data_LinkList( list, user_print,  whether_better_print)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues Print_All_Data_LinkList(
	Classic_DataList*									list,
	MyPrint												user_print, 
	BetterPrintSwitch_for_ClassicLinkList				whether_better_print
)
&#123;

	if (!list)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;

	if (!user_print)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;

	if (whether_better_print &#x3D;&#x3D; ClassicLinkList_OPEN) &#123;
		printf(&quot;\nStart printing:\n&quot;);
	&#125;


	Classic_DataNode* p_Currency &#x3D; list-&gt;Head;

	for (int i &#x3D; 0; i &lt; list-&gt;current_size; i++)
	&#123;
		user_print(p_Currency-&gt;data);
		p_Currency &#x3D; p_Currency-&gt;p_next_one;
	&#125;


	if (whether_better_print &#x3D;&#x3D; ClassicLinkList_OPEN) &#123;
		printf(&quot;\nFinish printing:\n&quot;);
	&#125;

	return ClassicLinkList_NORMAL;
&#125;

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to make some change to the specific data
&#x2F;&#x2F; use in this way:doChangetoSpecificElementinLinkList( list,  pos , user_func)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues doChangetoSpecificElementinLinkList(
	Classic_DataList*								list, 
	size_t											pos ,
	Do_Specific_Change								user_func
) 
&#123;
	if (list &#x3D;&#x3D; NULL&amp;&amp;user_func&#x3D;&#x3D;NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (pos&lt;0 || pos&gt;list-&gt;current_size)
	&#123;
		SHOW_ERROR_ClassicLinkList_Invalid_Input;
		exit(ClassicLinkList_Invalid_Input);
	&#125;
	Classic_DataNode* pCur &#x3D; list-&gt;Head;
	for (int i &#x3D; 0; i &lt; pos; i++)
	&#123;
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;
	user_func(pCur-&gt;data);
	return ClassicLinkList_NORMAL;
&#125;

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to make some change to the interval data
&#x2F;&#x2F; use in this way:doChangetoTargetIntervalDatainLinkList(list , pos1,pos2, user_func)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues doChangetoTargetIntervalDatainLinkList(
	Classic_DataList*										list, 
	size_t													front_pos,
	size_t													final_pos,
	Do_Specific_Change										user_func
) 
&#123;
	if (list &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (front_pos&lt;0 || front_pos&gt;list-&gt;current_size)
	&#123;
		SHOW_ERROR_ClassicLinkList_Invalid_Input;
		exit(ClassicLinkList_Invalid_Input);
	&#125;
	if (final_pos&lt;0 || final_pos&gt;list-&gt;current_size)
	&#123;
		SHOW_ERROR_ClassicLinkList_Invalid_Input;
		exit(ClassicLinkList_Invalid_Input);
	&#125;
	if (front_pos &gt; final_pos)
	&#123;
		SHOW_WARNING_ClassicLinkList_SWAPPED_POS;
		SHOW_WHETHER_ACCCEPTED(&quot;y&#x2F;n: y for yes , n for n&quot;);
		int choice;
		scanf(&quot;%c&quot;, &amp;choice);
		if (choice &#x3D;&#x3D; &#39;y&#39;)
		&#123;
			int temp &#x3D; final_pos;
			final_pos &#x3D; front_pos;
			front_pos &#x3D; temp;
		&#125;
		else
		&#123;
			SHOW_ERROR_ClassicLinkList_Invalid_Input;
			exit(ClassicLinkList_Invalid_Input);
		&#125;
	&#125;

	Classic_DataNode* pCur &#x3D; list-&gt;Head;
	for (int i &#x3D; 0; i &lt; front_pos; i++) &#123;
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;
	for (int i &#x3D; front_pos; i &lt; final_pos+1; i++)
	&#123;
		user_func(pCur-&gt;data);
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;
	return ClassicLinkList_NORMAL;

&#125;

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to make some change to the whole elements in the data
&#x2F;&#x2F; use in this way:doChangetoAllDatainLinkList( list,  user_func)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues doChangetoAllDatainLinkList(
	Classic_DataList*									list,
	Do_Specific_Change									user_func
)
&#123;
	if (list &#x3D;&#x3D; NULL &amp;&amp; user_func &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	Classic_DataNode* pCur &#x3D; list-&gt;Head;
	for (int i &#x3D; 0; i &lt; list-&gt;current_size; i++) 
	&#123;
		user_func(pCur-&gt;data);
		pCur&#x3D;pCur-&gt;p_next_one;
	&#125;
	return ClassicLinkList_NORMAL;
&#125;

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to reverse up the classiclinklist
&#x2F;&#x2F; use in this way:ReverseLinkList(list)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues ReverseLinkList(Classic_DataList* list)
&#123;
	if (list &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (list-&gt;current_size &#x3D;&#x3D; 1)
	&#123;
		printf(&quot;No need in reversing!,try a longer one lol&quot;);
		return ClassicLinkList_NORMAL;
	&#125;
	if (list-&gt;current_size &#x3D;&#x3D; 2)
	&#123;
		Classic_DataNode* headFisrt &#x3D; list-&gt;Head;
		Classic_DataNode* pFin &#x3D; headFisrt-&gt;p_next_one;
		pFin-&gt;p_next_one &#x3D; headFisrt;
		headFisrt-&gt;p_next_one &#x3D; NULL;
		list-&gt;Head &#x3D; pFin;
		return ClassicLinkList_NORMAL;
	&#125;
	Classic_DataNode* pFinal &#x3D; list-&gt;Head-&gt;p_next_one;
	Classic_DataNode* pPrior &#x3D; list-&gt;Head;
	while (pFinal!&#x3D; NULL) 
	&#123;
		Classic_DataNode* tempFin &#x3D; pFinal-&gt;p_next_one;
		pFinal-&gt;p_next_one &#x3D; pPrior;
		pPrior &#x3D; pFinal;
		pFinal &#x3D; tempFin;
	&#125;
	list-&gt;Head &#x3D; pPrior;
&#125;

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; to merge two linklist into the one
&#x2F;&#x2F; use in this way:mergeLinkList(list_be_added, list_adder, whether_copied)
&#x2F;&#x2F;
Classic_DataList* mergeLinkList(
	Classic_DataList*									list_be_added, 
	Classic_DataList*									list_adder, 
	size_t												whether_copied
)
&#123;
	if (list_be_added &#x3D;&#x3D; NULL &amp;&amp; list_adder &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	Classic_DataNode* pCur&#x3D;list_be_added-&gt;Head;
	for (int i &#x3D; 0; i &lt; list_be_added-&gt;current_size-1; i++)
	&#123;
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;
	&#x2F;&#x2F;Do not copy , instead just merge!
	if (whether_copied&#x3D;&#x3D;ClassicLinkList_NO_COPY) &#123;
		pCur-&gt;p_next_one &#x3D; list_adder-&gt;Head;
		list_be_added-&gt;current_size +&#x3D; list_adder-&gt;current_size;
		return list_be_added;
	&#125;
	Classic_DataNode* pAdder &#x3D; list_adder-&gt;Head;
	for (int i &#x3D; 0; i &lt; list_adder-&gt;current_size; i++)
	&#123;
		&#x2F;&#x2F;prepare the space
		Classic_DataNode* pCopy &#x3D; (Classic_DataNode*)malloc(sizeof(Classic_DataNode));
		void* dataCopy &#x3D; malloc(sizeof(pAdder-&gt;data));
		if (pCopy &#x3D;&#x3D; NULL &amp;&amp; dataCopy &#x3D;&#x3D; NULL)
		&#123;
			SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
			exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
		&#125;
		&#x2F;&#x2F;Using to copy data and initialize the copied node
		memcpy(dataCopy, pAdder-&gt;data, sizeof(pAdder-&gt;data));
		pCopy-&gt;data &#x3D; dataCopy;
		pCopy-&gt;p_next_one &#x3D; NULL;
		&#x2F;&#x2F;then push back into the linklist
		pCur-&gt;p_next_one &#x3D; pCopy;
		&#x2F;&#x2F;Moving the copy pointer
		pAdder &#x3D; pAdder-&gt;p_next_one;
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;
	list_be_added-&gt;current_size +&#x3D; list_adder-&gt;current_size;
	return list_be_added;
&#125;

&#x2F;&#x2F; About ClassicLinkList
&#x2F;&#x2F; sort the classicLinklist in the bobblesort
&#x2F;&#x2F; use in this way:sortClassicLinkListinBubbleSort(Classic_DataList* list, CompareFunc user_func) 
&#x2F;&#x2F;
ClassicLinkListFunctionStatues sortClassicLinkListinBubbleSort(
	Classic_DataList*														list, 
	CompareFunc																user_func
) 
&#123;
	if (list &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	if (user_func &#x3D;&#x3D; NULL)
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;
	for (int i &#x3D; 0; i &lt; list-&gt;current_size-1; i++)
	&#123;
		Classic_DataNode* pCur &#x3D; list-&gt;Head;
		for(int j&#x3D;0;j&lt;list-&gt;current_size-i-1;j++)
		&#123;
			&#x2F;&#x2F;this two for loops are just standard BobbleSort
			if (user_func(pCur-&gt;data, pCur-&gt;p_next_one-&gt;data))
			&#123;
				void* tempdata &#x3D; malloc(sizeof(pCur-&gt;data));
				memcpy(tempdata, pCur-&gt;data, sizeof(pCur-&gt;data));
				int tempdatasize &#x3D; sizeof(pCur-&gt;data);
				&#x2F;&#x2F;Before Swap,make sure that the dataContainer is huge enough to contain a new space
				if (sizeof(pCur-&gt;p_next_one-&gt;data) &gt; sizeof(pCur-&gt;data))
				&#123;
					void* pTempSwap &#x3D; realloc(pCur-&gt;data, sizeof(pCur-&gt;p_next_one-&gt;data));
					if (pTempSwap &#x3D;&#x3D; NULL)
					&#123;
						SHOW_ERROR_ClassicLinkList_ERROR_IN_MALLOCING_SPACE;
						exit(ClassicLinkList_ERROR_IN_MALLOCING_SPACE);
					&#125;
					pCur-&gt;data &#x3D; pTempSwap;
				&#125;
				&#x2F;&#x2F;Copy and swap
				memcpy(pCur-&gt;data, pCur-&gt;p_next_one-&gt;data, sizeof(pCur-&gt;p_next_one-&gt;data));
				memcpy(pCur-&gt;p_next_one-&gt;data, tempdata, tempdatasize);
			&#125;
			&#x2F;&#x2F;Moving pointer to the next one
			pCur &#x3D; pCur-&gt;p_next_one;
		&#125;
	&#125;
	return ClassicLinkList_NORMAL;
&#125;

&#x2F;&#x2F;----------------------------------------------------Basic_Erase------------------------------
&#x2F;&#x2F; 
&#x2F;&#x2F; 1.Erase A LinkList
&#x2F;&#x2F; used in just clear a linklist
&#x2F;&#x2F; func1: clearAClassicLinkList
&#x2F;&#x2F; 
&#x2F;&#x2F; input : just a classiclinklist
&#x2F;&#x2F; output: the statues of normal ,can be used in check or just ignore!
&#x2F;&#x2F; 
&#x2F;&#x2F; --------------------------------------------------------------------------------------------

&#x2F;&#x2F;About ClassicLinkList
&#x2F;&#x2F; Erase a classicLinkList
&#x2F;&#x2F; Use in this way clearAClassicLinkList( list)
&#x2F;&#x2F;
ClassicLinkListFunctionStatues clearAClassicLinkList(Classic_DataList* list)
&#123;
	if (list &#x3D;&#x3D; NULL) 
	&#123;
		SHOW_ERROR_ClassicLinkList_NULL_INPUT;
		exit(ClassicLinkList_NULL_INPUT);
	&#125;

	Classic_DataNode* pCur &#x3D; list-&gt;Head-&gt;p_next_one;
	Classic_DataNode* pDel &#x3D; list-&gt;Head;
	if (list-&gt;current_size &#x3D;&#x3D; 1) &#123;
		free(pDel);
	&#125;
	for (int i &#x3D; 0; i &lt; list-&gt;current_size-1; i++)
	&#123;
		free(pDel);
		pDel &#x3D; pCur;
		pCur &#x3D; pCur-&gt;p_next_one;
	&#125;

	list-&gt;current_size &#x3D; 0 ;
	return ClassicLinkList_NORMAL;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试文档：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">#define _CRT_SECURE_NO_WARNINGS 1
#include&quot;ClassicLinkList.h&quot;

MyPrint print(int* e) &#123;
	printf(&quot;%d &quot;, *e);
&#125;

Do_Specific_Change dochange(int* e) &#123;
	*e &#x3D; *e + 1;
&#125;

LocateFunc loc(int* e1, int* e2) &#123;
	return *e1 &#x3D;&#x3D; *e2;
&#125;

CompareFunc comp(int* e1, int* e2) &#123;
	return *e1 &lt; *e2;
&#125;
int main()
&#123;
	&#x2F;&#x2F;do test initailization

	&#x2F;&#x2F;default init
	Classic_DataList* defaultinit &#x3D; Init_A_ClassicLinkList();

	&#x2F;&#x2F;updata init

	int array[10] &#x3D; &#123; 1,2,3,4,5,6,7,8,9,10 &#125;;
	Classic_DataList* update_one &#x3D; UpdateStaticArray2ClassicLinkList(array, Dyarr_SIGINT, 10);
	Print_All_Data_LinkList(update_one, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F; copy init

	Classic_DataList* copy_one &#x3D; Init_A_ClassicLinkList_By_CopyAClassicLinkList(update_one);
	printf(&quot;\nThouth , this is the copy one:&quot;);
	Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);






	&#x2F;&#x2F; Push back 
	int addersig &#x3D; 100;
	printf(&quot;\nFirst push:&quot;);
	Push_Back_Into_A_ClassicLinkList(defaultinit, &amp;addersig, Dyarr_SIGINT);
	Print_All_Data_LinkList(defaultinit, print, ClassicLinkList_OPEN);
	printf(&quot;\nSecond push:&quot;);
	Push_Back_Into_A_ClassicLinkList(defaultinit, &amp;addersig, Dyarr_SIGINT);
	Print_All_Data_LinkList(defaultinit, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F; Push back a sum
	int adderarr[5] &#x3D; &#123; 101,102,103,104,105 &#125;;
	push_Back_BunchDataintoClassicLinkList(defaultinit, adderarr, Dyarr_SIGINT, 5);
	Print_All_Data_LinkList(defaultinit, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;Insert start:
	int insertionsig &#x3D; -100;

	&#x2F;&#x2F;to the head:
	Insert_into_AClassicLinkList(defaultinit, &amp;insertionsig, Dyarr_SIGINT, 0);
	Print_All_Data_LinkList(defaultinit, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;to other place
	Insert_into_AClassicLinkList(defaultinit, &amp;insertionsig, Dyarr_SIGINT, 1);
	Print_All_Data_LinkList(defaultinit, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;for a bunch ...
	&#x2F;&#x2F;head
	int insertarr[5] &#x3D; &#123; -1,-2,-3,-4,-5 &#125;;
	Insert_A_Bunch_of_data_intoClassicLinkList(update_one, 0, insertarr, Dyarr_SIGINT, 5);
	Print_All_Data_LinkList(update_one, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;other place
	Insert_A_Bunch_of_data_intoClassicLinkList(update_one, 1, insertarr, Dyarr_SIGINT, 5);
	Print_All_Data_LinkList(update_one, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;Erase 
	eraseAElementfromDataList(copy_one, 0);
	Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);

	eraseAElementfromDataList(copy_one, 1);
	Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;Erase bunch
	eraseAbunchData_inDataList(copy_one, 0, 2);
	Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);


	&#x2F;&#x2F;make change:
	&#x2F;&#x2F;sig
	doChangetoSpecificElementinLinkList(copy_one, 0, dochange);
	Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;interval
	doChangetoTargetIntervalDatainLinkList(copy_one, 0, 2, dochange);
	Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;all
	doChangetoAllDatainLinkList(copy_one, dochange);
	Print_All_Data_LinkList(copy_one, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;check if in
	Classic_DataList* checkerlist &#x3D; UpdateStaticArray2ClassicLinkList(insertarr, Dyarr_SIGINT, 5);
	int wannafind &#x3D; -1;
	printf(&quot;So is it null?&quot;);
	if (!isEmptyClassicLinkList(checkerlist)) &#123;
		printf(&quot;\nNot null sir!\n&quot;);
	&#125;
	if (checkIsLocateinLinkList(checkerlist, &amp;wannafind, loc)) &#123;
		printf(&quot;yes, there is a num that is -1\n&quot;);
	&#125;
	printf(&quot;and it is on the place: %d\n&quot;, returnOutDatabyposinLinkList(checkerlist, &amp;wannafind, loc));
	int wannafind2 &#x3D; wannafind - 1;
	printf(&quot;and also there is -2 too, it is in: %d\n&quot;, returnOutDatabyposinLinkList(checkerlist, &amp;wannafind2, loc));
	printf(&quot;I can also make a change in this way directly:\n&quot;);
	doChangetoSpecificElementinLinkList(checkerlist, returnOutDatabyposinLinkList(checkerlist, &amp;wannafind2, loc), dochange);
	Print_All_Data_LinkList(checkerlist, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;find bunch 
	Position_Stored_Dynamic_ArrayFordyarr* posarr &#x3D; Init_A_Postion_Stored_Dynamic_ArrayFordyarr();
	returnAbunchLocationsinLinkList(checkerlist, posarr, &amp;wannafind, loc);
	Show_All_Locations_In_PSDAfor_dyarr(posarr, PSDA_dyarr_OPEN);

	&#x2F;&#x2F;reverse
	ReverseLinkList(checkerlist);
	Print_All_Data_LinkList(checkerlist, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;Sort
	sortClassicLinkListinBubbleSort(checkerlist, comp);
	Print_All_Data_LinkList(checkerlist, print, ClassicLinkList_OPEN);

	&#x2F;&#x2F;Del
	clearAClassicLinkList(checkerlist);
	Print_All_Data_LinkList(checkerlist, print, ClassicLinkList_OPEN);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/Charliechen114514">Charlie Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://charliechen114514.github.io/2023/02/11/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/">http://charliechen114514.github.io/2023/02/11/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%EF%BC%9A%E7%BB%8F%E5%85%B8%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">全体目光向我看齐，我宣布个事！是我Charliechen写的这篇文章！(?)</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/MyTinyLibProject/">MyTinyLibProject</a></div><div class="post_share"><div class="social-share" data-image="/img/passagepage.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/12/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/" title="C语言数据结构模拟：动态数组的实现思路"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C语言数据结构模拟：动态数组的实现思路</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/10/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%95%99%E7%A8%8B%EF%BC%887%EF%BC%89/" title="高等数学教程 （7）"><img class="cover" src="/img/passagepage.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">高等数学教程 （7）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%881%EF%BC%89%E5%A4%B4%E6%96%87%E4%BB%B6-%E6%BA%90%E4%BB%A3%E7%A0%81-%E6%B5%8B%E8%AF%95/" title="C语言数据结构模拟：动态数组（1）头文件+源代码+测试"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">C语言数据结构模拟：动态数组（1）头文件+源代码+测试</div></div></a></div><div><a href="/2023/02/07/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%881%EF%BC%89%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84API%E8%AF%A6%E8%A7%A3/" title="C语言数据结构模拟（1）：动态数组API详解"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-07</div><div class="title">C语言数据结构模拟（1）：动态数组API详解</div></div></a></div><div><a href="/2023/02/12/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%9A%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/" title="C语言数据结构模拟：动态数组的实现思路"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="title">C语言数据结构模拟：动态数组的实现思路</div></div></a></div><div><a href="/2023/02/15/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%EF%BC%882%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8API%E8%AF%A6%E8%A7%A3/" title="C语言数据结构 （2） 单链表API详解"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="title">C语言数据结构 （2） 单链表API详解</div></div></a></div><div><a href="/2023/01/28/C%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%881%EF%BC%89/" title="C简单教程（1）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-28</div><div class="title">C简单教程（1）</div></div></a></div><div><a href="/2023/01/30/%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/" title="算法（1）"><img class="cover" src="/img/passagepage.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-30</div><div class="title">算法（1）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/webicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Charlie Chen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Charliechen114514"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Charliechen114514" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=725610365&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">大更新！这下上了简单的数据结构的C实现，如果只对思路感兴趣看思路即可，如果想查看API实现就取看详解</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#API%E4%B8%80%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">API一览</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/06/Essencial-cpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" title="Essencial_cpp阅读笔记（2）"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Essencial_cpp阅读笔记（2）"/></a><div class="content"><a class="title" href="/2023/05/06/Essencial-cpp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" title="Essencial_cpp阅读笔记（2）">Essencial_cpp阅读笔记（2）</a><time datetime="2023-05-06T04:23:59.000Z" title="发表于 2023-05-06 12:23:59">2023-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/04/%E6%91%B8%E9%B1%BCing%EF%BC%881%EF%BC%89-Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%9D%E6%8E%A2%EF%BC%881%EF%BC%89/" title="摸鱼ing（1） Windows API 程序设计初探（1）"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="摸鱼ing（1） Windows API 程序设计初探（1）"/></a><div class="content"><a class="title" href="/2023/05/04/%E6%91%B8%E9%B1%BCing%EF%BC%881%EF%BC%89-Windows-API-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%88%9D%E6%8E%A2%EF%BC%881%EF%BC%89/" title="摸鱼ing（1） Windows API 程序设计初探（1）">摸鱼ing（1） Windows API 程序设计初探（1）</a><time datetime="2023-05-04T15:38:05.000Z" title="发表于 2023-05-04 23:38:05">2023-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/02/ROS-%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%8F%91-3/" title="ROS-正式开发-3"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ROS-正式开发-3"/></a><div class="content"><a class="title" href="/2023/05/02/ROS-%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%8F%91-3/" title="ROS-正式开发-3">ROS-正式开发-3</a><time datetime="2023-05-02T12:56:03.000Z" title="发表于 2023-05-02 20:56:03">2023-05-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/26/Opencv-in-Visual-Studio-C-4/" title="Opencv in Visual Studio C(4)"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Opencv in Visual Studio C(4)"/></a><div class="content"><a class="title" href="/2023/04/26/Opencv-in-Visual-Studio-C-4/" title="Opencv in Visual Studio C(4)">Opencv in Visual Studio C(4)</a><time datetime="2023-04-26T14:45:53.000Z" title="发表于 2023-04-26 22:45:53">2023-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/26/Opencv-in-Visual-Studio-C-3/" title="Opencv in Visual Studio C(3)"><img src="/img/passagepage.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Opencv in Visual Studio C(3)"/></a><div class="content"><a class="title" href="/2023/04/26/Opencv-in-Visual-Studio-C-3/" title="Opencv in Visual Studio C(3)">Opencv in Visual Studio C(3)</a><time datetime="2023-04-26T14:45:50.000Z" title="发表于 2023-04-26 22:45:50">2023-04-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Charlie Chen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="哼啊啊啊啊啊啊啊啊啊啊啊啊,人民万岁！,兄啊，别点力" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>